/**********************************************************************
*
*	文件:	   appBattleMethod.cpp
*
*	描述:	   
*
*	作者:	   吴财华
*					
*
**********************************************************************/
#include <rbody/Creature3D/CreBody.h>
#include <JXJ/appBattleMethod.h>
#include <JXJ/appDataParam.h>
#include <JXJ/appMsg.h>
#include <JXJ/appPackets.h>
#include <CRUI/crWidgetExtend.h>
#include <CRNetApp/appNetLogic.h>
#include <CRNetApp/appGlobalHandle.h>
#include <CRProducer/crViewer.h>
#include <CRProducer/crSceneHandler.h>
#include <CRUtil/crAcceptGIVisitor.h>
#include <CRDataBase/crDataBaseManager.h>
#include <CRNetApp/appDBUpdate2.h>
#include <CRNetApp/appDBQuery2.h>
#include <CRIOManager/crLoadManager.h>
#include <CRIOManager/crFileNameUtils.h>
#include <CRNetApp/appNodeCallbacks.h>
#include <CREncapsulation/crGameDices.h>
#include <CRCore/crEventCallbackManager.h>
#include <CRDownload/crDownload.h>
#include <CRIOManager/crFileUtils.h>
#include <CRIOManager/crCookFile.h>
#include <CRCore/crTexMat.h>
#include <CRIOManager/crConvertUTF.h>
#include <JXJ/appDBQuery.h>
#include <CRNetApp/appGlobalHandle.h>
#include <CREncapsulation/crStartHandler.h>
#include <CRCore/crLightSourceManager.h>
#include <CRCore/crBlockDetectThread.h>
#include <shellapi.h>
using namespace CRCore;
using namespace CRNetApp;
using namespace CRDataBase;
using namespace CRNet;
using namespace CRProducer;
using namespace CRPhysics;
using namespace CREncapsulation;
using namespace CRUtil;
using namespace CRIOManager;
using namespace CRDownload;
using namespace rbody;
using namespace JXJ;
using namespace CRUI;
/////////////////////////////////////////
//
//crJXJCreateFubenMethod
//
/////////////////////////////////////////
crJXJCreateFubenMethod::crJXJCreateFubenMethod(){}
crJXJCreateFubenMethod::crJXJCreateFubenMethod(const crJXJCreateFubenMethod& handle):
	crMethod(handle)
{
}
void crJXJCreateFubenMethod::inputParam(int i, void *param)
{
}

void crJXJCreateFubenMethod::addParam(int i, const std::string& str)
{
}

void crJXJCreateFubenMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short fubenid = *(unsigned short *)param;
		crTableIO::StrVec record;
		if(type == FT_Fuben && fubenid>0 && fubentab.valid() && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
		{
			int timeid = fubentab->getTitleIndex("时间");
			int countid = fubentab->getTitleIndex("玩家数量");
			int nameid = fubentab->getTitleIndex("name");
			if (timeid >= 0 && countid >=0 && nameid >= 0)
			{
				char battleMode = crRoom::Extern;
				int timeLimit = atoi(record[timeid].c_str());
				short playerCount = (short)(atoi(record[countid].c_str()));
				std::string battleName = record[nameid];
				bool friendlyFire = false;
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					//crWaitNetReturnStreamLogic::getLock();
					ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
					std::string creatorName = myPlayer->getMainRole()->getIName();
					streamBuf->createBuf(16+creatorName.length()+battleName.length());
					streamBuf->_writeString(creatorName);
					streamBuf->_writeChar(battleMode);//1
					streamBuf->_writeString(battleName);//16+4
					streamBuf->_writeInt(timeLimit);//4
					streamBuf->_writeShort(playerCount);//2
					streamBuf->_writeBool(friendlyFire);//1
					//streamBuf->_writeBool(true);//1 m_autoStart
					//streamBuf->_writeFloat(10.0f);//4 m_autoStartTime
					//streamBuf->_writeString(password);//8+4
					crCreateSceneRoomPacket packet;
					crCreateSceneRoomPacket::buildRequestPacket(packet,streamBuf.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJInitSelectRoleMethod
//
/////////////////////////////////////////
crJXJInitSelectRoleMethod::crJXJInitSelectRoleMethod(){}
crJXJInitSelectRoleMethod::crJXJInitSelectRoleMethod(const crJXJInitSelectRoleMethod& handle):
	crMethod(handle)
{
}
void crJXJInitSelectRoleMethod::inputParam(int i, void *param)
{
}

void crJXJInitSelectRoleMethod::addParam(int i, const std::string& str)
{
}

void crJXJInitSelectRoleMethod::operator()(crHandle &handle)
{
	ref_ptr<crCamera> cam = crCameraManager::getInstance()->getMainCamera();
	crMyPlayerData *me = crMyPlayerData::getInstance();
	crRole *role = me->getLoadedRoleByIndex(0);
	crRole *role_1 = me->getLoadedRoleByIndex(1);
	crRole *role_2 = me->getLoadedRoleByIndex(2);
	if(role && cam.valid() && cam->getAttachedNode())
	{
		crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(cam->getAttachedNode());
		crVector3 rolePos = role->getPosition();
		cameraNode->doEvent(WCH_CameraFocus,MAKEINT64(&rolePos,NULL));
		//相机选择
		void *param;
		crData *cameraData = cameraNode->getDataClass();
		if(cameraData)
		{
			CRCore::ScopedLock<crData> lock(*cameraData);
			cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
			SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
			selectMyRoles->clear();
			//选中所有角色加入编队1
			cameraData->getParam(WCHDATA_JXJBattleFormation,param);
			BattleFormationMap *battleFormationMap = (BattleFormationMap *)param;
			ItemVec& itemvec = (*battleFormationMap)[49];

			selectMyRoles->push_back(role);
			itemvec.push_back(role);
			if(role_1)
			{
				selectMyRoles->push_back(role_1);
				itemvec.push_back(role_1);
			}
			if(role_2)
			{
				selectMyRoles->push_back(role_2);
				itemvec.push_back(role_2);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSelectRoleMethod
//
/////////////////////////////////////////
crJXJSelectRoleMethod::crJXJSelectRoleMethod():
	m_this(NULL),
	m_ea(NULL),
	m_index(0){}
crJXJSelectRoleMethod::crJXJSelectRoleMethod(const crJXJSelectRoleMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_ea(NULL),
	m_index(handle.m_index)
{
}
void crJXJSelectRoleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}

void crJXJSelectRoleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	}
}

void crJXJSelectRoleMethod::operator()(crHandle &handle)
{
	crMyPlayerData *me = crMyPlayerData::getInstance();
	crRole *role = me->getLoadedRoleByIndex(m_index);
	if(role)
	{
		unsigned int guisestate = GS_Normal;
		role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_StaticUnVisiable || guisestate & GS_UnVisiable || guisestate & GS_Stagnate /*|| guisestate & GS_NoAttack*/ || guisestate & GS_Taunt || guisestate & GS_Confusion || guisestate & GS_Scare)
		{//不可被自己选中
			return;
		}
		//相机选择
		bool found = false;
		void *param;
		bool isDoubleKeyDown = false;
		crData *cameraData = m_this->getDataClass();
		CRCore::ScopedLock<crData> lock(*cameraData);
		cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
		crNode *fxNode;
		SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;

		cameraData->getParam(WCHDATA_JXJKeyDownEventInfo,param);
		ref_ptr<CRProducer::crGUIEventAdapter> keyInfo = (CRProducer::crGUIEventAdapter *)param;
		if( keyInfo.valid() && m_ea &&
			keyInfo.get()->getKey() == m_ea->getKey() && m_ea->time()-keyInfo->time()<=0.5f)
			isDoubleKeyDown = true;
		cameraData->inputParam(WCHDATA_JXJKeyDownEventInfo,m_ea);
		// 		cameraData->getParam(WCHDATA_JXJKeyDoublePushDown,param);
		// 		crVector2i *keyState = (crVector2i *)param;
		// 		if((*keyState)[0] == 1)
		// 		{
		// 			(*keyState)[1] = 1;
		// 		}

		for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
			itr != selectMyRoles->end();
			++itr )
		{
			fxNode = (*itr)->findSceneFxNode("$SelectDecal");
			if(fxNode)
			{
				crDecalUpdateCallback *callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
				{
					callback->setVisiable(false);
				}
			}
		}
		selectMyRoles->clear();
		selectMyRoles->push_back(role);
		fxNode = role->findSceneFxNode("$SelectDecal");
		if(fxNode)
		{
			crDecalUpdateCallback *callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
			if(callback)
			{
				callback->setVisiable(true);
			}
		}

		//m_this->doEvent(WCH_JXJChangeCurSelectRole);
		//显示装备信息
		role->doEvent(WCH_JXJTouchRoleShow);
		//移动相机
		if(isDoubleKeyDown)
		{
			crRole *role = (*selectMyRoles)[0].get();
			crVector3 pos = role->getPosition();
			m_this->doEvent(WCH_CameraFocus,MAKEINT64(&pos,NULL));
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvBattleRMousePickMethod
////
///////////////////////////////////////////
//crJXJRecvBattleRMousePickMethod::crJXJRecvBattleRMousePickMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvBattleRMousePickMethod::crJXJRecvBattleRMousePickMethod(const crJXJRecvBattleRMousePickMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvBattleRMousePickMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvBattleRMousePickMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvBattleRMousePickMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		//CRCore::notify(CRCore::ALWAYS)<<"crNetMousePick2Method recv WCH_NetControl"<<std::endl;
//		//void *param;
//		crData *thisData = m_this->getDataClass();
//		void *param;
//		thisData->getParam(WCHDATA_ItemState,param);
//		unsigned char itemstate = *(unsigned char *)param;
//		if(itemstate == IS_Dead)
//		{
//			return;
//		}
//
//		unsigned char targetType = m_stream->_readUChar();
//		thisData->inputParam(WCHDATA_TargetType,&targetType);
//		crVector3 targetPosition;
//		int targetid = 0;
//		int targetroleid = 0;
//		ref_ptr<crInstanceItem>targetItem;
//		if(targetType & Target_Instance || targetType & Target_Self)
//		{
//			targetid = m_stream->_readInt();
//			targetroleid = targetType&Target_Role?m_stream->_readInt():0;
//			itemstate = m_stream->_readUChar();
//			thisData->inputParam(WCHDATA_TargetID,&targetid);
//			thisData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
//			if(m_netType == GameClient_Game)
//			{
//				ref_ptr<crMatrixTransform>targetNode;
//				m_this->clientGetTarget(targetItem,targetNode);
//				//thisData->inputParam(WCHDATA_TargetNode,targetNode.get());
//				if(targetItem.valid())
//				{
//					targetPosition = targetItem->getPosition();
//					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
//				}
//			}
//			else if(m_netType == SceneServer)
//			{
//				targetItem = m_this->serverGetTarget();
//				if(targetItem.valid())
//				{
//					targetPosition = targetItem->getPosition();
//					thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
//				}
//			}
//		}
//		else
//		{
//			targetPosition = m_stream->_readVec3();
//			itemstate = m_stream->_readUChar();
//			thisData->inputParam(WCHDATA_TargetPos,&targetPosition);
//		}
//		if(!m_stream->eof()/*itemstate >= IS_MoveToPos &&itemstate <= IS_CloseTargetTouch*/)
//		{					
//			float followDistance = m_stream->_readFloat();
//			thisData->inputParam(WCHDATA_FollowDistance,&followDistance);
//		}
//		//if(itemstate!=IS_UseItem)
//		//{
//		//	crVector3i pos;
//		//	pos[0] = m_stream->_readInt();
//		//	pos[1] = m_stream->_readInt();
//		//	pos[2] = m_stream->_readInt();
//		//	//pos 合法性检查
//		//	m_this->setPosx(pos[0]);
//		//	m_this->setPosy(pos[1]);
//		//	m_this->setPosz(pos[2]);
//		//	if(itemstate < IS_Move)
//		//	{
//		//		crVector3 dir;
//		//		dir[0] = m_stream->_readFloat();
//		//		dir[1] = m_stream->_readFloat();
//		//		dir[2] = m_stream->_readFloat();
//		//		m_this->setDir(dir);
//		//	}
//		//}
//		//else
//		//{
//		//	itemstate = IS_Stop;
//		//}
//		thisData->inputParam(WCHDATA_ItemState,&itemstate);
//		//		if(m_netType == SceneServer)
//		//{
//		//if(itemstate >= IS_Move)
//		//{
//		//crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//		//crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//		//crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//		//CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
//		//scene->getPathFindingManager()->addPathFindRequest(m_this);
//		//}
//		//}
//		//else if(m_netType == GameClient_Game)
//		//{
//		//	crNode *bot = m_this->getRelNode();
//		//	m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
//		//	//if(itemstate >= IS_Move)
//		//	//{
//		//	//	m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_TransMatrix));
//		//	//	//crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
//		//	//}
//		//	//else
//		//	//{
//		//	//	m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(bot,crMatterObject::MD_FullMatrix));
//		//	//}
//		//}
//	}
//}
/////////////////////////////////////////
//
//crJXJActUpdateMethod
//
/////////////////////////////////////////
crJXJActUpdateMethod::crJXJActUpdateMethod():
	m_dt(0.0f),
	m_attackDuration(0.0f),
	m_attacked(0),
	m_deadActFactor(0.01f),
	m_init(false),
	m_lastAct(ACT_None),
	m_stagnate(false),
	m_animSpeedrec(1.0f){}
crJXJActUpdateMethod::crJXJActUpdateMethod(const crJXJActUpdateMethod& handle):
	crMethod(handle),
	m_dt(0.0f),
	m_attackDuration(0.0f),
	m_attacked(0),
	m_deadActFactor(handle.m_deadActFactor),
	m_attackActRateVec(handle.m_attackActRateVec),
	m_critAttackActRateVec(handle.m_critAttackActRateVec),
	m_nearAttackActRateVec(handle.m_nearAttackActRateVec),
	m_init(false),
	m_lastAct(ACT_None),
	m_stagnate(false),
	m_animSpeedrec(1.0f)
{
}
void crJXJActUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}

void crJXJActUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_deadActFactor = atof(str.c_str());
		break;
	}
}
void crJXJActUpdateMethod::init()
{
	ref_ptr<crTableIO> dataAttrTab = NULL;
	if(m_this->getItemtype() == crInstanceItem::Role)
		dataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);
	else
		dataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
	if(dataAttrTab.valid())
	{
		crTableIO::StrVec record;
		if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getAbstractItemID()),record)>=0)
		{
			int actrateid = dataAttrTab->getTitleIndex("攻击动作");
			if(actrateid>0)
			{
				crArgumentParser::appAtoVec(record[actrateid],m_attackActRateVec);
				for( int i = 0; i<m_attackActRateVec.size(); ++i)
				{
					m_attackActRateVec[i] = 1.0f-m_attackActRateVec[i];
				}
			}
			actrateid = dataAttrTab->getTitleIndex("暴击动作");
			if(actrateid>0)
			{
				crArgumentParser::appAtoVec(record[actrateid],m_critAttackActRateVec);
				for( int i = 0; i<m_critAttackActRateVec.size(); ++i)
				{
					m_critAttackActRateVec[i] = 1.0f-m_critAttackActRateVec[i];
				}
			}
			actrateid = dataAttrTab->getTitleIndex("近身攻击");
			if(actrateid>0)
			{
				crArgumentParser::appAtoVec(record[actrateid],m_nearAttackActRateVec);
				for( int i = 0; i<m_nearAttackActRateVec.size(); ++i)
				{
					m_nearAttackActRateVec[i] = 1.0f-m_nearAttackActRateVec[i];
				}
			}
		}
	}
	m_init = true;
}
void crJXJActUpdateMethod::operator()(crHandle &handle)
{
	if(!m_init)
	{
		init();
		return;
	}
	if(m_dt>0.0f)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_CurActState,param);
		unsigned short* act = (unsigned short *)param;
		data->getParam(WCHDATA_CurActDuration,param);
		float* duration = (float *)param;
		data->getParam(WCHDATA_ActStateMap,param);
		ActStateMap *actStateMap = (ActStateMap *)param;
		if(*act == ACT_None)
		{
			data->getParam(WCHDATA_GuiseState,param);
			unsigned int *gs = (unsigned int *)param;
			*gs &= ~GS_Stop;
			*act = ACT_Idle;
		}
		if(*act == ACT_Move/* && *duration == -1.0f*/)//ACT_Move持续播放特效，其它动作只播放一次特效
		{
			//if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			//{
			crVector3 pos = m_this->getPosition();
			crVector3 dir = m_this->getDir();
			m_this->doEvent(MAKEINT64(WCH_PlayActFx,*act),MAKEINT64(&pos,&dir));
			//}
		}
		ref_ptr<crViewMatterObject> bot = dynamic_cast<crViewMatterObject *>(m_this->getRelNode());
		if(bot.valid() && bot->getBody())
		{
			CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(bot->getBodyChild());
			if(bodyNode)
			{
				unsigned int guisestate = GS_Normal;
				m_this->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if(*act!=ACT_Dead && (guisestate & GS_Stagnate || guisestate & GS_ExtraShifting))
				{
					m_stagnate = true;
					m_animSpeedrec = bodyNode->getAnimPlaySpeed();
					bodyNode->setAnimPlaySpeed(0.0f);
					data->excHandle(MAKEINT64(WCH_LockData,0));
					return;
				}
				else if(m_stagnate)
				{
					m_stagnate = false;
					bodyNode->setAnimPlaySpeed(m_animSpeedrec);
				}
				ActStateMap::iterator itr = actStateMap->find(*act);
				if(itr != actStateMap->end()/* && m_currentAct.compare(itr->second) != 0*/)
				{
					ActionRequest* action = bodyNode->getBody()->getActionPrototype( itr->second );
					//if (action)
					//{
						//if(isloop)
						//	m_currentAct = itr->second;
						//else
						//	m_currentAct.clear();
						if(*act==ACT_Attack || *act==ACT_CritAttack || *act==ACT_NearAttack || *act==ACT_Skill)
						{
							if( *act != m_lastAct /*m_currentAct != itr->second*/ )
							{
								m_attackDuration = *duration;
								m_attacked = 0;
								//if(*act!=ACT_Skill)
								//{
									float speed = 1.0f;
									if(action && *duration>0.0f)
									{
										speed = action->getPropertyFloat("duration")/(*duration);
										//if(speed>1.0f && speed<1.5f)
										//{
										//	speed = 1.0f;
										//	m_attackDuration = action->getPropertyFloat("duration");
										//}
									}
									bodyNode->setAnimPlaySpeed(speed);
								//}
								//else
								//{
								//	bodyNode->setAnimPlaySpeed(1.0f);
								//}
							}
						}
						else if(*act==ACT_Dead)
						{
							if( m_currentAct != itr->second )
							{
								if(action)
								{
									bodyNode->setAnimPlaySpeed(1.0f);
									*duration = action->getPropertyFloat("duration");
									action->setPrioritized(true);
									bodyNode->getBody()->executeAction(action, true);
								}
								m_currentAct = itr->second;
							}
						}
						else if(*act==ACT_Move)
						{
							bodyNode->setAnimPlaySpeed(1.0f);
							if(action && *duration == -1.0f)
							{
								*duration = action->getPropertyFloat("duration");
							}
						}
						else
						{
							bodyNode->setAnimPlaySpeed(1.0f);
						}
						if(m_currentAct != itr->second && *act!=ACT_Dead && crBrain::getInstance()->getCameraFrustum().contains(bot->getBoundBox()))
						{
							//int loopmode = action->getPropertyInt("loop");
							//if(loopmode==1 || crBrain::getInstance()->getCameraFrustum().contains(bot->getBoundBox()))
							//{
							if(action)
							{
								action->setPrioritized(false);
								bodyNode->getBody()->executeAction(action, false);
							}
							//}
							m_currentAct = itr->second;
						}
					//}
				}
			}
		}
		*duration -= m_dt;
		//unsigned short curact = *act;
		if((*act==ACT_Attack || *act==ACT_CritAttack || *act==ACT_NearAttack))
		{
			std::vector<float> attackActRateVec;
			if(*act==ACT_Attack)
				attackActRateVec = m_attackActRateVec;
			else if(*act==ACT_CritAttack)
				attackActRateVec = m_critAttackActRateVec;
			else if(*act==ACT_NearAttack)
				attackActRateVec = m_nearAttackActRateVec;
			if(m_attacked<attackActRateVec.size() && *duration < m_attackDuration * attackActRateVec[m_attacked])
			{//攻击动作完成，发动攻击
				//data->getParam(WCHDATA_ItemState,param);
				//unsigned char itemstate = *(unsigned char *)param;
				//if(itemstate == IS_UseItem)
				//{
					unsigned char itemstate = IS_Stop;
					data->inputParam(WCHDATA_ItemState,&itemstate);
					if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
					{
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						if(netConductor)
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(1);
							stream->_writeUChar(itemstate);//1
							crPlayerServerEventPacket packet;
							crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvItemState,m_this,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
				//}
				ref_ptr<crNode> userNode = m_this->getRelNode();
				if(userNode.valid())
				{
					data->getParam(WCHDATA_AttackUseParam,param);
					ItemUseParam *itemUseParam = (ItemUseParam *)param;
					if(itemUseParam && itemUseParam->isValid())
					{
						userNode->doEvent(WCH_ItemUse,MAKEINT64(itemUseParam,NULL));
					}
				}
				//if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
				{
					crVector3 pos = m_this->getPosition();
					crVector3 dir = m_this->getDir();
					m_this->doEvent(MAKEINT64(WCH_PlayActFx,*act),MAKEINT64(&pos,&dir));
				}
				m_attacked++;
			}
		}
		//if(*act == ACT_Dead && *duration<=0.1f)
		//{
		//	if(bot->getBody())
		//	{
		//		CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(bot->getBodyChild());
		//		if(bodyNode)
		//		{
		//			bodyNode->setAnimPlaySpeed(0.0f);
		//		}
		//	}
		//}
		/*else */
		if(*act==ACT_Skill)
		{
			data->getParam(WCHDATA_ItemUseParam,param);
			ItemUseParam *itemUseParam = (ItemUseParam *)param;
			if(itemUseParam && itemUseParam->isValid())
			{
				bool use = false;
				float chanttime = itemUseParam->m_chanttime;
				if(chanttime>0.0f)
				{
					float dur = m_attackDuration-chanttime;
					if(*duration<dur)
					{
						use = true;
						m_attackDuration = dur;
					}
				}
				else if(*duration<0.0f)
				{
					use = true;
				}
				if(use)
				{
					//data->getParam(WCHDATA_ItemState,param);
					unsigned char itemstate = IS_Stop;// = *(unsigned char *)param;
					if(m_this->getItemtype() != crInstanceItem::Role)
					{//npc
						if(*duration<0.0f)
						{
							itemstate = IS_Stop;
							data->inputParam(WCHDATA_ItemState,&itemstate);
						}
						ref_ptr<crNode> userNode = m_this->getRelNode();
						if(userNode.valid())
						{
							userNode->doEvent(WCH_ItemUse,MAKEINT64(itemUseParam,NULL));
						}
					}
					else if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
					{
						unsigned int guisestate = GS_Normal;
						m_this->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
						if( guisestate & GS_Stop || guisestate & GS_Silent/* || guisestate & GS_Garrison*/ || guisestate & GS_Swoon || guisestate & GS_Stagnate ||
							guisestate & GS_Taunt || guisestate & GS_Confusion || guisestate & GS_Scare || guisestate & GS_Sheep || guisestate & GS_OnHorse || 
							guisestate & GS_ExtraShifting/* || guisestate & GS_NoAttack*/ || guisestate & GS_Nihility)
						{//不能释放技能
							//if(itemstate == IS_UseItem)
							//{
								itemstate = IS_Stop;
								data->inputParam(WCHDATA_ItemState,&itemstate);
								crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
								if(netConductor)
								{
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(1);
									stream->_writeUChar(itemstate);//1
									crPlayerServerEventPacket packet;
									crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvItemState,m_this,stream.get());
									netConductor->getNetManager()->sendPacket("all",packet);
								}
							//}
							data->getParam(WCHDATA_GuiseState,param);
							unsigned int *gs = (unsigned int *)param;
							*gs &= ~GS_Stop;
						}
						else/* if(itemstate == IS_UseItem)*/
						{
							crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
							if(netConductor)
							{
								ref_ptr<crStreamBuf> stream = new crStreamBuf;
								stream->createBuf(16);
								stream->_writeInt(itemUseParam->m_itemid);
								stream->_writeVec3(itemUseParam->m_targetPos);
								crPlayerEventPacket packet;
								crPlayerEventPacket::buildRequestPacket(packet,m_this,WCH_RecvItemUse,stream.get());
								netConductor->getNetManager()->sendPacket("all",packet);
							}
							if(*duration<0.0f)
							{
								itemstate = IS_Stop;
								data->inputParam(WCHDATA_ItemState,&itemstate);
							}
							ref_ptr<crNode> userNode = m_this->getRelNode();
							if(userNode.valid())
							{
								userNode->doEvent(WCH_ItemUse,MAKEINT64(itemUseParam,NULL));
							}
						}
					}
					//if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
					{
						crVector3 pos = m_this->getPosition();
						crVector3 dir = m_this->getDir();
						m_this->doEvent(MAKEINT64(WCH_PlayActFx,*act),MAKEINT64(&pos,&dir));
					}
				}
			}
		}
		if(m_lastAct != *act)
		{
			if(*act != ACT_None && *act != ACT_Move && *act!=ACT_Attack && *act!=ACT_CritAttack && *act!=ACT_NearAttack && *act!=ACT_Skill)
			{
				//if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
				{
					crVector3 pos = m_this->getPosition();
					crVector3 dir = m_this->getDir();
					m_this->doEvent(MAKEINT64(WCH_PlayActFx,*act),MAKEINT64(&pos,&dir));
				}
			}
		}
		if(*duration<0.0f && *act != ACT_Dead)
		{
			*duration = 0.0f;
			*act = ACT_None;
			m_currentAct.clear();
		}
		m_lastAct = *act;
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvItemUseMethod
//
/////////////////////////////////////////
crJXJRecvItemUseMethod::crJXJRecvItemUseMethod():
	m_netType(GameClient_Game){}
crJXJRecvItemUseMethod::crJXJRecvItemUseMethod(const crJXJRecvItemUseMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvItemUseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvItemUseMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvItemUseMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			crData *userData = m_this->getDataClass();
			int itemid = m_stream->_readInt();
			ref_ptr<crItemChild> itemChild = m_this->findChildItem(itemid);
			if(itemChild.valid()&&itemChild->isLoaded())
			{
				crInstanceItem *item = itemChild->getInstanceItem();
				crData *itemData = item->getDataClass();
				void *param;
				itemData->getParam(WCHDATA_DataType,param);
				unsigned char datatype = *(unsigned char*)param;
				if(datatype == DT_Skill)
				{///UserExtra
					userData->getParam(WCHDATA_ExtraData,param);
					crData *extraData = (crData *)param;
					if(extraData)
					{
						crHandle *handle = itemData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Server));
						if(handle)
						{
							crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
							crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
							crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
							CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
							if(scene)
							{
								crVector3 targetPos = m_stream->_readVec3();
								itemData->getParam(WCHDATA_UserExtraID,param);
								_crInt32 userExtraID = *((_crInt32*)param);
								itemData->getParam(WCHDATA_JXJUserOverlapMaxCount,param);
								char maxOverlapCount = *((char*)param);

								char can = 1;//0：不能，1：可以，2：修改叠加数量
								short extraid = LOINT32(userExtraID);
								short extrapri = HIINT32(userExtraID);
								extraData->excHandle(MAKEINT64(WCH_LockData,1));
								extraData->getParam(WCHDATA_ExtraIDMap,param);
								ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
								ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
								_crInt8 overlapCount = 0;
								if(exitr != extraIDMap->end())
								{
									if(extrapri<HIINT16(exitr->second))
									{
										can = 0;
									}
									else if(extrapri == HIINT16(exitr->second))
									{
										can = 2;
										overlapCount = LOINT16(exitr->second);
										if(overlapCount<maxOverlapCount-1)
											overlapCount++;
									}
								}
								if(can==1)
								{
									crHandle *cloneHandle = handle->clone();
									cloneHandle->inputParam(WCHDATA_FireItem,m_this);
									short count = (short)overlapCount+1;
									cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
									cloneHandle->inputParam(WCHDATA_JXJItemUseTargetPos,&targetPos);
									extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
									//(*extraIDMap)[extraid] = extrapri;
									(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
								}
								else if(can==2)
								{
									crHandle *cloneHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
									if(!cloneHandle)
									{
										cloneHandle = handle->clone();
										extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
									}
									cloneHandle->inputParam(WCHDATA_FireItem,m_this);
									short count = (short)overlapCount+1;
									cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
									cloneHandle->inputParam(WCHDATA_JXJItemUseTargetPos,&targetPos);
									(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
								}
								extraData->excHandle(MAKEINT64(WCH_LockData,0));

								if(can>0)
								{
									unsigned char usertype = m_this->getItemtype();
									int userid = m_this->getID();
									//int userroleid = m_useItemParam->m_user->getRoleID();
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(5);
									stream->_writeInt(itemid);
									stream->_writeChar(overlapCount);
									if(usertype == crInstanceItem::Role)
									{
										crPlayerEventPacket packet;
										crPlayerEventPacket::buildRequestPacket(packet,userid,m_this,WCH_RecvUserExtra,stream.get());

										ref_ptr<crSceneServerPlayerData> firePlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(userid));
										if(firePlayerData.valid())
										{
											sceneServerConductor->getNetManager()->sendPacket(firePlayerData->getPlayerConnectServerAddress(),packet);
										}
										scene->sendPacketToItemNeighbor(m_this,packet);
									}
									else
									{
										crItemEventPacket packet;
										crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvUserExtra,stream.get());

										scene->sendPacketToItemNeighbor(m_this,packet);
									}
								}
							}
						}
					}
				}
			}
			unsigned char itemstate = IS_Stop;
			userData->inputParam(WCHDATA_ItemState,&itemstate);
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char itemstate = IS_RecvItemUse;
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_ItemState,&itemstate);

		}
	}
}
///////////////////////////////////////// 
//
//crJXJRecvItemUseUpdateMethod
//
/////////////////////////////////////////
crJXJRecvItemUseUpdateMethod::crJXJRecvItemUseUpdateMethod(){}
crJXJRecvItemUseUpdateMethod::crJXJRecvItemUseUpdateMethod(const crJXJRecvItemUseUpdateMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvItemUseUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJRecvItemUseUpdateMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvItemUseUpdateMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_ItemState,param);
	unsigned char itemstate = *(unsigned char *)param;
	if(itemstate == IS_RecvItemUse)
	{
		itemstate = IS_Stop;
		data->inputParam(WCHDATA_ItemState,&itemstate);
		crNode *userNode = m_this->getRelNode();
		if(userNode)
		{
			data->getParam(WCHDATA_ItemUseParam,param);
			ItemUseParam *itemUseParam = (ItemUseParam *)param;
			if(itemUseParam && itemUseParam->isValid())
			{
				userNode->doEvent(WCH_ItemUse,MAKEINT64(itemUseParam,NULL));
			}
		}
	}
}
///////////////////////////////////////// 
//
//crJXJUseItemActMethod
//
/////////////////////////////////////////
crJXJUseItemActMethod::crJXJUseItemActMethod():
	m_cdtime(0.5f){}
crJXJUseItemActMethod::crJXJUseItemActMethod(const crJXJUseItemActMethod& handle):
	crMethod(handle),
	m_cdtime(0.5f)
{
}
void crJXJUseItemActMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_cdtime = *(float *)(LOINT64(param64));
			m_item = (crInstanceItem*)(HIINT64(param64));	
		}
		break;
	}
}

void crJXJUseItemActMethod::addParam(int i, const std::string& str)
{
}

void crJXJUseItemActMethod::operator()(crHandle &handle)
{
	if(m_item)
	{
		void *param;
		crData *data = m_item->getDataClass();
		data->getParam(WCHDATA_DataType,param);
		unsigned char datatype = *(unsigned char *)param;
		crData *thisData = m_this->getDataClass();
		if(datatype == DT_Attack)
		{
			thisData->getParam(WCHDATA_IsMiss,param);
			bool isMiss = *(bool *)param;
			thisData->getParam(WCHDATA_IsCrit,param);
			bool isCrit = *(bool *)param;
			if(!isMiss && isCrit)
			{
				m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_CritAttack,&m_cdtime));
			}
			else
			{
				bool isTargetNear = false;
				m_this->doEvent(WCH_TargetNearTest,MAKEINT64(&isTargetNear,NULL));
				if(isTargetNear)
					m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_NearAttack,&m_cdtime));
				else
					m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Attack,&m_cdtime));
			}
			isMiss = false;
			isCrit = false;
			thisData->inputParam(WCHDATA_IsMiss,&isMiss);
			thisData->inputParam(WCHDATA_IsCrit,&isCrit);
		}
		else
		{
			m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Skill,&m_cdtime));
		}
	}
}
///////////////////////////////////////// 
//
//crJXJTargetNearTestMethod
//
/////////////////////////////////////////
crJXJTargetNearTestMethod::crJXJTargetNearTestMethod():
m_dist(3.0f),
m_isTargetNear(NULL){}
crJXJTargetNearTestMethod::crJXJTargetNearTestMethod(const crJXJTargetNearTestMethod& handle):
crMethod(handle),
m_dist(handle.m_dist),
m_isTargetNear(NULL)
{
}
void crJXJTargetNearTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_isTargetNear = (bool *)(LOINT64(param64));	
		}
		break;
	}
}

void crJXJTargetNearTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_dist = atof(str.c_str());
		break;
	}
}

void crJXJTargetNearTestMethod::operator()(crHandle &handle)
{
	if(m_isTargetNear)
	{
		ref_ptr<crInstanceItem> targetItem;
		ref_ptr<crMatrixTransform> targetNode;
		m_this->clientGetTarget(targetItem,targetNode);
		if(targetItem.valid())
		{
			crVector3f mypos = m_this->getPosition();
			crVector3f targetpos = targetItem->getPosition();
			*m_isTargetNear = (targetpos-mypos).length()<m_dist;
		}
	}
}
///////////////////////////////////////// 
//
//crJXJItemUseNoActMethod
//
/////////////////////////////////////////
crJXJItemUseNoActMethod::crJXJItemUseNoActMethod(){}
crJXJItemUseNoActMethod::crJXJItemUseNoActMethod(const crJXJItemUseNoActMethod& handle):
	crMethod(handle)
{
}
void crJXJItemUseNoActMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJItemUseNoActMethod::addParam(int i, const std::string& str)
{
}

void crJXJItemUseNoActMethod::operator()(crHandle &handle)
{//箭塔攻击
	crNode *userNode = m_this->getRelNode();
	if(userNode)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_ItemState,param);
		//unsigned char itemstate = *(unsigned char *)param;
		//if(itemstate == IS_UseItem)
		//{
			unsigned char itemstate = IS_Stop;
			data->inputParam(WCHDATA_ItemState,&itemstate);
			if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
			{
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeUChar(itemstate);//1
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvItemState,m_this,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		//}
		data->getParam(WCHDATA_AttackUseParam,param);
		ItemUseParam *itemUseParam = (ItemUseParam *)param;
		if(itemUseParam && itemUseParam->isValid())
		{
			userNode->doEvent(WCH_ItemUse,MAKEINT64(itemUseParam,NULL));
			itemUseParam->clear();
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////// 
//
//crJXJItemHurtActMethod
//
/////////////////////////////////////////
crJXJItemHurtActMethod::crJXJItemHurtActMethod():
	m_hurtActTime(0.5f){}
crJXJItemHurtActMethod::crJXJItemHurtActMethod(const crJXJItemHurtActMethod& handle):
	crMethod(handle),
	m_hurtActTime(0.5f)
{
}
void crJXJItemHurtActMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_bulletItem = (crInstanceItem*)(LOINT64(param64));
		}
		break;
	}
}

void crJXJItemHurtActMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_hurtActTime = atof(str.c_str());
		break;
	}
}

void crJXJItemHurtActMethod::operator()(crHandle &handle)
{
	if(m_bulletItem && m_bulletItem->getDataClass())
	{
		void *param;
		crData *data = m_bulletItem->getDataClass();
		data->getParam(WCHDATA_DataType,param);
		unsigned char datatype = *(unsigned char *)param;
		if(datatype == DT_Attack)
		{
			crData *thisData = m_this->getDataClass();
			thisData->getParam(WCHDATA_IsDodge,param);
			bool isDodge = *(bool *)param;
			thisData->getParam(WCHDATA_IsParry,param);
			bool isParry = *(bool *)param;
			if(isDodge)
			{
				m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Dodge,&m_hurtActTime));
			}
			else if(isParry)
			{
				m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Parry,&m_hurtActTime));
			}
			else
			{
				m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Hurt,&m_hurtActTime));
			}
			isDodge = false;
			isParry = false;
			thisData->inputParam(WCHDATA_IsDodge,&isDodge);
			thisData->inputParam(WCHDATA_IsParry,&isParry);
		}
		else
		{
			m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Hurt,&m_hurtActTime));
		}
	}
}
///////////////////////////////////////////
////
////crJXJLoginBattleSceneMethod
////
///////////////////////////////////////////
//crJXJLoginBattleSceneMethod::crJXJLoginBattleSceneMethod(){}
//crJXJLoginBattleSceneMethod::crJXJLoginBattleSceneMethod(const crJXJLoginBattleSceneMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJLoginBattleSceneMethod::inputParam(int i, void *param)
//{
//}
//
//void crJXJLoginBattleSceneMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJLoginBattleSceneMethod::operator()(crHandle &handle)
//{
//	bool taskCanceled = true;
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(myPlayer)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
//		unsigned char type = *(unsigned char *)param;
//		if(type == FT_Chengchi)
//		{
//			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
//			unsigned short chengchiid = *(unsigned short *)param;
//			if(chengchiid>0)
//			{
//				ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
//				crTableIO::StrVec record;
//				if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record))
//				{
//					int sceneid = atoi(record[chengchiTab->getTitleIndex("sceneid")].c_str());
//					if(sceneid>0)
//					{
//						crWaitNetReturnStreamLogic::getLock();
//						crMyPlayerData::getInstance()->setLoginGameSceneMode(1);
//						crLoginScenePacket packet;
//						crLoginScenePacket::buildRequestPacket(packet,sceneid);
//						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//						netConductor->getNetManager()->sendPacket("all",packet);
//						taskCanceled = false;
//					}
//				}
//			}
//		}
//	}
//	if(taskCanceled)
//	{
//		//std::string str = "进入战场失败！";
//		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1000,NULL));
//	}
//	handle.outputParam(0,&taskCanceled);
//}
/////////////////////////////////////////
//
//crJXJSearchBattleMethod
//
/////////////////////////////////////////
crJXJSearchBattleMethod::crJXJSearchBattleMethod()
{}
crJXJSearchBattleMethod::crJXJSearchBattleMethod(const crJXJSearchBattleMethod& handle):
	crMethod(handle)
{
}
void crJXJSearchBattleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJSearchBattleMethod::addParam(int i, const std::string& str)
{
}

void crJXJSearchBattleMethod::operator()(crHandle &handle)
{
	//bool taskCanceled = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJBattleRoomID,param);
		_crInt64 battleroomid = *(_crInt64 *)param;
		int roomid = HIINT64(battleroomid);
		if(roomid!=0)
		{
			//crWaitNetReturnStreamLogic::getLock();
			crJXJSearchBattlePacket packet;
			crJXJSearchBattlePacket::buildRequestPacket(packet,roomid);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			netConductor->getNetManager()->sendPacket("all",packet);
			//taskCanceled = false;
		}
	}
	//handle.outputParam(0,&taskCanceled);
	//crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	//if(myPlayer)
	//{
	//	void *param;
	//	crData *data = myPlayer->getDataClass();
	//	data->getParam(WCHDATA_JXJBattleChengchiID,param);
	//	unsigned short chengchiid = *(unsigned short *)param;
	//	if(chengchiid>0)
	//	{
	//		ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	//		crTableIO::StrVec record;
	//		chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record);
	//		int sceneid = atoi(record[chengchiTab->getTitleIndex("sceneid")].c_str());
	//		if(sceneid>0)
	//		{
	//			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	//			if(netConductor)
	//			{
	//				crWaitNetReturnStreamLogic::getLock();
	//				crJXJSearchBattlePacket packet;
	//				crJXJSearchBattlePacket::buildRequestPacket(packet,sceneid);
	//				netConductor->getNetManager()->sendPacket("all",packet);
	//			}
	//		}
	//	}
	//}
}
///////////////////////////////////////////
////
////crJXJCreateBattleMethod
////
///////////////////////////////////////////
//crJXJCreateBattleMethod::crJXJCreateBattleMethod(){}
//crJXJCreateBattleMethod::crJXJCreateBattleMethod(const crJXJCreateBattleMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJCreateBattleMethod::inputParam(int i, void *param)
//{
//}
//
//void crJXJCreateBattleMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJCreateBattleMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(myPlayer)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
//		unsigned char type = *(unsigned char *)param;
//		if(type == FT_Chengchi)
//		{
//			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
//			unsigned short chengchiid = *(unsigned short *)param;
//			if(chengchiid>0)
//			{
//				ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
//				crTableIO::StrVec record;
//				if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record))
//				{
//					int sceneid = atoi(record[chengchiTab->getTitleIndex("sceneid")].c_str());
//					if(sceneid>0)
//					{
//						int timeid = chengchiTab->getTitleIndex("时间");
//						int countid = chengchiTab->getTitleIndex("玩家数量");
//						int nameid = chengchiTab->getTitleIndex("名字");
//						if (timeid >= 0 && countid >=0 && nameid >= 0)
//						{
//							char battleMode = crRoom::Extern;
//							int timeLimit = atoi(record[timeid].c_str());
//							short playerCount = (short)(atoi(record[countid].c_str()));
//							std::string battleName = record[nameid];
//							bool friendlyFire = false;
//							crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//							if(netConductor)
//							{
//								//crWaitNetReturnStreamLogic::getLock();
//								ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
//								std::string creatorName = myPlayer->getMainRole()->getIName();
//								streamBuf->createBuf(16+creatorName.length()+battleName.length());
//								streamBuf->_writeString(creatorName);
//								streamBuf->_writeChar(battleMode);//1
//								streamBuf->_writeString(battleName);//16+4
//								streamBuf->_writeInt(timeLimit);//4
//								streamBuf->_writeShort(playerCount);//2
//								streamBuf->_writeBool(friendlyFire);//1
//								//streamBuf->_writeBool(true);//1 m_autoStart
//								//streamBuf->_writeFloat(10.0f);//4 m_autoStartTime
//								//streamBuf->_writeString(password);//8+4
//								crCreateSceneRoomPacket packet;
//								crCreateSceneRoomPacket::buildRequestPacket(packet,streamBuf.get());
//								netConductor->getNetManager()->sendPacket("all",packet);
//							}
//						}
//					}
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJTouchRoleMethod
//
/////////////////////////////////////////
crJXJTouchRoleMethod::crJXJTouchRoleMethod(){}
crJXJTouchRoleMethod::crJXJTouchRoleMethod(const crJXJTouchRoleMethod& handle):
	crMethod(handle)
{
}
void crJXJTouchRoleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
			m_camera = (crMatrixTransform *)(HIINT64(param64));
		}
		else
		{
			m_ea = NULL;
			m_camera = NULL;
		}
		break;
	}
}

void crJXJTouchRoleMethod::addParam(int i, const std::string& str)
{
}

void crJXJTouchRoleMethod::operator()(crHandle &handle)
{
	void *param;
	unsigned char itemstate;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_ItemState,param);
	itemstate = *(unsigned char *)param;
	if(itemstate == IS_Dead)//死亡的不可选中
		return;
	unsigned int guisestate = GS_Normal;
	m_this->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		if(guisestate & GS_StaticUnVisiable || guisestate & GS_UnVisiable || guisestate & GS_Stagnate/* || guisestate & GS_NoAttack*/ || guisestate & GS_Taunt || guisestate & GS_Confusion || guisestate & GS_Scare)
		{//不可被自己选中
			return;
		}
	}
	else
	{
		if(guisestate & GS_StaticUnVisiable || guisestate & GS_UnVisiable || guisestate & GS_Stagnate || guisestate & GS_NoAttack)
		{//不可被别人选中
			return;
		}
	}

	crNode *fxNode;
	crDecalUpdateCallback *callback;
	//crSelectNodeVisitor selectNode(false);
	ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
	if(camera.valid() && camera->getAttachedNode() && camera->getAttachedNode()->getDataClass())
	{
		crData* cameraData = camera->getAttachedNode()->getDataClass();
		CRCore::ScopedLock<crData> lock(*cameraData);
		cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
		SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
		if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
		{
			bool found = false;
			for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
				 itr != selectMyRoles->end();
				 ++itr )
			{
				if(itr->get()==m_this)
				{
					found = true;
					break;
				}
			}
			if(!found)
			{
				//selectNode.setSelect(true);
				//bot = m_this->getRelNode();
				//bot->accept(selectNode);
				selectMyRoles->push_back(dynamic_cast<crRole *>(m_this));
			}

			//显示装备信息
			//if(m_ea)
			//{
			//	double curTime = m_ea->time();
			//	m_this->doEvent(WCH_JXJTouchRoleShow,MAKEINT64(&curTime,NULL));
			//}
			m_this->doEvent(WCH_JXJTouchRoleShow);

			cameraData->getParam(WCHDATA_SelectItem,param);
			crInstanceItem *selectItem = (crInstanceItem*)param;
			if(selectItem)
			{
				fxNode = selectItem->findSceneFxNode("$SelectDecal");
				if(fxNode)
				{
					callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
					if(callback)
					{
						callback->setVisiable(false);
					}
				}
			}
			cameraData->inputParam(WCHDATA_SelectItem,NULL);
		}
		else
		{//选中的不是自己
			//selectNode.setSelect(false);
			cameraData->getParam(WCHDATA_JXJCameraOperator,param);
			unsigned short cameraoperator = *(unsigned short*)param;
			if(cameraoperator != Cam_AttackToPos && cameraoperator!=Cam_MoveToPos)
			{
				for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
					itr != selectMyRoles->end();
					++itr )
				{
					//bot = (*itr)->getRelNode();
					//bot->accept(selectNode);
					fxNode = (*itr)->findSceneFxNode("$SelectDecal");
					if(fxNode)
					{
						callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
						if(callback)
						{
							callback->setVisiable(false);
						}
					}
				}
				selectMyRoles->resize(0);
				cameraData->getParam(WCHDATA_SelectItem,param);
				crInstanceItem *selectItem = (crInstanceItem*)param;
				if(selectItem)
				{
					//selectItem->getRelNode()->accept(selectNode);
					fxNode = selectItem->findSceneFxNode("$SelectDecal");
					if(fxNode)
					{
						callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
						if(callback)
						{
							callback->setVisiable(false);
						}
					}
				}
				//selectNode.setSelect(true);
				//m_this->getRelNode()->accept(selectNode);
				cameraData->inputParam(WCHDATA_SelectItem,m_this);
				//if(m_ea)
				//{
				//	//显示装备信息
				//	double curTime = m_ea->time();
				//	m_this->doEvent(WCH_JXJTouchRoleShow,MAKEINT64(&curTime,NULL));
				//}
				m_this->doEvent(WCH_JXJTouchRoleShow);
			}
		
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISelectBirthPointInitMethod
//
/////////////////////////////////////////
crJXJUISelectBirthPointInitMethod::crJXJUISelectBirthPointInitMethod():
	m_this(NULL),
	m_selectTime(10)
{
}
crJXJUISelectBirthPointInitMethod::crJXJUISelectBirthPointInitMethod(const crJXJUISelectBirthPointInitMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_timerWidget(handle.m_timerWidget),
	m_CityHallPoint(handle.m_CityHallPoint),
	m_selectTime(handle.m_selectTime),
	m_battleMap(handle.m_battleMap),
	m_StrongholdButton(handle.m_StrongholdButton),
	m_AttackButton(handle.m_AttackButton),
	m_DefenseButton(handle.m_DefenseButton),
	m_StrongholdInput(handle.m_StrongholdInput),
	m_AttackInput(handle.m_AttackInput),
	m_DefenseInput(handle.m_DefenseInput),
	m_strInfo(handle.m_strInfo),
	m_strJuDian(handle.m_strJuDian)
{
}
void crJXJUISelectBirthPointInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUISelectBirthPointInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_timerWidget = str;
		break;
	case 1:
		m_CityHallPoint = str;
		break;
	case 2:
		m_battleMap = str;
		break;
	case 3:
		m_StrongholdButton = str;
		break;
	case 4:
		m_AttackButton = str;
		break;
	case 5:
		m_DefenseButton = str;
		break;
	case 6:
		m_StrongholdInput = str;
		break;
	case 7:
		m_AttackInput = str;
		break;
	case 8:
		m_DefenseInput = str;
		break;
	case 9:
		m_strInfo = str;
		break;
	case 10:
		m_strRotMap = str;
		break;
	}
}
void crJXJUISelectBirthPointInitMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(myPlayer && room && room->getDataClass())
	{
		void *param;
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if(camera.valid() && camera->getAttachedNode() && camera->getAttachedNode()->getDataClass())
		{
			crData* camadata = camera->getAttachedNode()->getDataClass();
			crData *data = myPlayer->getDataClass();
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char type = *(unsigned char *)param;
			if(type == FT_Chengchi)
			{
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short chengchiid = *(unsigned short *)param;
				if(chengchiid>0)
				{
					ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
					crTableIO::StrVec record;
					int chusindex = chengchiTab->getTitleIndex("出生点数");
					//int mapindex = chengchiTab->getTitleIndex("map");
					int ashiliInfoIndex = chengchiTab->getTitleIndex("攻方胜利条件");
					int dshiliInfoIndex = chengchiTab->getTitleIndex("守方胜利条件");
					if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0 && chusindex >=0/*&& mapindex >= 0*/)
					{
						std::string str = record[chusindex];
						crVector2i vec;
						crArgumentParser::appAtoVec(str,vec);

						data->getParam(WCHDATA_JXJChengChiMap,param);
						ChengchiMap *chengchimap = (ChengchiMap *)param;
						crData *roomdata = room->getDataClass();
						roomdata->getParam(WCHDATA_JXJBattleID,param);
						_crInt32 battleid = *(_crInt32 *)param;
						unsigned char ashili = LOINT16(LOINT32(battleid));
						unsigned char dshili = HIINT16(LOINT32(battleid));//(*chengchimap)[chengchiid]->getChengzhuShili();
						data->getParam(WCHDATA_JXJShiliID,param);
						unsigned char myShili = *(unsigned char *)param;
						int count = dshili == myShili?vec[1]:vec[0];

						const crMatrix &scaleMat = crDisplaySettings::instance()->getUIScaleMatrix();
						const crMatrix &invScaleMat = crDisplaySettings::instance()->getInvUIScaleMatrix();
						//crMatrix rotmat;
						ref_ptr<crImageBoxWidgetNode > battleMap = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_battleMap));
						//crVector3 trans = battleMap->getBound().center();
						//crMatrix put_mat = crMatrix::translate(trans);
						//crMatrix inv_put = crMatrix::inverse(put_mat);
						crVector2 mapWidgetSize;
						const crBoundingBox &mapbbox = battleMap->getBoundBox();
						mapWidgetSize.set(mapbbox.xLength(),mapbbox.yLength());
						crVector2 mapFactor = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize);
						//crCamera *camera = crCameraManager::getInstance()->getMainCamera();

						ref_ptr<crWidgetNode>rotMapWidget = dynamic_cast<crWidgetNode *>(m_this->getWidget(m_strRotMap));
						crMatrix viewerMat = camera->getCameraMatrix();
						viewerMat.setTrans(0.0f,0.0f,0.0f);
						crVector3 camDir = (-Y_AXIS * viewerMat).normalize();
						camDir[2] = 0.0f;
						camDir.normalize();
						CRCore::crMatrix newMat;
						if(camDir == crVector3(0.0f,0.0f,0.0f))
						{
							camDir[1] = -1.0f;
						}
						if(camDir[1] > 0.999)
						{
							newMat.makeRotate(-CRCore::Y_AXIS,camDir);
							CRCore::crVector3d ep,center,up;
							newMat.getLookAt(ep,center,up);
							if(center[2]>0.0f)
							{
								center = -center;
							}
							newMat.makeLookAt(ep,center,up);
						}
						else
							newMat.makeRotate(-CRCore::Y_AXIS,camDir);
						crMatrixf invertRot = crMatrix::inverse(newMat);
						//if(rotMapWidget.valid())
						//{
						//	crCamera *camera = crCameraManager::getInstance()->getMainCamera();
						//	crMatrix viewerMat = camera->getCameraMatrix();//viewer->getViewCameraNode();
						//	viewerMat.setTrans(0.0f,0.0f,0.0f);
						//	crVector3 camDir = (-Y_AXIS * viewerMat).normalize();
						//	camDir[2] = 0.0f;
						//	camDir.normalize();
						//	CRCore::crMatrix newMat;
						//	if(camDir == crVector3(0.0f,0.0f,0.0f))
						//	{
						//		camDir[1] = -1.0f;
						//	}
						//	if(camDir[1] > 0.999)
						//	{
						//		newMat.makeRotate(-CRCore::Y_AXIS,camDir);
						//		CRCore::crVector3d ep,center,up;
						//		newMat.getLookAt(ep,center,up);
						//		if(center[2]>0.0f)
						//		{
						//			center = -center;
						//		}
						//		newMat.makeLookAt(ep,center,up);
						//	}
						//	else
						//		newMat.makeRotate(-CRCore::Y_AXIS,camDir);
						//	rotmat.makeIdentity();
						//	rotmat.postMult(inv_put);
						//	rotmat.postMult(invScaleMat * newMat * scaleMat);
						//	rotmat.postMult(put_mat);
						//	rotMapWidget->setMatrix(rotmat);
						//	rotMapWidget->setEnableMatrix(true);
						//	rotMapWidget->setCanFocus(false);
						//}
						//crTableIO::StrVec Maprecord;
						//if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),Maprecord)>=0)
						//{
						//	std::string mapname = Maprecord[mapindex];
						//	battleMap->setImageName(mapname);
						//}
						////crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(camera->getAttachedNode());

						ref_ptr<crWidgetNode> judianshuming = dynamic_cast<crWidgetNode *>(m_this->getWidget("Dianji"));
						ref_ptr<crWidgetNode> hallshuming = dynamic_cast<crWidgetNode *>(m_this->getWidget("Jipo"));
						ref_ptr<crButtonWidgetNode> buttonS = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_StrongholdButton));
						ref_ptr<crButtonWidgetNode> buttonA = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_AttackButton));
						ref_ptr<crButtonWidgetNode> buttonD = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_DefenseButton));
						buttonS->setVisiable(false);
						buttonA->setVisiable(false);
						buttonD->setVisiable(false);

						ref_ptr<crStaticTextWidgetNode> inputS = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_StrongholdInput));
						ref_ptr<crStaticTextWidgetNode> inputA = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_AttackInput));
						ref_ptr<crStaticTextWidgetNode> inputD = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_DefenseInput));

						if(judianshuming.valid())
							judianshuming->setVisiable(false);
						if(hallshuming.valid())
							hallshuming->setVisiable(false);

						crSceneLayer::BirthPointArray pointVec = crMyPlayerData::getInstance()->getSceneLayer()->getBirthPointArray();

						camadata->excHandle(MAKEINT64(WCH_LockData,1));
						camadata->getParam(WCHDATA_JXJBirthPointButtonVec,param);
						ButtonVector *btVec = (ButtonVector *)param;
						ref_ptr<crButtonWidgetNode> button = NULL;
						ref_ptr<crStaticTextWidgetNode> input = NULL;
						int myIndex = 0,otherIndex = 0;
						int index = 0;
						for(;index<pointVec.size();index++)
						{
							std::string inputstr;
							if(myShili == dshili)
							{
								if(index<vec[0])
								{
									//复制红色
									continue;
	// 								button = dynamic_cast<crButtonWidgetNode*>(buttonA->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
	// 								if(!button) continue;
	// 								inputstr = "敌方"+ crArgumentParser::appItoa(++otherIndex);
								}
								else
								{
									//复制蓝色
									button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
									if(!button) continue;
									crData *data = button->getDataClass();
									data->inputParam(WCHDATA_JXJBirthPointButtonData,&(pointVec[index]));
									//myIndex++;
									inputstr = "己方" + crArgumentParser::appItoa(++myIndex);
								}
							}
							else
							{
								if(index<vec[0])
								{
									//复制蓝色
									continue;
	// 								button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
	// 								if(!button) continue;
	// 
	// 								crData *data = button->getDataClass();
	// 								data->inputParam(WCHDATA_JXJBirthPointButtonData,&(pointVec[index]));
	// 								//myIndex++;
	// 								inputstr = "己方" + crArgumentParser::appItoa(++myIndex);
								}
								else
								{
									//复制红色
									button = dynamic_cast<crButtonWidgetNode*>(buttonA->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
									if(!button) continue;

									inputstr = "敌方"+ crArgumentParser::appItoa(++otherIndex);
								}
							}
							button->initWindow();
							button->setParentCanvas(m_this);
							button->setVisiable(true);
							button->setEnable(true);

							float px =pointVec[index].x()*crGlobalHandle::gData()->gUnitScale();
							float py =pointVec[index].y()*crGlobalHandle::gData()->gUnitScale();
							px *= mapFactor[0];
							py *= mapFactor[1];
							button->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(battleMap->getBound().center()+crVector3(px,py,0.0f)));
							btVec->push_back(button.get());
							if(rotMapWidget.valid())
							{
								crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
							}
							else
							{
								crLoadManager::getInstance()->requestAddNode(battleMap.get(),button.get(),false);
							}
							if(inputD.valid())
							{
								inputD->setEnable(true);
								inputD->setEnableMatrix(true);
								input = dynamic_cast<crStaticTextWidgetNode*>(inputD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
								input->setString(inputstr);
								input->setColor(crVector4(255.0,255.0,0.0,255.0));
								input->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(button->getBoundBox().center().x(),button->getBoundBox().center().y()+0.05f,0.0f));
								input->setParentCanvas(m_this);
								if(rotMapWidget.valid())
								{
									crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),input.get(),false);
								}
								else
								{
									crLoadManager::getInstance()->requestAddNode(battleMap.get(),input.get(),false);
								}
							}
						}
						//
						camadata->excHandle(MAKEINT64(WCH_LockData,0));

						bool isMyshiliCampEmpty = false;
 						//crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
 						//if(room)
 						//{
 						//	crData *roomData = room->getDataClass();
 						//	if(roomData)
 						//	{
 								roomdata->excHandle(MAKEINT64(WCH_LockData,1));
 								roomdata->getParam(WCHDATA_JXJCampBirthPointMap,param);
 								JXJCampBirthpointMap *campMap = (JXJCampBirthpointMap *)param;

								//roomData->getParam(WCHDATA_JXJBattleID,param);
								//int battleid = *(int *)param;
								//unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
								//unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));

								JXJCampBirthpoint::iterator itr_point;
								if(campMap)
								{
									if((*campMap)[myShili].empty()) isMyshiliCampEmpty = true;

 									JXJCampBirthpointMap::iterator itr_map = campMap->begin();
									//int judianIndex = 1;
									for (;itr_map!=campMap->end();itr_map++)
									{
										itr_point = itr_map->second.begin();
										for (;itr_point!=itr_map->second.end();itr_point++)
										{
											if(myShili == dshili)
											{
												if(itr_map->first == myShili)
												{
													button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												}
												else if(itr_map->first == ashili)
												{
													button = dynamic_cast<crButtonWidgetNode*>(buttonA->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												}
												else
												{
													button = dynamic_cast<crButtonWidgetNode*>(buttonS->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												}
											}
											else
											{
												if(itr_map->first == myShili)
												{
													button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												}
												else if(itr_map->first == dshili)
												{
													button = dynamic_cast<crButtonWidgetNode*>(buttonA->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												}
												else
												{
													button = dynamic_cast<crButtonWidgetNode*>(buttonS->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												}
											}
											if(!button) continue;

											button->initWindow();
											button->setParentCanvas(m_this);
											button->setVisiable(true);
											button->setEnable(true);
											crData *data = button->getDataClass();
 											if(itr_map->first == myShili)
 											{
												crVector3i pos = itr_point->first;
 												data->inputParam(WCHDATA_JXJBirthPointButtonData,&pos);
 												//index++;
 											}
											float px =itr_point->first.x()*crGlobalHandle::gData()->gUnitScale();
											float py =itr_point->first.y()*crGlobalHandle::gData()->gUnitScale();
											px *= mapFactor[0];
											py *= mapFactor[1];
											button->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(battleMap->getBound().center()+crVector3(px,py,0.0f)));
											btVec->push_back(button.get());

											if(rotMapWidget.valid())
											{
												crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
											}
											else
											{
												crLoadManager::getInstance()->requestAddNode(battleMap.get(),button.get(),false);
											}

											if(inputD.valid())
											{
												inputD->setEnable(true);
												inputD->setEnableMatrix(true);
												input = dynamic_cast<crStaticTextWidgetNode*>(inputD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
												input->setString(itr_point->second);
												input->setColor(crVector4(255.0,255.0,0.0,255.0));
												input->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(button->getBoundBox().center().x(),button->getBoundBox().center().y()+0.05f,0.0f));
												input->setParentCanvas(m_this);
												if(rotMapWidget.valid())
												{
													crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),input.get(),false);
												}
												else
												{
													crLoadManager::getInstance()->requestAddNode(battleMap.get(),input.get(),false);
												}
											}
										}
									}
								}
													
 								roomdata->excHandle(MAKEINT64(WCH_LockData,0));
 							//}
 						//}

						data->getParam(WCHDATA_JXJVipLv,param);
						unsigned char vipLevel = *(unsigned char *)param;
						m_selectTime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJChooseTimeLimit,vipLevel).c_str()));
						if(isMyshiliCampEmpty) m_selectTime = 5.0f;
						camadata->inputParam(WCHDATA_JXJBattleChoosePointTimer,&m_selectTime);

						ref_ptr<crStaticTextWidgetNode> staticInfo = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_strInfo));
						if(staticInfo.valid() && ashiliInfoIndex>=0 && dshiliInfoIndex>=0 )
						{
							std::string strInfo = (dshili == myShili)?record[dshiliInfoIndex]:record[ashiliInfoIndex];
							staticInfo->setString(strInfo);
						}

						ref_ptr<crTableIO> chengchiMarkTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengchiMarkTab);
						if (chengchiMarkTab.valid())
						{
							crTableIO::StrVec recordid;
							int idxIndex = chengchiMarkTab->getTitleIndex("x");
							int idyIndex = chengchiMarkTab->getTitleIndex("y");
							int iconIndex = chengchiMarkTab->getTitleIndex("icon");
							if(chengchiMarkTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),recordid)>=0)
							{
								ref_ptr<crImageBoxWidgetNode>cityHallPoint = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_CityHallPoint));
								if (cityHallPoint.valid())
								{
									cityHallPoint->setVisiable(false);
									ref_ptr<crImageBoxWidgetNode>cityHallNode = dynamic_cast<crImageBoxWidgetNode*>(cityHallPoint->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
									if(cityHallNode.valid())
									{
										cityHallNode->initWindow();
										cityHallNode->setImageName(recordid[iconIndex]);
										float px =atof(recordid[idxIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
										float py =atof(recordid[idyIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
										px *= mapFactor[0];
										py *= mapFactor[1];

										crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(), cityHallNode.get(), false);
										cityHallNode->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(battleMap->getBound().center() + crVector3(px, py, 0.0f)));
										cityHallNode->setVisiable(true);
									}
								}
							}
						}
					}
				}
			}
			else
			{
				unsigned short chengchiid = 10003;

				const crMatrix &scaleMat = crDisplaySettings::instance()->getUIScaleMatrix();
				const crMatrix &invScaleMat = crDisplaySettings::instance()->getInvUIScaleMatrix();
				//crMatrix rotmat;
				ref_ptr<crImageBoxWidgetNode > battleMap = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_battleMap));

				crVector2 mapWidgetSize;
				const crBoundingBox &mapbbox = battleMap->getBoundBox();
				mapWidgetSize.set(mapbbox.xLength(),mapbbox.yLength());
				crVector2 mapFactor = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize);
				//crCamera *camera = crCameraManager::getInstance()->getMainCamera();

				ref_ptr<crWidgetNode>rotMapWidget = dynamic_cast<crWidgetNode *>(m_this->getWidget(m_strRotMap));
				crMatrix viewerMat = camera->getCameraMatrix();
				viewerMat.setTrans(0.0f,0.0f,0.0f);
				crVector3 camDir = (-Y_AXIS * viewerMat).normalize();
				camDir[2] = 0.0f;
				camDir.normalize();
				CRCore::crMatrix newMat;
				if(camDir == crVector3(0.0f,0.0f,0.0f))
				{
					camDir[1] = -1.0f;
				}
				if(camDir[1] > 0.999)
				{
					newMat.makeRotate(-CRCore::Y_AXIS,camDir);
					CRCore::crVector3d ep,center,up;
					newMat.getLookAt(ep,center,up);
					if(center[2]>0.0f)
					{
						center = -center;
					}
					newMat.makeLookAt(ep,center,up);
				}
				else
					newMat.makeRotate(-CRCore::Y_AXIS,camDir);
				crMatrixf invertRot = crMatrix::inverse(newMat);

				ref_ptr<crWidgetNode> judianshuming = dynamic_cast<crWidgetNode *>(m_this->getWidget("Dianji"));
				ref_ptr<crWidgetNode> hallshuming = dynamic_cast<crWidgetNode *>(m_this->getWidget("Jipo"));
				ref_ptr<crButtonWidgetNode> buttonS = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_StrongholdButton));
				ref_ptr<crButtonWidgetNode> buttonA = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_AttackButton));
				ref_ptr<crButtonWidgetNode> buttonD = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_DefenseButton));
				buttonS->setVisiable(false);
				buttonA->setVisiable(false);
				buttonD->setVisiable(false);

				ref_ptr<crStaticTextWidgetNode> inputS = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_StrongholdInput));
				ref_ptr<crStaticTextWidgetNode> inputA = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_AttackInput));
				ref_ptr<crStaticTextWidgetNode> inputD = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_DefenseInput));

				if(judianshuming.valid())
					judianshuming->setVisiable(false);
				if(hallshuming.valid())
					hallshuming->setVisiable(false);

				crSceneLayer::BirthPointArray pointVec = crMyPlayerData::getInstance()->getSceneLayer()->getBirthPointArray();

				camadata->excHandle(MAKEINT64(WCH_LockData,1));
				camadata->getParam(WCHDATA_JXJBirthPointButtonVec,param);
				ButtonVector *btVec = (ButtonVector *)param;
				ref_ptr<crButtonWidgetNode> button = NULL;
				ref_ptr<crStaticTextWidgetNode> input = NULL;
				ref_ptr<crWidgetNode> judian = NULL;
				ref_ptr<crWidgetNode> hall = NULL;
				int myIndex = 0,otherIndex = 0;
				int index = 0;
				for(;index<pointVec.size();index++)
				{
					std::string inputstr;
								
					//复制蓝色
					button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
					if(!button) continue;
					//ref_ptr<crMultiSwitch> shuomingsw = dynamic_cast<crMultiSwitch *>(button->getChildNode(m_zonglansw));
					crData *data = button->getDataClass();
					data->inputParam(WCHDATA_JXJBirthPointButtonData,&(pointVec[index]));
					//myIndex++;
					inputstr = "出生点";//"己方" + crArgumentParser::appItoa(++myIndex);
								
					button->initWindow();
					button->setParentCanvas(m_this);
					button->setVisiable(true);
					button->setEnable(true);

					float px =pointVec[index].x()*crGlobalHandle::gData()->gUnitScale();
					float py =pointVec[index].y()*crGlobalHandle::gData()->gUnitScale();
					px *= mapFactor[0];
					py *= mapFactor[1];
					button->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(battleMap->getBound().center()+crVector3(px,py,0.0f)));
					btVec->push_back(button.get());
					if(rotMapWidget.valid())
					{
						crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
					}
					else
					{
						crLoadManager::getInstance()->requestAddNode(battleMap.get(),button.get(),false);
					}
					if(inputD.valid())
					{
						inputD->setEnable(true);
						inputD->setEnableMatrix(true);
						input = dynamic_cast<crStaticTextWidgetNode*>(inputD->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
						input->setString(inputstr);
						input->setColor(crVector4(255.0,255.0,0.0,255.0));
						input->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(button->getBoundBox().center().x(),button->getBoundBox().center().y()+0.05f,0.0f));
						input->setParentCanvas(m_this);
						if(rotMapWidget.valid())
						{
							crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),input.get(),false);
						}
						else
						{
							crLoadManager::getInstance()->requestAddNode(battleMap.get(),input.get(),false);
						}
					}
					if(judianshuming.valid())
					{
						judianshuming->setEnable(true);
						judianshuming->setEnableMatrix(true);
						judian = dynamic_cast<crWidgetNode*>(judianshuming->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
						judian->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(button->getBoundBox().center().x()-button->getBoundBox().yLength()*0.4,button->getBoundBox().center().y(),0.0f));
						judian->setParentCanvas(m_this);
						if(rotMapWidget.valid())
						{
							crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),judian.get(),false);
						}
						else
						{
							crLoadManager::getInstance()->requestAddNode(battleMap.get(),judian.get(),false);
						}
						judian->setVisiable(true);
					}
				}
				//
				camadata->excHandle(MAKEINT64(WCH_LockData,0));

				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char vipLevel = *(unsigned char *)param;
				m_selectTime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJChooseTimeLimit,vipLevel).c_str()));
				//m_selectTime = 100.0f;
				camadata->inputParam(WCHDATA_JXJBattleChoosePointTimer,&m_selectTime);

				ref_ptr<crStaticTextWidgetNode> staticInfo = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_strInfo));
				if(staticInfo.valid())
				{
					//std::string strInfo = (dshili == myShili)?record[dshiliInfoIndex]:record[ashiliInfoIndex];
					std::string strInfo = "攻破敌方政厅";
					staticInfo->setString(strInfo);
				}

				ref_ptr<crTableIO> chengchiMarkTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengchiMarkTab);
				if (chengchiMarkTab.valid())
				{
					crTableIO::StrVec recordid;
					int idxIndex = chengchiMarkTab->getTitleIndex("x");
					int idyIndex = chengchiMarkTab->getTitleIndex("y");
					int iconIndex = chengchiMarkTab->getTitleIndex("icon");
					if(chengchiMarkTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),recordid)>=0)
					{
						ref_ptr<crImageBoxWidgetNode>cityHallPoint = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_CityHallPoint));
						if (cityHallPoint.valid())
						{
							cityHallPoint->setVisiable(false);
							ref_ptr<crImageBoxWidgetNode>cityHallNode = dynamic_cast<crImageBoxWidgetNode*>(cityHallPoint->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
							if(cityHallNode.valid())
							{
								cityHallNode->initWindow();
								//cityHallNode->setImageName(recordid[iconIndex]);
								cityHallNode->setImageName("T_CopyBattle_Xianshi3.img");
								float px =atof(recordid[idxIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
								float py =atof(recordid[idyIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
								px *= mapFactor[0];
								py *= mapFactor[1];

								crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(), cityHallNode.get(), false);
								cityHallNode->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(battleMap->getBound().center() + crVector3(px, py, 0.0f)));
								cityHallNode->setVisiable(true);

								if(hallshuming.valid())
								{
									/*judianshuming->setEnable(true);
									judianshuming->setEnableMatrix(true);*/
									hall = dynamic_cast<crWidgetNode*>(hallshuming->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
									hall->setEnableMatrix(true);
									hall->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::translate(cityHallNode->getBoundBox().center().x()-cityHallNode->getBoundBox().yLength()*0.6,cityHallNode->getBoundBox().center().y(),0.0f));
									//hall->setParentCanvas(m_this);
									if(rotMapWidget.valid())
									{
										crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),hall.get(),false);
									}
									else
									{
										crLoadManager::getInstance()->requestAddNode(battleMap.get(),hall.get(),false);
									}
									hall->setVisiable(true);
								}
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISelectedBirthPointMethod
//
/////////////////////////////////////////
crJXJUISelectedBirthPointMethod::crJXJUISelectedBirthPointMethod():
	m_this(NULL)
{
}
crJXJUISelectedBirthPointMethod::crJXJUISelectedBirthPointMethod(const crJXJUISelectedBirthPointMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_birthPointRadioGroup(handle.m_birthPointRadioGroup)
{
}
void crJXJUISelectedBirthPointMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISelectedBirthPointMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_birthPointRadioGroup = str;
		break;
	}
}
void crJXJUISelectedBirthPointMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(myPlayer && room && room->getDataClass())
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		if(type == FT_Chengchi)
		{
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short chengchiid = *(unsigned short *)param;
			if(chengchiid>0)
			{
				ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
				{
					std::string str = record[chengchiTab->getTitleIndex("出生点数")];
					crVector2i vec;
					crArgumentParser::appAtoVec(str,vec);

					data->getParam(WCHDATA_JXJChengChiMap,param);
					ChengchiMap *chengchimap = (ChengchiMap *)param;
					crData *roomdata = room->getDataClass();
					roomdata->getParam(WCHDATA_JXJBattleID,param);
					_crInt32 battleid = *(_crInt32 *)param;
					unsigned char ashili = LOINT16(LOINT32(battleid));
					unsigned char dshili = HIINT16(LOINT32(battleid));//(*chengchimap)[chengchiid]->getChengzhuShili();
					data->getParam(WCHDATA_JXJShiliID,param);
					unsigned char myShili = *(unsigned char *)param;

					ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
					ref_ptr<crRadioGroupWidgetNode> birthPointRadio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_birthPointRadioGroup));
					char selectid = birthPointRadio->getSelect();
					if(myShili == dshili)
					{//我是守方
						selectid += vec[0];
					}
					crSceneLayer::BirthPointArray pointVec = crMyPlayerData::getInstance()->getSceneLayer()->getBirthPointArray();
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor && selectid< pointVec.size())
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(12);
						stream->_writeVec3i(pointVec[selectid]);
						crPlayerDataSceneEventPacket packet;
						crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvBirthPoint,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerJoinRoomMethod
//
/////////////////////////////////////////
crJXJPlayerJoinRoomMethod::crJXJPlayerJoinRoomMethod(){}
crJXJPlayerJoinRoomMethod::crJXJPlayerJoinRoomMethod(const crJXJPlayerJoinRoomMethod& handle):
	crMethod(handle)
{
}
void crJXJPlayerJoinRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}

void crJXJPlayerJoinRoomMethod::addParam(int i, const std::string& str)
{
}

void crJXJPlayerJoinRoomMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid() && playerData->getRoomID()!=0)
		{
			crNetDataManager *netDataManager = sceneServer->getNetDataManager();
			crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			CRNetApp::crRoom* room = callback->findRoom(playerData->getRoomID());
			crRoomPlayer *roomPlayer = room->getMember(playerid);
			if(roomPlayer)
			{
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;
				roomPlayer->setGroupID(shiliid);
				roomPlayer->setCharacterName(playerData->getCharacterName());
				room->playerJoined(roomPlayer);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBirthPointMethod
//
/////////////////////////////////////////
crJXJRecvBirthPointMethod::crJXJRecvBirthPointMethod():
	m_netType(GameClient_Game){}
crJXJRecvBirthPointMethod::crJXJRecvBirthPointMethod(const crJXJRecvBirthPointMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBirthPointMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBirthPointMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvBirthPointMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			crVector3i birthPoint = m_stream->_readVec3i();
			int playerid = m_this->getPlayerID();
			crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && playerData->getRoomID()!=0)
			{
				crNetDataManager *netDataManager = sceneServer->getNetDataManager();
				crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crRoom* room = callback->findRoom(playerData->getRoomID());
				crRoomPlayer *roomPlayer = room->getMember(playerid);
				if(roomPlayer)
				{
					playerData->getPlayerGameData()->doEvent(WCH_PlayerJoinRoom);

					crRole *role = NULL;
					CRNetApp::crScene *scene = callback->findScene(playerData->getSceneID());
					//roomPlayer->setBirthPointIndex(index);
					crSceneServerPlayerData::RoleMap &roleMap = playerData->getRoleMap();
					//rangei range(-birthPoint[2],birthPoint[2]);
					float scale = crGlobalHandle::gData()->gUnitScale();
					crVector3 pos;
					for( crSceneServerPlayerData::RoleMap::iterator itr = roleMap.begin();
						itr != roleMap.end();
						++itr )
					{
						role = itr->second.get();
						//birthPoint[0] = birthPoint[0] + range.get_random();
						//birthPoint[1] = birthPoint[1] + range.get_random();
						if(!scene->findWalkablePos(role,crVector2((float)birthPoint[0]*scale,(float)birthPoint[1]*scale),c_walkableSearchRange,pos))
						{
							CRCore::notify(CRCore::ALWAYS)<<"crJXJRecvBirthPointMethod findWalkablePos失败 "<<birthPoint<<std::endl;
						}
						else
						{
							pos/=scale;
							//z = scene->getPosZ(role->getLayerID(),,birthPoint[1]*scale, role->getZoffset() * scale);
							role->setPosxy(pos[0],pos[1]);
							role->setPosz(pos[2]);
						}
					}
					room->setReady(roomPlayer);
					
					//void *param;
					//crData *data = m_this->getDataClass();
					//data->getParam(WCHDATA_JXJShiliID,param);
					//unsigned char shiliid = *(unsigned char *)param;
					//roomPlayer->setGroupID(shiliid);
					//room->playerJoined(roomPlayer);

					//crPlayerDataSceneEventPacket packet;
					//crPlayerDataSceneEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBirthPoint,NULL);
					//sceneServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIMapViewportUpdateMethod
//
/////////////////////////////////////////
crJXJUIMapViewportUpdateMethod::crJXJUIMapViewportUpdateMethod():
	m_this(NULL),
m_viewportWidget(NULL){}
crJXJUIMapViewportUpdateMethod::crJXJUIMapViewportUpdateMethod(const crJXJUIMapViewportUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_mapWidget(handle.m_mapWidget),
	m_viewportIcon(handle.m_viewportIcon),
	m_moveTargetIcon(handle.m_moveTargetIcon),
	m_viewportParent(handle.m_viewportParent),
	m_viewportWidget(NULL)
{
}
void crJXJUIMapViewportUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIMapViewportUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mapWidget = str;
		break;
	case 1:
		m_viewportIcon = str;
		break;
	case 2:
		m_moveTargetIcon = str;
		break;
	case 3:
		m_viewportParent = str;
		break;
	}
}
void crJXJUIMapViewportUpdateMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInGame())
	{
		if(!m_viewportWidget)
		{
			//crWidgetNode *viewportWidget = m_this->getWidget(m_viewportIcon);
			ref_ptr<crWidgetNode>viewportParentWidget = m_this->getWidget(m_viewportParent);
			if(viewportParentWidget.valid())
			{
				ref_ptr<crCanvasNode>mainCanvas = crFilterRenderManager::getInstance()->getMainCanvas();
				m_viewportWidget = mainCanvas->getWidget(m_viewportIcon);
				if(m_viewportWidget)
				{
					m_viewportWidget = dynamic_cast<crWidgetNode *>(m_viewportWidget->clone(crCopyOp::DEEP_COPY_NODES));
					m_viewportWidget->setVisiable(true);
					//viewportParentWidget->addChild(m_viewportWidget);
					crLoadManager::getInstance()->requestAddNode(viewportParentWidget.get(),m_viewportWidget,false);
				}
			}
		}
		if(m_viewportWidget)
		{
			ref_ptr<crImageBoxWidgetNode>mapWidget = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_mapWidget));
			crVector2 mapWidgetSize;
			const crBoundingBox &mapbbox = mapWidget->getBoundBox();

			mapWidgetSize.set(mapbbox.xLength(),mapbbox.yLength());
			crVector2 mapFactor = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize);
			//crMatrix scaleMat = crDisplaySettings::instance()->getUIScaleMatrix();
			crMatrix invScaleMat = crDisplaySettings::instance()->getInvUIScaleMatrix();
			ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
			if(camera.valid())
			{
				crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(camera->getAttachedNode());
				crVector3 campos = cameraNode->getTrans();
				crMatrixf rotation = cameraNode->getMatrix();
				rotation.setTrans(0.0f,0.0f,0.0f);
				crVector3 camDir = (-Y_AXIS * rotation).normalize();
				float x = -campos[2]/camDir[2];
				crVector3 tpos = campos + camDir * x;
				crVector3 coord;
				//const crMatrix& mat = cameraNode->getMatrix();
				//crVector3 pos,center,up;
				//mat.getLookAt(pos,center,up);
				//float x = center[2]/(pos[2]-center[2]);
				//crVector3 dir = center - pos;
				//crVector3 tpos = center + dir * x;
				coord[0] = tpos[0]*mapFactor[0];
				coord[1] = tpos[1]*mapFactor[1];
				coord += mapWidget->getBound().center();
				ref_ptr<crWidgetNode>rotMapWidget = m_this->getWidget("RotMap");
				coord = coord * rotMapWidget->getMatrix();
				//crVector3 eye,center,up;
				//cameraNode->getMatrix().getLookAt(eye,center,up);

				//float x,y,z;
				//cameraNode->getMatrix().getRotate().getRadians(x,y,z);
				//m_px = (campos[0]+campos[2]*tan(z)*cos(x)) * mapFactor[0];
				//m_py = (campos[1] + campos[2]*tan(z)*cos(y))* mapFactor[1];
				//m_px = campos.x()*center.z()/campos.z()* mapFactor[0];
				//m_py = campos.y()*center.z()/campos.z()* mapFactor[1];
				//m_px = -((center[0]*eye[2]-eye[0]*center[2])/(eye[2]-center[2]))*mapFactor[0];
				//m_py = -((center[1]*eye[2]-eye[1]*center[2])/(eye[2]-center[2]))*mapFactor[1];
				//m_px =-center[0]*mapFactor[0];
				//m_py =-center[1]*mapFactor[1];
				//crMatrixf rotation = cameraNode->getMatrix();
				//crQuat quat = rotation.getRotate();
				//double angle;
				//quat.getRotate(angle,crVector3(0,0,1));
				//CRCore::crMatrix newMat;
				//newMat.makeRotate(-angle,crVector3(0,0,1));

				m_viewportWidget->setMatrix(invScaleMat * crMatrix::translate(crVector3(coord[0],coord[1],0.0f)));
				//const crBoundingBox &viewportbbox = viewportWidget->getBoundBox();
				//crVector3 viewportcenter = viewportbbox.center();
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIUpdateMapInfoMethod
//
/////////////////////////////////////////
crJXJUIUpdateMapInfoMethod::crJXJUIUpdateMapInfoMethod():
	m_this(NULL){}
crJXJUIUpdateMapInfoMethod::crJXJUIUpdateMapInfoMethod(const crJXJUIUpdateMapInfoMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_nameWidget(handle.m_nameWidget),
	m_mapWidget(handle.m_mapWidget),
	m_myIconWidget(handle.m_myIconWidget),
	m_friendPlayerIconWidget(handle.m_friendPlayerIconWidget),
	m_threadPlayerIconWidget(handle.m_threadPlayerIconWidget),
	m_enemyPlayerIconWidget(handle.m_enemyPlayerIconWidget),
	m_friendNpcIconWidget(handle.m_friendNpcIconWidget),
	m_threadNpcIconWidget(handle.m_threadNpcIconWidget),
	m_enemyNpcIconWidget(handle.m_enemyNpcIconWidget),
	m_enemyBossIconWidget(handle.m_enemyBossIconWidget),
	m_itemIconWidget(handle.m_itemIconWidget),
	m_signalIcon(handle.m_signalIcon),
	m_rotMapWidget(handle.m_rotMapWidget),
	m_otherIconRoot(handle.m_otherIconRoot),
	m_playerIconRoot(handle.m_playerIconRoot)
{
}
void crJXJUIUpdateMapInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIUpdateMapInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameWidget = str;
		break;
	case 1:
		m_mapWidget = str;
		break;
	case 2:
		m_myIconWidget = str;
		break;
	case 3:
		m_friendPlayerIconWidget = str;
		break;
	case 4:
		m_threadPlayerIconWidget = str;
		break;
	case 5:
		m_enemyPlayerIconWidget = str;
		break;
	case 6:
		m_friendNpcIconWidget = str;
		break;
	case 7:
		m_threadNpcIconWidget = str;
		break;
	case 8:
		m_enemyNpcIconWidget = str;
		break;
	case 9:
		m_enemyBossIconWidget = str;
		break;
	case 10:
		m_itemIconWidget = str;
		break;
	case 11:
		m_signalIcon = str;
		break;
	case 12:
		m_rotMapWidget = str;
		break;
	case 13:
		m_myBulidingWidget = str;
		break;
	case 14:
		m_enemyBulidingWidget = str;
		break;
	case 15:
		m_thirdBulidingWidget = str;
		break;
	case 16:
		m_enemySmallBossIconWidget = str;
		break;
	case 17:
		m_otherIconRoot = str;
		break;
	case 18:
		m_playerIconRoot = str;
		break;
	case 19:
		m_buttonCanvas = str;
		break;
	case 20:
		m_AttackButton  = str;
		break;
	case 21:
		m_DefenseButton = str;
		break;
	case 22:
		m_StrongholdButton  = str;
		break;
	}
}
void crJXJUIUpdateMapInfoMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(me && m_this->getVisiable() && myPlayer)
	{
		const crMatrix &scaleMat = crDisplaySettings::instance()->getUIScaleMatrix();
		const crMatrix &invScaleMat = crDisplaySettings::instance()->getInvUIScaleMatrix();

		ref_ptr<crStaticTextWidgetNode> nameWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nameWidget));
		if(nameWidget.valid())
		{
			CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
			std::string str = scene->getSceneName();
			unsigned short layerid = me->getLayerID();
			if(layerid > 0)
			{
				str += ":"+crArgumentParser::appItoa(layerid);
			}
			nameWidget->setString(str);
		}
		ref_ptr<crImageBoxWidgetNode>mapWidget = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_mapWidget));
		crVector2 mapWidgetSize;
		const crBoundingBox &bbox = mapWidget->getBoundBox();
		mapWidgetSize.set(bbox.xLength(),bbox.yLength());
		crVector2 mapFactor = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize);

		ref_ptr<crWidgetNode>rotMapWidget = dynamic_cast<crWidgetNode *>(m_this->getWidget(m_rotMapWidget));

		ref_ptr<crGroup>otherIconRoot = dynamic_cast<crGroup *>(m_this->getChildNode(m_otherIconRoot));
		ref_ptr<crGroup>playerIconRoot = dynamic_cast<crGroup *>(m_this->getChildNode(m_playerIconRoot));
		if(!otherIconRoot.valid())
			otherIconRoot = dynamic_cast<crGroup *>(rotMapWidget.get());
		if(!playerIconRoot.valid())
			playerIconRoot = dynamic_cast<crGroup *>(rotMapWidget.get());


		ref_ptr<crCanvasNode> buttonCanvas = crFilterRenderManager::getInstance()->findCanvas(m_buttonCanvas);
		crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
		crData *roomdata = room?room->getDataClass():NULL;
		crData *data = myPlayer->getDataClass();
		if (buttonCanvas.valid() && roomdata && data)
		{
			ref_ptr<crButtonWidgetNode> buttonS = dynamic_cast<crButtonWidgetNode *>(buttonCanvas->getWidget(m_StrongholdButton));
			ref_ptr<crButtonWidgetNode> buttonA = dynamic_cast<crButtonWidgetNode *>(buttonCanvas->getWidget(m_AttackButton));
			ref_ptr<crButtonWidgetNode> buttonD = dynamic_cast<crButtonWidgetNode *>(buttonCanvas->getWidget(m_DefenseButton));
			for (int i = 0 ; i < m_defenseWidgetVec.size();++i)
			{
				m_defenseWidgetVec[i]->setVisiable(false);
			}
			for (int i = 0 ; i < m_attackWidgetVec.size();++i)
			{
				m_attackWidgetVec[i]->setVisiable(false);
			}
			for (int i = 0 ; i < m_strongholdWidgetVec.size();++i)
			{
				m_strongholdWidgetVec[i]->setVisiable(false);
			}
			ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
			if(buttonS.valid() && buttonA.valid() && buttonD.valid() && camera.valid() && camera->getAttachedNode() && camera->getAttachedNode()->getDataClass())
			{
				void* param = NULL;
				ref_ptr<crButtonWidgetNode> button = NULL;
				crData* camadata = camera->getAttachedNode()->getDataClass();
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				int index_S,index_D,index_A;
				index_S = index_D = index_A = 0;
				if(type == FT_Chengchi)
				{
					data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
					unsigned short chengchiid = *(unsigned short *)param;
					if(chengchiid>0)
					{
						ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
						crTableIO::StrVec record;
						int chusindex = chengchiTab->getTitleIndex("出生点数");
						int ashiliInfoIndex = chengchiTab->getTitleIndex("攻方胜利条件");
						int dshiliInfoIndex = chengchiTab->getTitleIndex("守方胜利条件");
						if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0 && chusindex >=0/*&& mapindex >= 0*/)
						{
							std::string str = record[chusindex];
							crVector2i vec;
							crArgumentParser::appAtoVec(str,vec);

							crData *roomdata = room->getDataClass();
							roomdata->getParam(WCHDATA_JXJBattleID,param);
							_crInt32 battleid = *(_crInt32 *)param;
							unsigned char ashili = LOINT16(LOINT32(battleid));
							unsigned char dshili = HIINT16(LOINT32(battleid));
							data->getParam(WCHDATA_JXJShiliID,param);
							unsigned char myShili = *(unsigned char *)param;

							crMatrix viewerMat = camera->getCameraMatrix();
							viewerMat.setTrans(0.0f,0.0f,0.0f);
							crVector3 camDir = (-Y_AXIS * viewerMat).normalize();
							camDir[2] = 0.0f;
							camDir.normalize();
							CRCore::crMatrix newMat;
							if(camDir == crVector3(0.0f,0.0f,0.0f))
							{
								camDir[1] = -1.0f;
							}
							if(camDir[1] > 0.999)
							{
								newMat.makeRotate(-CRCore::Y_AXIS,camDir);
								CRCore::crVector3d ep,center,up;
								newMat.getLookAt(ep,center,up);
								if(center[2]>0.0f)
								{
									center = -center;
								}
								newMat.makeLookAt(ep,center,up);
							}
							else
								newMat.makeRotate(-CRCore::Y_AXIS,camDir);
							crMatrixf invertRot = crMatrix::inverse(newMat);

							crSceneLayer::BirthPointArray pointVec = crMyPlayerData::getInstance()->getSceneLayer()->getBirthPointArray();

							camadata->excHandle(MAKEINT64(WCH_LockData,1));
							int index = 0;
							for(;index<pointVec.size();index++)
							{
								std::string inputstr;
								if(myShili == dshili)
								{
									if(index<vec[0])
									{
										//复制红色
										continue;
									}
									else
									{
										//复制蓝色
										if (index_D < m_defenseWidgetVec.size())
										{
											button = m_defenseWidgetVec[index_D++];
										}else
										{
											button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES));
											//crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
											rotMapWidget->insertChild(1,button.get());
											m_defenseWidgetVec.push_back(button.get());
										}
										if(!button) continue;
									}
								}
								else
								{
									if(index<vec[0])
									{
										//复制蓝色
										continue;
									}
									else
									{
										//复制红色
										if (index_A < m_attackWidgetVec.size())
										{
											button = m_attackWidgetVec[index_A++];
										}else
										{
											button = dynamic_cast<crButtonWidgetNode*>(buttonA->clone(crCopyOp::DEEP_COPY_NODES));
											//crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
											rotMapWidget->insertChild(1,button.get());
											m_attackWidgetVec.push_back(button.get());
										}
										if(!button) continue;
									}
								}
								button->initWindow();
								button->setParentCanvas(m_this);
								button->setVisiable(true);
								button->setEnable(true);
								button->setCanFocus(false);

								float px =pointVec[index].x()*crGlobalHandle::gData()->gUnitScale();
								float py =pointVec[index].y()*crGlobalHandle::gData()->gUnitScale();
								px *= mapFactor[0];
								py *= mapFactor[1];
								button->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::scale(0.5,0.5,1.0) * crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));								
							}
							//
							camadata->excHandle(MAKEINT64(WCH_LockData,0));
							
							roomdata->excHandle(MAKEINT64(WCH_LockData,1));
							roomdata->getParam(WCHDATA_JXJCampBirthPointMap,param);
							JXJCampBirthpointMap *campMap = (JXJCampBirthpointMap *)param;

							JXJCampBirthpoint::iterator itr_point;
							if(campMap )
							{
								//if((*campMap)[myShili].empty()) isMyshiliCampEmpty = true;
								crButtonWidgetNode* buttonT = NULL;
								JXJCampBirthpointMap::iterator itr_map = campMap->begin();
								for (;itr_map!=campMap->end();itr_map++)
								{
									itr_point = itr_map->second.begin();
									for (;itr_point!=itr_map->second.end();itr_point++)
									{
										if (itr_map->first == myShili)
										{
											if (index_D < m_defenseWidgetVec.size())
											{
												button = m_defenseWidgetVec[index_D++];
											}else
											{
												button = dynamic_cast<crButtonWidgetNode*>(buttonD->clone(crCopyOp::DEEP_COPY_NODES));
												//crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
												rotMapWidget->insertChild(1,button.get());
												m_defenseWidgetVec.push_back(button.get());
											}
										}
										else if ((myShili == dshili && itr_map->first == ashili) || (myShili != dshili && itr_map->first == dshili))
										{
											if (index_A < m_attackWidgetVec.size())
											{
												button = m_attackWidgetVec[index_A++];
											}else
											{
												button = dynamic_cast<crButtonWidgetNode*>(buttonA->clone(crCopyOp::DEEP_COPY_NODES));
												//crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
												rotMapWidget->insertChild(1,button.get());
												m_attackWidgetVec.push_back(button.get());
											}
										}else
										{
											if (index_S < m_strongholdWidgetVec.size())
											{
												button = m_strongholdWidgetVec[index_S++];
											}else
											{
												button = dynamic_cast<crButtonWidgetNode*>(buttonS->clone(crCopyOp::DEEP_COPY_NODES));
												//crLoadManager::getInstance()->requestAddNode(rotMapWidget.get(),button.get(),false);
												rotMapWidget->insertChild(1,button.get());
												m_strongholdWidgetVec.push_back(button.get());
											}
										}

										if(!button) continue;

										button->initWindow();
										button->setParentCanvas(m_this);
										button->setVisiable(true);
										button->setEnable(true);
										button->setCanFocus(false);
										
										float px =itr_point->first.x()*crGlobalHandle::gData()->gUnitScale();
										float py =itr_point->first.y()*crGlobalHandle::gData()->gUnitScale();
										px *= mapFactor[0];
										py *= mapFactor[1];										
										button->setMatrix(invScaleMat * invertRot * scaleMat * crMatrix::scale(0.5,0.5,1.0) * crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));
									}
								}
							}
							roomdata->excHandle(MAKEINT64(WCH_LockData,0));
						}
					}
				}
			}
		}

		ref_ptr<crCanvasNode>mainCanvas = crFilterRenderManager::getInstance()->getMainCanvas();
		ref_ptr<crWidgetNode>iconWidget;
		char isEnemy = 0;
		crRole *player;
		crNode *relNode;
		//crData *itemData;
		unsigned int guisestate;
		void *param;
		int i = 0;
		int j = 0;
		int k = 0;
		int myCount = m_myWidgetVec.size();
		ref_ptr<crWidgetNode>myIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_myIconWidget));
		if(!myIconWidget)return;
		crMyPlayerData::getInstance()->lockMyRoleNpcMap();
		crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
		for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
			itr != myRoles.end();
			++itr )
		{
			player = itr->second.first.get();
			relNode = player->getRelNode();
			if(!relNode || !relNode->getVisiable())
				continue;
			//itemData = player->getDataClass();
			//itemData->getParam(WCHDATA_GuiseState,param);
			//guisestate = *(unsigned char *)param;
			//if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
			//{
			//	continue;
			//}
			guisestate = GS_Normal;
			player->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
			{
				continue;
			}
			iconWidget = NULL;
			if(i<myCount)
			{
				iconWidget = m_myWidgetVec[i];
			}
			else
			{
				iconWidget = dynamic_cast<crWidgetNode *>(myIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
				//rotMapWidget->addChild(iconWidget);
				crLoadManager::getInstance()->requestAddNode(playerIconRoot.get(),iconWidget.get(),false);
				m_myWidgetVec.push_back(iconWidget.get());
			}
			i++;
			if(iconWidget.valid())
			{
				iconWidget->setVisiable(true);
				crVector3 dir(player->getDirx(),player->getDiry(),player->getDirz());
				CRCore::crMatrix newMat;
				if(dir == crVector3(0.0f,0.0f,0.0f))
				{
					dir[1] = -1.0f;
				}
				if(dir[1] > 0.999)
				{
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
					CRCore::crVector3d ep,center,up;
					newMat.getLookAt(ep,center,up);
					if(center[2]>0.0f)
					{
						center = -center;
					}
					newMat.makeLookAt(ep,center,up);
				}
				else
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
				float px = player->getPosx()*crGlobalHandle::gData()->gUnitScale();// - myX;
				float py = player->getPosy()*crGlobalHandle::gData()->gUnitScale();// - myY;
				px *= mapFactor[0];
				py *= mapFactor[1];
				iconWidget->setMatrix(invScaleMat * newMat * scaleMat * crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));
			}
		}
		if(i<myCount)
		{
			for(int ii = i; ii<myCount; ++ii)
			{
				m_myWidgetVec[ii]->setVisiable(false);
			}
		}
		crMyPlayerData::getInstance()->unlockMyRoleNpcMap();
		i = 0;
		j = 0;
		k = 0;
		int friendCount = m_friendPlayerWidgetVec.size();
		int thirdCount = m_threadPlayerWidgetVec.size();
		int enemyCount = m_enemyPlayerWidgetVec.size();
		ref_ptr<crWidgetNode>friendIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_friendPlayerIconWidget));
		ref_ptr<crWidgetNode>thirdIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_threadPlayerIconWidget));
		ref_ptr<crWidgetNode>enemyIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_enemyPlayerIconWidget));
		crMyPlayerData::getInstance()->lockInRangePlayerMap();
		crMyPlayerData::InRangePlayerMap &playerMap = crMyPlayerData::getInstance()->getInRangePlayerMap();
		for( crMyPlayerData::InRangePlayerMap::iterator itr = playerMap.begin();
			itr != playerMap.end();
			++itr )
		{
			player = itr->second.first.get();
			relNode = player->getRelNode();
			if(!relNode || !relNode->getVisiable())
				continue;
			//itemData = player->getDataClass();
			//itemData->getParam(WCHDATA_GuiseState,param);
			//guisestate = GS_Normal;
			//if(param)
			//{
			//	guisestate = *(unsigned char *)param;
			//	if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
			//	{
			//		continue;
			//	}
			//}
			guisestate = GS_Normal;
			player->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
			{
				continue;
			}
			iconWidget = NULL;
			isEnemy = 0;
			me->doEvent(WCH_EnemyCheck,MAKEINT64(player,&isEnemy));
			if(isEnemy==1)
			{
				if(i<friendCount)
				{
					iconWidget = m_friendPlayerWidgetVec[i];
				}
				else
				{
					iconWidget = dynamic_cast<crWidgetNode *>(friendIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
					//rotMapWidget->addChild(iconWidget);
					crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
					m_friendPlayerWidgetVec.push_back(iconWidget.get());
				}
				i++;
			}
			else if(isEnemy == 0)
			{
				if(j<thirdCount)
				{
					iconWidget = m_threadPlayerWidgetVec[j];
				}
				else
				{
					iconWidget = dynamic_cast<crWidgetNode *>(thirdIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
					//rotMapWidget->addChild(iconWidget);
					crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
					m_threadPlayerWidgetVec.push_back(iconWidget.get());
				}
				j++;
			}
			else
			{
				if(guisestate & GS_Hide && !(guisestate & GS_UnHide))
				{
					continue;
				}
				if(k<enemyCount)
				{
					iconWidget = m_enemyPlayerWidgetVec[k];
				}
				else
				{
					iconWidget = dynamic_cast<crWidgetNode *>(enemyIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
					//rotMapWidget->addChild(iconWidget);
					crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
					m_enemyPlayerWidgetVec.push_back(iconWidget.get());
				}
				k++;
			}
			if(iconWidget.valid())
			{
				iconWidget->setVisiable(true);
				crVector3 dir(player->getDirx(),player->getDiry(),player->getDirz());
				CRCore::crMatrix newMat;
				if(dir == crVector3(0.0f,0.0f,0.0f))
				{
					dir[1] = -1.0f;
				}
				if(dir[1] > 0.999)
				{
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
					CRCore::crVector3d ep,center,up;
					newMat.getLookAt(ep,center,up);
					if(center[2]>0.0f)
					{
						center = -center;
					}
					newMat.makeLookAt(ep,center,up);
				}
				else
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
				float px = player->getPosx()*crGlobalHandle::gData()->gUnitScale();// - myX;
				float py = player->getPosy()*crGlobalHandle::gData()->gUnitScale();// - myY;
				px *= mapFactor[0];
				py *= mapFactor[1];
				iconWidget->setMatrix(invScaleMat * newMat * scaleMat * crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));
			}
		}
		///PlayerCoordMap
		roomdata->excHandle(MAKEINT64(WCH_LockData,1));
		roomdata->getParam(WCHDATA_JXJPlayerCoordMap,param);
		PlayerCoordMap *playercoordMap = (PlayerCoordMap *)param;
		int playerid = myPlayer->getPlayerID();
		for(PlayerCoordMap::iterator itr = playercoordMap->begin();
			itr != playercoordMap->end();
			++itr )
		{
			if(LOINT64(itr->first) == playerid) 
				continue;
			if(i<friendCount)
			{
				iconWidget = m_friendPlayerWidgetVec[i];
			}
			else
			{
				iconWidget = dynamic_cast<crWidgetNode *>(friendIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
				//rotMapWidget->addChild(iconWidget);
				crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
				m_friendPlayerWidgetVec.push_back(iconWidget.get());
			}
			i++;
			if(iconWidget.valid())
			{
				iconWidget->setVisiable(true);
				crVector3 dir(0,-1,0);
				CRCore::crMatrix newMat;
				if(dir == crVector3(0.0f,0.0f,0.0f))
				{
					dir[1] = -1.0f;
				}
				if(dir[1] > 0.999)
				{
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
					CRCore::crVector3d ep,center,up;
					newMat.getLookAt(ep,center,up);
					if(center[2]>0.0f)
					{
						center = -center;
					}
					newMat.makeLookAt(ep,center,up);
				}
				else
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
				float px = (float)itr->second[0] * crGlobalHandle::gData()->gUnitScale();// - myX;
				float py = (float)itr->second[1] * crGlobalHandle::gData()->gUnitScale();// - myY;
				px *= mapFactor[0];
				py *= mapFactor[1];
				iconWidget->setMatrix(invScaleMat * newMat * scaleMat * crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));
			}
		}
		roomdata->excHandle(MAKEINT64(WCH_LockData,0));
		if(i<friendCount)
		{
			for(int ii = i; ii<friendCount; ++ii)
			{
				m_friendPlayerWidgetVec[ii]->setVisiable(false);
			}
		}
		if(j<thirdCount)
		{
			for(int ii = j; ii<thirdCount; ++ii)
			{
				m_threadPlayerWidgetVec[ii]->setVisiable(false);
			}
		}
		if(k<enemyCount)
		{
			for(int ii = k; ii<enemyCount; ++ii)
			{
				m_enemyPlayerWidgetVec[ii]->setVisiable(false);
			}
		}
		crMyPlayerData::getInstance()->unlockInRangePlayerMap();

		i = 0;
		j = 0;
		k = 0;
		int ibuliding = 0;
		int jbuliding = 0;
		int kbuliding = 0;
		int kboss = 0;
		int kSmallBoss = 0;
		friendCount = m_friendNpcWidgetVec.size();
		thirdCount = m_threadNpcWidgetVec.size();
		enemyCount = m_enemyNpcWidgetVec.size();
		int fiendBulidingCount = m_myBulidingWidgetVec.size();
		int enemyBulidingCount = m_enemyBulidingWidgetVec.size();
		int thirdBulidingCount = m_thirdBulidingWidgetVec.size();
		int bossCount = m_enemyBossWidgetVec.size();
		int smallBossCount = m_enemySmallBossWidgetVec.size();

		friendIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_friendNpcIconWidget));
		thirdIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_threadNpcIconWidget));
		enemyIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_enemyNpcIconWidget));
		ref_ptr<crWidgetNode>myBulidingIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_myBulidingWidget));
		ref_ptr<crWidgetNode>enemyBulidingIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_enemyBulidingWidget));
		ref_ptr<crWidgetNode>thirdBulidingIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_thirdBulidingWidget));
		ref_ptr<crWidgetNode>npcBossIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_enemyBossIconWidget));
		ref_ptr<crWidgetNode>npcSmallBossIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_enemySmallBossIconWidget));

		crMyPlayerData::getInstance()->lockInRangeNpcMap();
		crInstanceItem *item;
		crData *itemData;
		/*unsigned short*/int armyCount = 0;
		float rthp = 0.0f;
		crMyPlayerData::InRangeNpcMap &npcMap = crMyPlayerData::getInstance()->getInRangeNpcMap();
		for( crMyPlayerData::InRangeNpcMap::iterator itr = npcMap.begin();
			itr != npcMap.end();
			++itr )
		{
			item = itr->second.first.get();
			int instanceId = item->getInstanceItemID();
			itemData = item->getDataClass();
			if(itemData)
			{
				itemData->getParam(WCHDATA_JXJArmyCount,param);
				armyCount = *(/*unsigned short*/int *)param;
				itemData->getParam(WCHDATA_RTHP,param);
				rthp = *(float*)param;

				if(rthp<=0.0f) continue;
			}
			relNode = item->getRelNode();
			if(!relNode || !relNode->getVisiable())
				continue;
			//itemData = item->getDataClass();
			//itemData->getParam(WCHDATA_GuiseState,param);
			//guisestate = GS_Normal;
			//if(param)
			//{
			//	guisestate = *(unsigned char *)param;
			//	if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
			//	{
			//		continue;
			//	}
			//}
			guisestate = GS_Normal;
			item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
			{
				continue;
			}

			iconWidget = NULL;
			isEnemy = 0;
			me->doEvent(WCH_EnemyCheck,MAKEINT64(item,&isEnemy));
			if(isEnemy==1)
			{
				if(guisestate & GS_Static || guisestate & GS_StaticNoneBlock)
				{
					if(ibuliding<fiendBulidingCount)
					{
						iconWidget = m_myBulidingWidgetVec[ibuliding];
					}
					else
					{
						iconWidget = dynamic_cast<crWidgetNode *>(myBulidingIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
						//rotMapWidget->addChild(iconWidget);
						crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
						m_myBulidingWidgetVec.push_back(iconWidget.get());
					}
					ibuliding++;
				}
				else
				{
					if(i<friendCount)
					{
						iconWidget = m_friendNpcWidgetVec[i];
					}
					else
					{
						iconWidget = dynamic_cast<crWidgetNode *>(friendIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
						//rotMapWidget->addChild(iconWidget);
						crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
						m_friendNpcWidgetVec.push_back(iconWidget.get());
					}
					i++;
				}
			}
			else if(isEnemy == 0)
			{
				if(guisestate & GS_Static || guisestate & GS_StaticNoneBlock)
				{
					if(jbuliding<thirdBulidingCount)
					{
						iconWidget = m_thirdBulidingWidgetVec[jbuliding];
					}
					else
					{
						iconWidget = dynamic_cast<crWidgetNode *>(thirdBulidingIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
						//rotMapWidget->addChild(iconWidget);
						crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
						m_thirdBulidingWidgetVec.push_back(iconWidget.get());
					}
					jbuliding++;
				}
				else
				{
					if(j<thirdCount)
					{
						iconWidget = m_threadNpcWidgetVec[j];
					}
					else
					{
						iconWidget = dynamic_cast<crWidgetNode *>(thirdIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
						//rotMapWidget->addChild(iconWidget);
						crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
						m_threadNpcWidgetVec.push_back(iconWidget.get());
					}
					j++;
				}
			}
			else
			{
				if(guisestate & GS_Hide && !(guisestate & GS_UnHide))
				{
					continue;
				}
				if(guisestate &GS_Static || guisestate & GS_StaticNoneBlock)
				{
					if(kbuliding<enemyBulidingCount)
					{
						iconWidget = m_enemyBulidingWidgetVec[kbuliding];
					}
					else
					{
						iconWidget = dynamic_cast<crWidgetNode *>(enemyBulidingIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
						//rotMapWidget->addChild(iconWidget);
						crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
						m_enemyBulidingWidgetVec.push_back(iconWidget.get());
					}
					kbuliding++;
				}
				else
				{
					if(armyCount == 1)
					{
						crTableIO::StrVec record;
						ref_ptr<crTableIO> marktab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJNpcMarkTab);
						if(marktab.valid() && marktab->queryOneRecord(0,crArgumentParser::appItoa(instanceId),record)>=0)
						{
							int markindex = marktab->getTitleIndex("Mark");
							if(markindex>=0)
							{
								if(atoi(record[markindex].c_str()) == Npc_Big)
								{
									if(kboss<bossCount)
									{
										iconWidget = m_enemyBossWidgetVec[kboss];
									}
									else
									{
										iconWidget = dynamic_cast<crWidgetNode *>(npcSmallBossIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
										//rotMapWidget->addChild(iconWidget);
										crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
										m_enemyBossWidgetVec.push_back(iconWidget.get());
									}
									kboss++;
								}
								else if(atoi(record[markindex].c_str()) == Npc_Small)
								{
									if(kSmallBoss<smallBossCount)
									{
										iconWidget = m_enemySmallBossWidgetVec[kSmallBoss];
									}
									else
									{
										iconWidget = dynamic_cast<crWidgetNode *>(npcSmallBossIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
										//rotMapWidget->addChild(iconWidget);
										crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
										m_enemySmallBossWidgetVec.push_back(iconWidget.get());
									}
									kSmallBoss++;
								}
							}
						}
						else
						{
							if(kSmallBoss<smallBossCount)
							{
								iconWidget = m_enemySmallBossWidgetVec[kSmallBoss];
							}
							else
							{
								iconWidget = dynamic_cast<crWidgetNode *>(npcSmallBossIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
								//rotMapWidget->addChild(iconWidget);
								crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
								m_enemySmallBossWidgetVec.push_back(iconWidget.get());
							}
							kSmallBoss++;
						}
					}
					else
					{
						if(k<enemyCount)
						{
							iconWidget = m_enemyNpcWidgetVec[k];
						}
						else
						{
							iconWidget = dynamic_cast<crWidgetNode *>(enemyIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
							//rotMapWidget->addChild(iconWidget);
							crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
							m_enemyNpcWidgetVec.push_back(iconWidget.get());
						}
						k++;
					}
				}
			}
			if(iconWidget.valid())
			{
				iconWidget->setVisiable(true);
				crVector3 dir(item->getDirx(),item->getDiry(),item->getDirz());
				CRCore::crMatrix newMat;
				if(dir == crVector3(0.0f,0.0f,0.0f))
				{
					dir[1] = -1.0f;
				}
				if(dir[1] > 0.999)
				{
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
					CRCore::crVector3d ep,center,up;
					newMat.getLookAt(ep,center,up);
					if(center[2]>0.0f)
					{
						center = -center;
					}
					newMat.makeLookAt(ep,center,up);
				}
				else
					newMat.makeRotate(-CRCore::Y_AXIS,dir);
				float px = item->getPosx()*crGlobalHandle::gData()->gUnitScale();// - myX;
				float py = item->getPosy()*crGlobalHandle::gData()->gUnitScale();// - myY;
				px *= mapFactor[0];
				py *= mapFactor[1];
				iconWidget->setMatrix(invScaleMat * newMat * scaleMat * crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));
			}
		}
		if(i<friendCount)
		{
			for(int ii = i; ii<friendCount; ++ii)
			{
				m_friendNpcWidgetVec[ii]->setVisiable(false);
			}
		}
		if(j<thirdCount)
		{
			for(int ii = j; ii<thirdCount; ++ii)
			{
				m_threadNpcWidgetVec[ii]->setVisiable(false);
			}
		}
		if(k<enemyCount)
		{
			for(int ii = k; ii<enemyCount; ++ii)
			{
				m_enemyNpcWidgetVec[ii]->setVisiable(false);
			}
		}
		if(ibuliding<fiendBulidingCount)
		{
			for(int ii = ibuliding; ii<fiendBulidingCount; ++ii)
			{
				m_myBulidingWidgetVec[ii]->setVisiable(false);
			}
		}
		if(jbuliding<thirdBulidingCount)
		{
			for(int ii = jbuliding; ii<thirdBulidingCount; ++ii)
			{
				m_thirdBulidingWidgetVec[ii]->setVisiable(false);
			}
		}
		if(kbuliding<enemyBulidingCount)
		{
			for(int ii = kbuliding; ii<enemyBulidingCount; ++ii)
			{
				m_enemyBulidingWidgetVec[ii]->setVisiable(false);
			}
		}
		if(kboss<bossCount)
		{
			for(int ii = kboss; ii<bossCount; ++ii)
			{
				m_enemyBossWidgetVec[ii]->setVisiable(false);
			}
		}
		if(kSmallBoss<smallBossCount)
		{
			for(int ii = kSmallBoss; ii<smallBossCount; ++ii)
			{
				m_enemySmallBossWidgetVec[ii]->setVisiable(false);
			}
		}
		crMyPlayerData::getInstance()->unlockInRangeNpcMap();

		i = 0;
		int itemCount = m_itemWidgetVec.size();
		ref_ptr<crWidgetNode>itemIconWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_itemIconWidget));
		crMyPlayerData::getInstance()->lockInRangeItemMap();
		unsigned char dataType;
		crMyPlayerData::InRangeItemMap &itemMap = crMyPlayerData::getInstance()->getInRangeItemMap();
		for( crMyPlayerData::InRangeItemMap::iterator itr = itemMap.begin();
			itr != itemMap.end();
			++itr )
		{
			iconWidget = NULL;
			item = itr->second.first.get();
			relNode = item->getRelNode();
			if(!relNode || !relNode->getVisiable())
				continue;
			item->getDataClass()->getParam(WCHDATA_DataType,param);
			if(!param)
				continue;
			dataType = *(unsigned char *)param;
			if(dataType == DT_Bot || dataType == DT_NPC || dataType == DT_MatrixNode || dataType == DT_Box || dataType == DT_Sphere)
			{
				//itemData = item->getDataClass();
				//itemData->getParam(WCHDATA_GuiseState,param);
				//if(param)
				//{
				//	guisestate = *(unsigned char *)param;
				//	if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
				//	{
				//		continue;
				//	}
				//}
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
				{
					continue;
				}
				if(i<itemCount)
				{
					iconWidget = m_itemWidgetVec[i];
				}
				else
				{
					iconWidget = dynamic_cast<crWidgetNode *>(itemIconWidget->clone(crCopyOp::DEEP_COPY_NODES));
					//rotMapWidget->addChild(iconWidget);
					crLoadManager::getInstance()->requestAddNode(otherIconRoot.get(),iconWidget.get(),false);
					m_itemWidgetVec.push_back(iconWidget.get());
				}
				i++;
			}
			if(iconWidget.valid())
			{
				iconWidget->setVisiable(true);
				float px = item->getPosx()*crGlobalHandle::gData()->gUnitScale();// - myX;
				float py = item->getPosy()*crGlobalHandle::gData()->gUnitScale();// - myY;
				px *= mapFactor[0];
				py *= mapFactor[1];
				iconWidget->setMatrix(crMatrix::translate(mapWidget->getBound().center()+crVector3(px,py,0.0f)));
			}
		}
		if(i<itemCount)
		{
			for(int ii = i; ii<itemCount; ++ii)
			{
				m_itemWidgetVec[ii]->setVisiable(false);
			}
		}
		crMyPlayerData::getInstance()->unlockInRangeItemMap();
	}
}
/////////////////////////////////////////
//
//crJXJMapHitMoveMethod
//
/////////////////////////////////////////
crJXJMapHitMoveMethod::crJXJMapHitMoveMethod(){}
crJXJMapHitMoveMethod::crJXJMapHitMoveMethod(const crJXJMapHitMoveMethod& handle):
	crMethod(handle),
	m_rotMap(handle.m_rotMap),
	m_miniMap(handle.m_miniMap),
	m_signal(handle.m_signal)
{
}
void crJXJMapHitMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJMapHitMoveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rotMap = str;
		break;
	case 1:
		m_miniMap = str;
		break;
	case 2:
		m_signal = str;
		break;
	}
}
void crJXJMapHitMoveMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInGame())
	{
		void *param;
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if(camera.valid())
		{
			crData *cameraData = camera->getAttachedNode()->getDataClass();
			//crViewer *bindViewer = crKeyboardMouseHandle::getInstance()->getBindViewer();
			CRCore::ScopedLock<crData> lock(*cameraData);
			cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
			SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;

			crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			ref_ptr<crWidgetNode>rotMapWidget = canvas->getWidget(m_rotMap);
			rotMapWidget->mouseTrans(mouse[0],mouse[1]);
			canvas->mouseTrans(mouse[0],mouse[1]);
			ref_ptr<crWidgetNode>miniMap = canvas->getWidget(m_miniMap);
			crVector3 centerCoord = miniMap->getBound().center();
			const crBoundingBox &bbox = miniMap->getBoundBox();
			crVector2 mapWidgetSize(bbox.xLength(),bbox.yLength());
			crVector2 mapFactor = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize);
			crVector3 hitPos;
			hitPos[0] = (mouse[0] - centerCoord[0])/mapFactor[0];
			hitPos[1] = (mouse[1] - centerCoord[1])/mapFactor[1];

			crVector3 testPos;
			testPos[0] =mouse[0];
			testPos[1] =mouse[1];
			///////////////////////////////////////////////////////信号
			cameraData->getParam(WCHDATA_JXJCameraOperator,param);
			unsigned short signal = *(unsigned short*)param;
			if (signal == Cam_Signal)
			{
				CRCore::ref_ptr<CRCore::crWidgetNode> icon ;
				cameraData->getParam(WCHDATA_JXJSignalsMap,param);
				if(param)
				{
					SignalNodeMap *signaldeque = (SignalNodeMap *)param;
					ref_ptr<crCanvasNode>mainCanvas = crFilterRenderManager::getInstance()->getMainCanvas();	
					ref_ptr<crWidgetNode>iconWidget;
					ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
					ref_ptr<crWidgetNode>signalWidget = dynamic_cast<crWidgetNode *>(mainCanvas->getWidget(m_signal));

					SignalNodeMap::iterator itr_w = signaldeque->begin();
					while (itr_w!=signaldeque->end())
					{
						// 						if(signaldeque->size()>=20 && itr_w->first->getName().compare(m_signal) == 0)
						// 						{
						// 							iconWidget = itr_w->first;
						// 							itr_w->second = 10.0f;
						// 							break;
						// 						}
						if (itr_w->first->getVisiable() == false && \
							itr_w->first->getName().compare(m_signal) == 0)
						{
							iconWidget = itr_w->first;
							itr_w->second = 10.0f;
							break;
						}

						itr_w++;
					}

					if (itr_w == signaldeque->end() && signaldeque->size() <= 20)
					{
						iconWidget = dynamic_cast<crWidgetNode *>(signalWidget->clone(crCopyOp::DEEP_COPY_NODES));
						signaldeque->insert(std::make_pair(iconWidget, 10.0f));
						crLoadManager::getInstance()->requestAddNode(canvas.get(),iconWidget.get(),false);
					}

					if (iconWidget.valid())
					{
						iconWidget->setVisiable(true);
						testPos = testPos * rotMapWidget->getMatrix();
						iconWidget->setMatrix(crMatrix::translate(testPos));	
					}
				}
				camera->getAttachedNode()->doEvent(WCH_JXJPlaySignalFx,MAKEINT64(&hitPos,NULL));

				cameraData->inputParam(WCHDATA_JXJCameraOperator,NULL);

				// send packet
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				crNetManager *netManager = netConductor->getNetManager();
				ref_ptr<crStreamBuf> packetStream = new crStreamBuf;
				packetStream->createBuf(12);
				//packetStream->_writeBool(true);
				packetStream->_writeVec3(hitPos);
				crPlayerDataSceneEventPacket packet;
				crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvSignalsPos,packetStream.get());
				netManager->sendPacket("all",packet);
			}
			//////////////////////////////////////////////////////////////////////////
			//hitpos显示效果
			else if(signal == Cam_Patrol)
			{
				PatrolPointVec* patrolPositionVec;
				SelectMyRoleVec::iterator itr = selectMyRoles->begin();
				while (itr!=selectMyRoles->end())
				{		
					crRole *role = itr->get();
					crData *data = role->getDataClass();
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_GuiseState,param);
					unsigned int *gs = (unsigned int *)param;
					*gs &= ~GS_Garrison;
					data->getParam(WCHDATA_CurActState,param);
					unsigned short* act = (unsigned short *)param;
					if(*act == ACT_Skill)
					{//中断施法
						*act = ACT_Idle;
					}
					data->getParam(WCHDATA_PatrolPointVec,param);
					patrolPositionVec = (PatrolPointVec*)param;
					patrolPositionVec->clear();
					float scale = crGlobalHandle::gData()->gUnitScale();
					patrolPositionVec->push_back(crVector2(hitPos.x(),hitPos.y()));
					patrolPositionVec->push_back(crVector2(role->getPosx()*scale, role->getPosy()*scale));
					data->getParam(WCHDATA_PatrolIndex,param);
					char* idx = (char*)param;
					*idx = 0;
					unsigned char itemstate = IS_AttackToPos;
					unsigned char targettype = Target_Coord;
					data->inputParam(WCHDATA_ItemState,&itemstate);
					data->inputParam(WCHDATA_TargetType,&targettype);
					data->inputParam(WCHDATA_TargetPos,&hitPos);
					data->inputParam(WCHDATA_MoveToPos,&hitPos);
					crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(itr->get());
					data->excHandle(MAKEINT64(WCH_LockData,0));
					itr++;
				}
				cameraData->inputParam(WCHDATA_JXJCameraOperator,NULL);
				unsigned char targettype = Target_Coord;
				cameraData->inputParam(WCHDATA_TargetType, &targettype);
				cameraData->inputParam(WCHDATA_TargetPos, &hitPos);
				cameraData->inputParam(WCHDATA_TargetItem, NULL);
			}
			else// if((signal == Cam_AttackToPos) || (signal == Cam_MoveToPos))
			{
				//crRole *myRole;
				//int targetid = 0;
				//int  targetroleid = 0;
				//unsigned char targettype = Target_Coord;
				//unsigned char itemstate = signal == Cam_AttackToPos?IS_AttackToPos:IS_MoveToPos;
				//crData *myRoleData;
				//for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
				//	itr != selectMyRoles->end();
				//	++itr )
				//{
				//	//(*itr)->doEvent(WCH_PlayerMoveTo,MAKEINT64(&hitPos,NULL));
				//	myRole = itr->get();
				//	myRoleData = myRole->getDataClass();
				//	myRoleData->excHandle(MAKEINT64(WCH_LockData,1));
				//	myRoleData->getParam(WCHDATA_GuiseState,param);
				//	unsigned int *gs = (unsigned int *)param;
				//	*gs &= ~GS_Garrison;
				//	myRoleData->getParam(WCHDATA_PatrolPointVec,param);
				//	PatrolPointVec *patrolPositionVec = (PatrolPointVec*)param;
				//	patrolPositionVec->clear();
				//	myRoleData->excHandle(MAKEINT64(WCH_LockData,0));
				//	myRoleData->inputParam(WCHDATA_ItemState,&itemstate);
				//	myRoleData->inputParam(WCHDATA_TargetType,&targettype);
				//	myRoleData->inputParam(WCHDATA_TargetPos,&hitPos);
				//	myRoleData->inputParam(WCHDATA_MoveToPos,&hitPos);
				//	crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(myRole);
				//}
				crRole *myRole;
				bool isattack = true;
				int targetid = 0;
				int  targetroleid = 0;
				unsigned char targettype = Target_Coord;
				unsigned char itemstate = signal == Cam_AttackToPos?IS_AttackToPos:IS_MoveToPos;
				unsigned char olditemstate;
				//ref_ptr<crStreamBuf> stream;
				crData *myRoleData;
				//crPlayerEventPacket packet;
				crVector3 lastTargetPos;
				crInstanceItem *targetItem = NULL;
				for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
					itr != selectMyRoles->end();
					++itr )
				{
					myRole = itr->get();
					myRoleData = myRole->getDataClass();
					myRoleData->getParam(WCHDATA_ItemState,param);
					olditemstate = *(unsigned char *)param;
					if(olditemstate == IS_Dead)
						continue;

					if (itemstate == IS_AttackToPos)
					{
						if (!targetItem)
						{
							targetItem = crMyPlayerData::getInstance()->getOneInRangeEnemy(myRole);
						}
						if (targetItem)
						{
							targetid = targetItem->getID();
							targetroleid = targetItem->getRoleID();
							targettype = targetItem->getItemtype() == crInstanceItem::Role ? Target_Role : Target_Npc;
						}
					}
					myRoleData->getParam(WCHDATA_TargetPos,param);
					lastTargetPos = *(crVector3 *)param;
					myRoleData->inputParam(WCHDATA_ItemState,&itemstate);
					myRoleData->inputParam(WCHDATA_TargetType,&targettype);
					myRoleData->inputParam(WCHDATA_TargetID,&targetid);
					myRoleData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
					myRoleData->inputParam(WCHDATA_TargetPos,&hitPos);
					myRoleData->inputParam(WCHDATA_MoveToPos,&hitPos);
					myRoleData->inputParam(WCHDATA_AboutToUseItemID,NULL);
					//myRoleData->inputParam(WCHDATA_TargetItem,NULL);
					//////////////////////////////////////////////////////////////////////////
					myRoleData->excHandle(MAKEINT64(WCH_LockData,1));
					myRoleData->getParam(WCHDATA_GuiseState,param);
					unsigned int *gs = (unsigned int *)param;
					*gs &= ~GS_Garrison;
					myRoleData->getParam(WCHDATA_CurActState,param);
					unsigned short* act = (unsigned short *)param;
					if(*act == ACT_Skill)
					{//中断施法
						*act = ACT_Idle;
					}
					myRoleData->getParam(WCHDATA_PatrolPointVec,param);
					PatrolPointVec *patrolPositionVec = (PatrolPointVec*)param;
					patrolPositionVec->clear();
					myRoleData->excHandle(MAKEINT64(WCH_LockData,0));
					if (!targetItem && (crVector2(lastTargetPos[0], lastTargetPos[1]) - crVector2(hitPos[0], hitPos[1])).length()>0.5f)
					{
						crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(myRole);
					}
					//if(itemstate == IS_AttackToPos)
					//{
					//	//if(myRole->getAbstractItemID() == 20019)
					//	//{//投石车直接攻击
					//	//	myRoleData->excHandle(MAKEINT64(WCH_LockData,1));
					//	//	myRoleData->getParam(WCHDATA_AttackMap,param);
					//	//	AttackMap *attackMap = (AttackMap *)param;
					//	//	if(attackMap)
					//	//	{
					//	//		int attackid = attackMap->begin()->second;
					//	//		myRoleData->inputParam(WCHDATA_CurrentAttackID,&attackid);
					//	//	}
					//	//	myRoleData->excHandle(MAKEINT64(WCH_LockData,0));
					//	//}
					//	//else
					//	//{
					//		crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(myRole);
					//	//}
					//}
					//else
					//{
					//	crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(myRole);
					//}
				}
				cameraData->inputParam(WCHDATA_TargetType, &targettype);
				cameraData->inputParam(WCHDATA_TargetPos, &hitPos);
				cameraData->inputParam(WCHDATA_TargetItem, targetItem);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJMapDragCameraMethod
//
/////////////////////////////////////////
crJXJMapDragCameraMethod::crJXJMapDragCameraMethod(){}
crJXJMapDragCameraMethod::crJXJMapDragCameraMethod(const crJXJMapDragCameraMethod& handle):
	crMethod(handle),	
	m_rotMap(handle.m_rotMap),
	m_miniMap(handle.m_miniMap)
{
}
void crJXJMapDragCameraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJMapDragCameraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rotMap = str;
		break;
	case 1:
		m_miniMap = str;
		break;
	}
}
void crJXJMapDragCameraMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInGame())
	{
		//crViewer *bindViewer = crKeyboardMouseHandle::getInstance()->getBindViewer();
		crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized()/*+bindViewer->getUIMouseOffset()*/);
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crWidgetNode>rotMapWidget = canvas->getWidget(m_rotMap);
		rotMapWidget->mouseTrans(mouse[0],mouse[1]);
		canvas->mouseTrans(mouse[0],mouse[1]);
		ref_ptr<crWidgetNode>miniMapWidget = canvas->getWidget(m_miniMap);
		crVector3 centerCoord = miniMapWidget->getBound().center();
		const crBoundingBox &bbox = miniMapWidget->getBoundBox();
		crVector2 mapWidgetSize(bbox.xLength(),bbox.yLength());
		crVector2 mapFactor = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize);
		crVector3 hitPos;

		float halfWidth = mapWidgetSize[0] * 0.5f;
		float leftBound = centerCoord[0] - halfWidth;
		float rightBound = centerCoord[0] + halfWidth;
		mouse[0] = CRCore::clampTo(mouse[0], leftBound, rightBound);

		halfWidth = mapWidgetSize[1] * 0.5f;
		leftBound = centerCoord[1] - halfWidth;
		rightBound = centerCoord[1] + halfWidth;
		mouse[1] = CRCore::clampTo(mouse[1], leftBound, rightBound);

		hitPos[0] = (mouse[0] - centerCoord[0])/mapFactor[0];
		hitPos[1] = (mouse[1] - centerCoord[1])/mapFactor[1];

		//hitPos[2] = 0.0f;//crMyPlayerData::getInstance()->getPosZ(hitPos[0],hitPos[1],0);
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if(camera.valid())camera->getAttachedNode()->doEvent(WCH_CameraFocus,MAKEINT64(&hitPos,NULL));
	}
}
////////////////////////////////
//
//crJXJSelectTargetRTTMethod
//
///////////////////////////////////
crJXJSelectTargetRTTMethod::crJXJSelectTargetRTTMethod():
	m_updInterval(0.5f),
	m_rtt(NULL),
	m_frameCounter(0)
{
	m_texSize.set(256,256);
	m_distScale.set(1.5f,1.5f);
}

crJXJSelectTargetRTTMethod::crJXJSelectTargetRTTMethod(const crJXJSelectTargetRTTMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_imageBox(handle.m_imageBox),
	m_backModel(handle.m_backModel),
	m_texSize(handle.m_texSize),
	m_updInterval(handle.m_updInterval),
	m_distScale(handle.m_distScale),
	m_rtt(NULL),
	m_frameCounter(0)
{
}

void crJXJSelectTargetRTTMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJSelectTargetRTTMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_imageBox = str;
		break;
	case 2:
		m_backModel = str;
		break;
	case 3:
		crArgumentParser::appAtoVec(str,m_texSize);
		break;
	case 4:
		m_updInterval = atof(str.c_str());
		break;
	case 5:
		crArgumentParser::appAtoVec(str,m_distScale);
		break;
	}
}

void crJXJSelectTargetRTTMethod::operator()(crHandle &handle)
{
	CRCore::ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvas.valid())
	{
		ref_ptr<crImageBoxWidgetNode>imageBox = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_imageBox));
		if(imageBox.valid())
		{
			void *param;
			crData *cameraData = m_this->getDataClass();
			CRCore::ScopedLock<crData> lock(*cameraData);
			cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
			SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
			crNode *selectNode = NULL;
			crInstanceItem *selectItem = NULL;
			//crData *data;
			unsigned int guisestate;
			if(!selectMyRoles->empty())
			{
				selectItem = dynamic_cast<crInstanceItem *>((*selectMyRoles)[0].get());
				if(selectItem)
				{
					guisestate = GS_Normal;
					selectItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
					{
						crNode *fxNode = selectItem->findSceneFxNode("$SelectDecal");
						if(fxNode)
						{
							crDecalUpdateCallback *callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
							if(callback)
							{
								callback->setVisiable(false);
							}
						}
						selectMyRoles->erase(selectMyRoles->begin());
					}
					else if(selectItem->getRelNode()->getVisiable())
					{
						selectNode = dynamic_cast<crGroup *>(selectItem->getRelNode())->getChild(0);
					}
				}
			}
			if(!selectNode)
			{
				cameraData->getParam(WCHDATA_SelectItem,param);
				selectItem = (crInstanceItem *)param;
				if(selectItem)
				{
					guisestate = GS_Normal;
					selectItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
					{
						crNode *fxNode = selectItem->findSceneFxNode("$SelectDecal");
						if(fxNode)
						{
							crDecalUpdateCallback *callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
							if(callback)
							{
								callback->setVisiable(false);
							}
						}
						cameraData->inputParam(WCHDATA_SelectItem,NULL);
					}
					else if(selectItem->getRelNode()->getVisiable())
					{
						selectNode = dynamic_cast<crGroup *>(selectItem->getRelNode())->getChild(0);
					}
				}
			}
			if(!selectNode)
			{
				return;
			}
			//if(m_frameCounter<10)
			//	return;
			//crRenderToTexture *rtt = crRenderToTextureManager::getInstance()->findRenderToTexture("JXJSelectTargetRTT");
			if(!m_rtt)
			{
				m_rtt = new crRenderToTexture;
				m_rtt->setName("JXJSelectTargetRTT");
				m_rtt->setMode(crRenderToTexture::RenderToTextureMode(crRenderToTexture::RenderToTexture|crRenderToTexture::RenderColorMap|crRenderToTexture::RealTimeUpd|crRenderToTexture::ExternMVP));
				m_rtt->setMapSize(m_texSize[0],m_texSize[1]);
				m_rtt->setUpdateInterval(m_updInterval);

				crGroup *adapter = new crGroup;
				adapter->setName("#adapter");
				m_rtt->addRenderNode(adapter);
				if(m_backModel.compare("NULL")!=0)
					crLoadManager::getInstance()->requestNode(m_backModel,m_rtt->getRender(),true);
				m_rtt->addTexturedNode(imageBox->getImageObject());
				//rtt->setProjectionMatrix(crMatrix::perspective(50.0f,1.4f,1.0f,100.0f));
				//rtt->setViewMatrix(crMatrix::translate(m_cameraPos));
				const crBoundingBox &bbox = imageBox->getBoundBox();
				m_rtt->setProjectionMatrix(crMatrix::perspective(50.0f,bbox.xLength()/bbox.yLength(),1.0f,1000.0f));
				m_rtt->init(1.0f);
				if(crBrain::getInstance()->getFog()==1)
				{
					crStateSet *ss = m_rtt->getRender()->getOrCreateStateSet();
					crUniform *uniform = ss->getOrCreateUniform("fog_params",CRCore::crUniform::FLOAT_VEC4);
					uniform->setDataVariance(crBase::STATIC);
					uniform->set(crVector4(0,0,0,0));
				}
				crRenderToTextureManager::getInstance()->addRenderToTexture(m_rtt);
			}
			//m_rtt->setEnable(canvas->getVisiable() && imageBox->getVisiable());
			//if(m_rtt->getEnable())
			{
				crGroup *adapter = dynamic_cast<crGroup *>(m_rtt->findRenderNode("#adapter"));
				if(adapter->getNumChildren() == 0)
				{
					if(selectItem)
					{
						//crLoadManager::getInstance()->requestAddNode(adapter,selectNode,false);
						adapter->addChild(selectNode);
						//crBoundingSphere &bs = selectNode->getBound();
						//crVector3 center = bs.center();
						//center[2] += 1.0f;
						//crVector2 dist = m_distScale * bs.radius();
						crData *itemdata = selectItem->getDataClass();
						itemdata->getParam(WCHDATA_EyeHeight,param);
						short eyeHeight = *(short *)param;
						float r = eyeHeight * crGlobalHandle::gData()->gUnitScale();
						crVector3 center = crVector3(0.0f,0.0f,r*0.5f);
						crVector2 dist = m_distScale * r;
						crVector3 rotpos = crVector3(0.0,-dist[0],dist[1]) * crMatrix::rotate(PI*0.1f,Z_AXIS);
						crMatrix viewMatrix = crMatrix::lookAt(center + rotpos, center, Z_AXIS);
						//crMatrix viewMatrix = crMatrix::lookAt(bs.center()+crVector3(0.0,-dist[0],dist[1]),bs.center(),Z_AXIS);
						m_rtt->setViewMatrix(viewMatrix);
						m_frameCounter = 0;
					}
				}
				else
				{
					if(!selectItem)
					{
						//crLoadManager::getInstance()->requestRemoveNode(adapter,adapter->getChild(0));
						adapter->removeChild(0,1);
						m_frameCounter = 0;
					}
					else if(selectNode != adapter->getChild(0))
					{
						//crLoadManager::getInstance()->requestRemoveNode(adapter,adapter->getChild(0));
						//crLoadManager::getInstance()->requestAddNode(adapter,selectNode,false);
						adapter->setChild(0,selectNode);
						//crBoundingSphere &bs = selectNode->getBound();
						//crVector3 center1 = bs.center();
						//crVector2 dist1 = m_distScale * bs.radius();
						crData *itemdata = selectItem->getDataClass();
						itemdata->getParam(WCHDATA_EyeHeight,param);
						short eyeHeight = *(short *)param;
						float r = eyeHeight * crGlobalHandle::gData()->gUnitScale();
						crVector3 center = crVector3(0.0f,0.0f,r*0.5f);
						crVector2 dist = m_distScale * r;
						crVector3 rotpos = crVector3(0.0,-dist[0],dist[1]) * crMatrix::rotate(PI*0.1f,Z_AXIS);
						crMatrix viewMatrix = crMatrix::lookAt(center + rotpos, center, Z_AXIS);
						//crMatrix viewMatrix = crMatrix::lookAt(bs.center()+crVector3(0.0,-dist[0],dist[1]),bs.center(),Z_AXIS);
						m_rtt->setViewMatrix(viewMatrix);
						m_frameCounter = 0;
					}
					//else if(m_frameCounter<50)
					//{
					//	//crBoundingSphere &bs = selectNode->getBound();
					//	//crVector3 center = bs.center();
					//	//crVector2 dist = m_distScale * bs.radius();
					//	float r = selectItem->getMinDistance();
					//	crVector3 center = selectItem->getPosition()+crVector3(0.0f,0.0f,r*0.5f);
					//	crVector2 dist = m_distScale * r;
					//	crVector3 rotpos = crVector3(0.0,-dist[0],dist[1]*0.8f) * crMatrix::rotate(PI*0.1f,Z_AXIS);
					//	crMatrix viewMatrix = crMatrix::lookAt(center + rotpos, center, Z_AXIS);
					//	//crMatrix viewMatrix = crMatrix::lookAt(bs.center()+crVector3(0.0,-dist[0],dist[1]),bs.center(),Z_AXIS);
					//	m_rtt->setViewMatrix(viewMatrix);
					//	m_frameCounter++;
					//}
				}
				//
			}
		}
	}
}
////////////////////////////////
//
//crJXJSelectTargetDecalUpdateMethod
//
///////////////////////////////////
crJXJSelectTargetDecalUpdateMethod::crJXJSelectTargetDecalUpdateMethod():
	m_addRadius(0.0f)
{
}

crJXJSelectTargetDecalUpdateMethod::crJXJSelectTargetDecalUpdateMethod(const crJXJSelectTargetDecalUpdateMethod& handle):
	crMethod(handle),
	m_addRadius(handle.m_addRadius),
	m_myColor(handle.m_myColor),
	m_friendColor(handle.m_friendColor),
	m_enemyColor(handle.m_enemyColor),
	m_otherColor(handle.m_otherColor)
{
}

void crJXJSelectTargetDecalUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJSelectTargetDecalUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_addRadius = atof(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_myColor);
		m_myColor /= 255.0f;
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_friendColor);
		m_friendColor /= 255.0f;
		break;
	case 3:
		crArgumentParser::appAtoVec(str,m_enemyColor);
		m_enemyColor /= 255.0f;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_otherColor);
		m_otherColor /= 255.0f;
		break;
	}
}

void crJXJSelectTargetDecalUpdateMethod::operator()(crHandle &handle)
{
	void *param;
	crData *cameraData = m_this->getDataClass();
	CRCore::ScopedLock<crData> lock(*cameraData);
	cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	crInstanceItem *selectItem = NULL;
	crMatrixTransform *bot;
	crNode *fxNode = NULL; crNode *fxNode_2 = NULL;
	//float scale = crGlobalHandle::gData()->gUnitScale();
	crVector3 pos;
	crData *data;
	unsigned int guisestate;
	crVector2 lengths;
	crVector3 halfPhysicsBox;
	crDecalUpdateCallback *callback;
	//std::vector<crRole*> EraseVec;
	for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
		itr != selectMyRoles->end(); )
	{
		selectItem = itr->get();
		fxNode = selectItem->findSceneFxNode("$SelectDecal");
		guisestate = GS_Normal;
		selectItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
					callback->setVisiable(false);
			}
			itr = selectMyRoles->erase(itr);
			continue;
		}
		else
		{
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
				{
					bot = dynamic_cast<crMatrixTransform *>(selectItem->getRelNode());
					if(!bot || !bot->getVisiable())
					{
						callback->setVisiable(false);
					}
					else
					{
						callback->setVisiable(true);
						callback->setColor(m_myColor);
						pos = bot->getTrans();
						callback->setPosition(crVector2(pos[0],pos[1]));
						data = selectItem->getDataClass();
						data->getParam(WCHDATA_HalfPhysicsBox,param);
						halfPhysicsBox = *((crVector3*)(param));
						lengths.set(halfPhysicsBox[0],halfPhysicsBox[1]);
						lengths *= 2.0f;
						lengths[0] = lengths.length()+m_addRadius;
						lengths[1] = lengths[0];
						callback->setSize(lengths);
					}
				}
			}
			else
			{//create fxnode
				selectItem->doEvent(WCH_Touch/*,MAKEINT64(NULL,m_this)*/);
			}
		}
		++itr;
	}
	cameraData->getParam(WCHDATA_SelectItem,param);
	selectItem = (crInstanceItem *)param;
	if(selectItem)
	{
		fxNode = selectItem->findSceneFxNode("$SelectDecal");
		fxNode_2 = selectItem->findSceneFxNode("$MouseOnDecal");
		if (fxNode_2)
		{
			callback = dynamic_cast<crDecalUpdateCallback *>(fxNode_2->getUpdateCallback("DecalUpdate"));
			if (callback)
				callback->setVisiable(false);
		}
		guisestate = GS_Normal;
		selectItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
					callback->setVisiable(false);
			}
			cameraData->inputParam(WCHDATA_SelectItem,NULL);
		}
		else
		{
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
				{
					bot = dynamic_cast<crMatrixTransform *>(selectItem->getRelNode());
					if(!bot || !bot->getVisiable())
					{
						callback->setVisiable(false);
					}
					else
					{
						callback->setVisiable(true);
						char isEnemy = 0;
						crMyPlayerData::getInstance()->getCurrentRole()->doEvent(WCH_EnemyCheck,MAKEINT64(selectItem,&isEnemy));
						if(isEnemy == -1)
							callback->setColor(m_enemyColor);
						else if(isEnemy == 1)
							callback->setColor(m_friendColor);
						else
							callback->setColor(m_otherColor);
						pos = bot->getTrans();
						callback->setPosition(crVector2(pos[0],pos[1]));
						data = selectItem->getDataClass();
						data->getParam(WCHDATA_HalfPhysicsBox,param);
						halfPhysicsBox = *((crVector3*)(param));
						lengths.set(halfPhysicsBox[0],halfPhysicsBox[1]);
						lengths *= 2.0f;
						lengths[0] = lengths.length()+m_addRadius;
						lengths[1] = lengths[0];
						callback->setSize(lengths);
					}
				}
			}
			else
			{//
				selectItem->doEvent(WCH_Touch/*,MAKEINT64(NULL,m_this)*/);
			}
		}
	}

	cameraData->getParam(WCHDATA_JXJBattleTargetRoleVec,param);
	TargetItemVec *targetItemVec = (TargetItemVec *)param;
	for( TargetItemVec::iterator itr_target = targetItemVec->begin();
		itr_target != targetItemVec->end(); )
	{
		selectItem = itr_target->get();
		fxNode = selectItem->findSceneFxNode("$SelectDecal");
		guisestate = GS_Normal;
		selectItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
					callback->setVisiable(false);
			}
			itr_target = targetItemVec->erase(itr_target);
			continue;
		}
		else
		{
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
				{
					bot = dynamic_cast<crMatrixTransform *>(selectItem->getRelNode());
					if(!bot || !bot->getVisiable())
					{
						callback->setVisiable(false);
					}
					else
					{
						callback->setVisiable(true);
						callback->setColor(m_enemyColor);
						pos = bot->getTrans();
						callback->setPosition(crVector2(pos[0],pos[1]));
						data = selectItem->getDataClass();
						data->getParam(WCHDATA_HalfPhysicsBox,param);
						halfPhysicsBox = *((crVector3*)(param));
						lengths.set(halfPhysicsBox[0],halfPhysicsBox[1]);
						lengths *= 2.0f;
						lengths[0] = lengths.length()+m_addRadius;
						lengths[1] = lengths[0];
						callback->setSize(lengths);
					}
				}
			}
			else
			{//create fxnode
				selectItem->doEvent(WCH_Touch/*,MAKEINT64(NULL,m_this)*/);
			}
		}
		++itr_target;
	}
}
/////////////////////////////////////////
//
//crJXJRecvRoleInfo2Method
//
/////////////////////////////////////////
crJXJRecvRoleInfo2Method::crJXJRecvRoleInfo2Method(){}
crJXJRecvRoleInfo2Method::crJXJRecvRoleInfo2Method(const crJXJRecvRoleInfo2Method& handle):
	crMethod(handle)
{
}
void crJXJRecvRoleInfo2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crSceneServerPlayerData*)(LOINT64(param64));
			m_role = (crRole*)(HIINT64(param64));
		}
		else
		{
			m_player = NULL;
			m_role = NULL;
		}
		break;
	}
}

void crJXJRecvRoleInfo2Method::addParam(int i, const std::string& str)
{
}

void crJXJRecvRoleInfo2Method::operator()(crHandle &handle)
{
	if(m_role && m_player)
	{
		void *param;
		crData *myData = m_this->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		myData->getParam(WCHDATA_JXJShiliID,param);
		unsigned char shiliid = *(unsigned char *)param;
		myData->getParam(WCHDATA_JXJPlayerGuanZhi,param);
		unsigned char guanzhi = *(unsigned char *)param;
		myData->getParam(WCHDATA_JXJFormationInfoVec,param);
		int roleid = m_role->getRoleID();
		/*unsigned short*/int armyCount;
		crTableIO::StrVec itemrecord,record;
		EquipOnMap *equipOnMap;
		bool found = false;
		ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if (itemtab.valid())
		{
			ref_ptr<crTableIO> troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			int abid = itemtab->getTitleIndex("abstractid");
			crData *roleData;
			FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
			for( FormationInfoVec::iterator itr = formationInfoVec->begin();
				itr != formationInfoVec->end();
				++itr )
			{
				if(roleid == (*itr)->getRoleID() && m_role->getAbstractItemID()>0 && m_role->getAbstractItemID() == (*itr)->getAbstractID())
				{
					roleData = m_role->getDataClass();
					if(roleData)
					{
						roleData->inputParam(WCHDATA_JXJRoleChengHao,&guanzhi);
						roleData->inputParam(WCHDATA_Camp,&shiliid);
						armyCount = (*itr)->getCount();
						roleData->inputParam(WCHDATA_JXJArmyCount,&armyCount);
						crVector2i &equips = (*itr)->getEquips();
						roleData->excHandle(MAKEINT64(WCH_LockData,1));
						roleData->getParam(WCHDATA_EquipOnMap,param);
						equipOnMap = (EquipOnMap *)param;
						//equipOnMap->clear();
						if(equips[0]>0)
						{
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(equips[0]),itemrecord)>=0)
								equipOnMap->insert(std::make_pair(atoi(itemrecord[abid].c_str()),0));
						}
						if(equips[1]>0)
						{
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(equips[1]),itemrecord)>=0)
								equipOnMap->insert(std::make_pair(atoi(itemrecord[abid].c_str()),0));
						}
						roleData->excHandle(MAKEINT64(WCH_LockData,0));

						//if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa(m_role->getAbstractItemID()),record)>=0)
						//	m_role->setIName(record[1]);
						m_role->setIName(m_this->getCharacterName());

						//设置天赋
						m_this->doEvent(WCH_JXJSetInborn,MAKEINT64(m_role,&equips));
						found = true;
					}
					else
					{
						CRCore::notify(CRCore::ALWAYS)<<"crJXJRecvRoleInfo2Method Error aitemid= "<<m_role->getAbstractItemID()<<std::endl;
						//sprintf(gDebugInfo->buf(),"crJXJRecvRoleInfo2Method Error aitemid=%d\n\0",m_role->getAbstractItemID());
						//gDebugInfo->debugInfo(CRCore::ALWAYS);
					}
					break;
				}
			}
		}
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		if(!found)
		{
			CRCore::notify(CRCore::ALWAYS)<<"crJXJRecvRoleInfo2Method Error 没有找到编队信息,roleid="<<roleid<<" abstractid="<<m_role->getAbstractItemID()<<std::endl;
			//sprintf(gDebugInfo->buf(),"crJXJRecvRoleInfo2Method Error 没有找到编队信息,roleid=%d abstractid=%d\n\0",roleid,m_role->getAbstractItemID());
			//gDebugInfo->debugInfo(CRCore::ALWAYS);
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetInbornMethod
//
/////////////////////////////////////////
crJXJSetInbornMethod::crJXJSetInbornMethod(){}
crJXJSetInbornMethod::crJXJSetInbornMethod(const crJXJSetInbornMethod& handle):
	crMethod(handle)
{
}
void crJXJSetInbornMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_role = (crRole*)(LOINT64(param64));
			m_card = *(crVector2i *)(HIINT64(param64));
		}
		else
		{
			m_role = NULL;
		}
		break;
	}
}

void crJXJSetInbornMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetInbornMethod::setMagicAttr(CRCore::crData *roleData,int startid,const CREncapsulation::crTableIO::StrVec &record)
{
	CRCore::ScopedLock<crData> lock(*roleData);
	short base;
	void *param;
	for (int i = 0; i<28;i++)
	{
		switch (i)
		{
		case 0:
			{//攻速
				roleData->getParam(WCHDATA_InbornAttackSpeedPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 1:
			{//CD缩减
				roleData->getParam(WCHDATA_InbornSkillSpeedPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 2:
			{//移动速度
				roleData->getParam(WCHDATA_InbornSpeed,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 3:
			{//护甲值
				roleData->getParam(WCHDATA_InbornDefendPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 4:
			{//法术抗性
				roleData->getParam(WCHDATA_InbornMagicDefendPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 5:
			{//格挡几率
				roleData->getParam(WCHDATA_InbornParry,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 6:
			{//攻击力
				roleData->getParam(WCHDATA_InbornAttackPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 7:
			{//生命值
				roleData->getParam(WCHDATA_InbornHPPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 8:
			{//暴击率
				roleData->getParam(WCHDATA_InbornCrit,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 9:
			{//闪避率
				roleData->getParam(WCHDATA_InbornDodge,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 10:
			{//攻城攻击力
				roleData->getParam(WCHDATA_InbornBuildAttackPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 11:
			{//攻击距离
				roleData->getParam(WCHDATA_InbornAttackDist,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
					//unsigned char inc = (unsigned char)(atoi(record[startid+i].c_str()));
					//INTLIMITADD(*addpercent,inc,255);
				}
			}
			break;
		case 12:
			{//命中率
				roleData->getParam(WCHDATA_InbornHitratioPercent,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 13:
			{//穿透
				roleData->getParam(WCHDATA_InbornIgnoreDefend,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = atoi(record[startid+i].c_str());
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 14:
			{//法术穿透
				roleData->getParam(WCHDATA_InbornIgnoreMagicDefend,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = atoi(record[startid+i].c_str());
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 15:
			{//潜行
				roleData->getParam(WCHDATA_InbornStealth,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 16:
			{//反潜行
				roleData->getParam(WCHDATA_InbornStealthSpy,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 17:
			{//视野
				roleData->getParam(WCHDATA_InbornSightRange,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 18:
			{//无视闪避
				roleData->getParam(WCHDATA_InbornIgnoreDodge,param);
				unsigned char *addpercent = (unsigned char *)param;
				if (addpercent && !(*addpercent))
				{//0或1
					*addpercent = (unsigned char)(atoi(record[startid+i].c_str()));
				}
			}
			break;
		case 19:
			{//反弹物伤
				roleData->getParam(WCHDATA_InbornAttackDamageBack,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = atoi(record[startid+i].c_str());
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 20:
			{//反弹法伤
				roleData->getParam(WCHDATA_InbornSkillDamageBack,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = atoi(record[startid+i].c_str());
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 21:
			{//物理吸血
				roleData->getParam(WCHDATA_InbornAttackAbsorbHP,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = atoi(record[startid+i].c_str());
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 22:
			{//法术吸血
				roleData->getParam(WCHDATA_InbornSkillAbsorbHP,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = atoi(record[startid+i].c_str());
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 23:
			{//暴击剑,不可叠加->暴击倍率
				roleData->getParam(WCHDATA_InbornCritPower,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{//0或1
					base = atoi(record[startid+i].c_str());
					*addpercent+=(short)(base);
				}
			}
			break;
		case 24:
			{
				//溅射
				crVector2f vecbase;
				if(crArgumentParser::appAtoVec(record[startid+i],vecbase))
				{
					//if(lvstartid>0 && crArgumentParser::appAtoVec(lvrecord[lvstartid+i],vecadd))
					//{
					//	vecbase[0] *= 1.0f+vecadd[0] * 0.001f;
					//	vecbase[1] *= 1.0f+vecadd[1] * 0.001f;
					//}
					void *param;
					roleData->getParam(WCHDATA_InbornSputtering,param);
					_crInt32 sput = *(_crInt32*)param;
					_crInt32 sputtering;
					if(sput != 0)
					{
						_crInt16 area = LOINT32(sput);
						_crInt16 percent = HIINT32(sput);
						//if(area>0)
						//	area = CRCore::minimum(area,(short)vecbase[0]);
						//else
						area = CRCore::maximum(area,(short)vecbase[0]);//(short)vecbase[0];
						percent += (short)vecbase[1];
						sputtering = MAKEINT32(area,percent);
					}
					else
					{
						sputtering = MAKEINT32((short)vecbase[0],(short)vecbase[1]);
					} 
					roleData->inputParam(WCHDATA_InbornSputtering,&sputtering);
				}
			}
			break;
		case 25:
			{//物伤加深
				roleData->getParam(WCHDATA_InbornAttackDamage,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 26:
			{//法伤加深
				roleData->getParam(WCHDATA_InbornSkillDamage,param);
				short *addpercent = (short *)param;
				if (addpercent)
				{
					base = (short)(atoi(record[startid+i].c_str()));
					//if(base!=0 && lvstartid>0)
					//{
					//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
					//	base = (float)(base) * (1.0f+add);
					//}
					*addpercent+=(short)(base);
				}
			}
			break;
		case 27:
			{//技能类
				if(startid+i<record.size())
				{
					int equipid = atoi(record[startid+i].c_str());
					if(equipid>0)
					{
						roleData->getParam(WCHDATA_EquipOnMap,param);
						EquipOnMap *equipOnMap = (EquipOnMap *)param;
						(*equipOnMap).insert(std::make_pair(equipid,0));
					}
					//if(lvstartid>0)
					//{
					//	equipid = atoi(lvrecord[lvstartid+i].c_str());
					//	if(equipid>0)
					//	{
					//		roleData->getParam(WCHDATA_EquipOnMap,param);
					//		EquipOnMap *equipOnMap = (EquipOnMap *)param;
					//		(*equipOnMap).insert(std::make_pair(equipid,0));
					//	}
					//}
				}
			}
			break;
		}
	}
}
void crJXJSetInbornMethod::operator()(crHandle &handle)
{
	if(m_role && m_this->getDataClass())
	{
		crRole *mainRole = m_this->getMainRole();
		if(mainRole && mainRole->getDataClass())
		{
			void *param;
			crData *roleData = m_role->getDataClass();
			//roleData->excHandle(MAKEINT64(WCH_LockData,1));
			float bingfa = 0.0f;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char vipLevel = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char fubenOrChengchiType = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short fubenOrChengchiID = *(unsigned short *)param;
			//兵法--》攻击力
			mainRole->doEvent(WCH_JXJGetBingFa,MAKEINT64(&bingfa,NULL));
			crVector3f bingfaFactor;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBingFaFactor,vipLevel),bingfaFactor);
			short inbornAttackPercent = (bingfa * bingfaFactor[0]/((bingfa * bingfaFactor[1]) + bingfaFactor[2])) * 1000.0f;
			roleData->inputParam(WCHDATA_InbornAttackPercent,&inbornAttackPercent);
			roleData->inputParam(WCHDATA_InbornBuildAttackPercent,&inbornAttackPercent);
			//阵法--》防御力
			float zhenfa = 0.0f;
			mainRole->doEvent(WCH_JXJGetZhenFa,MAKEINT64(&zhenfa,NULL));
			crVector3f zhenfaFactor;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJZhenFaFactor,vipLevel),zhenfaFactor);
			short inbornDefendPercent = (zhenfa * zhenfaFactor[0]/((zhenfa * zhenfaFactor[1]) + zhenfaFactor[2])) * 1000.0f;
			roleData->inputParam(WCHDATA_InbornDefendPercent,&inbornDefendPercent);
			//洞察--》魔抗
			float dongcha = 0.0f;
			mainRole->doEvent(WCH_JXJGetDongCha,MAKEINT64(&dongcha,NULL));
			crVector3f dongchaFactor;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJDongChaFactor,vipLevel),dongchaFactor);
			short inbornMagicDefendPercent = (dongcha * dongchaFactor[0]/((dongcha * dongchaFactor[1]) + dongchaFactor[2])) * 1000.0f;
			roleData->inputParam(WCHDATA_InbornMagicDefendPercent,&inbornMagicDefendPercent);

			/////科技对天赋的影响
			//int addid;
			//crTableIO::StrVec record;
			//ref_ptr<crTableIO> techtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
			//int lvindex = techtab->getTitleIndex("lv");
			//int addindex = techtab->getTitleIndex("属性加成");
			//unsigned char techlv;
			//for (int i = WCHDATA_JXJTechJingBinglv; i<=WCHDATA_JXJTechQiangXinglv;i++)
			//{
			//	data->getParam(i, param);
			//	techlv = *(unsigned char *)param;
			//	if(techtab->queryOneRecord(0,crArgumentParser::appItoa(i),lvindex,crArgumentParser::appItoa((int)techlv),record)>=0)
			//	{
			//		addid = 0;
			//		switch (i)
			//		{
			//		case WCHDATA_JXJTechJingBinglv:
			//			addid = WCHDATA_InbornAttackPercent;
			//			break;
			//		case WCHDATA_JXJTechJianJialv:
			//			addid = WCHDATA_InbornDefendPercent;
			//			break;
			//		case WCHDATA_JXJTechQiangRenlv:
			//			addid = WCHDATA_InbornHPPercent;
			//			break;
			//		case WCHDATA_JXJTechGuiMoulv:
			//			addid = WCHDATA_InbornSkillSpeedPercent;
			//			break;
			//		case WCHDATA_JXJTechGongChenglv:
			//			addid = WCHDATA_InbornBuildAttackPercent;
			//			break;
			//		case WCHDATA_JXJTechYuanGonglv:
			//			addid = WCHDATA_InbornMagicDefendPercent;
			//			break;
			//		case WCHDATA_JXJTechSuGonglv:
			//			addid = WCHDATA_InbornAttackSpeedPercent;
			//			break;
			//		case WCHDATA_JXJTechQiangXinglv:
			//			addid = WCHDATA_InbornSpeed;
			//			break;
			//		}
			//		if(addid>0)
			//		{
			//			roleData->getParam(addid,param);
			//			short *addpercent = (short *)param;
			//			if (addpercent && addindex>0)
			//			{
			//				*addpercent+=(short)(atoi(record[addindex].c_str()));
			//			}
			//		}
			//	}
			//}
			/////套装加成及魔法装备加成
			ref_ptr<crTableIO> lordequiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
			ref_ptr<crTableIO> troopstab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			ref_ptr<crTableIO> equipref0tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine0Tab);
			ref_ptr<crTableIO> equipref1tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine1Tab);
			ref_ptr<crTableIO> equipref2tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine2Tab);
			ref_ptr<crTableIO> equipsuit2tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipSuit2Tab);
			ref_ptr<crTableIO> equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
			ref_ptr<crTableIO> equipRoleExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRoleExtraTab);
			ref_ptr<crTableIO> equipTroopsExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipTroopsExtraTab);
			ref_ptr<crTableIO> cardExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCardExtraTab);
			ref_ptr<crTableIO> TroopsTechLvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTechLvTab);
			ref_ptr<crTableIO> equipDataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_EquipDataAttrTab);
			ref_ptr<crTableIO> TroopsChengchiTab = fubenOrChengchiType==1?crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsChengchiTab):crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsFubenTab);
			int refstart = equipref0tab->getTitleIndex("攻速");
			int suit2start = equipsuit2tab->getTitleIndex("攻速");
			int inlaystart = equipinlaytab->getTitleIndex("攻速");
			int roleexstart = equipRoleExtraTab->getTitleIndex("攻速");
			int troopexstart = equipTroopsExtraTab->getTitleIndex("攻速");
			int cardexstart = cardExtraTab->getTitleIndex("攻速");
			int	equipdataexstart = equipDataAttrTab->getTitleIndex("攻速");
			int bingzhongid = lordequiptab->getTitleIndex("兵种");
			int partindex = lordequiptab->getTitleIndex("partid");
			int techbingzhongindex = TroopsTechLvTab->getTitleIndex("兵种");
			int troopstechstart = TroopsTechLvTab->getTitleIndex("攻速");
			int abstractidindex = TroopsTechLvTab->getTitleIndex("abstractid");
			int techlvindex = TroopsTechLvTab->getTitleIndex("lv");
			int chengchibingzhongindex = TroopsChengchiTab->getTitleIndex("兵种");
			int troopschengchistart = TroopsChengchiTab->getTitleIndex("攻速");
			int chengchiTroopsidindex = TroopsChengchiTab->getTitleIndex("abstractid");
			int mybingzhong = 0;
			int myabstractid = m_role->getAbstractItemID();
			std::string strAbstractItemID = crArgumentParser::appItoa(myabstractid);
			crTableIO::StrVec troopsRec;
			if(troopstab->queryOneRecord(0,strAbstractItemID,troopsRec)>=0)
			{
				mybingzhong = atoi(troopsRec[troopstab->getTitleIndex("兵种")].c_str());
			}
			std::string strMybingzhong = crArgumentParser::appItoa(mybingzhong);

			ref_ptr<crTableIO> suitequiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipSuitTab);
			crTableIO::StrVec equiprecord,suitrecord,refrecord,inlayrecord,exrecord;
			int equipindex = suitequiptab->getTitleIndex("头盔");

			//mainRoleData->excHandle(MAKEINT64(WCH_LockData,1));
			int equipid = 0;
			_crInt32 equipmagic = 0;
			unsigned char ref0,ref1,ref2,inlayid;
			crData *mainRoleData = mainRole->getDataClass();
			mainRoleData->getParam(WCHDATA_JXJLordEquipVec,param);
			JXJLordEquipVec lordequipvec = *(JXJLordEquipVec *)param;
			std::map<int,int> SuiteMap;//套装id,件数
			std::map<int,int>::iterator sitr;
			int suitid = 0;
			_crInt16 lo16;
			_crInt16 hi16;
			int bingzhong = 0;
			std::string strEquipID;
			for(int partid = 0; partid<ET_Count; partid++)
			{
				equipid = (lordequipvec)[partid].first;
				strEquipID = crArgumentParser::appItoa(equipid);
				if(equipid>0 && lordequiptab->queryOneRecord(0,strEquipID,equiprecord)>=0)
				{
					bingzhong = atoi(equiprecord[bingzhongid].c_str());
					if(bingzhong==-1 || bingzhong == mybingzhong)
					{
						equipmagic = (lordequipvec)[partid].second;
						if(equipmagic!=0)
						{//设置魔法装备属性
							lo16 = LOINT32(equipmagic);
							hi16 = HIINT32(equipmagic);
							ref0 = LOINT16(lo16);
							ref1 = HIINT16(lo16);
							ref2 = LOINT16(hi16);
							inlayid = HIINT16(hi16);
							if(ref0!=0 && equipref0tab->queryOneRecord(0,crArgumentParser::appItoa(ref0),refrecord)>=0)
							{
								setMagicAttr(roleData,refstart,refrecord);
							}
							if(ref1!=0 && equipref1tab->queryOneRecord(0,crArgumentParser::appItoa(ref1),refrecord)>=0)
							{
								setMagicAttr(roleData,refstart,refrecord);
							}
							if(ref2!=0 && equipref2tab->queryOneRecord(0,crArgumentParser::appItoa(ref2),refrecord)>=0)
							{
								setMagicAttr(roleData,refstart,refrecord);
							}
							if(inlayid!=0 && equipinlaytab->queryOneRecord(0,equiprecord[partindex],2,crArgumentParser::appItoa(inlayid),inlayrecord)>=0)
							{
								setMagicAttr(roleData,inlaystart,inlayrecord);
							}
						}
					}
					/////查询兵种特性
					if(equipTroopsExtraTab->queryOneRecord(0,strEquipID,2,strMybingzhong,exrecord)>=0)
					{
						setMagicAttr(roleData,troopexstart,exrecord);
					}
					else if(equipRoleExtraTab->queryOneRecord(0,strEquipID,2,strAbstractItemID,exrecord)>=0)
						setMagicAttr(roleData,roleexstart,exrecord);

					//查询是否是套装ID
					if(suitequiptab->queryOneRecord(equipindex+partid,strEquipID,suitrecord)>=0)
					{//是套装
						suitid = atoi(suitrecord[0].c_str());
						sitr = SuiteMap.find(suitid);
						if(sitr != SuiteMap.end())
						{
							sitr->second += 1;
						}
						else
						{
							SuiteMap[atoi(suitrecord[0].c_str())] = 1;
						}
					}
				}
			}
			crTableIO::DataVec suitequip2Rec;
			for( sitr = SuiteMap.begin();
				sitr != SuiteMap.end();
				++sitr )
			{
				if(sitr->second>1)
				{//设置套装属性
					equipsuit2tab->queryRecords(0,crArgumentParser::appItoa(sitr->first),suitequip2Rec);
					for(int si = 0; si<suitequip2Rec.size();++si)
					{
						if(si+2 <= sitr->second)
						{//设置套装属性
							setMagicAttr(roleData,suit2start,suitequip2Rec[si]);
						}
					}
				}
			}
			/////查询将卡兵种特性
			std::string strCard0 = crArgumentParser::appItoa(m_card[0]);
			std::string strCard1 = crArgumentParser::appItoa(m_card[1]);
			if(m_card[0]>0)
			{
				if(equipDataAttrTab->queryOneRecord(0,strCard0,exrecord)>=0)
				{
					setMagicAttr(roleData,equipdataexstart,exrecord);
				}
				if(equipTroopsExtraTab->queryOneRecord(0,strCard0,2,strMybingzhong,exrecord)>=0)
				{
					setMagicAttr(roleData,troopexstart,exrecord);
				}
				else if(equipRoleExtraTab->queryOneRecord(0,strCard0,2,strAbstractItemID,exrecord)>=0)
					setMagicAttr(roleData,roleexstart,exrecord);
			}
			if(m_card[1]>0)
			{
				if(equipDataAttrTab->queryOneRecord(0,strCard1,exrecord)>=0)
				{
					setMagicAttr(roleData,equipdataexstart,exrecord);
				}
				if(equipTroopsExtraTab->queryOneRecord(0,strCard1,2,strMybingzhong,exrecord)>=0)
				{
					setMagicAttr(roleData,troopexstart,exrecord);
				}
				else if(equipRoleExtraTab->queryOneRecord(0,strCard1,2,strAbstractItemID,exrecord)>=0)
					setMagicAttr(roleData,roleexstart,exrecord);
			}
			//if(m_card[0]>0 && m_card[1]>0)
			//{
			//	bool bFound = false;
			//	int nRowCount = cardExtraTab->getRowCount();
			//	std::string strSearch1("|"), strSearch2("|");
			//	strSearch1 += strCard0 + "|";
			//	strSearch2 += strCard1 + "|";
			//	for (int i=0; i<nRowCount; i++)
			//	{
			//		if ((*cardExtraTab)(i,0).find(strSearch1)!=std::string::npos && 
			//			(*cardExtraTab)(i,1).find(strSearch2)!=std::string::npos)
			//		{
			//			exrecord = cardExtraTab->getDataVec()[i];
			//			bFound = true;
			//			break;
			//		}
			//	}
			//	if (bFound)
			//		setMagicAttr(roleData,cardexstart,exrecord);
			//	//if(cardExtraTab->queryOneRecord(0,strCard0,1,strCard1,exrecord)>=0)
			//	//	setMagicAttr(roleData,cardexstart,exrecord);
			//}
			data->excHandle(MAKEINT64(WCH_LockData,1));
			//组合将卡
			if(m_card[0]>0 && m_card[1]>0)
			{
				data->getParam(WCHDATA_JXJCardExtraTechMap,param);
				CardExtraTechMap *cardExtraTechMap = (CardExtraTechMap *)param;
				int nRowCount = cardExtraTab->getRowCount();
				std::string strSearch1("|"), strSearch2("|");
				strSearch1 += strCard0 + "|";
				strSearch2 += strCard1 + "|";
				unsigned short cardid = 0;
				std::string cardidStr;
				unsigned char cardlv = 0;
				CardExtraTechMap::iterator cetitr;
				for (int i=0; i<nRowCount; i++)
				{
					if ((*cardExtraTab)(i,0).find(strSearch1)!=std::string::npos && 
						(*cardExtraTab)(i,1).find(strSearch2)!=std::string::npos)
					{
						if(cardid == 0)
						{
							cardidStr = (*cardExtraTab)(i,2);
							cardid = atoi(cardidStr.c_str());
							cetitr = cardExtraTechMap->find(cardid);
							if(cetitr != cardExtraTechMap->end())
							{
								cardlv = cetitr->second;
							}
						}
						if(cardlv==0)
							break;
						if(atoi((*cardExtraTab)(i,3).c_str())<=cardlv)
						{
							setMagicAttr(roleData,cardexstart,cardExtraTab->getDataVec()[i]);
						}
						else
						{
							break;
						}
					}
					if(!cardidStr.empty() && cardidStr != (*cardExtraTab)(i,2))
						break;
				}
				//CardExtraTechMap::iterator itr = cardExtraTechMap->find(MAKEINT64(m_card[0],m_card[1]));
				//if(itr != cardExtraTechMap->end())
				//{//有激活了该组合科技
				//	if(cardExtraTab->queryOneRecord(0,strCard0,1,strCard1,2,crArgumentParser::appItoa(itr->second),exrecord)>=0)
				//		setMagicAttr(roleData,cardexstart,exrecord);
				//}
			}
			////军备加成
			crTableIO::StrVec troopstechrecord;
			std::vector< int > techabstractid;
			bool iftechadd = false;
			data->getParam(WCHDATA_JXJTroopsTechMap, param);
			TroopsTechMap *troopstechmap = (TroopsTechMap *)param;
			for (TroopsTechMap::iterator titr = troopstechmap->begin();
				titr != troopstechmap->end();
				++titr)
			{
				iftechadd = false;
				if(TroopsTechLvTab->queryOneRecord(0,crArgumentParser::appItoa(titr->first),techlvindex,crArgumentParser::appItoa(titr->second),troopstechrecord)>=0)
				{
					bingzhong = atoi(troopstechrecord[techbingzhongindex].c_str());
					if(crArgumentParser::appAtoVec(troopstechrecord[abstractidindex].c_str(),techabstractid) && !techabstractid.empty())
					{
						if (bingzhong == -1 && techabstractid[0] == -1)
						{
							iftechadd = true;
						}
						else if(bingzhong == mybingzhong)
						{
							iftechadd = true;
						}
						else
						{
							for (int i = 0; i < techabstractid.size(); ++i)
							{
								if (m_role->getAbstractItemID() == techabstractid[i])
								{
									iftechadd = true;
									break;
								}
							}
						}
					}
					if (iftechadd)
					{
						setMagicAttr(roleData,troopstechstart,troopstechrecord);
					}
				}
			}
			////
			data->excHandle(MAKEINT64(WCH_LockData,0));
			////////城池|副本对兵种的加成
			crTableIO::DataVec datavec;
			TroopsChengchiTab->queryRecords(0,crArgumentParser::appItoa(fubenOrChengchiID),datavec);
			if(!datavec.empty())
			{
				std::vector<int> idvec;
				std::vector<int>::iterator iitr;
				for( crTableIO::DataVec::iterator itr = datavec.begin();
					 itr != datavec.end();
					 ++itr )
				{
					if(!(*itr)[2].empty())
					{
						crArgumentParser::appAtoVec((*itr)[2],idvec);
						for( iitr = idvec.begin();
							 iitr != idvec.end();
							 ++iitr )
						{
							if(*iitr == myabstractid)
							{
								setMagicAttr(roleData,troopschengchistart,*itr);
								break;
							}
						}
					}
					if(!(*itr)[1].empty())
					{
						crArgumentParser::appAtoVec((*itr)[1],idvec);
						for( iitr = idvec.begin();
							iitr != idvec.end();
							++iitr )
						{
							if(*iitr == mybingzhong)
							{
								setMagicAttr(roleData,troopschengchistart,*itr);
								break;
							}
						}
					}
				}
			}
			//if(TroopsChengchiTab->queryOneRecord(0,crArgumentParser::appItoa(fubenOrChengchiID),2,strAbstractItemID,troopstechrecord)>=0)
			//{
			//	setMagicAttr(roleData,troopschengchistart,troopstechrecord);
			//}
			//else if(TroopsChengchiTab->queryOneRecord(0,crArgumentParser::appItoa(fubenOrChengchiID),1,strMybingzhong,troopstechrecord)>=0)
			//{
			//	setMagicAttr(roleData,troopschengchistart,troopstechrecord);
			//}
			//mainRoleData->excHandle(MAKEINT64(WCH_LockData,0));
			//roleData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetResProductPercentMethod
//
/////////////////////////////////////////
crJXJGetResProductPercentMethod::crJXJGetResProductPercentMethod():
	m_this(NULL),
	m_output(NULL),
	m_thingtype(0){}
crJXJGetResProductPercentMethod::crJXJGetResProductPercentMethod(const crJXJGetResProductPercentMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL),
	m_thingtype(0)
{
}
void crJXJGetResProductPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
			m_thingtype = (unsigned char)(HIINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetResProductPercentMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetResProductPercentMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		//float intellect = 0.0f;
		////m_this->doEvent(WCH_JXJGetIntellect,MAKEINT64(&intellect,NULL));
		//m_this->doEvent(WCH_JXJGetBingFa,MAKEINT64(&intellect,NULL));
		//crVector3f intellectFactor;
		//crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJIntellectFactor),intellectFactor);
		float percent = 0.0f;//(intellect * intellectFactor[0]/((intellect * intellectFactor[1]) + intellectFactor[2]));
		//委任将卡加成
		crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
		if (playerData)
		{
			void *param;
			crData *data = playerData->getDataClass();
			crTableIO::StrVec cardrecord;
			ref_ptr<crTableIO> cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
			int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
			int addpercentindex = cardtab->getTitleIndex("政卡加成");
			data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
			JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

			int zhengcardtype = -1;
			switch (m_thingtype)
			{
			case T_Food:
				zhengcardtype = ZhengAdd_IncreaseFoodGet;
				break;
			case T_Wood:
				zhengcardtype = ZhengAdd_IncreaseWoodGet;
				break;
			case T_Iron:
				zhengcardtype = ZhengAdd_IncreaseIronGet;
				break;
			case T_Horse:
				zhengcardtype = ZhengAdd_IncreaseHoreseGet;
				break;
			default:
				break;
			}
			if (zhengcardtype >= 0)
			{
				for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
					carditr!=appjiangkavec->end();
					++carditr)
				{
					if ((*carditr)!=NULL)
					{
						if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord)>=0)
						{
							if(atoi(cardrecord[zhengkatypeindex].c_str()) == zhengcardtype)
							{
								percent +=atof(cardrecord[addpercentindex].c_str());
								break;
							}
						}
					}
				}
			}
		}
		*m_output = percent * 0.01f;
	}
}
/////////////////////////////////////////
//
//crJXJGetBingFaMethod
//
/////////////////////////////////////////
crJXJGetBingFaMethod::crJXJGetBingFaMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetBingFaMethod::crJXJGetBingFaMethod(const crJXJGetBingFaMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetBingFaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetBingFaMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetBingFaMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJBingFa,param);
		unsigned short base = *((unsigned short*)param);

		ref_ptr<crTableIO> lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		ref_ptr<crTableIO> equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
		int partindex = lordEquipTab->getTitleIndex("partid");
		int tid = lordEquipTab->getTitleIndex("兵法");
		int inlaytid = equipinlaytab->getTitleIndex("兵法");
		//ref_ptr<crTableIO> equiplvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquiplvTab);
		//int tid1 = equiplvTab->getTitleIndex("兵法");
		crTableIO::StrVec equiprecord,inlayrecord;

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJLordEquipVec,param);
		short equipadd = 0;
		//float add;
		float equipSum = 0.0f;
		//_crInt32 equipmagic;
		//_crInt8 equiplv;
		int equipid = 0;
		_crInt32 equipmagic = 0;
		unsigned char ref0,ref1,ref2,inlayid;
		_crInt16 lo16;
		_crInt16 hi16;
		std::string strEquipID;
		JXJLordEquipVec* lordEquipVec = (JXJLordEquipVec*)param;
		for(int partid = 0; partid<ET_Count; partid++)
		{
			equipid = (*lordEquipVec)[partid].first;
			strEquipID = crArgumentParser::appItoa(equipid);
			equipadd = 0;
			if(equipid>0 && lordEquipTab->queryOneRecord(0,strEquipID,equiprecord)>=0)
			{
				equipadd = atoi(equiprecord[tid].c_str());
				equipmagic = (*lordEquipVec)[partid].second;
				if(equipmagic!=0)
				{//查询装备等级加成
					lo16 = LOINT32(equipmagic);
					hi16 = HIINT32(equipmagic);
					ref0 = LOINT16(lo16);
					ref1 = HIINT16(lo16);
					ref2 = LOINT16(hi16);
					inlayid = HIINT16(hi16);
					if(inlayid!=0 && equipinlaytab->queryOneRecord(0,equiprecord[partindex],2,crArgumentParser::appItoa(inlayid),inlayrecord)>=0)
					{
						equipadd += atoi(inlayrecord[inlaytid].c_str());
					}
				}
				equipSum+=equipadd;
			}
		}

		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = (float)base + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetZhenFaMethod
//
/////////////////////////////////////////
crJXJGetZhenFaMethod::crJXJGetZhenFaMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetZhenFaMethod::crJXJGetZhenFaMethod(const crJXJGetZhenFaMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetZhenFaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetZhenFaMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetZhenFaMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJZhenFa,param);
		unsigned short base = *((unsigned short*)param);

		ref_ptr<crTableIO> lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		ref_ptr<crTableIO> equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
		int partindex = lordEquipTab->getTitleIndex("partid");
		int tid = lordEquipTab->getTitleIndex("阵法");
		int inlaytid = equipinlaytab->getTitleIndex("阵法");
		//ref_ptr<crTableIO> equiplvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquiplvTab);
		//int tid1 = equiplvTab->getTitleIndex("阵法");
		crTableIO::StrVec equiprecord,inlayrecord;

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJLordEquipVec,param);
		short equipadd = 0;
		//float add;
		float equipSum = 0.0f;
		//_crInt32 equipmagic;
		//_crInt8 equiplv;
		int equipid = 0;
		_crInt32 equipmagic = 0;
		unsigned char ref0,ref1,ref2,inlayid;
		_crInt16 lo16;
		_crInt16 hi16;
		std::string strEquipID;
		JXJLordEquipVec* lordEquipVec = (JXJLordEquipVec*)param;
		for(int partid = 0; partid<ET_Count; partid++)
		{
			equipid = (*lordEquipVec)[partid].first;
			strEquipID = crArgumentParser::appItoa(equipid);
			equipadd = 0;
			if(equipid>0 && lordEquipTab->queryOneRecord(0,strEquipID,equiprecord)>=0)
			{
				equipadd = atoi(equiprecord[tid].c_str());
				equipmagic = (*lordEquipVec)[partid].second;
				if(equipmagic!=0)
				{//查询装备等级加成
					lo16 = LOINT32(equipmagic);
					hi16 = HIINT32(equipmagic);
					ref0 = LOINT16(lo16);
					ref1 = HIINT16(lo16);
					ref2 = LOINT16(hi16);
					inlayid = HIINT16(hi16);
					if(inlayid!=0 && equipinlaytab->queryOneRecord(0,equiprecord[partindex],2,crArgumentParser::appItoa(inlayid),inlayrecord)>=0)
					{
						equipadd += atoi(inlayrecord[inlaytid].c_str());
					}
				}
				equipSum+=equipadd;
				//equipmagic = itr->second;
				//if(equip!=0 && equipmagic!=0)
				//{//查询装备等级加成
				//	equiplv = HIINT16(LOINT32(equipmagic));
				//	if(equiplv>0 && equiplvTab->queryOneRecord(0,crArgumentParser::appItoa(itr->first),2,crArgumentParser::appItoa(equiplv),record1))
				//	{
				//		add = atof(record1[tid1].c_str()) * 0.001f;
				//		equip = (float)equip * (1.0f+add);
				//	}
				//}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = (float)base + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetDongChaMethod
//
/////////////////////////////////////////
crJXJGetDongChaMethod::crJXJGetDongChaMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetDongChaMethod::crJXJGetDongChaMethod(const crJXJGetDongChaMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetDongChaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetDongChaMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetDongChaMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJDongCha,param);
		unsigned short base = *((unsigned short*)param);

		ref_ptr<crTableIO> lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		ref_ptr<crTableIO> equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
		int partindex = lordEquipTab->getTitleIndex("partid");
		int tid = lordEquipTab->getTitleIndex("洞察");
		int inlaytid = equipinlaytab->getTitleIndex("洞察");
		//ref_ptr<crTableIO> equiplvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquiplvTab);
		//int tid1 = equiplvTab->getTitleIndex("洞察");
		crTableIO::StrVec equiprecord,inlayrecord;

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJLordEquipVec,param);
		short equipadd = 0;
		//float add;
		float equipSum = 0.0f;
		//_crInt32 equipmagic;
		//_crInt8 equiplv;
		int equipid = 0;
		_crInt32 equipmagic = 0;
		unsigned char ref0,ref1,ref2,inlayid;
		_crInt16 lo16;
		_crInt16 hi16;
		std::string strEquipID;
		JXJLordEquipVec* lordEquipVec = (JXJLordEquipVec*)param;
		for(int partid = 0; partid<ET_Count; partid++)
		{
			equipid = (*lordEquipVec)[partid].first;
			strEquipID = crArgumentParser::appItoa(equipid);
			equipadd = 0;
			if(equipid>0 && lordEquipTab->queryOneRecord(0,strEquipID,equiprecord)>=0)
			{
				equipadd = atoi(equiprecord[tid].c_str());
				equipmagic = (*lordEquipVec)[partid].second;
				if(equipmagic!=0)
				{//查询装备等级加成
					lo16 = LOINT32(equipmagic);
					hi16 = HIINT32(equipmagic);
					ref0 = LOINT16(lo16);
					ref1 = HIINT16(lo16);
					ref2 = LOINT16(hi16);
					inlayid = HIINT16(hi16);
					if(inlayid!=0 && equipinlaytab->queryOneRecord(0,equiprecord[partindex],2,crArgumentParser::appItoa(inlayid),inlayrecord)>=0)
					{
						equipadd += atoi(inlayrecord[inlaytid].c_str());
					}
				}
				equipSum+=equipadd;
				//equipmagic = itr->second;
				//if(equip!=0 && equipmagic!=0)
				//{//查询装备等级加成
				//	equiplv = HIINT16(LOINT32(equipmagic));
				//	if(equiplv>0 && equiplvTab->queryOneRecord(0,crArgumentParser::appItoa(itr->first),2,crArgumentParser::appItoa(equiplv),record1))
				//	{
				//		add = atof(record1[tid1].c_str()) * 0.001f;
				//		equip = (float)equip * (1.0f+add);
				//	}
				//}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = (float)base + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetTongShuaiMethod
//
/////////////////////////////////////////
crJXJGetTongShuaiMethod::crJXJGetTongShuaiMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetTongShuaiMethod::crJXJGetTongShuaiMethod(const crJXJGetTongShuaiMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetTongShuaiMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetTongShuaiMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetTongShuaiMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJTongShuai,param);
		unsigned short base = *((unsigned short*)param);

		ref_ptr<crTableIO> lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		ref_ptr<crTableIO> equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
		int partindex = lordEquipTab->getTitleIndex("partid");
		int tid = lordEquipTab->getTitleIndex("统率");
		int inlaytid = equipinlaytab->getTitleIndex("统率");
		//ref_ptr<crTableIO> equiplvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquiplvTab);
		//int tid1 = equiplvTab->getTitleIndex("统率");
		crTableIO::StrVec equiprecord,inlayrecord;

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJLordEquipVec,param);
		short equipadd = 0;
		//float add;
		float equipSum = 0.0f;
		//_crInt32 equipmagic;
		//_crInt8 equiplv;
		int equipid = 0;
		_crInt32 equipmagic = 0;
		unsigned char ref0,ref1,ref2,inlayid;
		_crInt16 lo16;
		_crInt16 hi16;
		std::string strEquipID;
		JXJLordEquipVec* lordEquipVec = (JXJLordEquipVec*)param;
		for(int partid = 0; partid<ET_Count; partid++)
		{
			equipid = (*lordEquipVec)[partid].first;
			strEquipID = crArgumentParser::appItoa(equipid);
			equipadd = 0;
			if(equipid>0 && lordEquipTab->queryOneRecord(0,strEquipID,equiprecord)>=0)
			{
				equipadd = atoi(equiprecord[tid].c_str());
				equipmagic = (*lordEquipVec)[partid].second;
				if(equipmagic!=0)
				{//查询装备等级加成
					lo16 = LOINT32(equipmagic);
					hi16 = HIINT32(equipmagic);
					ref0 = LOINT16(lo16);
					ref1 = HIINT16(lo16);
					ref2 = LOINT16(hi16);
					inlayid = HIINT16(hi16);
					if(inlayid!=0 && equipinlaytab->queryOneRecord(0,equiprecord[partindex],2,crArgumentParser::appItoa(inlayid),inlayrecord)>=0)
					{
						equipadd += atoi(inlayrecord[inlaytid].c_str());
					}
				}
				equipSum+=equipadd;
				//equipmagic = itr->second;
				//if(equip!=0 && equipmagic!=0)
				//{//查询装备等级加成
				//	equiplv = HIINT16(LOINT32(equipmagic));
				//	if(equiplv>0 && equiplvTab->queryOneRecord(0,crArgumentParser::appItoa(itr->first),2,crArgumentParser::appItoa(equiplv),record1))
				//	{
				//		add = atof(record1[tid1].c_str()) * 0.001f;
				//		equip = (float)equip * (1.0f+add);
				//	}
				//}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = (float)base + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetLeaderPowerMethod
//
/////////////////////////////////////////
crJXJGetLeaderPowerMethod::crJXJGetLeaderPowerMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetLeaderPowerMethod::crJXJGetLeaderPowerMethod(const crJXJGetLeaderPowerMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetLeaderPowerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetLeaderPowerMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetLeaderPowerMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJGovPost,param);
		unsigned char post = *(unsigned char*)param;
		ref_ptr<crTableIO> postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
		int powerid = postTab->getTitleIndex("领导力");
		crTableIO::StrVec record;
		int base = 0;
		if(postTab->queryOneRecord(0,crArgumentParser::appItoa(post),record)>=0)
			base = atoi(record[powerid].c_str());

		ref_ptr<crTableIO> lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		powerid = lordEquipTab->getTitleIndex("领导力");

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJLordEquipVec,param);
		float equip = 0.0f;
		float equipSum = 0.0f;
		JXJLordEquipVec* lordEquipVec = (JXJLordEquipVec*)param;
		for( JXJLordEquipVec::iterator itr = lordEquipVec->begin();
			itr != lordEquipVec->end();
			++itr )
		{
			if(itr->first>0)
			{
				equip = 0.0f;
				if(lordEquipTab->queryOneRecord(0,crArgumentParser::appItoa(itr->first),record)>=0)
				{
					equip = atoi(record[powerid].c_str());
					equipSum+=equip;
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		*m_output = base + equipSum;
	}
}
//////////////////////////////////////////
////
////crJXJGetTotalLeaderPowerMethod
////
///////////////////////////////////////////
//crJXJGetTotalLeaderPowerMethod::crJXJGetTotalLeaderPowerMethod():
//	m_this(NULL),
//	m_output(NULL){}
//crJXJGetTotalLeaderPowerMethod::crJXJGetTotalLeaderPowerMethod(const crJXJGetTotalLeaderPowerMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_output(NULL)
//{
//}
//void crJXJGetTotalLeaderPowerMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 1:
//		m_this = (crPlayerGameData *)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_output = (float *)(LOINT64(param64));
//		}
//		else
//		{
//			m_output = NULL;
//		}
//		break;
//	}
//}
//void crJXJGetTotalLeaderPowerMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJGetTotalLeaderPowerMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_output)
//	{
//		crData *data = m_this->getDataClass();
//		//void *param;
//
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//		//*m_output = base + equipSum;
//	}
//}
//////////////////数值公式
///////////////////////////////////////////
////
////crJXJGetAttackRangeExaltMethod
////
///////////////////////////////////////////
//crJXJGetAttackRangeExaltMethod::crJXJGetAttackRangeExaltMethod():
//	m_this(NULL),
//	m_baseRange(0.0f),
//	m_output(NULL){}
//crJXJGetAttackRangeExaltMethod::crJXJGetAttackRangeExaltMethod(const crJXJGetAttackRangeExaltMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_baseRange(0.0f),
//	m_output(NULL)
//{
//}
//void crJXJGetAttackRangeExaltMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_output = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_baseRange = *(float *)(LOINT64(param64));
//			m_output = (float *)(HIINT64(param64));
//		}
//		else
//		{
//			m_output = NULL;
//		}
//		break;
//	}
//}
//void crJXJGetAttackRangeExaltMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJGetAttackRangeExaltMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_baseRange>0.0f && m_output)
//	{
//		crData *data = m_this->getDataClass();
//		void *param;
//		data->getParam(WCHDATA_InbornAttackRangePercent,param);
//		short inborn = *((short*)param);
//
//		*m_output = (float)m_baseRange*(float)inborn*0.01f;
//	}
//}
/////////////////////////////////////////
//
//crJXJGetSightRangeMethod
//
/////////////////////////////////////////
crJXJGetSightRangeMethod::crJXJGetSightRangeMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetSightRangeMethod::crJXJGetSightRangeMethod(const crJXJGetSightRangeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetSightRangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetSightRangeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetSightRangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_SightRange,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraSightRange_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornSightRange,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipSightRange,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = base+inborn+extra/*+equipSum*/;
		if(*m_output<0.0f)
			*m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetItemSightRangeMethod
//
/////////////////////////////////////////
crJXJGetItemSightRangeMethod::crJXJGetItemSightRangeMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetItemSightRangeMethod::crJXJGetItemSightRangeMethod(const crJXJGetItemSightRangeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetItemSightRangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetItemSightRangeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetItemSightRangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_SightRange,param);
		short base = *((short*)param);

		*m_output = base;
	}
}
/////////////////////////////////////////
//
//crJXJGetSpeedMethod
//
/////////////////////////////////////////
crJXJGetSpeedMethod::crJXJGetSpeedMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetSpeedMethod::crJXJGetSpeedMethod(const crJXJGetSpeedMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetSpeedMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetSpeedMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Speed,param);
		short base = *((short*)param);

		//data->getParam(WCHDATA_ExtraSpeed_RD,param);
		//short extraSpeed = *((short*)param);

		data->getParam(WCHDATA_ExtraSpeedPercent_RD,param);
		short extraPercent = *((short*)param);

		data->getParam(WCHDATA_InbornSpeed,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSpeedSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipSpeed,MAKEINT64(m_this,&equip));
		//		equipSpeedSum+=equip;
		//	}
		//}

		*m_output = (float)(inborn/*+equipSpeedSum*/)+(float)base*(1.0f+(float)(extraPercent*0.001f));
		*m_output = CRCore::clampTo(*m_output,0.0f,c_maxMoveSpeed);
		//if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetStealthMethod
//
/////////////////////////////////////////
crJXJGetStealthMethod::crJXJGetStealthMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetStealthMethod::crJXJGetStealthMethod(const crJXJGetStealthMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetStealthMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetStealthMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetStealthMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Stealth,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraStealth_RD,param);
		short extraStealth = *((short*)param);

		data->getParam(WCHDATA_InbornStealth,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipStealth,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = base+inborn+extraStealth/*+equipSum*/;
		//*m_output = (float)(base+extraStealth+inborn) + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetStealthSpyMethod
//
/////////////////////////////////////////
crJXJGetStealthSpyMethod::crJXJGetStealthSpyMethod():
	m_this(NULL),
	m_output(NULL){}
crJXJGetStealthSpyMethod::crJXJGetStealthSpyMethod(const crJXJGetStealthSpyMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJGetStealthSpyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetStealthSpyMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetStealthSpyMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_StealthSpy,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraStealthSpy_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornStealthSpy,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipStealthSpy,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = base+inborn+extra/*+equipSum*/;
		//*m_output = (float)(base+extra+inborn) + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetDefendMethod
//
/////////////////////////////////////////
crJXJGetDefendMethod::crJXJGetDefendMethod():
	m_output(NULL){}
crJXJGetDefendMethod::crJXJGetDefendMethod(const crJXJGetDefendMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetDefendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetDefendMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetDefendMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Defend,param);
		int base = *((int*)param);
		data->getParam(WCHDATA_ExtraDefend_RD,param);
		short extraDefend = *((short*)param);

		data->getParam(WCHDATA_ExtraDefendPercent_RD,param);
		short extraPercent = *((short*)param);

		data->getParam(WCHDATA_InbornDefendPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipDefendSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipDefend,MAKEINT64(m_this,&equip));
		//		equipDefendSum+=equip;
		//	}
		//}

		*m_output = (float)extraDefend + (float)base * (1.0f + (float)(inborn+extraPercent/*+equipDefendSum*/) * 0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
		//*m_output += extraDefend;
		//if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetMagicDefendMethod
//
/////////////////////////////////////////
crJXJGetMagicDefendMethod::crJXJGetMagicDefendMethod():
	m_output(NULL){}
crJXJGetMagicDefendMethod::crJXJGetMagicDefendMethod(const crJXJGetMagicDefendMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetMagicDefendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetMagicDefendMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetMagicDefendMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_MagicDefend,param);
		short base = *((short*)param);
		data->getParam(WCHDATA_ExtraMagicDefendPercent_RD,param);
		short extraPercent = *((short*)param);

		data->getParam(WCHDATA_InbornMagicDefendPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipDefendSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipMagicDefend,MAKEINT64(m_this,&equip));
		//		equipDefendSum+=equip;
		//	}
		//}

		*m_output = (float)base * (1.0f + (float)(inborn+extraPercent/*+equipDefendSum*/) * 0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetDamageMethod
//
/////////////////////////////////////////
crJXJGetDamageMethod::crJXJGetDamageMethod():
	m_output(NULL){}
crJXJGetDamageMethod::crJXJGetDamageMethod(const crJXJGetDamageMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetDamageMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetDamageMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Attack,param);
		int base = *((int*)param);

		data->getParam(WCHDATA_ExtraAttack_RD,param);
		short extraAttack = *((short*)param);

		data->getParam(WCHDATA_ExtraAttackPercent_RD,param);
		short extraPercent = *((short*)param);

		data->getParam(WCHDATA_InbornAttackPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	 itr != equipOnMap.end();
		//	 ++itr )
		//{
		//          itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipAttack,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)extraAttack+(float)base*(1.0f+(float)(inborn+extraPercent/*+equipSum*/)*0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
		//*m_output += (float)extraAttack;
		//if(*m_output<0.0f) *m_output = 0.0f;
		//*m_output *= crGameDices::getInstance()->dicef(m_dice[0],m_dice[1]);
	}
}
/////////////////////////////////////////
//
//crJXJGetBuildDamageMethod
//
/////////////////////////////////////////
crJXJGetBuildDamageMethod::crJXJGetBuildDamageMethod():
	m_output(NULL){}
crJXJGetBuildDamageMethod::crJXJGetBuildDamageMethod(const crJXJGetBuildDamageMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetBuildDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetBuildDamageMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetBuildDamageMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Attack,param);
		int base = *((int*)param);

		//data->getParam(WCHDATA_ExtraAttack,param);
		//short extraAttack = *((short*)param);

		data->getParam(WCHDATA_ExtraBuildAttackPercent_RD,param);
		short extraPercent = *((short*)param);

		data->getParam(WCHDATA_InbornBuildAttackPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipAttackSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	 itr != equipOnMap.end();
		//	 ++itr )
		//{
		//          itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipBuildAttack,MAKEINT64(m_this,&equip));
		//		equipAttackSum+=equip;
		//	}
		//}

		*m_output = (float)base*(1.0f+(float)(inborn+extraPercent/*+equipAttackSum*/)*0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
		//*m_output += /*(float)extraAttack + */equipAttackSum;
		//if(*m_output<0.0f) *m_output = 0.0f;
		//*m_output *= crGameDices::getInstance()->dicef(m_dice[0],m_dice[1]);
	}
}
/////////////////////////////////////////
//
//crJXJGetHPMethod
//
/////////////////////////////////////////
crJXJGetHPMethod::crJXJGetHPMethod():
	m_output(NULL){}
crJXJGetHPMethod::crJXJGetHPMethod(const crJXJGetHPMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetHPMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetHPMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_HP,param);
		if(!param)
			return;
		int hp = *((int*)param);

		data->getParam(WCHDATA_ExtraHP_RD,param);
		short extrahp = *((short*)param);

		data->getParam(WCHDATA_InbornHPPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		equip = 0.0f;
		//		itemChild->getInstanceItem()->doEvent(WCH_GetEquipHP,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)hp*(1.0f+((float)inborn+(float)extrahp/*+equipSum*/)*0.001f);
	}
}
/////////////////////////////////////////
//
//crJXJGetRTHPPercentMethod
//
/////////////////////////////////////////
crJXJGetRTHPPercentMethod::crJXJGetRTHPPercentMethod():
	m_output(NULL){}
crJXJGetRTHPPercentMethod::crJXJGetRTHPPercentMethod(const crJXJGetRTHPPercentMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetRTHPPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetRTHPPercentMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetRTHPPercentMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		void *param;
		crData *itemData = m_this->getDataClass();
		itemData->excHandle(MAKEINT64(WCH_LockData,1));
		itemData->getParam(WCHDATA_RTHP,param);
		float rthp = *(float*)param;
		itemData->getParam(WCHDATA_HP,param);
		int perhp = *(int *)param; 
		itemData->getParam(WCHDATA_JXJArmyCount,param);
		/*unsigned short*/int armyCount = *(/*unsigned short*/int *)param;
		float maxhp = (float)perhp*armyCount;
		itemData->excHandle(MAKEINT64(WCH_LockData,0));

		*m_output = rthp/maxhp;
	}
}
///////////////////////////////////////////
////
////crJXJGetRTHPMethod
////
///////////////////////////////////////////
//crJXJGetRTHPMethod::crJXJGetRTHPMethod():
//	m_output(NULL){}
//crJXJGetRTHPMethod::crJXJGetRTHPMethod(const crJXJGetRTHPMethod& handle):
//	crMethod(handle),
//	m_output(NULL)
//{
//}
//void crJXJGetRTHPMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_output = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_output = (float *)(LOINT64(param64));
//		}
//		else
//		{
//			m_output = NULL;
//		}
//		break;
//	}
//}
//void crJXJGetRTHPMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJGetRTHPMethod::operator()(crHandle &handle)
//{
//	if(m_output)
//	{
//		crData *data = m_this->getDataClass();
//		void *param;
//		data->getParam(WCHDATA_RTHP,param);
//		float rthp = *((float*)param);
//
//		data->getParam(WCHDATA_ExtraRTHP_RD,param);
//		float extrahp = *((float*)param);
//
//		*m_output = rthp + extrahp;
//	}
//}
/////////////////////////////////////////
//
//crJXJGetEquipAttrShortMethod
//
/////////////////////////////////////////
crJXJGetEquipAttrShortMethod::crJXJGetEquipAttrShortMethod():
	m_output(NULL),
	m_equipAttrID(WCHDATA_EquipHP){}
crJXJGetEquipAttrShortMethod::crJXJGetEquipAttrShortMethod(const crJXJGetEquipAttrShortMethod& handle):
	crMethod(handle),
	m_output(NULL),
	m_equipAttrID(handle.m_equipAttrID)

{
}
void crJXJGetEquipAttrShortMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_owner = (crInstanceItem *)(LOINT64(param64));
			m_output = (float *)(HIINT64(param64));
		}
		else
		{
			m_owner = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetEquipAttrShortMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipAttrID = atoi(str.c_str());
		break;
	}
}
void crJXJGetEquipAttrShortMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(m_equipAttrID,param);
		if(param) *m_output = *((short*)param);
	}
}
/////////////////////////////////////////
//
//crJXJGetEquipAttrUCharMethod
//
/////////////////////////////////////////
crJXJGetEquipAttrUCharMethod::crJXJGetEquipAttrUCharMethod():
	m_output(NULL),
	m_equipAttrID(WCHDATA_EquipHP){}
crJXJGetEquipAttrUCharMethod::crJXJGetEquipAttrUCharMethod(const crJXJGetEquipAttrUCharMethod& handle):
	crMethod(handle),
	m_output(NULL),
	m_equipAttrID(handle.m_equipAttrID)

{
}
void crJXJGetEquipAttrUCharMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_owner = (crInstanceItem *)(LOINT64(param64));
			m_output = (unsigned char *)(HIINT64(param64));
		}
		else
		{
			m_owner = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetEquipAttrUCharMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipAttrID = atoi(str.c_str());
		break;
	}
}
void crJXJGetEquipAttrUCharMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(m_equipAttrID,param);
		if(param) *m_output = *((unsigned char*)param);
	}
}
/////////////////////////////////////////
//
//crJXJGetEquipAttrIntMethod
//
/////////////////////////////////////////
crJXJGetEquipAttrIntMethod::crJXJGetEquipAttrIntMethod():
	m_output(NULL),
	m_equipAttrID(WCHDATA_EquipHP){}
crJXJGetEquipAttrIntMethod::crJXJGetEquipAttrIntMethod(const crJXJGetEquipAttrIntMethod& handle):
	crMethod(handle),
	m_output(NULL),
	m_equipAttrID(handle.m_equipAttrID)

{
}
void crJXJGetEquipAttrIntMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_owner = (crInstanceItem *)(LOINT64(param64));
			m_output = (int *)(HIINT64(param64));
		}
		else
		{
			m_owner = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetEquipAttrIntMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipAttrID = atoi(str.c_str());
		break;
	}
}
void crJXJGetEquipAttrIntMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(m_equipAttrID,param);
		if(param) *m_output = *((int*)param);
	}
}
/////////////////////////////////////////
//
//crJXJGetMPMethod
//
/////////////////////////////////////////
crJXJGetMPMethod::crJXJGetMPMethod():
	m_output(NULL){}
crJXJGetMPMethod::crJXJGetMPMethod(const crJXJGetMPMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetMPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetMPMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetMPMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_MP,param);
		int mp = *((int*)param);

		data->getParam(WCHDATA_ExtraMP_RD,param);
		short extramp = *((short*)param);

		data->getParam(WCHDATA_InbornMPPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		equip = 0.0f;
		//		itemChild->getInstanceItem()->doEvent(WCH_GetEquipMP,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)mp*(1.0f+((float)inborn+(float)extramp/*+equipSum*/)*0.001f);
		//*m_output = (float)mp*(1.0f+(float)inborn*0.01f) + (float)extramp + equipSum;
	}
}
/////////////////////////////////////////
//
//crJXJGetHPRevertMethod
//
/////////////////////////////////////////
crJXJGetHPRevertMethod::crJXJGetHPRevertMethod():
	m_factor(0.1f),
	m_output(NULL){}
crJXJGetHPRevertMethod::crJXJGetHPRevertMethod(const crJXJGetHPRevertMethod& handle):
	crMethod(handle),
	m_factor(handle.m_factor),
	m_output(NULL)
{
}
void crJXJGetHPRevertMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetHPRevertMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_factor = atof(str.c_str());
		break;
	}
}
void crJXJGetHPRevertMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_RTHP,param);
		float base = *((float*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		equip = 0.0f;
		//		itemChild->getInstanceItem()->doEvent(WCH_GetEquipHPRevert,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = base*m_factor /*+ equipSum*/;
	}
}
/////////////////////////////////////////
//
//crJXJGetMPRevertMethod
//
/////////////////////////////////////////
crJXJGetMPRevertMethod::crJXJGetMPRevertMethod():
	m_factor(0.1f),
	m_output(NULL){}
crJXJGetMPRevertMethod::crJXJGetMPRevertMethod(const crJXJGetMPRevertMethod& handle):
	crMethod(handle),
	m_factor(handle.m_factor),
	m_output(NULL)
{
}
void crJXJGetMPRevertMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetMPRevertMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_factor = atof(str.c_str());
		break;
	}
}
void crJXJGetMPRevertMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_RTMP,param);
		float base = *((float*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		equip = 0.0f;
		//		itemChild->getInstanceItem()->doEvent(WCH_GetEquipMPRevert,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = base*m_factor /*+ equipSum*/;
	}
}
/////////////////////////////////////////
//
//crJXJGetCritMethod
//
/////////////////////////////////////////
crJXJGetCritMethod::crJXJGetCritMethod():
	m_output(NULL){}
crJXJGetCritMethod::crJXJGetCritMethod(const crJXJGetCritMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetCritMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetCritMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetCritMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Crit,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraCrit_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_ExtraCritPercent_RD,param);
		short critPercent = *(short *)param;

		data->getParam(WCHDATA_InbornCrit,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	 itr != equipOnMap.end();
		//	 ++itr )
		//{
		//          itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipCrit,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}
		*m_output = (float)extra+(float)base*(1.0f+(float)(critPercent+inborn/*+equipSum*/)*0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetParryMethod
//
/////////////////////////////////////////
crJXJGetParryMethod::crJXJGetParryMethod():
	m_output(NULL){}
crJXJGetParryMethod::crJXJGetParryMethod(const crJXJGetParryMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetParryMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetParryMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetParryMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Parry,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraParry_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_ExtraParryPercent_RD,param);
		short extraPercent = *(short*)param;

		data->getParam(WCHDATA_InbornParry,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipParry,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)extra+(float)base*(1.0f+(float)(extraPercent+inborn/*+equipSum*/)*0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetDodgeMethod
//
/////////////////////////////////////////
crJXJGetDodgeMethod::crJXJGetDodgeMethod():
	m_output(NULL){}
crJXJGetDodgeMethod::crJXJGetDodgeMethod(const crJXJGetDodgeMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetDodgeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetDodgeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetDodgeMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Dodge,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraDodge_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_ExtraDodgePercent_RD,param);
		short extraPercent = *((short*)param);

		data->getParam(WCHDATA_InbornDodge,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipDodge,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)extra+(float)base*(1.0f+(float)(extraPercent+inborn/*+equipSum*/) * 0.001f);
		if(*m_output<0.0f) *m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetHitratioMethod
//
/////////////////////////////////////////
crJXJGetHitratioMethod::crJXJGetHitratioMethod():
	m_output(NULL){}
crJXJGetHitratioMethod::crJXJGetHitratioMethod(const crJXJGetHitratioMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetHitratioMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetHitratioMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetHitratioMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_Hitratio,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraHitratioPercent_RD,param);
		short extraPercent = *((short*)param);
		data->getParam(WCHDATA_InbornHitratioPercent,param);
		short inbornPercent = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipHitratio,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)base*(1.0f+(float)(extraPercent+inbornPercent/*+equipSum*/)*0.001f);
		if(*m_output<0)	*m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetIgnoreDefendMethod
//
/////////////////////////////////////////
crJXJGetIgnoreDefendMethod::crJXJGetIgnoreDefendMethod():
	m_output(NULL){}
crJXJGetIgnoreDefendMethod::crJXJGetIgnoreDefendMethod(const crJXJGetIgnoreDefendMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetIgnoreDefendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetIgnoreDefendMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetIgnoreDefendMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraIgnoreDefend_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornIgnoreDefend,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipIgnoreDefend,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}
		*m_output = ((float)extra+inborn/*+equipSum*/) * 0.001f;
	}
}
/////////////////////////////////////////
//
//crJXJGetIgnoreMagicDefendMethod
//
/////////////////////////////////////////
crJXJGetIgnoreMagicDefendMethod::crJXJGetIgnoreMagicDefendMethod():
	m_output(NULL){}
crJXJGetIgnoreMagicDefendMethod::crJXJGetIgnoreMagicDefendMethod(const crJXJGetIgnoreMagicDefendMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetIgnoreMagicDefendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetIgnoreMagicDefendMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetIgnoreMagicDefendMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraIgnoreMagicDefend_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornIgnoreMagicDefend,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipIgnoreMagicDefend,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = ((float)extra+inborn/*+equipSum*/) * 0.001f;
	}
}
/////////////////////////////////////////
//
//crJXJAttackSpeedMethod
//
/////////////////////////////////////////
crJXJAttackSpeedMethod::crJXJAttackSpeedMethod():
	m_output(NULL),
	m_limit(-0.99f){}
crJXJAttackSpeedMethod::crJXJAttackSpeedMethod(const crJXJAttackSpeedMethod& handle):
	crMethod(handle),
	m_output(NULL),
	m_limit(handle.m_limit)
{
}
void crJXJAttackSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJAttackSpeedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_limit = atof(str.c_str());
		break;
	}
}
void crJXJAttackSpeedMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_AttackSpeed,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraAttackSpeed_RD,param);
		short extraAttackSpeed = *((short*)param);

		data->getParam(WCHDATA_InbornAttackSpeedPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipAttackSpeedSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipAttackSpeed,MAKEINT64(m_this,&equip));
		//		equipAttackSpeedSum+=equip;
		//	}
		//}

		//float fattackSpeed = (float)base*(1.0f+(float)(extraAttackSpeed+inborn+equipAttackSpeedSum)*0.001f);
		float fattackSpeed = (float)base+(float)inborn+(float)extraAttackSpeed/*+equipAttackSpeedSum*/;
		fattackSpeed *= 0.001f;
		*m_output = fattackSpeed;
		if(*m_output<m_limit) *m_output = m_limit;
	}
}
/////////////////////////////////////////
//
//crJXJSkillSpeedMethod
//
/////////////////////////////////////////
crJXJSkillSpeedMethod::crJXJSkillSpeedMethod():
	m_output(NULL),
	m_limit(0.0f){}
crJXJSkillSpeedMethod::crJXJSkillSpeedMethod(const crJXJSkillSpeedMethod& handle):
	crMethod(handle),
	m_output(NULL),
	m_limit(handle.m_limit)
{
}
void crJXJSkillSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJSkillSpeedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_limit = atof(str.c_str());
		break;
	}
}
void crJXJSkillSpeedMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_SkillSpeed,param);
		short base = *((short*)param);

		data->getParam(WCHDATA_ExtraSkillSpeed_RD,param);
		short extraSkillSpeed = *((short*)param);

		data->getParam(WCHDATA_InbornSkillSpeedPercent,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipSkillSpeed,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		//float fskillSpeed = (float)base*(1.0f+(float)(extraSkillSpeed+inborn+equipSum)*0.001f);
		float fskillSpeed = (float)base+(float)inborn+(float)extraSkillSpeed/*+equipSum*/;
		fskillSpeed *= 0.001f;
		*m_output = fskillSpeed;
		if(*m_output<m_limit) *m_output = m_limit;
	}
}
/////////////////////////////////////////
//
//crJXJGetGuiseStateMethod
//
/////////////////////////////////////////
crJXJGetGuiseStateMethod::crJXJGetGuiseStateMethod():
	m_output(NULL){}
crJXJGetGuiseStateMethod::crJXJGetGuiseStateMethod(const crJXJGetGuiseStateMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetGuiseStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (unsigned int *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetGuiseStateMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetGuiseStateMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_GuiseState,param);
		unsigned int base = *((unsigned int*)param);

		data->getParam(WCHDATA_ExtraGuise_RD,param);
		unsigned int extra = *((unsigned int*)param);

		*m_output = base | extra;
	}
}
/////////////////////////////////////////
//
//crJXJGetItemGuiseStateMethod
//
/////////////////////////////////////////
crJXJGetItemGuiseStateMethod::crJXJGetItemGuiseStateMethod():
	m_output(NULL){}
crJXJGetItemGuiseStateMethod::crJXJGetItemGuiseStateMethod(const crJXJGetItemGuiseStateMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetItemGuiseStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (unsigned int *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetItemGuiseStateMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetItemGuiseStateMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_GuiseState,param);
		unsigned int base = *((unsigned int*)param);

		*m_output = base;
	}
}
/////////////////////////////////////////
//
//crJXJGetRadiusMethod
//
/////////////////////////////////////////
crJXJGetRadiusMethod::crJXJGetRadiusMethod():
	m_output(NULL),
	m_limit(0.0f){}
crJXJGetRadiusMethod::crJXJGetRadiusMethod(const crJXJGetRadiusMethod& handle):
	crMethod(handle),
	m_output(NULL),
	m_limit(handle.m_limit)
{
}
void crJXJGetRadiusMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetRadiusMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_limit = atof(str.c_str());
		break;
	}
}
void crJXJGetRadiusMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_HalfPhysicsBox,param);
		crVector3 halfLengths = *((crVector3*)(param));
		data->getParam(WCHDATA_ExtraRadius_RD,param);
		if(param)
		{
			char extra = *((char *)param);
			*m_output = halfLengths[0]*(float)extra*0.01f;
		}
		else
		{
			*m_output = halfLengths[0];
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetAttackDistMethod
//
/////////////////////////////////////////
crJXJGetAttackDistMethod::crJXJGetAttackDistMethod():
	m_output(NULL){}
crJXJGetAttackDistMethod::crJXJGetAttackDistMethod(const crJXJGetAttackDistMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetAttackDistMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetAttackDistMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetAttackDistMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraAttackDist_RD,param);
		short extra = *((short *)param);
		data->getParam(WCHDATA_InbornAttackDist,param);
		short inborn = *((short *)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipAttackDist,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (/*equipSum+*/(float)(extra + inborn)) * 0.01f;//厘米转换成米
		if(*m_output<0.0f)
			*m_output = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJGetIgnoreDodgeMethod
//
/////////////////////////////////////////
crJXJGetIgnoreDodgeMethod::crJXJGetIgnoreDodgeMethod():
	m_output(NULL){}
crJXJGetIgnoreDodgeMethod::crJXJGetIgnoreDodgeMethod(const crJXJGetIgnoreDodgeMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetIgnoreDodgeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (bool *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetIgnoreDodgeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetIgnoreDodgeMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_InbornIgnoreDodge,param);
		unsigned char ignoreDodge = *((unsigned char *)param);
		//if(ignoreDodge!=1)
		//{
		//	data->getParam(WCHDATA_ExtraIgnoreDodge_RD,param);
		//	ignoreDodge = *((unsigned char *)param);
		//	if(ignoreDodge!=1)
		//	{
		//		crItemChild *itemChild;
		//		crInstanceItem *item;
		//		data->excHandle(MAKEINT64(WCH_LockData,1));
		//		data->getParam(WCHDATA_EquipOnMap,param);
		//		EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//		data->excHandle(MAKEINT64(WCH_LockData,0));
		//		for( EquipOnMap::iterator itr = equipOnMap.begin();
		//			itr != equipOnMap.end();
		//			++itr )
		//		{
		//			itemChild = m_this->findChildItem(itr->second);
		//			if(itemChild && itemChild->isLoaded())
		//			{
		//				item = itemChild->getInstanceItem();
		//				item->doEvent(WCH_GetEquipIgnoreDodge,MAKEINT64(m_this,&ignoreDodge));
		//				if(ignoreDodge==1)
		//					break;
		//			}
		//		}
		//	}
		//}
		*m_output = ignoreDodge==1;//0或者1
	}
}
/////////////////////////////////////////
//
//crJXJGetCritSwordMethod
//
/////////////////////////////////////////
crJXJGetCritSwordMethod::crJXJGetCritSwordMethod():
	m_output(NULL){}
crJXJGetCritSwordMethod::crJXJGetCritSwordMethod(const crJXJGetCritSwordMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetCritSwordMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetCritSwordMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetCritSwordMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraCritPower_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornCritPower,param);
		short inborn = *((short*)param);

		*m_output = (float)(extra+inborn) * 0.001f;//千分比
	}
	//if(m_this && m_output)
	//{
	//	void *param;
	//	crData *data = m_this->getDataClass();
	//	data->getParam(WCHDATA_InbornCritPower,param);
	//	unsigned char critsword = *((unsigned char *)param);
	//	//if(critsword!=1)
	//	//{
	//	//	data->getParam(WCHDATA_ExtraCritSword_RD,param);
	//	//	critsword = *((unsigned char *)param);
	//	//	if(critsword!=1)
	//	//	{
	//	//		crItemChild *itemChild;
	//	//		crInstanceItem *item;
	//	//		data->excHandle(MAKEINT64(WCH_LockData,1));
	//	//		data->getParam(WCHDATA_EquipOnMap,param);
	//	//		EquipOnMap equipOnMap = *(EquipOnMap*)param;
	//	//		data->excHandle(MAKEINT64(WCH_LockData,0));
	//	//		for( EquipOnMap::iterator itr = equipOnMap.begin();
	//	//			itr != equipOnMap.end();
	//	//			++itr )
	//	//		{
	//	//			itemChild = m_this->findChildItem(itr->second);
	//	//			if(itemChild && itemChild->isLoaded())
	//	//			{
	//	//				item = itemChild->getInstanceItem();
	//	//				item->doEvent(WCH_GetEquipCritSword,MAKEINT64(m_this,&critsword));
	//	//				if(critsword==1)
	//	//					break;
	//	//			}
	//	//		}
	//	//	}
	//	//}
	//	*m_output = critsword==1;//0或者1
	//}
}
/////////////////////////////////////////
//
//crJXJGetAttackAbsorbHPMethod
//
/////////////////////////////////////////
crJXJGetAttackAbsorbHPMethod::crJXJGetAttackAbsorbHPMethod():
	m_output(NULL){}
crJXJGetAttackAbsorbHPMethod::crJXJGetAttackAbsorbHPMethod(const crJXJGetAttackAbsorbHPMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetAttackAbsorbHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetAttackAbsorbHPMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetAttackAbsorbHPMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraAttackAbsorbHP_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornAttackAbsorbHP,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipAttackAbsorbHP,MAKEINT64(m_this,&equip));
		//		equipSum += equip;
		//	}
		//}

		*m_output = (float)(extra+inborn/*+equipSum*/) * 0.001f;//百分比
	}
}
/////////////////////////////////////////
//
//crJXJGetSkillAbsorbHPMethod
//
/////////////////////////////////////////
crJXJGetSkillAbsorbHPMethod::crJXJGetSkillAbsorbHPMethod():
	m_output(NULL){}
crJXJGetSkillAbsorbHPMethod::crJXJGetSkillAbsorbHPMethod(const crJXJGetSkillAbsorbHPMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetSkillAbsorbHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetSkillAbsorbHPMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetSkillAbsorbHPMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraSkillAbsorbHP_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornSkillAbsorbHP,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipSkillAbsorbHP,MAKEINT64(m_this,&equip));
		//		equipSum += equip;
		//	}
		//}

		*m_output = (float)(extra+inborn/*+equipSum*/) * 0.001f;//百分比
	}
}
/////////////////////////////////////////
//
//crJXJGetAttackDamageBackMethod
//
/////////////////////////////////////////
crJXJGetAttackDamageBackMethod::crJXJGetAttackDamageBackMethod():
	m_output(NULL){}
crJXJGetAttackDamageBackMethod::crJXJGetAttackDamageBackMethod(const crJXJGetAttackDamageBackMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetAttackDamageBackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetAttackDamageBackMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetAttackDamageBackMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraAttackDamageBack_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornAttackDamageBack,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipMax = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipAttackDamageBack,MAKEINT64(m_this,&equip));
		//		if(equipMax<equip)
		//			equipMax = equip;
		//	}
		//}

		*m_output = (float)(extra+inborn/*+equipMax*/) * 0.001f;//百分比
	}
}
/////////////////////////////////////////
//
//crJXJGetSkillDamageBackMethod
//
/////////////////////////////////////////
crJXJGetSkillDamageBackMethod::crJXJGetSkillDamageBackMethod():
	m_output(NULL){}
crJXJGetSkillDamageBackMethod::crJXJGetSkillDamageBackMethod(const crJXJGetSkillDamageBackMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetSkillDamageBackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetSkillDamageBackMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetSkillDamageBackMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraSkillDamageBack_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornSkillDamageBack,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipMax = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipSkillDamageBack,MAKEINT64(m_this,&equip));
		//		if(equipMax<equip)
		//			equipMax = equip;
		//	}
		//}

		*m_output = (float)(extra+inborn/*+equipMax*/) * 0.001f;//百分比
	}
}
/////////////////////////////////////////
//
//crJXJGetSputteringMethod
//
/////////////////////////////////////////
crJXJGetSputteringMethod::crJXJGetSputteringMethod():
	m_output(NULL){}
crJXJGetSputteringMethod::crJXJGetSputteringMethod(const crJXJGetSputteringMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetSputteringMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (_crInt32 *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetSputteringMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetSputteringMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;

		data->getParam(WCHDATA_InbornSputtering,param);
		_crInt32 inborn = *((_crInt32*)param);
		_crInt16 area = LOINT32(inborn);
		_crInt16 percent = HIINT32(inborn);
		data->getParam(WCHDATA_ExtraSputtering_RD,param);
		_crInt32 extra = *((_crInt32*)param);
		_crInt16 extraarea = LOINT32(extra);
		_crInt16 extrapercent = HIINT32(extra);
		percent += extrapercent;
		//if(area>0)
		//	area = CRCore::minimum(area,extraarea);
		//else
		area = CRCore::maximum(area,extraarea);//extraarea;
		//crItemChild *itemChild;
		//_crInt32 equip = 0;
		//_crInt16 equiparea;
		//_crInt16 equippercent;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0;
		//		item->doEvent(WCH_GetEquipSputtering,MAKEINT64(m_this,&equip));
		//		equiparea = LOINT32(equip);
		//		if(equip != 0 && equiparea > 0)
		//		{
		//			equippercent = HIINT32(equip);
		//			percent += equippercent;
		//			if(area>0)
		//				area = CRCore::minimum(area,equiparea);
		//			else
		//				area = equiparea;
		//		}
		//	}
		//}

		*m_output = MAKEINT32(area,percent);
	}
}
/////////////////////////////////////////
//
//crJXJGetAttackDamageMethod
//
/////////////////////////////////////////
crJXJGetAttackDamageMethod::crJXJGetAttackDamageMethod():
	m_output(NULL){}
crJXJGetAttackDamageMethod::crJXJGetAttackDamageMethod(const crJXJGetAttackDamageMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetAttackDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetAttackDamageMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetAttackDamageMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraAttackDamage_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornAttackDamage,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipAttackDamage,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)(extra+inborn/*+equipSum*/) * 0.001f;//百分比
	}
}
/////////////////////////////////////////
//
//crJXJGetSkillDamageMethod
//
/////////////////////////////////////////
crJXJGetSkillDamageMethod::crJXJGetSkillDamageMethod():
	m_output(NULL){}
crJXJGetSkillDamageMethod::crJXJGetSkillDamageMethod(const crJXJGetSkillDamageMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetSkillDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetSkillDamageMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetSkillDamageMethod::operator()(crHandle &handle)
{
	if(m_output)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_ExtraSkillDamage_RD,param);
		short extra = *((short*)param);

		data->getParam(WCHDATA_InbornSkillDamage,param);
		short inborn = *((short*)param);

		//crItemChild *itemChild;
		//float equip = 0.0f;
		//float equipSum = 0.0f;
		//crInstanceItem *item;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_EquipOnMap,param);
		//EquipOnMap equipOnMap = *(EquipOnMap*)param;
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//for( EquipOnMap::iterator itr = equipOnMap.begin();
		//	itr != equipOnMap.end();
		//	++itr )
		//{
		//	itemChild = m_this->findChildItem(itr->second);
		//	if(itemChild && itemChild->isLoaded())
		//	{
		//		item = itemChild->getInstanceItem();
		//		equip = 0.0f;
		//		item->doEvent(WCH_GetEquipSkillDamage,MAKEINT64(m_this,&equip));
		//		equipSum+=equip;
		//	}
		//}

		*m_output = (float)(extra+inborn/*+equipSum*/) * 0.001f;//百分比
	}
}
/////////////////////////////////////////
//
//crJXJFireExtraAttackMethod
//
/////////////////////////////////////////
crJXJFireExtraAttackMethod::crJXJFireExtraAttackMethod(){}
crJXJFireExtraAttackMethod::crJXJFireExtraAttackMethod(const crJXJFireExtraAttackMethod& handle):
	crMethod(handle)
{
}
void crJXJFireExtraAttackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJFireExtraAttackMethod::addParam(int i, const std::string& str)
{
}
void crJXJFireExtraAttackMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	if(m_hitParam->m_fireItem.valid() && m_hitParam->m_fireItem->getDataClass())
	{
		unsigned int guisestate = GS_Normal;
		m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_ExtraAttack)
		{
			cancelTask = false;
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJHitExtraAttackMethod
//
/////////////////////////////////////////
crJXJHitExtraAttackMethod::crJXJHitExtraAttackMethod(){}
crJXJHitExtraAttackMethod::crJXJHitExtraAttackMethod(const crJXJHitExtraAttackMethod& handle):
	crMethod(handle)
{
}
void crJXJHitExtraAttackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJHitExtraAttackMethod::addParam(int i, const std::string& str)
{
}
void crJXJHitExtraAttackMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	if(m_hitParam->m_hitItem.valid() && m_hitParam->m_hitItem->getDataClass())
	{
		unsigned int guisestate = GS_Normal;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_ExtraAttack)
		{
			cancelTask = false;
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJBackstabExtraAttackMethod
//
/////////////////////////////////////////
crJXJBackstabExtraAttackMethod::crJXJBackstabExtraAttackMethod(){}
crJXJBackstabExtraAttackMethod::crJXJBackstabExtraAttackMethod(const crJXJBackstabExtraAttackMethod& handle):
	crMethod(handle)
{
}
void crJXJBackstabExtraAttackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJBackstabExtraAttackMethod::addParam(int i, const std::string& str)
{
}
void crJXJBackstabExtraAttackMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	if(m_hitParam->m_fireItem.valid() && m_hitParam->m_fireItem->getDataClass() && m_hitParam->m_hitItem.valid() && m_hitParam->m_hitItem->getDataClass())
	{
		unsigned int guisestate = GS_Normal;
		m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_Backstab)
		{
			crVector3 hititempos = m_hitParam->m_hitItem->getPosition();
			crVector3 fireitempos = m_hitParam->m_fireItem->getPosition();
			crVector3 dir = hititempos - fireitempos;
			dir.normalize();
			const crVector3& hitdir = m_hitParam->m_hitItem->getDir();
			float cos_a = dir * hitdir;
			if(cos_a>0.0f)
			{//目标背对攻击者
				cancelTask = false;
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJGetImmunoMethod
//
/////////////////////////////////////////
crJXJGetImmunoMethod::crJXJGetImmunoMethod(){}
crJXJGetImmunoMethod::crJXJGetImmunoMethod(const crJXJGetImmunoMethod& handle):
	crMethod(handle)
{
}
void crJXJGetImmunoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJGetImmunoMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetImmunoMethod::operator()(crHandle &handle)
{
	int immuno = 0;//0无效 1正常 2物理免疫 3魔法免疫 4无敌
	if(m_hitParam->m_hitItem.valid())
	{
		immuno = 1;
		do 
		{
			unsigned int guisestate = GS_Normal;
			crData *hitData = m_hitParam->m_hitItem->getDataClass();
			if(!hitData)
			{
				immuno = 0;
				break;
			}
			void *param;
			hitData->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char *)param;
			if(itemstate == IS_Relive)
			{
				immuno = 0;
				break;
			}
			m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & GS_StaticUnVisiable || guisestate & GS_UnVisiable || guisestate & GS_Stagnate || guisestate & GS_NoAttack)
			{
				immuno = 0;
				break;
			}
			if(guisestate & GS_immunoPhysics && guisestate & GS_immunoSkill)
			{
				immuno = 4;
				break;
			}
			if(guisestate & GS_immunoSkill || guisestate & GS_Static || guisestate & GS_StaticNoneBlock)
			{
				immuno = 3;
				break;
			}
			if(guisestate & GS_immunoPhysics || guisestate & GS_Nihility)
			{
				immuno = 2;
				break;
			}
		} while (0);
	}
	handle.outputParam(0,&immuno);
}
/////////////////////////////////////////
//
//crJXJAttackDamageMethod
//
/////////////////////////////////////////
crJXJAttackDamageMethod::crJXJAttackDamageMethod(){}
crJXJAttackDamageMethod::crJXJAttackDamageMethod(const crJXJAttackDamageMethod& handle):
	crMethod(handle)
{
}
void crJXJAttackDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJAttackDamageMethod::addParam(int i, const std::string& str)
{
}
void crJXJAttackDamageMethod::operator()(crHandle &handle)
{
	if(m_hitParam.valid() && m_hitParam->m_fireItem.valid() && m_hitParam->m_hitItem.valid())
	{
		//命中率、暴击、格挡、闪避等判断
		void *param;
		crData *fireData = m_hitParam->m_fireItem->getDataClass();
		fireData->getParam(WCHDATA_IsMiss,param);
		bool isMiss = *(bool *)param;
		if(isMiss)
		{
			m_hitParam->m_hitItem->doEvent(WCH_JXJDamageType,MAKEINT64(MissDM,m_hitParam->m_fireItem.get()));
			return;
		}
		crData *hitData = m_hitParam->m_hitItem->getDataClass();
		hitData->getParam(WCHDATA_IsDodge,param);
		bool isDodge = *(bool *)param;
		if(isDodge)
		{
			//CRCore::notify(CRCore::ALWAYS)<<"crJXJAttackDamageMethod Dodge "<<m_hitParam->m_hitItem->getID()<<std::endl;
			//攻击者是否无视闪避
			bool ignoreDodge = false;
			m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetIgnoreDodge,0),MAKEINT64(&ignoreDodge,NULL));
			if(!ignoreDodge)
			{
				m_hitParam->m_hitItem->doEvent(WCH_JXJDamageType,MAKEINT64(DodgeDM,m_hitParam->m_fireItem.get()));
				return;
			}
		}

		// 普通攻击增加士气
		float gainRTMP = 0.0f;
		m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_JXJGetGainRTMP,NULL),MAKEINT64(&gainRTMP,1));
		if(gainRTMP>0.0f)
			m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_JXJCureRTMp,0),MAKEINT64(&gainRTMP,NULL));

		hitData->getParam(WCHDATA_IsParry,param);
		bool isParry = *(bool *)param;
		float damage = 0.0f;
		float fireDamage = 0.0f;
		m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetDamage,0),MAKEINT64(&fireDamage,NULL));
		float hitDefend = 0.0f;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetDefend,0),MAKEINT64(&hitDefend,NULL));

		float ignoreDefend = 0.0f;
		m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetIgnoreDefend,0),MAKEINT64(&ignoreDefend,NULL));
		hitDefend *= (1.0f - ignoreDefend);
		if(hitDefend<0.0f)
			hitDefend = 0.0f;
		////////计算伤害
		fireData->getParam(WCHDATA_JXJRTArmyCount,param);
		float armcount = *(/*unsigned short*/int *)param;
		//fireDamage *= armcount * m_hitParam->m_rate;
		{//测试
			fireData->getParam(WCHDATA_JXJArmyCount,param);
			float maxarmcount = *(/*unsigned short*/int *)param;
			fireDamage *= /*m_hitParam->m_rate **/(armcount+maxarmcount)/2.0f;
		}
		fireData->getParam(WCHDATA_IsCrit,param);
		bool isCrit = *(bool *)param;
		if(isCrit)
		{
			float critPower = 0.0f;
			m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetCritSword,0),MAKEINT64(&critPower,NULL));
			fireDamage *= 2.0f+critPower;
		}
		////计算反弹
		//if(fireDamage>0.0f)
		//{//攻击者受到伤害
		//	float damageback = 0.0f;
		//	m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetAttackDamageBack,0),MAKEINT64(&damageback,NULL));
		//	damageback = fireDamage * damageback;
		//	if(damageback>0.0f)
		//	{//攻击者受到伤害
		//		DamagePair dp(damageback,PhysicsDM);
		//		m_hitParam->m_fireItem->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_hitItem.get()));
		//	}
		//}
		//护甲的伤害减免
		hitData->getParam(WCHDATA_ArmourType,param);
		unsigned char armourType = *(unsigned char *)param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_DamageType,param);
		unsigned char damageType = *(unsigned char *)param;
		//0:减伤极限,1:防御力增加系数,2:普通攻击打城甲,3:攻城攻击打普通甲,4攻城攻击打城甲
		std::vector<float> damageParam;

		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJDamageParam,0),damageParam);
		while(damageParam.size()<5)
			damageParam.push_back(1.0f);
		if(damageType == Damage_Physics)
		{
			if(armourType == Armour_Physics)
			{
				damage = fireDamage * (1.0f - (CRCore::minimum(damageParam[0],hitDefend/(hitDefend+damageParam[1]))));
			}
			else if(armourType == Armour_Build)
			{
				damage = fireDamage*damageParam[2]*(1.0f - (CRCore::minimum(damageParam[0],hitDefend/(hitDefend+damageParam[1]))));
			}
		}
		else if(damageType == Damage_Build)
		{
			if(armourType == Armour_Physics)
			{
				damage = fireDamage * damageParam[3] * (1.0f - (CRCore::minimum(damageParam[0],hitDefend/(hitDefend+damageParam[1]))));
			}
			else if(armourType == Armour_Build)
			{
				damage = fireDamage*damageParam[4]*(1.0f - (CRCore::minimum(damageParam[0],hitDefend/(hitDefend+damageParam[1]))));
			}
		}
		//crData *data = m_hitParam->m_fireItem->getDataClass();
		if(isParry)
		{//格挡减免
			damage *= 0.5f;
		}
		//加深伤害
		float adddamage = 0.0f;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetAttackDamage,0),MAKEINT64(&adddamage,NULL));
		damage *= 1.0f+adddamage;
		if(damage>0)
		{
			//计算反弹
			//攻击者受到伤害
			float damageback = 0.0f;
			m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetAttackDamageBack,0),MAKEINT64(&damageback,NULL));
			damageback = damage * damageback;
			if(damageback>0.0f)
			{//攻击者受到伤害
				DamagePair dp(damageback,std::make_pair(PhysicsDM,0));
				m_hitParam->m_fireItem->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_hitItem.get()));
			}

			//float totaldamage = damage;
			//溅射伤害
			_crInt32 sputtering = 0;
			m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetSputtering,0),MAKEINT64(&sputtering,NULL));
			if(sputtering!=0)
			{//溅射伤害
				float range = (float)(LOINT32(sputtering)) * crGlobalHandle::gData()->gUnitScale();
				short damagepercent = HIINT32(sputtering);
				float sputteringdm = damage * (float)damagepercent * 0.001f;
				if(sputteringdm>0.0f)
				{
					ref_ptr<crSightInfo> hitSight = m_hitParam->m_hitItem->getSightInfo();
					if(hitSight.valid())
					{
						std::vector< ref_ptr<crInstanceItem> > SPItemVec;
						crVector3 hitpos = m_hitParam->m_hitItem->getPosition();
						crVector3 itempos;
						ref_ptr<crInstanceItem> item;
						ref_ptr<crData> itemData;
						unsigned char itemstate;
						unsigned int guisestate = GS_Normal;

						hitSight->lockItemEyeMap();
						crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
						for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
							itr != itemEyeMap.end();
							++itr )
						{
							item = itr->second;
							if(m_hitParam->m_hitItem != item)
							{
								itemData = item->getDataClass();
								if(itemData.valid())
								{
									itemData->getParam(WCHDATA_ItemState,param);
									itemstate = *(unsigned char *)param;
									if(itemstate == IS_Dead)
										continue;
								}

								guisestate = GS_Normal;
								item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
								if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
									guisestate & GS_Stagnate || guisestate & GS_immunoPhysics || guisestate & GS_Nihility || guisestate & GS_NoAttack )
								{
									continue;
								}
								itempos = item->getPosition();
								if((itempos - hitpos).length() < range)
								{
									SPItemVec.push_back(item);
								}
							}
						}
						hitSight->unlockItemEyeMap();

						ref_ptr<crSceneServerPlayerData> playerdata;
						hitSight->lockPlayerEyeMap();
						crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
						for( crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
							itr != playerEyeMap.end();
							++itr )
						{
							playerdata = itr->second;
							crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
							for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
								ritr != roleMap.end();
								++ritr )
							{
								item = dynamic_cast<crInstanceItem *>(ritr->second.get());
								if(m_hitParam->m_hitItem != item)
								{
									itemData = item->getDataClass();
									if(itemData.valid())
									{
										itemData->getParam(WCHDATA_ItemState,param);
										itemstate = *(unsigned char *)param;
										if(itemstate == IS_Dead)
											continue;
									}

									guisestate = GS_Normal;
									item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
									if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
										guisestate & GS_Stagnate || guisestate & GS_immunoPhysics || guisestate & GS_Nihility || guisestate & GS_NoAttack )
									{
										continue;
									}
									itempos = item->getPosition();
									if((itempos - hitpos).length() < range)
									{
										SPItemVec.push_back(item);
									}
								}
							}
						}
						hitSight->unlockPlayerEyeMap();
						DamagePair dp(sputteringdm,std::make_pair(PhysicsDM,1));
						for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
							itr != SPItemVec.end();
							++itr )
						{
							//totaldamage += sputteringdm;
							(*itr)->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_fireItem.get()));
						}
					}
				}
			}
			if(armourType != Armour_Build)
			{//溅射不累计吸血
				//攻击者吸血
				float absorbHP = 0.0f;
				m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetAttackAbsorbHP,0),MAKEINT64(&absorbHP,NULL));
				absorbHP = /*totaldamage*/damage * absorbHP; 
				if(absorbHP>0.0f)
				{
					m_hitParam->m_fireItem->doEvent(WCH_CureHP,MAKEINT64(&absorbHP,NULL/*m_hitParam->m_hitItem.get()*/));
				}
			}
			DamagePair dp(damage,std::make_pair(PhysicsDM,1));
			if(isCrit)
			{
				dp.second = std::make_pair(CritDM,1);
			}
			else if(isParry)
			{
				dp.second = std::make_pair(ParryDM,1);
			}
			m_hitParam->m_hitItem->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_fireItem.get()));

			if(armourType == Armour_Physics)
			{//////////附魔测试
				m_hitParam->m_fireItem->doEvent(WCH_AttackExtraTest,MAKEINT64(m_hitParam.get(),&damage));
			}
			m_hitParam->m_hitItem->doEvent(WCH_HitExtraTest,MAKEINT64(m_hitParam.get(),&damage));
		}
		//CRCore::notify(CRCore::ALWAYS)<<"crJXJAttackDamageMethod AddDamage "<<damage<<" "<<m_hitParam->m_hitItem->getID()<<std::endl;
		ref_ptr<crSightInfo> sightinfo = m_hitParam->m_hitItem->getSightInfo();
		if(m_hitParam->m_hitItem->getItemtype() == crInstanceItem::Role && sightinfo.valid())
		{//
			crRole *fireRole = dynamic_cast<crRole *>(m_hitParam->m_fireItem.get());
			if( (fireRole && !sightinfo->isRoleInSight(fireRole)) || 
				(!fireRole && !sightinfo->isItemInSight(m_hitParam->m_fireItem.get())))
			{
				int playerid = m_hitParam->m_hitItem->getID();
				crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
				ref_ptr<crSceneServerPlayerData> playerdata = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
				if(playerdata.valid())
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(16);
					stream->_writeFloat(m_hitParam->m_fireItem->getPosx());
					stream->_writeFloat(m_hitParam->m_fireItem->getPosy());
					stream->_writeFloat(m_hitParam->m_fireItem->getPosz());
					stream->_writeInt(m_hitParam->m_fireItem->getInstanceItemID());
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid, WCH_JXJNotInSightMsgData, stream.get());
					sceneServer->getNetManager()->sendPacket(playerdata->getPlayerConnectServerAddress(),packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAttackExtraTestMethod
//
/////////////////////////////////////////
crJXJAttackExtraTestMethod::crJXJAttackExtraTestMethod():
	m_this(NULL),
	m_hitParam(NULL),
	m_damage(0.0f){}
crJXJAttackExtraTestMethod::crJXJAttackExtraTestMethod(const crJXJAttackExtraTestMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_hitParam(NULL),
	m_damage(0.0f)
{
}
void crJXJAttackExtraTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
			m_damage = *(float *)(HIINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
			m_damage = 0.0f;
		}
		break;
	}
}
void crJXJAttackExtraTestMethod::addParam(int i, const std::string& str)
{
}
void crJXJAttackExtraTestMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_EquipOnMap,param);
	EquipOnMap equipOnMap = *(EquipOnMap *)param;
	//data->excHandle(MAKEINT64(WCH_LockData,0));
	crItemChild *itemChild;
	crInstanceItem *equip;
	for( EquipOnMap::iterator itr = equipOnMap.begin();
		itr != equipOnMap.end();
		++itr )
	{
		itemChild = m_this->findChildItem(itr->second);
		if(itemChild && itemChild->isLoaded())
		{
			equip = itemChild->getInstanceItem();
			equip->doEvent(WCH_AttackExtraTest,MAKEINT64(m_hitParam.get(),&m_damage));
		}
	}
}
/////////////////////////////////////////
//
//crJXJSkillExtraTestMethod
//
/////////////////////////////////////////
crJXJSkillExtraTestMethod::crJXJSkillExtraTestMethod():
	m_this(NULL),
	m_hitParam(NULL){}
crJXJSkillExtraTestMethod::crJXJSkillExtraTestMethod(const crJXJSkillExtraTestMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_hitParam(NULL)
{
}
void crJXJSkillExtraTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
			m_damage = *(float *)(HIINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
			m_damage = 0.0f;
		}
		break;
	}
}
void crJXJSkillExtraTestMethod::addParam(int i, const std::string& str)
{
}
void crJXJSkillExtraTestMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_EquipOnMap,param);
	EquipOnMap equipOnMap = *(EquipOnMap *)param;
	//data->excHandle(MAKEINT64(WCH_LockData,0));
	crItemChild *itemChild;
	crInstanceItem *equip;
	for( EquipOnMap::iterator itr = equipOnMap.begin();
		itr != equipOnMap.end();
		++itr )
	{
		itemChild = m_this->findChildItem(itr->second);
		if(itemChild && itemChild->isLoaded())
		{
			equip = itemChild->getInstanceItem();
			equip->doEvent(WCH_SkillExtraTest,MAKEINT64(m_hitParam.get(),&m_damage));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraTestMethod
//
/////////////////////////////////////////
crJXJExtraTestMethod::crJXJExtraTestMethod():
	m_this(NULL),
	m_hitParam(NULL),
	m_msg(WCH_UseSkillExtraTest){}
crJXJExtraTestMethod::crJXJExtraTestMethod(const crJXJExtraTestMethod& handle):
	crMethod(handle),
	m_msg(handle.m_msg),
	m_this(NULL),
	m_hitParam(NULL)
{
}
void crJXJExtraTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJExtraTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msg = atoi(str.c_str());
		break;
	}
}
void crJXJExtraTestMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_EquipOnMap,param);
	EquipOnMap equipOnMap = *(EquipOnMap *)param;
	//data->excHandle(MAKEINT64(WCH_LockData,0));
	crItemChild *itemChild;
	crInstanceItem *equip;
	for( EquipOnMap::iterator itr = equipOnMap.begin();
		itr != equipOnMap.end();
		++itr )
	{
		itemChild = m_this->findChildItem(itr->second);
		if(itemChild && itemChild->isLoaded())
		{
			equip = itemChild->getInstanceItem();
			equip->doEvent(WCH_USER+m_msg,MAKEINT64(m_hitParam.get(),NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJEquipAttackExtraTestMethod
//
/////////////////////////////////////////
crJXJEquipAttackExtraTestMethod::crJXJEquipAttackExtraTestMethod():
	m_hitrate(10){}
crJXJEquipAttackExtraTestMethod::crJXJEquipAttackExtraTestMethod(const crJXJEquipAttackExtraTestMethod& handle):
	crMethod(handle),
	m_hitrate(handle.m_hitrate)
{
}
void crJXJEquipAttackExtraTestMethod::inputParam(int i, void *param)
{
}
void crJXJEquipAttackExtraTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_hitrate = atoi(str.c_str());
		break;
	}
}
void crJXJEquipAttackExtraTestMethod::operator()(crHandle &handle)
{
	bool valid = CRCore::rangei(0,100).get_random()<m_hitrate;
	handle.outputParam(0,&valid);
}
/////////////////////////////////////////
//
//crJXJHitExtraTestMethod
//
/////////////////////////////////////////
crJXJHitExtraTestMethod::crJXJHitExtraTestMethod():
	m_this(NULL),
	m_hitParam(NULL),
	m_msg(340),
	m_damage(0.0f){}
crJXJHitExtraTestMethod::crJXJHitExtraTestMethod(const crJXJHitExtraTestMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_hitParam(NULL),
	m_msg(handle.m_msg),
	m_damage(0.0f)
{
}
void crJXJHitExtraTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
			m_damage = *(float *)(HIINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
			m_damage = 0.0f;
		}
		break;
	}
}
void crJXJHitExtraTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msg = atoi(str.c_str());
		break;
	}
}
void crJXJHitExtraTestMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_EquipOnMap,param);
	EquipOnMap equipOnMap = *(EquipOnMap *)param;
	//data->excHandle(MAKEINT64(WCH_LockData,0));
	crItemChild *itemChild;
	crInstanceItem *equip;
	m_hitParam->m_fireItem.swap(m_hitParam->m_hitItem);
	for( EquipOnMap::iterator itr = equipOnMap.begin();
		itr != equipOnMap.end();
		++itr )
	{
		itemChild = m_this->findChildItem(itr->second);
		if(itemChild && itemChild->isLoaded())
		{
			equip = itemChild->getInstanceItem();
			equip->doEvent(WCH_USER+m_msg,MAKEINT64(m_hitParam.get(),&m_damage));
		}
	}
	m_hitParam->m_fireItem.swap(m_hitParam->m_hitItem);
}
/////////////////////////////////////////
//
//crJXJDicesMethod
//
/////////////////////////////////////////
crJXJDicesMethod::crJXJDicesMethod():
	m_rate(10){}
crJXJDicesMethod::crJXJDicesMethod(const crJXJDicesMethod& handle):
	crMethod(handle),
	m_rate(handle.m_rate)
{
}
void crJXJDicesMethod::inputParam(int i, void *param)
{
}
void crJXJDicesMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rate = atoi(str.c_str());
		break;
	}
}
void crJXJDicesMethod::operator()(crHandle &handle)
{
	bool valid = CRCore::rangei(0,100).get_random()<m_rate;
	handle.outputParam(0,&valid);
}
/////////////////////////////////////////
//
//crJXJSkillDamageMethod
//
/////////////////////////////////////////
crJXJSkillDamageMethod::crJXJSkillDamageMethod():
	m_sputteringmode(0),
	m_sputteringrange(0),
	m_sputteringparam(0){}
crJXJSkillDamageMethod::crJXJSkillDamageMethod(const crJXJSkillDamageMethod& handle):
	crMethod(handle),
	m_sputteringmode(handle.m_sputteringmode),
	m_sputteringrange(handle.m_sputteringrange),
	m_sputteringparam(handle.m_sputteringparam)
{
}
void crJXJSkillDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJSkillDamageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sputteringmode = atoi(str.c_str());
		break;
	case 1:
		m_sputteringrange = atoi(str.c_str());
		break;
	case 2:
		m_sputteringparam = atof(str.c_str());
		break;
	}
}
void crJXJSkillDamageMethod::operator()(crHandle &handle)
{
	if(m_hitParam.valid() && m_hitParam->m_fireItem.valid() && m_hitParam->m_hitItem.valid())
	{
		void *param;
		crData *hitData = m_hitParam->m_hitItem->getDataClass();
		hitData->getParam(WCHDATA_ArmourType,param);
		unsigned char armourType = *(unsigned char *)param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_DamageType,param);
		unsigned char damageType = *(unsigned char *)param;
		if(damageType == Damage_Skill && armourType == Armour_Build)
		{
			return;
		}

		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Damage,param);
		float fireDamage = *((int*)param);

		data->getParam(WCHDATA_JXJPercentDamage,param);
		unsigned short percentDamage = *((unsigned short*)param);
		if(percentDamage>0)
		{
			float fpercentDamage = (float)percentDamage * 0.001f;
			float attackDamage = 0.0f;
			m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetDamage,0),MAKEINT64(&attackDamage,NULL));
			crData *fireData = m_hitParam->m_fireItem->getDataClass();
			////////计算伤害
			fireData->getParam(WCHDATA_JXJRTArmyCount,param);
			float armcount = *(/*unsigned short*/int *)param;
			fireData->getParam(WCHDATA_JXJArmyCount,param);
			float maxarmcount = *(/*unsigned short*/int *)param;
			attackDamage *= fpercentDamage * (armcount+maxarmcount)/2.0f;
			fireDamage+=attackDamage;
		}
		//fireDamage *= m_hitParam->m_rate;
		if(fireDamage>0.0f)
		{//目标反弹法伤
			float damageback = 0.0f;
			m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetSkillDamageBack,0),MAKEINT64(&damageback,NULL));
			damageback = fireDamage * damageback;
			if(damageback>0)
			{//攻击者受到伤害
				DamagePair dp(damageback,std::make_pair(SkillDM,0));
				m_hitParam->m_fireItem->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_hitItem.get()));
			}
		}
		//魔防减免
		float hitDefend = 0.0f;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetDefend,1),MAKEINT64(&hitDefend,NULL));
		//法防忽视
		float ignoreDefend = 0.0f;
		m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetIgnoreDefend,1),MAKEINT64(&ignoreDefend,NULL));
		hitDefend *= (1.0f - ignoreDefend);
		if(hitDefend<0.0f)
			hitDefend = 0.0f;

		crVector4 damageParam;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJDamageParam, 0),damageParam);
		float damage = fireDamage * (1.0f - (CRCore::minimum(damageParam[0],hitDefend/(hitDefend+damageParam[1]))));
		unsigned int guisestate = GS_Normal;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		float adddamage = 0.0f;
		m_hitParam->m_hitItem->doEvent(MAKEINT64(WCH_GetSkillDamage,0),MAKEINT64(&adddamage,NULL));
		if(guisestate & GS_Nihility)
			damage *= 1.4f+adddamage;//虚无状态加40%的魔法伤害
		else
			damage *= 1.0f+adddamage;
		if(damage>0.0f)
		{
			float absorbHP = 0.0f;
			m_hitParam->m_fireItem->doEvent(MAKEINT64(WCH_GetSkillAbsorbHP,0),MAKEINT64(&absorbHP,NULL));
			absorbHP = damage * absorbHP; 
			if(absorbHP>0.0f)
			{
				m_hitParam->m_fireItem->doEvent(WCH_CureHP,MAKEINT64(&absorbHP,NULL/*m_hitParam->m_hitItem.get()*/));
			}
			if(m_sputteringmode>0)
			{//////////溅射
				float range = (float)(m_sputteringrange) * crGlobalHandle::gData()->gUnitScale();
				//float sputteringdm = damage * (float)damagepercent * 0.001f;
				ref_ptr<crSightInfo> hitSight = m_hitParam->m_hitItem->getSightInfo();
				if(hitSight.valid())
				{
					std::vector< ref_ptr<crInstanceItem> > SPItemVec;
					crVector3 hitpos = m_hitParam->m_hitItem->getPosition();
					crVector3 itempos;
					ref_ptr<crInstanceItem> item;
					ref_ptr<crData> itemData;
					unsigned char itemstate;
					unsigned int guisestate = GS_Normal;

					hitSight->lockItemEyeMap();
					crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
					for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
						itr != itemEyeMap.end();
						++itr )
					{
						item = itr->second;
						if(m_hitParam->m_hitItem != item)
						{
							itemData = item->getDataClass();
							if(itemData.valid())
							{
								itemData->getParam(WCHDATA_ItemState,param);
								itemstate = *(unsigned char *)param;
								if(itemstate == IS_Dead)
									continue;
							}
							guisestate = GS_Normal;
							item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
							if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
								guisestate & GS_Stagnate || guisestate & GS_immunoSkill || guisestate & GS_NoAttack )
							{
								continue;
							}
							itempos = item->getPosition();
							if((itempos - hitpos).length() < range)
							{
								SPItemVec.push_back(item);
							}
						}
					}
					hitSight->unlockItemEyeMap();

					ref_ptr<crSceneServerPlayerData> playerdata;
					hitSight->lockPlayerEyeMap();
					crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
					for( crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
						itr != playerEyeMap.end();
						++itr )
					{
						playerdata = itr->second;
						crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
						for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
							ritr != roleMap.end();
							++ritr )
						{
							item = dynamic_cast<crInstanceItem *>(ritr->second.get());
							if(m_hitParam->m_hitItem != item)
							{
								itemData = item->getDataClass();
								if(itemData.valid())
								{
									itemData->getParam(WCHDATA_ItemState,param);
									itemstate = *(unsigned char *)param;
									if(itemstate == IS_Dead)
										continue;
								}
								guisestate = GS_Normal;
								item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
								if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
									guisestate & GS_Stagnate || guisestate & GS_immunoSkill || guisestate & GS_NoAttack )
								{
									continue;
								}
								itempos = item->getPosition();
								if((itempos - hitpos).length() < range)
								{
									SPItemVec.push_back(item);
								}
							}
						}
					}
					hitSight->unlockPlayerEyeMap();

					if(!SPItemVec.empty())
					{
						switch (m_sputteringmode)
						{
						case 1://1分摊溅射
							{
								damage /= (float)(SPItemVec.size()+1);
								DamagePair dp(damage,std::make_pair(SkillDM,0));
								for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
									itr != SPItemVec.end();
									++itr )
								{
									//totaldamage += sputteringdm;
									(*itr)->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_fireItem.get()));
								}
							}
							break;
						case 2://2衰减溅射
							{
								float sputteringdm = damage * (float)m_sputteringparam * 0.01f;
								DamagePair dp(sputteringdm,std::make_pair(SkillDM,0));
								for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
									itr != SPItemVec.end();
									++itr )
								{
									//totaldamage += sputteringdm;
									(*itr)->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_fireItem.get()));
								}
							}
							break;
						case 3://3概率溅射
							{
								DamagePair dp(damage,std::make_pair(SkillDM,0));
								for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
									itr != SPItemVec.end();
									++itr )
								{
									//totaldamage += sputteringdm;
									if(CRCore::rangei(0,100).get_random()<m_sputteringparam)
										(*itr)->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_fireItem.get()));
								}
							}
							break;
						}
					}
				}
			}
			DamagePair dp(damage,std::make_pair(SkillDM,0));
			m_hitParam->m_hitItem->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_hitParam->m_fireItem.get()));
			m_hitParam->m_fireItem->doEvent(WCH_SkillExtraTest,MAKEINT64(m_hitParam.get(),&damage));
			m_hitParam->m_hitItem->doEvent(WCH_SkillHitExtraTest,MAKEINT64(m_hitParam.get(),&damage));
		}
	}
}
/////////////////////////////////////////
//
//crJXJTargetExtraMethod
//
/////////////////////////////////////////
crJXJTargetExtraMethod::crJXJTargetExtraMethod(){}
crJXJTargetExtraMethod::crJXJTargetExtraMethod(const crJXJTargetExtraMethod& handle):
	crMethod(handle)
{
}
void crJXJTargetExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJTargetExtraMethod::addParam(int i, const std::string& str)
{
}
void crJXJTargetExtraMethod::operator()(crHandle &handle)
{
	if(m_hitParam.valid() && m_hitParam->m_fireItem.valid() && m_hitParam->m_hitItem.valid())
	{
		///TargetExtra
		void *param;
		crData *hitData = m_hitParam->m_hitItem->getDataClass();
		hitData->getParam(WCHDATA_ExtraData,param);
		crData *extraData = (crData *)param;
		if(extraData)
		{
			crData *bulletData = m_this->getDataClass();
			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_TargetExtra,WCH_Server));
			if(handle)
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
				if(scene)
				{
					crVector3 targetPos = m_hitParam->m_hitItem->getPosition();
					bulletData->getParam(WCHDATA_TargetExtraID,param);
					_crInt32 targetExtraID = *((_crInt32*)param);
					bulletData->getParam(WCHDATA_JXJTargetOverlapMaxCount,param);
					char maxOverlapCount = *((char*)param);

					char can = 1;//0：不能，1：可以，2：修改叠加数量
					short extraid = LOINT32(targetExtraID);
					short extrapri = HIINT32(targetExtraID);
					extraData->excHandle(MAKEINT64(WCH_LockData,1));
					extraData->getParam(WCHDATA_ExtraIDMap,param);
					ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
					ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
					_crInt8 overlapCount = 0;
					if(exitr != extraIDMap->end())
					{
						if(extrapri<HIINT16(exitr->second))
						{
							can = 0;
						}
						else if(extrapri == HIINT16(exitr->second))
						{
							can = 2;
							overlapCount = LOINT16(exitr->second);
							if(overlapCount<maxOverlapCount-1)
								overlapCount++;
						}
					}
					if(can==1)
					{
						crHandle *cloneHandle = handle->clone();
						cloneHandle->inputParam(WCHDATA_FireItem,m_hitParam->m_fireItem.get());
						short count = (short)overlapCount+1;
						cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
						cloneHandle->inputParam(WCHDATA_JXJItemUseTargetPos,&targetPos);
						extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
						(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
					}
					else if(can==2)
					{
						crHandle *cloneHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
						if(!cloneHandle)
						{
							cloneHandle = handle->clone();
							extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
						}
						cloneHandle->inputParam(WCHDATA_FireItem,m_hitParam->m_fireItem.get());
						short count = (short)overlapCount+1;
						cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
						cloneHandle->inputParam(WCHDATA_JXJItemUseTargetPos,&targetPos);
						(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
					}
					extraData->excHandle(MAKEINT64(WCH_LockData,0));
					//crHandle *cloneHandle = handle->clone();
					//cloneHandle->inputParam(WCHDATA_FireItem,m_hitParam->m_fireItem.get());
					//extraData->insertHandle(MAKEINT64(WCH_DoExtra,targetExtraID),cloneHandle);
					if(can>0)
					{
						//send packet to hititem及其附近
						unsigned char hittype = m_hitParam->m_hitItem->getItemtype();
						unsigned char firetype = m_hitParam->m_fireItem->getItemtype();
						int fireid = m_hitParam->m_fireItem->getID();
						int fireroleid = m_hitParam->m_fireItem->getRoleID();
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(14);
						stream->_writeUChar(firetype);
						stream->_writeInt(fireid);
						if(firetype == crInstanceItem::Role)
							stream->_writeInt(fireroleid);
						stream->_writeInt(m_this->getInstanceItemID());
						stream->_writeChar(overlapCount);
						if(hittype == crInstanceItem::Role)
						{
							int hitid = m_hitParam->m_hitItem->getID();
							//int hitroleid = m_hitParam->m_hitItem->getRoleID();
							crPlayerEventPacket packet;
							crPlayerEventPacket::buildRequestPacket(packet,hitid,m_hitParam->m_hitItem.get(),WCH_RecvTargetExtra,stream.get());
							ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
							if(hitPlayerData.valid())
							{
								sceneServerConductor->getNetManager()->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
							}
							scene->sendPacketToItemNeighbor(m_hitParam->m_hitItem.get(),packet);
						}
						else
						{
							crItemEventPacket packet;
							crItemEventPacket::buildRequestPacket(packet,0,m_hitParam->m_hitItem.get(),WCH_RecvTargetExtra,stream.get());

							scene->sendPacketToItemNeighbor(m_hitParam->m_hitItem.get(),packet);
						}
						//crAddTargetExtraPacket packet;
						//crAddTargetExtraPacket::buildRequestPacket(packet,hitid,hittype,hitid,fireType,fireID,bulletItemID);
						//if(hittype == crInstanceItem::Role)
						//{
						//	crSceneServerPlayerData *hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
						//	sceneServerConductor->getNetManager()->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
						//	hitPlayerData->sendPacketToNeighbor(packet);
						//}
						//else
						//{
						//	netCallback->sendPacketToItemNeighbor(m_this,packet);
						//}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUserExtraMethod
//
/////////////////////////////////////////
crJXJUserExtraMethod::crJXJUserExtraMethod(){}
crJXJUserExtraMethod::crJXJUserExtraMethod(const crJXJUserExtraMethod& handle):
	crMethod(handle)
{
}
void crJXJUserExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJUserExtraMethod::addParam(int i, const std::string& str)
{
}
void crJXJUserExtraMethod::operator()(crHandle &handle)
{
	if(m_hitParam.valid() && m_hitParam->m_fireItem.valid()/* && m_hitParam->m_hitItem.valid()*/)
	{
		///UserExtra
		void *param;
		crData *fireData = m_hitParam->m_fireItem->getDataClass();
		fireData->getParam(WCHDATA_ExtraData,param);
		crData *extraData = (crData *)param;
		if(extraData)
		{
			crData *bulletData = m_this->getDataClass();
			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Server));
			if(handle)
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
				if(scene)
				{
					crVector3 targetPos = m_hitParam->m_fireItem->getPosition();
					bulletData->getParam(WCHDATA_UserExtraID,param);
					_crInt32 userExtraID = *((_crInt32*)param);
					bulletData->getParam(WCHDATA_JXJUserOverlapMaxCount,param);
					char maxOverlapCount = *((char*)param);

					char can = 1;//0：不能，1：可以，2：修改叠加数量
					short extraid = LOINT32(userExtraID);
					short extrapri = HIINT32(userExtraID);
					extraData->excHandle(MAKEINT64(WCH_LockData,1));
					extraData->getParam(WCHDATA_ExtraIDMap,param);
					ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
					ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
					_crInt8 overlapCount = 0;
					if(exitr != extraIDMap->end())
					{
						if(extrapri<HIINT16(exitr->second))
						{
							can = 0;
						}
						else if(extrapri == HIINT16(exitr->second))
						{
							can = 2;
							overlapCount = LOINT16(exitr->second);
							if(overlapCount<maxOverlapCount-1)
								overlapCount++;
						}
					}
					if(can==1)
					{
						crHandle *cloneHandle = handle->clone();
						cloneHandle->inputParam(WCHDATA_FireItem,m_hitParam->m_fireItem.get());
						short count = (short)overlapCount+1;
						cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
						cloneHandle->inputParam(WCHDATA_JXJItemUseTargetPos,&targetPos);
						extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
						//(*extraIDMap)[extraid] = extrapri;
						(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
					}
					else if(can==2)
					{
						crHandle *cloneHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
						if(!cloneHandle)
						{
							cloneHandle = handle->clone();
							extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
						}
						cloneHandle->inputParam(WCHDATA_FireItem,m_hitParam->m_fireItem.get());
						short count = (short)overlapCount+1;
						cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
						cloneHandle->inputParam(WCHDATA_JXJItemUseTargetPos,&targetPos);
						(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
					}
					extraData->excHandle(MAKEINT64(WCH_LockData,0));

					if(can>0)
					{
						unsigned char firetype = m_hitParam->m_fireItem->getItemtype();
						int fireid = m_hitParam->m_fireItem->getID();
						//int fireroleid = m_hitParam->m_fireItem->getRoleID();
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(5);
						stream->_writeInt(m_this->getInstanceItemID());
						stream->_writeChar(overlapCount);
						if(firetype == crInstanceItem::Role)
						{
							crPlayerEventPacket packet;
							crPlayerEventPacket::buildRequestPacket(packet,fireid,m_hitParam->m_fireItem.get(),WCH_RecvUserExtra,stream.get());
							ref_ptr<crSceneServerPlayerData> firePlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(fireid));
							if(firePlayerData.valid())
							{
								sceneServerConductor->getNetManager()->sendPacket(firePlayerData->getPlayerConnectServerAddress(),packet);
							}
							scene->sendPacketToItemNeighbor(m_hitParam->m_fireItem.get(),packet);

						}
						else
						{
							crItemEventPacket packet;
							crItemEventPacket::buildRequestPacket(packet,0,m_hitParam->m_fireItem.get(),WCH_RecvUserExtra,stream.get());

							scene->sendPacketToItemNeighbor(m_hitParam->m_fireItem.get(),packet);
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraHandleMethod
//
/////////////////////////////////////////
crJXJExtraHandleMethod::crJXJExtraHandleMethod():
	m_extid(0),
	m_extparam(0){}
crJXJExtraHandleMethod::crJXJExtraHandleMethod(const crJXJExtraHandleMethod& handle):
	crMethod(handle),
	m_extid(0),
	m_extparam(0)
{
}
void crJXJExtraHandleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			_crInt32 lo64 = LOINT64(param64);
			m_extid = LOINT32(lo64);
			m_extparam = HIINT32(lo64);
			m_fireItem = (crInstanceItem *)HIINT64(param64);
		}
		else
		{
			m_extid = NULL;
			m_extparam = NULL;
			m_fireItem = NULL;
		}
		break;
	}
}
void crJXJExtraHandleMethod::addParam(int i, const std::string& str)
{
}
void crJXJExtraHandleMethod::operator()(crHandle &handle)
{
	if(m_extid!=0)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_ExtraData,param);
		crData *extraData = (crData *)param;
		short eraseID = 0;
		switch (m_extid)
		{
		case JXJExt_Inspire_2:
			eraseID = JXJExt_Inspire;
			break;
		case JXJExt_Inspire_3:
			eraseID = JXJExt_Inspire_2;
			break;
		case JXJExt_Inspire_4:
			eraseID = JXJExt_Inspire_3;
			break;
		case JXJExt_Inspire_5:
			eraseID = JXJExt_Inspire_4;
			break;
		case JXJExt_Inspire_6:
			eraseID = JXJExt_Inspire_5;
			break;
		case JXJExt_Inspire_7:
			eraseID = JXJExt_Inspire_6;
			break;
		case JXJExt_Inspire_8:
			eraseID = JXJExt_Inspire_7;
			break;
		case JXJExt_Inspire_9:
			eraseID = JXJExt_Inspire_8;
			break;
		case JXJExt_Inspire_10:
			eraseID = JXJExt_Inspire_9;
			break;
		case JXJExt_Inspire_11:
			eraseID = JXJExt_Inspire_10;
			break;
		case JXJExt_Inspire_12:
			eraseID = JXJExt_Inspire_11;
			break;
		case JXJExt_Inspire_13:
			eraseID = JXJExt_Inspire_12;
			break;
		case JXJExt_Inspire_14:
			eraseID = JXJExt_Inspire_13;
			break;
		case JXJExt_Inspire_15:
			eraseID = JXJExt_Inspire_14;
			break;
		}
		if(extraData && !extraData->getHandle(MAKEINT64(WCH_DoExtra,m_extid)))
		{
			crHandle *handle = data->getHandle(MAKEINT64(WCH_ServerExtraHandle,m_extid));
			if(handle)
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
				if(scene)
				{
					extraData->excHandle(MAKEINT64(WCH_LockData,1));
					crHandle *cloneHandle = handle->clone();
					cloneHandle->inputParam(WCHDATA_FireItem,m_fireItem.get());
					cloneHandle->inputParam(WCHDATA_ExtraParam,&m_extparam);
					extraData->insertHandle(MAKEINT64(WCH_DoExtra,m_extid),cloneHandle);
					extraData->getParam(WCHDATA_ExtraIDMap,param);
					ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
					(*extraIDMap)[m_extid] = 0;
					if(eraseID!=0)
					{
						extraIDMap->erase(eraseID);
					}
					extraData->excHandle(MAKEINT64(WCH_LockData,0));

					if(m_extid != Ext_TrueSight)
					{//真视不需要发包
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(13);
						stream->_writeShort(m_extid);
						stream->_writeShort(m_extparam);
						if(m_fireItem.valid())
						{//////////
							unsigned char hittype = m_fireItem->getItemtype();
							unsigned char firetype = m_fireItem->getItemtype();
							int fireid = m_fireItem->getID();
							int fireroleid = m_fireItem->getRoleID();
							stream->_writeUChar(firetype);
							stream->_writeInt(fireid);
							if(firetype == crInstanceItem::Role)
								stream->_writeInt(fireroleid);
						}
						if(m_this->getItemtype() == crInstanceItem::Role)
						{
							int playerid = m_this->getID();
							//int roleid = m_this->getRoleID();
							crPlayerEventPacket packet;
							crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvExtraHandle,stream.get());
							ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
							if(playerData.valid())
							{
								sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							}
							scene->sendPacketToItemNeighbor(m_this,packet);
						}
						else
						{
							crItemEventPacket packet;
							crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvExtraHandle,stream.get());
							scene->sendPacketToItemNeighbor(m_this,packet);
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvExtraHandleMethod
//
/////////////////////////////////////////
crJXJRecvExtraHandleMethod::crJXJRecvExtraHandleMethod(){}
crJXJRecvExtraHandleMethod::crJXJRecvExtraHandleMethod(const crJXJRecvExtraHandleMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvExtraHandleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvExtraHandleMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvExtraHandleMethod::operator()(crHandle &handle)
{
	if(m_stream.valid() && crRunGameHandle::getInstance()->getRunningCode() == crRunGameHandle::NetGame)
	{
		short extid = m_stream->_readShort();
		if(extid!=0)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_ExtraData,param);
			crData *extraData = (crData *)param;

			short eraseID = 0;
			switch (extid)
			{
			case JXJExt_Inspire_2:
				eraseID = JXJExt_Inspire;
				break;
			case JXJExt_Inspire_3:
				eraseID = JXJExt_Inspire_2;
				break;
			case JXJExt_Inspire_4:
				eraseID = JXJExt_Inspire_3;
				break;
			case JXJExt_Inspire_5:
				eraseID = JXJExt_Inspire_4;
				break;
			case JXJExt_Inspire_6:
				eraseID = JXJExt_Inspire_5;
				break;
			case JXJExt_Inspire_7:
				eraseID = JXJExt_Inspire_6;
				break;
			case JXJExt_Inspire_8:
				eraseID = JXJExt_Inspire_7;
				break;
			case JXJExt_Inspire_9:
				eraseID = JXJExt_Inspire_8;
				break;
			case JXJExt_Inspire_10:
				eraseID = JXJExt_Inspire_9;
				break;
			case JXJExt_Inspire_11:
				eraseID = JXJExt_Inspire_10;
				break;
			case JXJExt_Inspire_12:
				eraseID = JXJExt_Inspire_11;
				break;
			case JXJExt_Inspire_13:
				eraseID = JXJExt_Inspire_12;
				break;
			case JXJExt_Inspire_14:
				eraseID = JXJExt_Inspire_13;
				break;
			case JXJExt_Inspire_15:
				eraseID = JXJExt_Inspire_14;
				break;
			}

			if(extraData)
			{
				crHandle *handle = data->getHandle(MAKEINT64(WCH_ClientExtraHandle,extid));
				if(handle)
				{
					short extparam = m_stream->_readShort();
					ref_ptr<crInstanceItem> fireItem;
					if(!m_stream->eof())
					{
						unsigned char firetype = m_stream->_readUChar();
						int fireid = m_stream->_readInt();
						int fireroleid = firetype == crInstanceItem::Role?m_stream->_readInt():0;

						if(firetype == crInstanceItem::Role)
						{
							if(fireid == crMyPlayerData::getInstance()->getPlayerID())
							{
								fireItem = crMyPlayerData::getInstance()->getRole(fireroleid);
							}
							else
							{
								crMyPlayerData::RoleNpcPair roleNpcPair;
								if(crMyPlayerData::getInstance()->findInRangePlayer(fireid,fireroleid,roleNpcPair))
								{
									fireItem = roleNpcPair.first.get();
								}
								else if(crMyPlayerData::getInstance()->findOutRangePlayer(fireid,fireroleid,roleNpcPair))
								{
									fireItem = roleNpcPair.first.get();
								}
							}
						}
						else if(firetype == crInstanceItem::Npc)
						{
							crMyPlayerData::ItemNpcPair itemNpcPair;
							if(crMyPlayerData::getInstance()->findInRangeNpc(fireid,itemNpcPair))
							{
								fireItem = itemNpcPair.first.get();
							}
							else if(crMyPlayerData::getInstance()->findOutRangeNpc(fireid,itemNpcPair))
							{
								fireItem = itemNpcPair.first.get();
							}
						}
						else
						{
							crMyPlayerData::ItemNodePair itemNodePair;
							if(crMyPlayerData::getInstance()->findInRangeItem(fireid,itemNodePair))
							{
								fireItem = itemNodePair.first.get();
							}
							else if(crMyPlayerData::getInstance()->findOutRangeItem(fireid,itemNodePair))
							{
								fireItem = itemNodePair.first.get();
							}
						}
					}
					extraData->excHandle(MAKEINT64(WCH_LockData,1));

					extraData->getParam(WCHDATA_ExtraIDMap,param);
					ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
					(*extraIDMap)[extid] = 0;  
					if(eraseID!=0)
					{
						crHandle *handle = extraData->getHandle(MAKEINT64(WCH_DoExtra,eraseID));
						if(handle)
							handle->releaseObjects(NULL);
						extraIDMap->erase(eraseID);
					}
					crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extid));
					if(existhandle)
					{
						existhandle->releaseObjects(NULL);
					}
					crHandle *cloneHandle = handle->clone();
					cloneHandle->inputParam(WCHDATA_FireItem,fireItem.get());
					cloneHandle->inputParam(WCHDATA_ExtraParam,&extparam);
					extraData->insertHandle(MAKEINT64(WCH_DoExtra,extid),cloneHandle);

					extraData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvTargetExtraMethod
//
/////////////////////////////////////////
crJXJRecvTargetExtraMethod::crJXJRecvTargetExtraMethod(){}
crJXJRecvTargetExtraMethod::crJXJRecvTargetExtraMethod(const crJXJRecvTargetExtraMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvTargetExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTargetExtraMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvTargetExtraMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();

		unsigned char firetype = m_stream->_readUChar();
		int fireid = m_stream->_readInt();
		int fireroleid = firetype == crInstanceItem::Role?m_stream->_readInt():0;
		int bulletitemid = m_stream->_readInt();
		_crInt8 overlapCount = m_stream->_readChar();

		ref_ptr<crInstanceItem> fireItem;
		if(firetype == crInstanceItem::Role)
		{
			if(fireid == crMyPlayerData::getInstance()->getPlayerID())
			{
				fireItem = crMyPlayerData::getInstance()->getRole(fireroleid);
			}
			else
			{
				crMyPlayerData::RoleNpcPair roleNpcPair;
				if(crMyPlayerData::getInstance()->findInRangePlayer(fireid,fireroleid,roleNpcPair))
				{
					fireItem = roleNpcPair.first.get();
				}
				else if(crMyPlayerData::getInstance()->findOutRangePlayer(fireid,fireroleid,roleNpcPair))
				{
					fireItem = roleNpcPair.first.get();
				}
			}
		}
		else if(firetype == crInstanceItem::Npc)
		{
			crMyPlayerData::ItemNpcPair itemNpcPair;
			if(crMyPlayerData::getInstance()->findInRangeNpc(fireid,itemNpcPair))
			{
				fireItem = itemNpcPair.first.get();
			}
			else if(crMyPlayerData::getInstance()->findOutRangeNpc(fireid,itemNpcPair))
			{
				fireItem = itemNpcPair.first.get();
			}
		}
		else
		{
			crMyPlayerData::ItemNodePair itemNodePair;
			if(crMyPlayerData::getInstance()->findInRangeItem(fireid,itemNodePair))
			{
				fireItem = itemNodePair.first.get();
			}
			else if(crMyPlayerData::getInstance()->findOutRangeItem(fireid,itemNodePair))
			{
				fireItem = itemNodePair.first.get();
			}
		}
		do 
		{
			if(!fireItem.valid()) break;
			crItemChild *itemChild = fireItem->findChildItem(bulletitemid);
			if(!itemChild || !itemChild->isLoaded()) break;
			crInstanceItem *bulletitem = itemChild->getInstanceItem();
			if(!bulletitem) break;

			void *param;
			crData *bulletData = bulletitem->getDataClass();
			if(!bulletData) break;
			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_TargetExtra,WCH_Client));
			if(!handle) break;

			bulletData->getParam(WCHDATA_TargetExtraID,param);
			_crInt32 targetExtraID = *((_crInt32*)param);
			// 			bulletData->getParam(WCHDATA_JXJTargetOverlapMaxCount,param);
			// 			char maxOverlapCount = *((char*)param);
			//crRole *myrole = crMyPlayerData::getInstance()->getLoadedRoleByIndex(0);
			//if(myrole && myrole->getDataClass())
			//{//缓存bufhandle
			//	crData *myroledata = myrole->getDataClass();
			//	crHandle *existhandle = myroledata->getHandle(MAKEINT64(WCH_ClientExtraHandle,targetExtraID));
			//	if(!existhandle)
			//	{
			//		myroledata->insertHandle(MAKEINT64(WCH_ClientExtraHandle,targetExtraID),handle->clone());
			//	}
			//}

			crData *hitData = m_this->getDataClass();
			//hitData->excHandle(MAKEINT64(WCH_LockData,1));
			hitData->getParam(WCHDATA_ExtraData,param);
			crData *extraData = (crData *)param;
			if(extraData)
			{
				//extraData->insertHandle(MAKEINT64(WCH_DoExtra,targetExtraID),cloneHandle);
				//extraData->inputParam(WCHDATA_ExtraIDSet,&targetExtraID);
				char can = 1;//0：不能，1：可以，2：修改叠加数量
				short extraid = LOINT32(targetExtraID);
				short extrapri = HIINT32(targetExtraID);
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
				ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
				if(exitr != extraIDMap->end())
				{
					if(extrapri<HIINT16(exitr->second))
					{
						can = 0;
					}
					else if(extrapri == HIINT16(exitr->second))
					{
						can = 2;
					}
				}
				if(can>0)
				{
					ref_ptr<crHandle> cloneHandle;
					if(can==2)
						cloneHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
					else if(can==1)
					{
						crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
						if(existhandle)
						{
							existhandle->releaseObjects(NULL);
						}
					}
					if(!cloneHandle)
					{
						cloneHandle = handle->clone();
						extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle.get());
					}
					crVector3 dir = m_this->getPosition() - fireItem->getPosition();
					dir.normalize();
					cloneHandle->inputParam(WCHDATA_AttachDir,&dir);
					cloneHandle->inputParam(WCHDATA_FireItem,fireItem.get());
					short count = (short)overlapCount+1;
					cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
					(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			//hitData->excHandle(MAKEINT64(WCH_LockData,0));
		} while (0);
	}
}
/////////////////////////////////////////
//
//crJXJRecvUserExtraMethod
//
/////////////////////////////////////////
crJXJRecvUserExtraMethod::crJXJRecvUserExtraMethod(){}
crJXJRecvUserExtraMethod::crJXJRecvUserExtraMethod(const crJXJRecvUserExtraMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUserExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvUserExtraMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvUserExtraMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();

		int bulletitemid = m_stream->_readInt();
		_crInt8 overlapCount = m_stream->_readChar();
		do 
		{
			//if(!fireItem) break;
			crItemChild *itemChild = m_this->findChildItem(bulletitemid);
			if(!itemChild || !itemChild->isLoaded()) break;
			crInstanceItem *bulletitem = itemChild->getInstanceItem();
			if(!bulletitem) break;

			void *param;
			crData *bulletData = bulletitem->getDataClass();
			if(!bulletData) break;
			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Client));
			if(!handle) break;

			bulletData->getParam(WCHDATA_UserExtraID,param);
			_crInt32 userExtraID = *((_crInt32*)param);
			//bulletData->getParam(WCHDATA_JXJUserOverlapMaxCount,param);
			//char maxOverlapCount = *((char*)param);
			//crRole *myrole = crMyPlayerData::getInstance()->getLoadedRoleByIndex(0);
			//if(myrole && myrole->getDataClass())
			//{//缓存bufhandle
			//	crData *myroledata = myrole->getDataClass();
			//	crHandle *existhandle = myroledata->getHandle(MAKEINT64(WCH_ClientExtraHandle,userExtraID));
			//	if(!existhandle)
			//	{
			//		myroledata->insertHandle(MAKEINT64(WCH_ClientExtraHandle,userExtraID),handle->clone());
			//	}
			//}

			crData *hitData = m_this->getDataClass();
			//hitData->excHandle(MAKEINT64(WCH_LockData,1));
			hitData->getParam(WCHDATA_ExtraData,param);
			crData *extraData = (crData *)param;
			if(extraData)
			{
				//extraData->insertHandle(MAKEINT64(WCH_DoExtra,targetExtraID),cloneHandle);
				//extraData->inputParam(WCHDATA_ExtraIDSet,&targetExtraID);
				char can = 1;//0：不能，1：可以，2：修改叠加数量
				short extraid = LOINT32(userExtraID);
				short extrapri = HIINT32(userExtraID);
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
				ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
				//_crInt8 overlapCount = 0;
				if(exitr != extraIDMap->end())
				{
					if(extrapri<HIINT16(exitr->second))
					{
						can = 0;
					}
					else if(extrapri == HIINT16(exitr->second))
					{
						can = 2;
					}
				}
				if(can>0)
				{
					ref_ptr<crHandle> cloneHandle;
					if(can==2)
						cloneHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
					else if(can==1)
					{
						crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
						if(existhandle)
						{
							existhandle->releaseObjects(NULL);
						}
					}
					if(!cloneHandle)
					{
						cloneHandle = handle->clone();
						extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle.get());
					}
					crVector3 dir = m_this->getDir();
					cloneHandle->inputParam(WCHDATA_AttachDir,&dir);
					cloneHandle->inputParam(WCHDATA_FireItem,m_this);
					short count = (short)overlapCount+1;
					cloneHandle->inputParam(WCHDATA_JXJOverlapParam,&count);
					(*extraIDMap)[extraid] = MAKEINT16(overlapCount,extrapri);
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			//hitData->excHandle(MAKEINT64(WCH_LockData,0));
		} while (0);
	}
}
/////////////////////////////////////////
//
//crJXJComputeRTHPMethod
//
/////////////////////////////////////////
crJXJComputeRTHPMethod::crJXJComputeRTHPMethod(){}
crJXJComputeRTHPMethod::crJXJComputeRTHPMethod(const crJXJComputeRTHPMethod& handle):
	crMethod(handle)
{
}
void crJXJComputeRTHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJComputeRTHPMethod::addParam(int i, const std::string& str)
{
}
void crJXJComputeRTHPMethod::operator()(crHandle &handle)
{//因为单兵血量受BUF影响会产生变化
	float hp = 0.0f;
	m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&hp,NULL));
	crData *thisData = m_this->getDataClass();
	void *param;
	thisData->excHandle(MAKEINT64(WCH_LockData,1));
	thisData->getParam(WCHDATA_RTHP,param);
	float *rthp = (float*)param;
	if(!rthp)
	{
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		return;
	}
	thisData->getParam(WCHDATA_JXJRTArmyCount,param);
	/*unsigned short*/int *armyCount = (/*unsigned short*/int *)param;
	float nowmaxhp = *armyCount * hp;
	if(fabs(nowmaxhp - *rthp) > hp)
	{
		//float _hp = *rthp/(float)(*armyCount);
		//_hp = (_hp - (int)_hp) * hp;//伤兵血量
		//*rthp = nowmaxhp - hp + _hp;
		*rthp = nowmaxhp;
	}
	thisData->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJAddDamageMethod
//
/////////////////////////////////////////
crJXJAddDamageMethod::crJXJAddDamageMethod(){}
crJXJAddDamageMethod::crJXJAddDamageMethod(const crJXJAddDamageMethod& handle):
	crMethod(handle)
{
}
void crJXJAddDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_damagePair = *(DamagePair *)(LOINT64(param64));
			m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_fireItem = NULL;
		}
		break;
	}
}
void crJXJAddDamageMethod::addParam(int i, const std::string& str)
{
}
void crJXJAddDamageMethod::operator()(crHandle &handle)
{//不能复活部队,不能回血
	if(m_damagePair.first<=0.0f)
		return;

	// 受到攻击增加士气
	if (m_damagePair.second.second == 1)
	{
		float gainRTMP = 0.0f;
		m_this->doEvent(MAKEINT64(WCH_JXJGetGainRTMP,NULL),MAKEINT64(&gainRTMP,0));
		if(gainRTMP>0.0f)
			m_this->doEvent(MAKEINT64(WCH_JXJCureRTMp,0),MAKEINT64(&gainRTMP,NULL));
		//float addMP = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAttackedAddMP).c_str());
		//m_this->doEvent(MAKEINT64(WCH_JXJCureRTMp,0)/*,MAKEINT64(&addMP,NULL)*/);
	}

	float hp = 0.0f;
	m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&hp,NULL));
	crData *thisData = m_this->getDataClass();
	void *param;
	thisData->excHandle(MAKEINT64(WCH_LockData,1));
	//float rthp = 0.0f;
	//m_this->doEvent(WCH_GetRTHP,MAKEINT64(&rthp,NULL));
	thisData->getParam(WCHDATA_RTHP,param);
	float *rthp = (float*)param;
	if(!rthp)
	{
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		return;
	}
	thisData->getParam(WCHDATA_ExtraRTHP,param);
	float* extrahp = (float*)param;
	if(*extrahp>0.0f)
	{
		*extrahp -= m_damagePair.first;
		if(*extrahp<0.0f)
		{
			*rthp += *extrahp;
			*extrahp = 0.0f;
		}
	}
	else if(*extrahp<0.0f)
	{
		*rthp += *extrahp;
		*extrahp = 0.0f;
		*rthp -= m_damagePair.first;
	}
	else
	{
		*rthp -= m_damagePair.first;
	}
	thisData->getParam(WCHDATA_JXJRTArmyCount,param);
	/*unsigned short*/int *armyCount = (/*unsigned short*/int *)param;
	short deadArmy = 0;
	int remain = ceil(*rthp/hp);
	if(remain<0)
		remain = 0;
	deadArmy = (int)(*armyCount) - remain;
	if(deadArmy>0)
		*armyCount = remain;
	else
		deadArmy = 0;

	if(m_this->getItemtype() == crInstanceItem::Npc && m_fireItem.valid())
	{//NPC仇恨度
		int enmity = m_damagePair.first;
		thisData->getParam(WCHDATA_EnmityMap,param);
		EnmityMap *enmityMap = (EnmityMap *)param;
		//_crInt64 id;
		//if(m_fireItem->getItemtype() == crInstanceItem::Role)
		//{
		//	id = MAKEINT64(m_fireItem->getRoleID(),m_fireItem->getID());//roleid,playerid
		//}
		//else if(m_fireItem->getItemtype() == crInstanceItem::Npc)
		//{
		//	id = MAKEINT64(m_fireItem->getInstanceItemID(),NULL);
		//}
		EnmityMap::iterator itr = enmityMap->find(m_fireItem);
		if(itr != enmityMap->end())
		{
			itr->second += m_damagePair.first;
			enmity = itr->second;
		}
		else
			enmityMap->insert(std::make_pair(m_fireItem,(int)(m_damagePair.first)));

		//thisData->getParam(WCHDATA_InPatrolEnemyMap,param);
		//InPatrolEnemyMap *inPatrolEnemyMap = (InPatrolEnemyMap *)param;
		//if(inPatrolEnemyMap)
		//{
		//	bool insight = false;
		//	for( InPatrolEnemyMap::iterator itr = inPatrolEnemyMap->begin();
		//		itr != inPatrolEnemyMap->end();
		//		++itr )
		//	{
		//		if(itr->second == m_fireItem)
		//		{
		//			insight = true;
		//			break;
		//		}
		//	}
		//	if(!insight)
		//	{
		//		crVector3 thisPos(m_this->getPosx(),m_this->getPosy(),m_this->getPosz());
		//		crVector3 itmePos(m_fireItem->getPosx(),m_fireItem->getPosy(),m_fireItem->getPosz());
		//		short dist = (thisPos - itmePos).length();
		//		//_crInt64 distEnmity = MAKEINT64(-(int)dist,enmity);
		//		inPatrolEnemyMap->insert(std::make_pair(dist,m_fireItem));
		//	}
		//}
	}
	float _rthp = *rthp;
	float _extrahp = *extrahp;
	/*unsigned short*/int _armyCount = *armyCount;
	thisData->excHandle(MAKEINT64(WCH_LockData,0));
	//将信息传给m_this以及其附近玩家
	unsigned char hittype = m_this->getItemtype();
	int hitid = m_this->getID();

	unsigned char firetype = 0;
	int fireid = 0;
	if(m_fireItem.valid())
	{
		firetype = m_fireItem->getItemtype();
		fireid = m_fireItem->getID();
	}

	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crNetManager *netManager = sceneServerConductor->getNetManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crStreamBuf> damageStream = new crStreamBuf;
		damageStream->createBuf(18);
		damageStream->_writeUChar(m_damagePair.second.first);
		damageStream->_writeUChar(firetype);
		damageStream->_writeInt(fireid);
		damageStream->_writeShort(deadArmy);
		damageStream->_writeFloat(_rthp);
		damageStream->_writeFloat(_extrahp);
		damageStream->_writeInt(_armyCount);

		if(firetype == crInstanceItem::Role)
		{
			ref_ptr<crSceneServerPlayerData> firePlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(fireid));
			if (firePlayerData.valid())
			{
				crPlayerGameData *playerGameData = firePlayerData->getPlayerGameData();
				crData *playerData = playerGameData->getDataClass();
				if(playerData)
				{
					float time = c_battleActiveInterval;
					playerData->inputParam(WCHDATA_JXJBattleActiveTimer,&time);
				}
			}
		}
		if(hittype == crInstanceItem::Role)
		{
			crPlayerEventPacket damagePacket;
			crPlayerEventPacket::buildRequestPacket(damagePacket,hitid,m_this,WCH_RecvDamage,damageStream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData;
			hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if (hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),damagePacket);
			}
			scene->sendPacketToItemNeighbor(m_this,damagePacket);
			if(_rthp<=0.0f)
			{
				ref_ptr<crStreamBuf> deadStream = new crStreamBuf;
				deadStream->createBuf(5);
				deadStream->_writeUChar(firetype);
				deadStream->_writeInt(fireid);

				crPlayerEventPacket deadPacket;
				crPlayerEventPacket::buildRequestPacket(deadPacket,hitid,m_this,WCH_RecvItemDead,deadStream.get());
				if (hitPlayerData.valid()) netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),deadPacket);
				scene->sendPacketToItemNeighbor(m_this,deadPacket);
			}
			if(hitPlayerData.valid())
			{
				crPlayerGameData *playerGameData = hitPlayerData->getPlayerGameData();
				crData *playerData = playerGameData->getDataClass();
				if(playerData)
				{
					float time = c_battleActiveInterval;
					playerData->inputParam(WCHDATA_JXJBattleActiveTimer,&time);
					if(deadArmy!=0 && scene->getExternSceneType() == Ext_Battle)
					{
						void *param;
						playerData->excHandle(MAKEINT64(WCH_LockData,1));
						playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
						FormationInfoVec *formationVec = (FormationInfoVec *)param;
						for( FormationInfoVec::iterator fitr = formationVec->begin();
							fitr != formationVec->end();
							++fitr )
						{
							if((*fitr)->getRoleID() == m_this->getRoleID())
							{
								(*fitr)->setCount(*armyCount);
								break;
							}
						}
						playerData->excHandle(MAKEINT64(WCH_LockData,0));
						//netCallback->savePlayerData(hitPlayerData.get());
					}
				}
			}
		}
		else
		{
			crItemEventPacket damagePacket;
			crItemEventPacket::buildRequestPacket(damagePacket,0,m_this,WCH_RecvDamage,damageStream.get());
			scene->sendPacketToItemNeighbor(m_this,damagePacket);
			if(_rthp<=0.0f)
			{
				ref_ptr<crStreamBuf> deadStream = new crStreamBuf;
				deadStream->createBuf(5);
				deadStream->_writeUChar(firetype);
				deadStream->_writeInt(fireid);

				crItemEventPacket deadPacket;
				crItemEventPacket::buildRequestPacket(deadPacket,0,m_this,WCH_RecvItemDead,deadStream.get());
				scene->sendPacketToItemNeighbor(m_this,deadPacket);
			}
		}

		if(_rthp<=0.0f)
		{
			unsigned char itemstate = IS_Dead;
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
			m_this->doEvent(WCH_ItemDead,MAKEINT64(m_fireItem.get(),NULL));

			ref_ptr<HitParam>hitParam = new HitParam;
			hitParam->m_hitItem = m_this;
			hitParam->m_fireItem = m_fireItem;
			if(m_fireItem.valid())
			{
				//hitParam->m_hitItem.swap(hitParam->m_fireItem);
				m_fireItem->doEvent(WCH_KillExtraTest,MAKEINT64(hitParam.get(),NULL));
			}
			hitParam->m_hitItem.swap(hitParam->m_fireItem);
			m_this->doEvent(WCH_DeadExtraTest,MAKEINT64(hitParam.get(),NULL));
			m_this->clearSyncPos();
			unsigned char targetType = Target_Coord;
			thisData->inputParam(WCHDATA_TargetType,&targetType);
			m_this->getOrCreatePathFinder()->dirty();
		}
		int roomid = m_this->getRoomID();
		if(roomid!=0)
		{
			crRoom *room = netCallback->findRoom(roomid);
			if(room)
			{
				if(deadArmy>0)
				{
					std::pair<crInstanceItem*,crInstanceItem*>ItemPair(m_this,m_fireItem.get());//deaditem,fireitem
					room->doEvent(WCH_RoomKillStats,MAKEINT64(&deadArmy,&ItemPair));
				}
				if(_rthp<=0.0f)
				{
					if(hittype == crInstanceItem::Role)
						room->doEvent(WCH_RoomPlayerDead,MAKEINT64(m_this,m_fireItem.get()));
					else
					{
						int id = m_this->getInstanceItemID();
						if(id<0) id = 0;
						room->doEvent(MAKEINT64(WCH_RoomItemDead,id),MAKEINT64(m_this,m_fireItem.get()));
					}
				}
				else
				{
					if(hittype == crInstanceItem::Role)
						room->doEvent(WCH_RoomPlayerDamage,MAKEINT64(m_this,m_fireItem.get()));
					else
					{
						int id = m_this->getInstanceItemID();
						if(id<0) id = 0;
						room->doEvent(MAKEINT64(WCH_RoomItemDamage,id),MAKEINT64(m_this,m_fireItem.get()));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSceneServerUpdateMethod
//
/////////////////////////////////////////
crJXJSceneServerUpdateMethod::crJXJSceneServerUpdateMethod():
	m_dt(NULL),
	m_kickTime(-40.0f)
{
}
crJXJSceneServerUpdateMethod::crJXJSceneServerUpdateMethod(const crJXJSceneServerUpdateMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_kickTime(handle.m_kickTime)
{
}
void crJXJSceneServerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float *)(LOINT64(param64));
			m_player = (crSceneServerPlayerData*)(HIINT64(param64));
		}
		else
		{
			m_dt = NULL;
			m_player = NULL;
		}
		break;
	}
}
void crJXJSceneServerUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_kickTime = atof(str.c_str());
		break;
	}
}
void crJXJSceneServerUpdateMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char fubentype = *(unsigned char *)param;
	if(fubentype == 1)
	{//1：城站
		data->getParam(WCHDATA_JXJBattleActiveTimer,param);
		float *timer = (float *)param;
		*timer -= *m_dt;
		//if(*timer<m_kickTime)
		//{//验证失败，踢出玩家
		//	///游戏日志
		//	std::string logdata = "踢除战场无操作玩家";
		//	GameLogData gamelog(Log_NotActive,logdata);
		//	crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_this->getPlayerID(),&gamelog));
		//	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		//	//聊天框消息
		//	crHandle *noticeHandle = crServerBrainHandle::getInstance()->getDataClass()->getHandle(WCH_JXJServerNotice);
		//	std::string outString ;
		//	int texid = 1097;
		//	noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
		//	noticeHandle->inputParam(WCHDATA_NoticeOutPut,&outString);
		//	crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerNotice);

		//	ref_ptr<crStreamBuf> streamBuf = new crStreamBuf;
		//	streamBuf->createBuf(outString.length()+9);
		//	streamBuf->_writeChar(ChatAll);
		//	streamBuf->_writeString("[系统]");
		//	streamBuf->_writeString(outString);
		//	crPlayerDataSceneEventPacket packet;
		//	crPlayerDataSceneEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvRoomChatMessage,streamBuf.get());
		//	sceneServerConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(),packet);
		//	//sceneServerConductor->getNetDataManager()->removePlayerData(m_this->getPlayerID());
		//}
		//else 
		if(*timer<0.0f)
		{
			data->getParam(WCHDATA_JXJBattleValidateID,param);
			unsigned short* validid = (unsigned short*)param;
			if(*validid==0)
			{
				ref_ptr<crTableIO> validtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJValidateTab);
				*validid = rangei(1,validtab->getRowCount()+1).get_random();
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(2);
				stream->_writeUShort(*validid);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvBattleValidateID,stream.get());
				sceneServerConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(),packet);
			}
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvBattleValidateIDMethod
//
/////////////////////////////////////////
crJXJRecvBattleValidateIDMethod::crJXJRecvBattleValidateIDMethod():
	m_netType(GameClient_Game){}
crJXJRecvBattleValidateIDMethod::crJXJRecvBattleValidateIDMethod(const crJXJRecvBattleValidateIDMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBattleValidateIDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBattleValidateIDMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvBattleValidateIDMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			ref_ptr<crCanvasNode> validateCanvas = crFilterRenderManager::getInstance()->findCanvas("UI_Beta2_Battleground_Gztxh");
			unsigned short id = m_stream->_readUShort(); 
			crData *data = m_this->getDataClass();
			if(data && validateCanvas.valid())
			{
				data->inputParam(WCHDATA_JXJBattleValidateID,&id);
				crFilterRenderManager::getInstance()->showCanvas(validateCanvas.get(), true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvDamageMethod
//
/////////////////////////////////////////
crJXJRecvDamageMethod::crJXJRecvDamageMethod(){}
crJXJRecvDamageMethod::crJXJRecvDamageMethod(const crJXJRecvDamageMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDamageMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvDamageMethod::operator()(crHandle &handle)
{
	if(m_stream.valid() && crRunGameHandle::getInstance()->getRunningCode() == crRunGameHandle::NetGame)
	{
		unsigned char damagetype = m_stream->_readUChar();
		unsigned char firetype = m_stream->_readUChar();
		int fireid = m_stream->_readInt();
		short deadArmy = m_stream->_readShort();
		float _rthp = m_stream->_readFloat();
		float _extrahp = m_stream->_readFloat();
		/*unsigned short*/int armyCount = m_stream->_readInt();
		crData *data = m_this->getDataClass();
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		data->inputParam(WCHDATA_RTHP,&_rthp);
		data->inputParam(WCHDATA_ExtraRTHP,&_extrahp);
		//data->inputParam(WCHDATA_RTHP,&rthp);
		data->inputParam(WCHDATA_JXJRTArmyCount,&armyCount);
		//data->excHandle(MAKEINT64(WCH_LockData,0));
		//客户端显示
		if(deadArmy>0)
		{
			char ifire = 0;
			if(firetype == crInstanceItem::Role && crMyPlayerData::getInstance()->getPlayerID() == fireid)
			{
				ifire = 1;
			}
			m_this->doEvent(WCH_JXJClientRecvDamage,MAKEINT64(-deadArmy,MAKEINT32(damagetype,ifire)));
		}
		//crNode *node = m_this->getRelNode();
		//if(node && deadArmy!=0)
		//{
		//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_RecvDamage,MAKEINT32(-deadArmy,-1)));
		//m_this->doEvent()
		//}
		if(deadArmy!=0 && crMyPlayerData::getInstance()->ifItemIsMe(m_this) && crMyPlayerData::getInstance()->getScene()->getExternSceneType() == Ext_Battle)
		{
			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
			crData *playerData = playerGameData->getDataClass();
			void *param;
			playerData->excHandle(MAKEINT64(WCH_LockData,1));
			playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
			FormationInfoVec *formationVec = (FormationInfoVec *)param;
			for( FormationInfoVec::iterator fitr = formationVec->begin();
				fitr != formationVec->end();
				++fitr )
			{
				if((*fitr)->getRoleID() == m_this->getRoleID())
				{
					(*fitr)->setCount(armyCount);
					break;
				}
			}
			playerData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJDamageTypeMethod
//
/////////////////////////////////////////
crJXJDamageTypeMethod::crJXJDamageTypeMethod():
	m_damageType(0){}
crJXJDamageTypeMethod::crJXJDamageTypeMethod(const crJXJDamageTypeMethod& handle):
	crMethod(handle),
	m_damageType(0)
{
}
void crJXJDamageTypeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_damageType = (unsigned char)(LOINT64(param64));
		}
		break;
	}
}
void crJXJDamageTypeMethod::addParam(int i, const std::string& str)
{
}
void crJXJDamageTypeMethod::operator()(crHandle &handle)
{
	//将信息传给m_this以及其附近玩家
	unsigned char hittype = m_this->getItemtype();
	int hitid = m_this->getID();
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crNetManager *netManager = sceneServerConductor->getNetManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crStreamBuf> damageStream = new crStreamBuf;
		damageStream->createBuf(1);
		damageStream->_writeUChar(m_damageType);

		if(hittype == crInstanceItem::Role)
		{
			crPlayerEventPacket damagePacket;
			crPlayerEventPacket::buildRequestPacket(damagePacket,hitid,m_this,WCH_JXJRecvDamageType,damageStream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if (hitPlayerData.valid())
			{
				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),damagePacket);
			}
			scene->sendPacketToItemNeighbor(m_this,damagePacket);
		}
		else
		{
			crItemEventPacket damagePacket;
			crItemEventPacket::buildRequestPacket(damagePacket,0,m_this,WCH_JXJRecvDamageType,damageStream.get());
			scene->sendPacketToItemNeighbor(m_this,damagePacket);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvDamageTypeMethod
//
/////////////////////////////////////////
crJXJRecvDamageTypeMethod::crJXJRecvDamageTypeMethod(){}
crJXJRecvDamageTypeMethod::crJXJRecvDamageTypeMethod(const crJXJRecvDamageTypeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvDamageTypeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDamageTypeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvDamageTypeMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		unsigned char damagetype = m_stream->_readUChar();
		//客户端显示
		m_this->doEvent(WCH_JXJClientRecvDamage,MAKEINT64(0,damagetype));
	}
}
/////////////////////////////////////////
//
//crJXJTrackFireMissMethod
//
/////////////////////////////////////////
crJXJTrackFireMissMethod::crJXJTrackFireMissMethod(){}
crJXJTrackFireMissMethod::crJXJTrackFireMissMethod(const crJXJTrackFireMissMethod& handle):
	crMethod(handle)
{
}
void crJXJTrackFireMissMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crViewMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_bullet = (crBulletMatterObject *)(LOINT64(param64));
			m_collideNode = (crNode *)(LOINT64(param64));
		}
		break;
	}
}

void crJXJTrackFireMissMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJTrackFireMissMethod::operator()(crHandle &handle)
{///攻击打在模型上的提示
	if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
		return;
	if(crRunGameHandle::getInstance()->isInGame())
	{
		void *param;
		crVector3 window,pos,initPos;
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		ref_ptr<crCanvasNode > mainCanvas = crFilterRenderManager::getInstance()->getMainCanvas();
		ref_ptr<crCanvasNode >demageNode = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
		if(mainCanvas.valid() == false || demageNode.valid() == false || !bindview || !bindview->isInited() || bindview->done()) return;
		if(camera.valid() && m_bullet && bindview&&bindview->isInited())
		{
			ref_ptr<crSceneView> sceneView = bindview->getDefaultSceneHandler()->getSceneView();
			crData *cameraData = camera->getAttachedNode()->getDataClass();
			if(cameraData)
			{
				CRCore::ref_ptr<CRCore::crCanvasNode> cpDamageNode;
				cameraData->excHandle(MAKEINT64(WCH_LockData,1));
				cameraData->getParam(WCHDATA_JXJRecvDamageMap,param);
				WidgetNodeMap *DamageNodeMap = (WidgetNodeMap *)param;
				//cameraData->getParam(WCHDATA_JXJRecvDamageShowDeque,param);
				//WidgetNodeDeque *damageNodeDeque = (WidgetNodeDeque *)param;

				WidgetNodeMap::iterator itr = DamageNodeMap->find(TrackFireMissDM);
				bool found = false;
				for ( ; itr != DamageNodeMap->end() && itr->first == TrackFireMissDM; ++itr )
				{
					if(!itr->second->getVisiable())
					{
						cpDamageNode = itr->second.get();
						found = true;
						break;
					}
				}
				if(!found)
				{
					cpDamageNode = dynamic_cast<crCanvasNode *>(demageNode->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
					cpDamageNode->setCanFocus(false);
					cpDamageNode->setMsgTraverse(KM_All);
					//cpDamageNode->setEnable(true);
					DamageNodeMap->insert(std::make_pair(TrackFireMissDM,cpDamageNode.get()));
					cameraData->excHandle(MAKEINT64(WCH_LockData,0));
					crLoadManager::getInstance()->requestAddNode(mainCanvas.get(),cpDamageNode.get(),false);
				}
				else
				{
					cameraData->excHandle(MAKEINT64(WCH_LockData,0));
				}
				if(cpDamageNode.valid())
				{
					crSequence *seq = dynamic_cast<crSequence *>(cpDamageNode->getChild(0));
					if(seq)
					{
						seq->setVanishWhenStop(true);
						seq->setDuration(0.1,1);
						seq->setMode(crSequence::START);
					}
					crData *data = cpDamageNode->getDataClass();
					if(data)
					{
						data->inputParam(WCHDATA_JXJRecvTrackFireMissObject,m_bullet);
						initPos = m_bullet->getTrans();
						pos = initPos;
						pos[2]+=2.0;
						sceneView->projectObjectIntoWindow(pos,window);
						pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
						pos[2] = 0.0f;
						data->inputParam(WCHDATA_JXJTrackFireMissPos,&initPos);
						cpDamageNode->setPosition(pos);
						cpDamageNode->setVisiable(true);
						//damageNodeDeque->push_back(cpDamageNode);
					}
					else
					{
						cpDamageNode->setVisiable(false);
						char gbuf[256];
						sprintf(gbuf,"JXJTrackFireMiss:%s没有data\n\0",cpDamageNode->getName().c_str());
						gDebugInfo->debugInfo(CRCore::WARN,gbuf);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCureHPMethod
//
/////////////////////////////////////////
crJXJCureHPMethod::crJXJCureHPMethod():
	m_curehp(0.0f){}
crJXJCureHPMethod::crJXJCureHPMethod(const crJXJCureHPMethod& handle):
	crMethod(handle),
	m_curehp(0.0f)
{
}
void crJXJCureHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_curehp = *(float *)(LOINT64(param64));
			//m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_curehp = 0;
			//m_fireItem = NULL;
		}
		break;
	}
}
void crJXJCureHPMethod::addParam(int i, const std::string& str)
{
}
void crJXJCureHPMethod::operator()(crHandle &handle)
{//回血复活部队
	float hp = 0.0f;
	m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&hp,NULL));
	crData *thisData = m_this->getDataClass();
	void *param;
	thisData->excHandle(MAKEINT64(WCH_LockData,1));
	thisData->getParam(WCHDATA_RTHP,param);
	float *rthp = (float*)param;
	if(!rthp || *rthp<=0)
	{
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		return;
	}
	thisData->getParam(WCHDATA_JXJArmyCount,param);
	/*unsigned short*/int armyCount = *(/*unsigned short*/int *)param;
	float armsmaxhp = armyCount * hp;
	if(*rthp>=armsmaxhp)
	{
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		return;
	}
	thisData->getParam(WCHDATA_JXJRTArmyCount,param);
	/*unsigned short*/int *rtArmyCount = (/*unsigned short*/int *)param;
	*rthp += m_curehp;
	bool rtcountchange = false;
	int offsetCount = 0;
	if(*rthp>=armsmaxhp)
	{
		*rthp = armsmaxhp;
		if(*rtArmyCount != armyCount)
		{
			offsetCount += *rtArmyCount - armyCount;
			*rtArmyCount = armyCount;
			rtcountchange = true;
		}
	}
	else
	{
		int count = ceil(*rthp / hp);

		if(count>=0 && *rtArmyCount != count)
		{
			offsetCount += *rtArmyCount - count;
			*rtArmyCount = count;
			rtcountchange = true;
		}
	}
	thisData->excHandle(MAKEINT64(WCH_LockData,0));
	//将信息传给m_this以及其附近玩家
	unsigned char hittype = m_this->getItemtype();
	int hitid = m_this->getID();

	//unsigned char firetype = 0;
	//int fireid = 0;
	//if(m_fireItem.valid())
	//{
	//	firetype = m_fireItem->getItemtype();
	//	fireid = m_fireItem->getID();
	//}

	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crNetManager *netManager = sceneServerConductor->getNetManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(6);
		stream->_writeFloat(*rthp);
		stream->_writeInt(*rtArmyCount);
		if(hittype == crInstanceItem::Role)
		{
			//吸血统计值扣除
			CRNetApp::crRoom* room = netCallback->findRoom(m_this->getRoomID());
			if(room && offsetCount<0)
			{
				crData *roomData = room->getDataClass();
				if(roomData)
				{
					roomData->excHandle(MAKEINT64(WCH_LockData,1));
					roomData->getParam(WCHDATA_JXJBattleStatsMap,param);
					BattleStatsMap *battleStatsMap = (BattleStatsMap *)param;

					int playerid = m_this->getID();
					BattleStatsMap::iterator itr = battleStatsMap->find(playerid);
					if(itr!=battleStatsMap->end())
					{
						itr->second->addDeadMap(m_this->getAbstractItemID(),offsetCount);
					}
					roomData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
			crPlayerEventPacket packet;
			crPlayerEventPacket::buildRequestPacket(packet,hitid,m_this,WCH_RecvCureHP,stream.get());
			ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
			if (hitPlayerData.valid())
			{
				if(rtcountchange && scene->getExternSceneType() == Ext_Battle)
				{
					crPlayerGameData *playerGameData = hitPlayerData->getPlayerGameData();
					crData *playerData = playerGameData->getDataClass();
					void *param;
					playerData->excHandle(MAKEINT64(WCH_LockData,1));
					playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
					FormationInfoVec *formationVec = (FormationInfoVec *)param;
					for( FormationInfoVec::iterator fitr = formationVec->begin();
						fitr != formationVec->end();
						++fitr )
					{
						if((*fitr)->getRoleID() == m_this->getRoleID())
						{
							(*fitr)->setCount(*rtArmyCount);
							break;
						}
					}
					playerData->excHandle(MAKEINT64(WCH_LockData,0));
					//netCallback->savePlayerData(hitPlayerData.get());
				}

				netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
			}
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
		else
		{
			crItemEventPacket packet;
			crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvCureHP,stream.get());
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
	}

}
/////////////////////////////////////////
//
//crJXJRecvCureHPMethod
//
/////////////////////////////////////////
crJXJRecvCureHPMethod::crJXJRecvCureHPMethod(){}
crJXJRecvCureHPMethod::crJXJRecvCureHPMethod(const crJXJRecvCureHPMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCureHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCureHPMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCureHPMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		float rthp = m_stream->_readFloat();
		/*unsigned short*/int rtArmCount = m_stream->_readInt();
		data->inputParam(WCHDATA_RTHP,&rthp);
		void *param;

		data->getParam(WCHDATA_JXJRTArmyCount,param);
		/*unsigned short*/int myrt = *(/*unsigned short*/int *)param;
		if(myrt != rtArmCount)
		{
			short change = (int)rtArmCount - (int)myrt;
			data->inputParam(WCHDATA_JXJRTArmyCount,&rtArmCount);
			//客户端显示
			if(change>0)
				m_this->doEvent(WCH_JXJClientRecvDamage,MAKEINT64(change,CureHP));
			if(change!=0 && crMyPlayerData::getInstance()->ifItemIsMe(m_this) && crMyPlayerData::getInstance()->getScene()->getExternSceneType() == Ext_Battle)
			{
				crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
				crData *playerData = playerGameData->getDataClass();
				void *param;
				playerData->excHandle(MAKEINT64(WCH_LockData,1));
				playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
				FormationInfoVec *formationVec = (FormationInfoVec *)param;
				for( FormationInfoVec::iterator fitr = formationVec->begin();
					fitr != formationVec->end();
					++fitr )
				{
					if((*fitr)->getRoleID() == m_this->getRoleID())
					{
						(*fitr)->setCount(rtArmCount);
						break;
					}
				}
				playerData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJSceneSavePlayerDataMethod
////
///////////////////////////////////////////
//crJXJSceneSavePlayerDataMethod::crJXJSceneSavePlayerDataMethod(){}
//crJXJSceneSavePlayerDataMethod::crJXJSceneSavePlayerDataMethod(const crJXJSceneSavePlayerDataMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJSceneSavePlayerDataMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	}
//}
//
//void crJXJSceneSavePlayerDataMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJSceneSavePlayerDataMethod::operator()(crHandle &handle)
//{
//	int playerid = m_this->getPlayerID();
//	//返回信息
//	crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
//	crSceneServerPlayerData* playerData = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
//	if(playerData)
//	{
//		crRole *role;
//		crData *data;
//		void *param;
//		unsigned short armyCount = 0;
//		crData *playerGameData = m_this->getDataClass();
//		playerGameData->excHandle(MAKEINT64(WCH_LockData,1));
//		playerGameData->getParam(WCHDATA_JXJFormationInfoVec,param);
//		FormationInfoVec *formationVec = (FormationInfoVec *)param;
//		FormationInfoVec::iterator fitr;
//		crSceneServerPlayerData::RoleMap &roleMap = playerData->getRoleMap();
//		for( crSceneServerPlayerData::RoleMap::iterator itr = roleMap.begin();
//			itr != roleMap.end();
//			++itr )
//		{
//			role = itr->second.get();
//			data = role->getDataClass();
//			data->getParam(WCHDATA_JXJRTArmyCount,param);
//			armyCount = *(unsigned short *)param;
//			for( fitr = formationVec->begin();
//				 fitr != formationVec->end();
//				 ++fitr )
//			{
//				if((*fitr)->getAbstractID() == role->getAbstractItemID())
//				{
//					(*fitr)->setCount(armyCount);
//					break;
//				}
//			}
//		}
//		playerGameData->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
///////////////////////////////////////// 
//
//crJXJMissCritTestMethod
//
/////////////////////////////////////////
crJXJMissCritTestMethod::crJXJMissCritTestMethod(){}
crJXJMissCritTestMethod::crJXJMissCritTestMethod(const crJXJMissCritTestMethod& handle):
	crMethod(handle)
{
}
void crJXJMissCritTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJMissCritTestMethod::addParam(int i, const std::string& str)
{
}

void crJXJMissCritTestMethod::operator()(crHandle &handle)
{
	int attackDice = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAttackDice, 0).c_str());
	float hitratio = 0.0f;
	m_this->doEvent(WCH_GetHitratio,MAKEINT64(&hitratio,NULL));
	bool isHit = crGameDices::getInstance()->dice(1,attackDice)<=hitratio;
	bool isMiss = !isHit;
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_IsMiss,&isMiss);
	bool isCrit = false;
	if(!isMiss)
	{
		float crit = 0.0f;
		m_this->doEvent(WCH_GetCrit,MAKEINT64(&crit,NULL));
		isCrit = crGameDices::getInstance()->dice(1,attackDice)<=crit;
	}
	data->inputParam(WCHDATA_IsCrit,&isCrit);
	if(isMiss || isCrit)
	{
		CRCore::ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(2);
		stream->_writeBool(isMiss);
		stream->_writeBool(isCrit);

		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			if(m_this->getItemtype() == crInstanceItem::Role)
			{
				int playerid = m_this->getID();
				//int roleid = m_this->getRoleID();
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvMissCrit,stream.get());

				ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if (playerData.valid())
				{
					sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				scene->sendPacketToItemNeighbor(m_this,packet);
			}
			else
			{
				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvMissCrit,stream.get());

				scene->sendPacketToItemNeighbor(m_this,packet);
			}
		}
	}
}
/////////////////////////////////////////// 
////
////crJXJCritTestMethod
////
///////////////////////////////////////////
//crJXJCritTestMethod::crJXJCritTestMethod(){}
//crJXJCritTestMethod::crJXJCritTestMethod(const crJXJCritTestMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJCritTestMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	}
//}
//
//void crJXJCritTestMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJCritTestMethod::operator()(crHandle &handle)
//{
//	float crit = 0;
//	m_this->doEvent(WCH_GetCrit,MAKEINT64(&crit,NULL));
//	int attackDice = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAttackDice).c_str());
//	bool isCrit = crGameDices::getInstance()->dice(1,attackDice)<=crit;
//	m_this->getDataClass()->inputParam(WCHDATA_IsCrit,&isCrit);
//	CRCore::ref_ptr<crStreamBuf> stream = new crStreamBuf;
//	stream->createBuf(1);
//	stream->_writeBool(isCrit);
//	//if(crGlobalHandle::isClient() && crMyPlayerData::getInstance()->ifItemIsMe(m_this))
//	//{//发送给服务器
//	//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	//	if(netConductor)
//	//	{
//	//		crPlayerEventPacket packet;
//	//		crPlayerEventPacket::buildRequestPacket(packet,m_this->getRoleID(),WCH_RecvCrit,stream.get());
//	//		netConductor->getNetManager()->sendPacket("all",packet);
//	//	}
//	//}
//	//else
//	//{//发送给客户端
//		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
//		if(scene)
//		{
//			if(m_this->getItemtype() == crInstanceItem::Role)
//			{
//				int playerid = m_this->getID();
//				int roleid = m_this->getRoleID();
//				crPlayerEventPacket packet;
//				crPlayerEventPacket::buildRequestPacket(packet,playerid,playerid,roleid,WCH_RecvCrit,stream.get());
//
//				ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
//				if (playerData.valid())
//				{
//					sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//					scene->sendPacketToItemNeighbor(m_this,packet);
//				}
//			}
//			else
//			{
//				crItemEventPacket packet;
//				crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvCrit,stream.get());
//
//				scene->sendPacketToItemNeighbor(m_this,packet);
//			}
//		}
//	//}
//}
///////////////////////////////////////// 
//
//crJXJDodgeParryTestMethod
//
/////////////////////////////////////////
crJXJDodgeParryTestMethod::crJXJDodgeParryTestMethod(){}
crJXJDodgeParryTestMethod::crJXJDodgeParryTestMethod(const crJXJDodgeParryTestMethod& handle):
	crMethod(handle)
{
}
void crJXJDodgeParryTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJDodgeParryTestMethod::addParam(int i, const std::string& str)
{
}

void crJXJDodgeParryTestMethod::operator()(crHandle &handle)
{
	int attackDice = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAttackDice, 0).c_str());
	float dodge = 0.0f;
	m_this->doEvent(WCH_GetDodge,MAKEINT64(&dodge,NULL));
	bool isDodge = crGameDices::getInstance()->dice(1,attackDice)<=dodge;
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_IsDodge,&isDodge);
	bool isParry = false;
	if(!isDodge)
	{
		float parry = 0.0f;
		m_this->doEvent(WCH_GetParry,MAKEINT64(&parry,NULL));
		isParry = crGameDices::getInstance()->dice(1,attackDice)<=parry;
	}
	data->inputParam(WCHDATA_IsParry,&isParry);
	if(isDodge || isParry)
	{
		//发送给客户端
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			CRCore::ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(2);
			stream->_writeBool(isDodge);
			stream->_writeBool(isParry);
			if(m_this->getItemtype() == crInstanceItem::Role)
			{
				int playerid = m_this->getID();
				//int roleid = m_this->getRoleID();
				crPlayerEventPacket packet;
				crPlayerEventPacket::buildRequestPacket(packet,playerid,m_this,WCH_RecvDodgeParry,stream.get());

				ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if (playerData.valid())
				{
					sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				scene->sendPacketToItemNeighbor(m_this,packet);
			}
			else
			{
				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvDodgeParry,stream.get());

				scene->sendPacketToItemNeighbor(m_this,packet);
			}
		}
	}
}
/////////////////////////////////////////// 
////
////crJXJDodgeTestMethod
////
///////////////////////////////////////////
//crJXJDodgeTestMethod::crJXJDodgeTestMethod(){}
//crJXJDodgeTestMethod::crJXJDodgeTestMethod(const crJXJDodgeTestMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJDodgeTestMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	}
//}
//
//void crJXJDodgeTestMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJDodgeTestMethod::operator()(crHandle &handle)
//{
//	float dodge = 0;
//	m_this->doEvent(WCH_GetDodge,MAKEINT64(&dodge,NULL));
//	int attackDice = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAttackDice).c_str());
//	bool isDodge = crGameDices::getInstance()->dice(1,attackDice)<=dodge;
//	m_this->getDataClass()->inputParam(WCHDATA_IsDodge,&isDodge);
//	//发送给客户端
//	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
//	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
//	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
//	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
//	if(scene)
//	{
//		CRCore::ref_ptr<crStreamBuf> stream = new crStreamBuf;
//		stream->createBuf(1);
//		stream->_writeBool(isDodge);
//		if(m_this->getItemtype() == crInstanceItem::Role)
//		{
//			int playerid = m_this->getID();
//			int roleid = m_this->getRoleID();
//			crPlayerEventPacket packet;
//			crPlayerEventPacket::buildRequestPacket(packet,playerid,playerid,roleid,WCH_RecvDodge,stream.get());
//
//			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
//			if (playerData.valid())
//			{
//				sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				scene->sendPacketToItemNeighbor(m_this,packet);
//			}
//		}
//		else
//		{
//			crItemEventPacket packet;
//			crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_RecvDodge,stream.get());
//
//			scene->sendPacketToItemNeighbor(m_this,packet);
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJRecvMissCritMethod
//
/////////////////////////////////////////
crJXJRecvMissCritMethod::crJXJRecvMissCritMethod(){}
crJXJRecvMissCritMethod::crJXJRecvMissCritMethod(const crJXJRecvMissCritMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvMissCritMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvMissCritMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvMissCritMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		bool isMiss = m_stream->_readBool();
		bool isCrit = m_stream->_readBool();
		data->inputParam(WCHDATA_IsMiss,&isMiss);
		data->inputParam(WCHDATA_IsCrit,&isCrit);
	}
}
///////////////////////////////////////////
////
////crJXJRecvCritMethod
////
///////////////////////////////////////////
//crJXJRecvCritMethod::crJXJRecvCritMethod(){}
//crJXJRecvCritMethod::crJXJRecvCritMethod(const crJXJRecvCritMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvCritMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvCritMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvCritMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		crData *data = m_this->getDataClass();
//		bool isCrit = m_stream->_readBool();
//		data->inputParam(WCHDATA_IsCrit,&isCrit);
//	}
//}
/////////////////////////////////////////
//
//crJXJRecvDodgeParryMethod
//
/////////////////////////////////////////
crJXJRecvDodgeParryMethod::crJXJRecvDodgeParryMethod(){}
crJXJRecvDodgeParryMethod::crJXJRecvDodgeParryMethod(const crJXJRecvDodgeParryMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvDodgeParryMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDodgeParryMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvDodgeParryMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		bool isDodge = m_stream->_readBool();
		bool isParry = m_stream->_readBool();
		data->inputParam(WCHDATA_IsDodge,&isDodge);
		data->inputParam(WCHDATA_IsParry,&isParry);
	}
}
///////////////////////////////////////////
////
////crJXJRecvDodgeMethod
////
///////////////////////////////////////////
//crJXJRecvDodgeMethod::crJXJRecvDodgeMethod(){}
//crJXJRecvDodgeMethod::crJXJRecvDodgeMethod(const crJXJRecvDodgeMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvDodgeMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvDodgeMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvDodgeMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		crData *data = m_this->getDataClass();
//		bool isDodge = m_stream->_readBool();
//		data->inputParam(WCHDATA_IsDodge,&isDodge);
//	}
//}
////////////////////////////////////////////////////////////
/////////////////////////////////////////
//
//crJXJHeadCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJHeadCanvasUpdateMethod::crJXJHeadCanvasUpdateMethod():
	m_init(false){}
crJXJHeadCanvasUpdateMethod::crJXJHeadCanvasUpdateMethod(const crJXJHeadCanvasUpdateMethod& handle):
	crMethod(handle),
	m_myCanvas(handle.m_myCanvas),
	m_friendPlayerCanvas(handle.m_friendPlayerCanvas),
	m_thirdPlayerCanvas(handle.m_thirdPlayerCanvas),
	m_enemyPlayerCanvas(handle.m_enemyPlayerCanvas),
	m_friendNpcCanvas(handle.m_friendNpcCanvas),
	m_thirdNpcCanvas(handle.m_thirdNpcCanvas),
	m_enemyNpcCanvas(handle.m_enemyNpcCanvas),
	m_itemCanvas(handle.m_itemCanvas),
	m_nameWidget(handle.m_nameWidget),
	m_hpWidget(handle.m_hpWidget),
	m_perHPWidget(handle.m_perHPWidget),
	m_iconSW(handle.m_iconSW),
	m_perHPWidget_0(handle.m_perHPWidget_0),
	m_perHPWidget_1(handle.m_perHPWidget_1),
	m_perHPWidget_2(handle.m_perHPWidget_2),
	m_init(false),
	m_nameNpc(handle.m_nameNpc),
	m_nameBoss(handle.m_nameBoss),
	m_nameTa(handle.m_nameTa),
	m_strMapCanvas(handle.m_strMapCanvas),
	m_strCheckBox(handle.m_strCheckBox),
	m_perHPWidget_Zhengting(handle.m_perHPWidget_Zhengting),
	m_strJKIcon(handle.m_strJKIcon),
	m_nameZhengting(handle.m_nameZhengting),
	m_perHPWidget_JuDian(handle.m_perHPWidget_JuDian),
	m_nameJuDian(handle.m_nameJuDian),
	m_swJuDian(handle.m_swJuDian),
	m_itemSpringCanvas(handle.m_itemSpringCanvas),
	m_itemSpringSw(handle.m_itemSpringSw),
	m_itemSourceCarCanvas(handle.m_itemSourceCarCanvas),
	m_chengxiangziji(handle.m_chengxiangziji),
	m_chengxiangyou(handle.m_chengxiangyou),
	m_chengxiangdi(handle.m_chengxiangdi)
{
}
void crJXJHeadCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if (param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}
void crJXJHeadCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_myCanvas = str;
		break;
	case 1:
		m_friendPlayerCanvas = str;
		break;
	case 2:
		m_thirdPlayerCanvas = str;
		break;
	case 3:
		m_enemyPlayerCanvas = str;
		break;
	case 4:
		m_friendNpcCanvas = str;
		break;
	case 5:
		m_thirdNpcCanvas = str;
		break;
	case 6:
		m_enemyNpcCanvas = str;
		break;
	case 7:
		m_itemCanvas = str;
		break;
	case 8:
		m_nameWidget = str;
		break;
	case 9:
		m_hpWidget = str;
		break;
	case 10:
		m_perHPWidget = str;
		break;
	case 11:
		m_iconSW = str;
		break;
	case 12:
		m_perHPWidget_0 = str;
		break;
	case 13:
		m_perHPWidget_1 = str;
		break;
	case 14:
		m_perHPWidget_2 = str;
		break;
	case 15:
		m_nameNpc = str;
		break;
	case 16:
		m_nameBoss = str;
		break;
	case 17:
		m_nameTa = str;
		break;
	case 18:
		m_strMapCanvas = str;
		break;
	case 19:
		m_strCheckBox = str;
		break;
	case 20:
		m_perHPWidget_Zhengting = str;
		break;
	case 21:
		m_strJKIcon = str;
		break;
	case 23:
		m_nameZhengting = str;
		break;
	case 24:
		m_perHPWidget_JuDian = str;
		break;
	case 25:
		m_nameJuDian = str;
		break;
	case 26:
		m_swJuDian = str;
		break;
	case 27:
		m_itemSpringCanvas = str;
		break;
	case 28:
		m_itemSpringSw = str;
		break;
	case 29:
		m_itemSourceCarCanvas = str;
		break;
	case 30:
		m_chengxiangziji = str;
		break;
	case 31:
		m_chengxiangyou = str;
		break;
	case 32:
		m_chengxiangdi = str;
		break;
	case 33:
		m_ExtraGCanvas = str;
		break;
	case 34:
		m_ExtraFCanvas = str;
		break;
	case 35:
		m_ExtraQCanvas = str;
		break;
	}
}
void crJXJHeadCanvasUpdateMethod::init()
{
	m_myCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_myCanvas);
	m_friendPlayerCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_friendPlayerCanvas);
	m_thirdPlayerCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_thirdPlayerCanvas);
	m_enemyPlayerCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_enemyPlayerCanvas);
	m_friendNpcCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_friendNpcCanvas);
	m_thirdNpcCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_thirdNpcCanvas);
	m_enemyNpcCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_enemyNpcCanvas);
	m_springItemCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_itemSpringCanvas);
	m_souceCarItemCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_itemSourceCarCanvas);
	m_extraGCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_ExtraGCanvas);
	m_extraFCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_ExtraFCanvas);
	m_extraQCanvasTemp = crFilterRenderManager::getInstance()->findCanvas(m_ExtraQCanvas);
	m_init = true;
}
void crJXJHeadCanvasUpdateMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
	if(me&&bindview&&bindview->isInited() && itemtab.valid())
	{
		if(!m_init)
			init();
		if(!m_myCanvasTemp.valid())
			return;
		crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
		if(!room)
			return;
		ref_ptr<crSceneView> sceneView = bindview->getDefaultSceneHandler()->getSceneView();
		crVector3 window,pos;

		crGroup *canvasRoot = crFilterRenderManager::getInstance()->getMainCanvas();
		ref_ptr<crCanvasNode >headCanvas;
		ref_ptr<crStaticTextWidgetNode> nameWidget;
		ref_ptr<crProgressWidgetNode> hpProgress;
		ref_ptr<crImageBoxWidgetNode> imgWidget;
		//ref_ptr<crProgressWidgetNode> perHpProgress;
		ref_ptr<crMultiSwitch> shiliSW;
		ref_ptr<crMultiSwitch> canAddArmySw;
		char isEnemy = 0;
		crRole *player;
		crData *itemData;
		float scale = 1.0f;
		unsigned int guisestate;
		void *param;
		//int i = 0;
		//int j = 0;
		//int k = 0;
		//int myCount = m_myCanvasVec.size();
		float maxhp,rthp;
		/*unsigned short*/int armyCount,rtArmyCount;
		unsigned char shiliid;
		int perHP = 0;
		//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
		//ref_ptr<crRoomPlayer> roomMember = room->getMember(crMyPlayerData::getInstance()->getPlayerID()); 

		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		crData *myPlayerData = myPlayer->getDataClass();
		//myPlayerData->getParam(WCHDATA_JXJVipLv,param);
		//unsigned char vipLevel = *(unsigned char *)param;
		int perCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleHPBarPerCount, 0).c_str());

		crTableIO::StrVec record;
		int cardindex = itemtab->getTitleIndex("将卡类型");
		int iconindex = itemtab->getTitleIndex("picture");
		int absindex = itemtab->getTitleIndex("abstractid");
		crData *cameraData = m_this->getDataClass();
		cameraData->getParam(WCHDATA_JXJCampAddArmyTimer, param);
		float canAddArmyTimer = *(float *)param;
		//ref_ptr<crTableIO> dataRoleAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);
		//ref_ptr<crTableIO> dataNPCAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
		//char name[64];
		std::string characterName;
		crViewMatterObject *bot;
		crObject *obj;
		crStateSet *stateset;
		crTexMat *tm;
		//crData * headCanvasData = NULL;
		unsigned char itemstate;
		std::string strJkIconImg;
		//crMultiSwitch *bodySwitch;
		//crTableIO::StrVec record;
		crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		data->getParam(WCHDATA_JXJShiliID,param);
		unsigned char myShili = *(unsigned char *)param;
		for( VisiableCanvasNodeList::iterator itr = m_visiableCanvasNodeList.begin();
			itr != m_visiableCanvasNodeList.end();
			++itr )
		{
			(*itr)->setVisiable(false);
		}
		m_visiableCanvasNodeList.clear();

		crMyPlayerData::getInstance()->lockMyRoleNpcMap();
		crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
		for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
			itr != myRoles.end();
			++itr )
		{
			player = itr->second.first.get();
			bot = dynamic_cast<crViewMatterObject *>(player->getRelNode());
			if(!bot->getVisiable())
				continue;
			itemData = player->getDataClass();
			if(!itemData) continue;
			itemData->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate == IS_Dead)
			{
				continue;
			}
			guisestate = GS_Normal;
			player->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & GS_NoAttack)
			{
				continue;
			}
			pos = bot->getTrans();	
			//if(dataRoleAttrTab->queryOneRecord(0,crArgumentParser::appItoa(player->getAbstractItemID()),record)>=0)
			//	pos[2] += atof(record[ dataRoleAttrTab->getTitleIndex("血条高度")].c_str());
			//else
			pos[2]+=bot->getBoundBox().zLength();
			//bodySwitch = dynamic_cast<crMultiSwitch *>(bot->getBody());
			if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
			{
				//if(bodySwitch)
				//	bodySwitch->setActiveSwitchSet(1);
				continue;
			}
			// 			for( FormationInfoVec::iterator itr = myteam->begin();
			// 				itr != myteam->end();
			// 				++itr )
			// 			{
			// 				if(player->getRoleID() == (*itr)->getRoleID())
			// 				{
			// 					equips = (*itr)->getEquips();
			// 					break;
			// 				}
			// 			}
			itemData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap & equipOnMap = *(EquipOnMap *)param;

			IconMap::iterator itr_icon;
			EquipOnMap::iterator itr_card = equipOnMap.begin();
			strJkIconImg.clear();
			for (;itr_card!=equipOnMap.end();itr_card++)
			{
				itr_icon = m_jkIcon.find(itr_card->first);

				if(itr_icon!=m_jkIcon.end())
				{
					strJkIconImg = itr_icon->second;
					break;
				}
				if (itemtab->queryOneRecord(absindex,crArgumentParser::appItoa(itr_card->first),record)>=0 && \
					cardindex>=0 && iconindex>=0)
				{
					if(JiangkaType_ji == atoi(record[cardindex].c_str()))
					{
						strJkIconImg = record[iconindex];
						m_jkIcon.insert(std::make_pair(itr_card->first,strJkIconImg));
						break;
					}
				}
			}

			headCanvas = m_myCanvasMap[itr->first];
			//if(i<myCount)
			//{
			//	headCanvas = m_myCanvasMap[i];
			//}
			//else
			if(!headCanvas.valid())
			{
				headCanvas = dynamic_cast<crCanvasNode *>(m_myCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
				headCanvas->setCanFocus(false);
				headCanvas->setCanvasPos(CANVAS_BOTTOM);
				headCanvas->setMsgTraverse(KM_All);
				//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
				//headCanvasData = headCanvas->getDataClass();
				//if (headCanvasData)
				//{
				//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, player);
				//}
				//canvasRoot->addChild(headCanvas);
				crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
				//m_myCanvasVec.push_back(headCanvas.get());
				m_myCanvasMap[itr->first] = headCanvas;

				nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(m_nameWidget));
				characterName = player->getIName();//roomMember->getCharacterName();
				nameWidget->setString(characterName);

				imgWidget = dynamic_cast<crImageBoxWidgetNode *>(headCanvas->getWidget(m_strJKIcon));
				if(!strJkIconImg.empty())
				{
					imgWidget->setVisiable(true);
					imgWidget->setImageName(strJkIconImg);
				}
				else
				{
					imgWidget->setVisiable(false);
				}
				ref_ptr<crPlayerGameData> playergamedata = player->getPlayerGameData();
				if (playergamedata.valid() && playergamedata->getDataClass())
				{
					ref_ptr<crData> playerdata = playergamedata->getDataClass();
					playerdata->getParam(WCHDATA_JXJPlayerGuanZhi,param);
					unsigned char guanzhi = *(unsigned char *)param;

					ref_ptr<crNode> chengxiangwidget = dynamic_cast<crNode *>(headCanvas->getChildNode(m_chengxiangziji));
					if(chengxiangwidget.valid())
					{
						if(guanzhi == 1)
							chengxiangwidget->setVisiable(true);
						else
							chengxiangwidget->setVisiable(false);
					}
				}
			}
			//i++;
			if(headCanvas.valid())
			{
				sceneView->projectObjectIntoWindow(pos,window);
				pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
				pos[2] = 0.0f;
				headCanvas->setPosition(pos);
				headCanvas->setVisiable(true);
				m_visiableCanvasNodeList.push_back(headCanvas.get());
				maxhp = 0.0f;
				//itemData->excHandle(MAKEINT64(WCH_LockData,1));
				player->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
				//itemData->excHandle(MAKEINT64(WCH_LockData,0));
				itemData->getParam(WCHDATA_JXJArmyCount,param);
				armyCount = *(/*unsigned short*/int *)param;
				itemData->getParam(WCHDATA_JXJRTArmyCount,param);
				rtArmyCount = *(/*unsigned short*/int *)param;
				perHP = maxhp;
				maxhp *= armyCount;
				//perHpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget));
				hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_hpWidget));
				if(maxhp>0.0f)
				{
					itemData->getParam(WCHDATA_RTHP,param);
					rthp = *(float*)param;
					//if(rthp == maxhp) perHpProgress->setProgress(1.0f);
					//else perHpProgress->setProgress(rthp/perHP-(int)(rthp/perHP));
					hpProgress->setProgress(rthp/maxhp);

					obj = dynamic_cast<crObject *>(hpProgress->getChild(0));								
					stateset = obj->getOrCreateStateSet();										
					tm = dynamic_cast<crTexMat *>(stateset->getTextureAttribute(0,crStateAttribute::TEXMAT));
					if(!tm)
					{
						tm = new crTexMat;
						stateset->setTextureAttribute(0, tm);
					}
					//float scale = armyCount/perCount+((armyCount/(float)perCount - armyCount/perCount)>0.5f)?1.0f:0.0f;


					scale = 3.0f+(float)((armyCount-250)/perCount);
					if (scale > 10.0f) scale = 10.0f;
					tm->setMatrix(crMatrix::scale(scale,1.0f,1.0f));
				}
				else
				{
					//perHpProgress->setProgress(0);
					hpProgress->setProgress(0);
				}
				shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_iconSW));
				if(shiliSW.valid())
				{
					shiliSW->setActiveSwitchSet(myShili-c_startShiliID);
				}
			}
		}

		//if(i<myCount)
		//{
		//	for(int ii = i; ii<myCount; ++ii)
		//	{
		//		m_myCanvasVec[ii]->setVisiable(false);
		//	}
		//}
		crMyPlayerData::getInstance()->unlockMyRoleNpcMap();
		//i = 0;
		//j = 0;
		//k = 0;
		//int friendCount = m_friendPlayerCanvasVec.size();
		//int thirdCount = m_thirdPlayerCanvasVec.size();
		//int enemyCount = m_enemyPlayerCanvasVec.size();
		ref_ptr<crData> roledata;
		ref_ptr<crNode> chengxiangwidget;
		unsigned char guanzhi = 0;

		crMyPlayerData::getInstance()->lockInRangePlayerMap();
		crMyPlayerData::InRangePlayerMap &playerMap = crMyPlayerData::getInstance()->getInRangePlayerMap();
		for( crMyPlayerData::InRangePlayerMap::iterator itr = playerMap.begin();
			itr != playerMap.end();
			++itr )
		{
			player = itr->second.first.get();
			itemData = player->getDataClass();
			if(!itemData) continue;
			itemData->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate == IS_Dead)
			{
				continue;
			}
			guisestate = GS_Normal;
			player->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & GS_NoAttack)
			{
				continue;
			}
			bot = dynamic_cast<crViewMatterObject *>(player->getRelNode());
			if(!bot->getVisiable())
				continue;
			pos = bot->getTrans();
			//if(dataRoleAttrTab->queryOneRecord(0,crArgumentParser::appItoa(player->getAbstractItemID()),record)>=0)
			//	pos[2] += atof(record[ dataRoleAttrTab->getTitleIndex("血条高度")].c_str());
			//else
			pos[2]+=bot->getBoundBox().zLength();
			//bodySwitch = dynamic_cast<crMultiSwitch *>(bot->getBody());
			if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
			{
				//if(bodySwitch)
				//	bodySwitch->setActiveSwitchSet(1);
				continue;
			}

			itemData->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap & equipOnMap = *(EquipOnMap *)param;

			IconMap::iterator itr_icon;
			EquipOnMap::iterator itr_card = equipOnMap.begin();
			strJkIconImg.clear();

			for (;itr_card!=equipOnMap.end();itr_card++)
			{
				itr_icon = m_jkIcon.find(itr_card->first);

				if(itr_icon!=m_jkIcon.end())
				{
					strJkIconImg = itr_icon->second;
					break;
				}
				if (itemtab->queryOneRecord(absindex,crArgumentParser::appItoa(itr_card->first),record)>=0 && \
					cardindex>=0 && iconindex>=0)
				{
					if(JiangkaType_ji == atoi(record[cardindex].c_str()))
					{
						strJkIconImg = record[iconindex];
						m_jkIcon.insert(std::make_pair(itr_card->first,strJkIconImg));
						break;
					}
				}
			}
			//if(bodySwitch)
			//	bodySwitch->setActiveSwitchSet(0);
			guanzhi = 0;
			roledata = player->getDataClass();
			if (roledata.valid())
			{
				roledata->getParam(WCHDATA_JXJRoleChengHao,param);
				guanzhi = *(unsigned char *)param;
				//playerdata->getParam(WCHDATA_JXJVipLv,param);
				//unsigned char viplv = *(unsigned char *)param;
			}

			//roomMember = room->getMember(player->getPlayerID());
			//if(!roomMember.valid())
			//	continue;
			headCanvas = NULL;
			isEnemy = 0;
			me->doEvent(WCH_EnemyCheck,MAKEINT64(player,&isEnemy));
			if(m_friendPlayerCanvasTemp.valid() && isEnemy==1)
			{
				//if(i<friendCount)
				//{
				//headCanvas = m_friendPlayerCanvasVec[i];
				//}
				//else
				headCanvas = m_friendPlayerCanvasMap[itr->first];
				if(!headCanvas.valid())
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_friendPlayerCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					//headCanvas->setCanFocus(true);
					//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
					//headCanvasData = headCanvas->getDataClass();
					//if (headCanvasData)
					//{
					//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, player);
					//}

					//canvasRoot->addChild(headCanvas);
					crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
					m_friendPlayerCanvasMap[itr->first] = headCanvas;
					//m_friendPlayerCanvasVec.push_back(headCanvas.get());

					nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(m_nameWidget));
					if(nameWidget.valid())
					{
						characterName = player->getIName();//roomMember->getCharacterName();
						nameWidget->setString(characterName);
					}

					chengxiangwidget = dynamic_cast<crNode *>(headCanvas->getChildNode(m_chengxiangyou));
					if(chengxiangwidget.valid())
					{
						if(guanzhi == 1)
							chengxiangwidget->setVisiable(true);
						else
							chengxiangwidget->setVisiable(false);
					}
				}
				//i++;
			}
			else if(m_thirdPlayerCanvasTemp.valid() && isEnemy == 0)
			{
				//if(j<thirdCount)
				//{
				//	headCanvas = m_thirdPlayerCanvasVec[j];
				//}
				//else
				headCanvas = m_thirdPlayerCanvasMap[itr->first];
				if(!headCanvas.valid())
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_thirdPlayerCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					//headCanvas->setCanFocus(true);
					//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
					//headCanvasData = headCanvas->getDataClass();
					//if (headCanvasData)
					//{
					//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, player);
					//}
					//canvasRoot->addChild(headCanvas);
					crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
					m_thirdPlayerCanvasMap[itr->first] = headCanvas;
					//m_thirdPlayerCanvasVec.push_back(headCanvas.get());

					nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(m_nameWidget));
					if(nameWidget.valid())
					{
						characterName = player->getIName();//roomMember->getCharacterName();
						nameWidget->setString(characterName);
					}
				}
				//j++;
			}
			else if (m_enemyPlayerCanvasTemp.valid())
			{
				//if(guisestate & GS_Hide)
				//{
				//	continue;
				//}
				//if(k<enemyCount)
				//{
				//	headCanvas = m_enemyPlayerCanvasVec[k];
				//}
				//else
				headCanvas = m_enemyPlayerCanvasMap[itr->first];
				if(!headCanvas.valid())
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_enemyPlayerCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					//headCanvas->setCanFocus(true);
					//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
					//headCanvasData = headCanvas->getDataClass();
					//if (headCanvasData)
					//{
					//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, player);
					//}
					//canvasRoot->addChild(headCanvas);
					crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
					m_enemyPlayerCanvasMap[itr->first] = headCanvas;
					//m_enemyPlayerCanvasVec.push_back(headCanvas.get());

					nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(m_nameWidget));
					if(nameWidget.valid())
					{
						characterName = player->getIName();//roomMember->getCharacterName();
						nameWidget->setString(characterName);
					}

					chengxiangwidget = dynamic_cast<crNode *>(headCanvas->getChildNode(m_chengxiangdi));
					if(chengxiangwidget.valid())
					{
						if(guanzhi == 1)
							chengxiangwidget->setVisiable(true);
						else
							chengxiangwidget->setVisiable(false);
					}
				}
				//k++;
			}
			if(headCanvas.valid())
			{
				imgWidget = dynamic_cast<crImageBoxWidgetNode *>(headCanvas->getWidget(m_strJKIcon));
				if (imgWidget.valid())
				{
					if (!strJkIconImg.empty())
					{
						imgWidget->setVisiable(true);
						imgWidget->setImageName(strJkIconImg);
					}
					else
					{
						imgWidget->setVisiable(false);
					}
				}

				sceneView->projectObjectIntoWindow(pos,window);
				pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
				pos[2] = 0.0f;
				headCanvas->setPosition(pos);
				headCanvas->setVisiable(true);
				m_visiableCanvasNodeList.push_back(headCanvas.get());
				maxhp = 0.0f;
				//itemData->excHandle(MAKEINT64(WCH_LockData,1));
				player->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
				//itemData->excHandle(MAKEINT64(WCH_LockData,0));
				itemData->getParam(WCHDATA_JXJRTArmyCount,param);
				rtArmyCount = *(/*unsigned short*/int *)param;
				itemData->getParam(WCHDATA_JXJArmyCount,param);
				armyCount = *(/*unsigned short*/int *)param;
				perHP = maxhp;
				maxhp *= armyCount;

				//perHpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget));
				hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_hpWidget));
				if(maxhp>0.0f)
				{
					itemData->getParam(WCHDATA_RTHP,param);
					rthp = *(float*)param;
					//if(rthp == maxhp)perHpProgress->setProgress(1.0f);
					//else perHpProgress->setProgress(rthp/perHP-(int)(rthp/perHP));
					hpProgress->setProgress(rthp/maxhp);

					obj = dynamic_cast<crObject *>(hpProgress->getChild(0));								
					stateset = obj->getOrCreateStateSet();										
					tm = dynamic_cast<crTexMat *>(stateset->getTextureAttribute(0,crStateAttribute::TEXMAT));
					if(!tm)
					{
						tm = new crTexMat;
						stateset->setTextureAttribute(0, tm);
					}
					//float scale = armyCount/perCount+((armyCount/(float)perCount - armyCount/perCount)>0.5f)?1.0f:0.0f;
					//tm->setMatrix(crMatrix::scale(armyCount/(float)perCount,1.0f,1.0f));
					//scale = armyCount/perCount;
					//if(scale<0.5) scale = 0.5f;

					scale = 3.0f + (float)((armyCount - 250) / perCount);
					if (scale > 10.0f) scale = 10.0f;

					tm->setMatrix(crMatrix::scale(scale,1.0f,1.0f));
				}
				else
				{
					//perHpProgress->setProgress(0);
					hpProgress->setProgress(0);
				}
				shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_iconSW));
				if(shiliSW.valid())
				{
					itemData->getParam(WCHDATA_Camp,param);
					shiliid = *(unsigned char*)param;
					//shiliid = roomMember->getGroupID();
					shiliSW->setActiveSwitchSet(shiliid-c_startShiliID);
				}
			}
		}
		//if(i<friendCount)
		//{
		//	for(int ii = i; ii<friendCount; ++ii)
		//	{
		//		m_friendPlayerCanvasVec[ii]->setVisiable(false);
		//	}
		//}
		//if(j<thirdCount)
		//{
		//	for(int ii = j; ii<thirdCount; ++ii)
		//	{
		//		m_thirdPlayerCanvasVec[ii]->setVisiable(false);
		//	}
		//}
		//if(k<enemyCount)
		//{
		//	for(int ii = k; ii<enemyCount; ++ii)
		//	{
		//		m_enemyPlayerCanvasVec[ii]->setVisiable(false);
		//	}
		//}
		crMyPlayerData::getInstance()->unlockInRangePlayerMap();

		//i = 0;
		//j = 0;
		//k = 0;
		//friendCount = m_friendNpcCanvasVec.size();
		//thirdCount = m_thirdNpcCanvasVec.size();
		//enemyCount = m_enemyNpcCanvasVec.size();
		//friendCanvas = crFilterRenderManager::getInstance()->findCanvas(m_friendNpcCanvas);
		//thirdCanvas = crFilterRenderManager::getInstance()->findCanvas(m_thirdNpcCanvas);
		//enemyCanvas = crFilterRenderManager::getInstance()->findCanvas(m_enemyNpcCanvas);

		bool isNpcShow = true;
		// 		crCamera *camera = crCameraManager::getInstance()->getMainCamera();
		// 		if(camera)
		// 		{
		// 			crData *cameraData = camera->getAttachedNode()->getDataClass();
		// 			if(cameraData)
		// 			{
		// 				cameraData->getParam(WCHDATA_JXJISShowNPCHeadCanvas,param);
		// 				isNpcShow = *(bool *)param;
		// 			}
		// 		}
		ref_ptr<crCanvasNode >mapCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strMapCanvas);
		if(mapCanvas.valid())
		{
			ref_ptr<crCheckBoxWidgetNode> checkBox = dynamic_cast<crCheckBoxWidgetNode *>(mapCanvas->getWidget(m_strCheckBox));
			if(checkBox.valid())
			{
				isNpcShow = !(checkBox->getSelect());
			}
		}

		unsigned char npcItemType = 0;

		crInstanceItem *item;
		if(isNpcShow)
		{
			//std::string perHpWeidget;
			std::string name;
			ref_ptr<crMultiSwitch> wSwitch;

			crMyPlayerData::getInstance()->lockInRangeNpcMap();
			crMyPlayerData::InRangeNpcMap &npcMap = crMyPlayerData::getInstance()->getInRangeNpcMap();
			for( crMyPlayerData::InRangeNpcMap::iterator itr = npcMap.begin();
				itr != npcMap.end();
				++itr )
			{
				item = itr->second.first.get();
				itemData = item->getDataClass();
				if(!itemData) continue;
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
				{
					continue;
				}
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if(guisestate & GS_NoAttack)
				{
					continue;
				}
				bot = dynamic_cast<crViewMatterObject *>(item->getRelNode());
				if(!bot->getVisiable())
					continue;
				pos = bot->getTrans();
				//if(dataNPCAttrTab->queryOneRecord(0,crArgumentParser::appItoa(item->getAbstractItemID()),record)>=0)
				//	pos[2] += atof(record[ dataRoleAttrTab->getTitleIndex("血条高度")].c_str());
				//else
				pos[2]+=bot->getBoundBox().zLength();	

				//bodySwitch = dynamic_cast<crMultiSwitch *>(bot->getBody());
				if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
				{
					//if(bodySwitch)
					//	bodySwitch->setActiveSwitchSet(1);
					continue;
				}
				//if(bodySwitch)
				//	bodySwitch->setActiveSwitchSet(0);
				itemData->getParam(WCHDATA_RTHP,param);
				rthp = *(float*)param;
				if(rthp <= 0.0f)
					continue;
				itemData->getParam(WCHDATA_JXJArmyCount,param);
				armyCount = *(/*unsigned short*/int *)param;
				itemData->getParam(WCHDATA_JXJNpcItemType,param);
				npcItemType = *(unsigned char *)param;
				//////将卡
				itemData->getParam(WCHDATA_EquipOnMap,param);
				EquipOnMap & equipOnMap = *(EquipOnMap *)param;

				IconMap::iterator itr_icon;
				EquipOnMap::iterator itr_card = equipOnMap.begin();
				strJkIconImg.clear();

				for (;itr_card!=equipOnMap.end();itr_card++)
				{
					itr_icon = m_jkIcon.find(itr_card->first);

					if(itr_icon!=m_jkIcon.end())
					{
						strJkIconImg = itr_icon->second;
						break;
					}
					if (itemtab->queryOneRecord(absindex,crArgumentParser::appItoa(itr_card->first),record)>=0 && \
						cardindex>=0 && iconindex>=0)
					{
						if(JiangkaType_ji == atoi(record[cardindex].c_str()))
						{
							strJkIconImg = record[iconindex];
							m_jkIcon.insert(std::make_pair(itr_card->first,strJkIconImg));
							break;
						}
					}
				}
				////////////////////////////
				headCanvas = NULL;
				isEnemy = 0;
				me->doEvent(WCH_EnemyCheck,MAKEINT64(item,&isEnemy));
				if(isEnemy==1 && m_friendNpcCanvasTemp.valid())
				{
					//if(i<friendCount)
					//{
					//	headCanvas = m_friendNpcCanvasVec[i];
					//}
					//else
					headCanvas = m_friendNpcCanvasMap[itr->first];
					if(!headCanvas.valid())
					{
						headCanvas = dynamic_cast<crCanvasNode *>(m_friendNpcCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
						headCanvas->setCanFocus(false);
						headCanvas->setCanvasPos(CANVAS_BOTTOM);
						headCanvas->setMsgTraverse(KM_All);
						//headCanvas->setCanFocus(true);
						//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
						//headCanvasData = headCanvas->getDataClass();
						//if (headCanvasData)
						//{
						//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, item);
						//}
						//canvasRoot->addChild(headCanvas);
						crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
						//m_friendNpcCanvasVec.push_back(headCanvas.get());
						m_friendNpcCanvasMap[itr->first] = headCanvas;

						wSwitch = dynamic_cast<crMultiSwitch *>(headCanvas->getChild(0));
						if (NPC_JianTa == npcItemType || NPC_ChengMen == npcItemType)
						{
							wSwitch->setActiveSwitchSet(2);
							//perHpWeidget = m_perHPWidget_2;
							name = m_nameTa;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_2));
							hpProgress->setName("$npchp");
						}
						else if (NPC_JuDian == npcItemType)
						{
							wSwitch->setActiveSwitchSet(4);
							name = m_nameJuDian;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_JuDian));
							hpProgress->setName("$npchp");
							canAddArmySw = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_swJuDian));
							canAddArmySw->setActiveSwitchSet(1);
						}
						else if(NPC_ZhengTing == npcItemType)
						{
							wSwitch->setActiveSwitchSet(3);
							//perHpWeidget = m_perHPWidget_1;
							name = m_nameZhengting;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_Zhengting));
							hpProgress->setName("$npchp");
						}
						else if(NPC_Boss == npcItemType)
						{
							wSwitch->setActiveSwitchSet(1);
							//perHpWeidget = m_perHPWidget_1;
							name = m_nameBoss;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_1));
							hpProgress->setName("$npchp");

							shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_strBossSw));
							if(shiliSW.valid())
							{
								shiliSW->setActiveSwitchSet(0);
							}
						}
						else
						{
							wSwitch->setActiveSwitchSet(0);
							//perHpWeidget = m_perHPWidget_0;
							name = m_nameNpc;

							shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_iconSW));
							if(shiliSW.valid())
							{
								itemData->getParam(WCHDATA_Camp,param);
								shiliid = *(unsigned char*)param;
								if(shiliid>2)
									shiliSW->setActiveSwitchSet(shiliid-c_startShiliID+1);
								else
									shiliSW->setActiveSwitchSet(0);
							}
						}
						nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(name));
						characterName = item->getIName();
						if(nameWidget.valid())
							nameWidget->setString(characterName);
						//hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(perHpWeidget));
						//hpProgress->setName("$npchp");
					}
					//i++;
				}
				else if(isEnemy == 0 && m_thirdNpcCanvasTemp.valid())
				{
					//if(j<thirdCount)
					//{
					//	headCanvas = m_thirdNpcCanvasVec[j];
					//}
					//else
					headCanvas = m_thirdNpcCanvasMap[itr->first];
					if(!headCanvas.valid())
					{
						headCanvas = dynamic_cast<crCanvasNode *>(m_thirdNpcCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
						headCanvas->setCanFocus(false);
						headCanvas->setCanvasPos(CANVAS_BOTTOM);
						headCanvas->setMsgTraverse(KM_All);
						//headCanvas->setCanFocus(true);
						//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
						//headCanvasData = headCanvas->getDataClass();
						//if (headCanvasData)
						//{
						//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, item);
						//}
						//canvasRoot->addChild(headCanvas);
						crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
						//m_thirdNpcCanvasVec.push_back(headCanvas.get());
						m_thirdNpcCanvasMap[itr->first] = headCanvas;

						wSwitch = dynamic_cast<crMultiSwitch *>(headCanvas->getChild(0));
						if(NPC_JianTa == npcItemType || NPC_ChengMen == npcItemType)
						{
							wSwitch->setActiveSwitchSet(2);
							//perHpWeidget = m_perHPWidget_2;
							name = m_nameTa;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_2));
							hpProgress->setName("$npchp");
						}
						else if (NPC_JuDian == npcItemType)
						{
							wSwitch->setActiveSwitchSet(4);
							name = m_nameJuDian;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_JuDian));
							hpProgress->setName("$npchp");
						}
						else if(NPC_ZhengTing == npcItemType)
						{
							wSwitch->setActiveSwitchSet(3);
							//perHpWeidget = m_perHPWidget_1;
							name = m_nameZhengting;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_Zhengting));
							hpProgress->setName("$npchp");
						}
						else if(NPC_Boss == npcItemType)
						{
							wSwitch->setActiveSwitchSet(1);
							//perHpWeidget = m_perHPWidget_1;
							name = m_nameBoss;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_1));
							hpProgress->setName("$npchp");

							shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_strBossSw));
							if(shiliSW.valid())
							{
								shiliSW->setActiveSwitchSet(1);
							}
						}
						else
						{
							wSwitch->setActiveSwitchSet(0);
							//perHpWeidget = m_perHPWidget_0;
							name = m_nameNpc;

							shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_iconSW));
							if(shiliSW.valid())
							{
								itemData->getParam(WCHDATA_Camp,param);
								shiliid = *(unsigned char*)param;
								if(shiliid>2)
									shiliSW->setActiveSwitchSet(shiliid-c_startShiliID+1);
								else
									shiliSW->setActiveSwitchSet(0);
							}
						}
						nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(name));
						characterName = item->getIName();
						if(nameWidget.valid())
							nameWidget->setString(characterName);
						//hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(perHpWeidget));
						//hpProgress->setName("$npchp");
					}
					//j++;
				}
				else if (m_enemyNpcCanvasTemp.valid())
				{
					//if(guisestate & GS_Hide)
					//{
					//	continue;
					//}
					//if(k<enemyCount)
					//{
					//	headCanvas = m_enemyNpcCanvasVec[k];
					//}
					//else
					headCanvas = m_enemyNpcCanvasMap[itr->first];
					if(!headCanvas.valid())
					{
						headCanvas = dynamic_cast<crCanvasNode *>(m_enemyNpcCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
						headCanvas->setCanFocus(false);
						headCanvas->setCanvasPos(CANVAS_BOTTOM);
						headCanvas->setMsgTraverse(KM_All);
						//headCanvas->setCanFocus(true);
						//headCanvas->setMsgTraverse(KM_Keyboard | KM_RightMouse | KM_MiddleMouse);
						//headCanvasData = headCanvas->getDataClass();
						//if (headCanvasData)
						//{
						//	headCanvasData->inputParam(WCHDATA_JXJHeadCanvasBindInstance, item);
						//}
						//canvasRoot->addChild(headCanvas);
						crLoadManager::getInstance()->requestAddNode(canvasRoot,headCanvas.get(),false);
						//m_enemyNpcCanvasVec.push_back(headCanvas.get());
						m_enemyNpcCanvasMap[itr->first] = headCanvas;

						wSwitch = dynamic_cast<crMultiSwitch *>(headCanvas->getChild(0));
						if(NPC_JianTa == npcItemType || NPC_ChengMen == npcItemType)
						{
							wSwitch->setActiveSwitchSet(2);
							//perHpWeidget = m_perHPWidget_2;
							name = m_nameTa;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_2));
							hpProgress->setName("$npchp");
						}
						else if (NPC_JuDian == npcItemType)
						{
							wSwitch->setActiveSwitchSet(4);
							name = m_nameJuDian;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_JuDian));
							hpProgress->setName("$npchp");
						}
						else if(NPC_ZhengTing == npcItemType)
						{
							wSwitch->setActiveSwitchSet(3);
							//perHpWeidget = m_perHPWidget_1;
							name = m_nameZhengting;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_Zhengting));
							hpProgress->setName("$npchp");
						}
						else if(NPC_Boss == npcItemType)
						{
							wSwitch->setActiveSwitchSet(1);
							//perHpWeidget = m_perHPWidget_1;
							name = m_nameBoss;

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_perHPWidget_1));
							hpProgress->setName("$npchp");
						}
						else
						{
							wSwitch->setActiveSwitchSet(0);
							//perHpWeidget = m_perHPWidget_0;
							name = m_nameNpc;

							shiliSW = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_iconSW));
							if(shiliSW.valid())
							{
								itemData->getParam(WCHDATA_Camp,param);
								shiliid = *(unsigned char*)param;
								if(shiliid>2)
									shiliSW->setActiveSwitchSet(shiliid-c_startShiliID+1);
								else
									shiliSW->setActiveSwitchSet(0);
							}
						}
						nameWidget = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(name));
						characterName = item->getIName();
						if(nameWidget.valid())
							nameWidget->setString(characterName);
					}
					//k++;
				}
				if(headCanvas.valid())
				{
					imgWidget = dynamic_cast<crImageBoxWidgetNode *>(headCanvas->getWidget(m_strJKIcon));
					if (imgWidget.valid())
					{
						if (!strJkIconImg.empty())
						{
							imgWidget->setVisiable(true);
							imgWidget->setImageName(strJkIconImg);
						}
						else
						{
							imgWidget->setVisiable(false);
						}
					}
					sceneView->projectObjectIntoWindow(pos,window);
					pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
					pos[2] = 0.0f;
					headCanvas->setPosition(pos);
					headCanvas->setVisiable(true);
					m_visiableCanvasNodeList.push_back(headCanvas.get());
					maxhp = 0.0f;
					//itemData->excHandle(MAKEINT64(WCH_LockData,1));
					item->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
					//itemData->excHandle(MAKEINT64(WCH_LockData,0));
					if (isEnemy == 1 && NPC_JuDian == npcItemType)
					{
						canAddArmySw = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_swJuDian));
						if (canAddArmySw.valid())
						{
							if (canAddArmyTimer <= 0.0f)
								canAddArmySw->setActiveSwitchSet(0);
							else
								canAddArmySw->setActiveSwitchSet(1);
						}
					}

					itemData->getParam(WCHDATA_JXJRTArmyCount,param);
					rtArmyCount = *(/*unsigned short*/int *)param;
					perHP = maxhp;
					maxhp *= armyCount;
					itemData->getParam(WCHDATA_JXJNpcItemType,param);
					npcItemType = *(unsigned char *)param;
					//
					if(maxhp>0.0f)
					{
						if(NPC_ZhengTing == npcItemType || \
							NPC_JianTa == npcItemType || \
							NPC_ChengMen == npcItemType || \
							NPC_Boss == npcItemType || NPC_JuDian == npcItemType)
						{//BOSS
							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget("$npchp"));

						}
						else
						{
							//if(rthp == maxhp)perHpProgress->setProgress(1.0f);
							//else perHpProgress->setProgress(rthp/perHP-(int)(rthp/perHP));

							hpProgress = dynamic_cast<crProgressWidgetNode *>(headCanvas->getWidget(m_hpWidget));
							//hpProgress->setProgress(rthp/maxhp);
						}

						hpProgress->setProgress(rthp / maxhp);
						obj = dynamic_cast<crObject *>(hpProgress->getChild(0));
						stateset = obj->getOrCreateStateSet();
						tm = dynamic_cast<crTexMat *>(stateset->getTextureAttribute(0, crStateAttribute::TEXMAT));
						if (!tm)
						{
							tm = new crTexMat;
							stateset->setTextureAttribute(0, tm);
						}
						//float scale = armyCount/perCount+((armyCount/(float)perCount - armyCount/perCount)>0.5f)?1.0f:0.0f;
						//tm->setMatrix(crMatrix::scale(armyCount/(float)perCount,1.0f,1.0f));
						// 							scale = armyCount/perCount;
						// 							if(scale<0.5) scale = 0.5f;

						scale = 3.0f + (float)((armyCount - 250) / perCount);
						if (scale > 10.0f) scale = 10.0f;

						tm->setMatrix(crMatrix::scale(scale, 1.0f, 1.0f));
					}
					else
					{
						//perHpProgress->setProgress(0);
						//if(armyCount != 1)
						hpProgress->setProgress(0);
					}
				}
			}
			//if(i<friendCount)
			//{
			//	for(int ii = i; ii<friendCount; ++ii)
			//	{
			//		m_friendNpcCanvasVec[ii]->setVisiable(false);
			//	}
			//}
			//if(j<thirdCount)
			//{
			//	for(int ii = j; ii<thirdCount; ++ii)
			//	{
			//		m_thirdNpcCanvasVec[ii]->setVisiable(false);
			//	}
			//}
			//if(k<enemyCount)
			//{
			//	for(int ii = k; ii<enemyCount; ++ii)
			//	{
			//		m_enemyNpcCanvasVec[ii]->setVisiable(false);
			//	}
			//}
			crMyPlayerData::getInstance()->unlockInRangeNpcMap();
		}
		//if(!isNpcShow && (friendCount>0 || enemyCount>0 || thirdCount >0))
		//{
		//	for(int ii = 0; ii<friendCount; ++ii)
		//	{
		//		m_friendNpcCanvasVec[ii]->setVisiable(false);
		//	}
		//	for(int ii = 0; ii<thirdCount; ++ii)
		//	{
		//		m_thirdNpcCanvasVec[ii]->setVisiable(false);
		//	}
		//	for(int ii = 0; ii<enemyCount; ++ii)
		//	{
		//		m_enemyNpcCanvasVec[ii]->setVisiable(false);
		//	}
		//}


		crMatrixTransform *itembot = NULL;
		crMultiSwitch * swSpring = NULL;
		crMyPlayerData::getInstance()->lockInRangeItemMap();
		crMyPlayerData::InRangeItemMap &itemMap = crMyPlayerData::getInstance()->getInRangeItemMap();
		for( crMyPlayerData::InRangeItemMap::iterator itr = itemMap.begin();
			itr != itemMap.end();
			++itr )
		{
			item = itr->second.first.get();
			itemData = item->getDataClass();
			if(!itemData) continue;
			//pos = item->getPosition();
			itembot = dynamic_cast<crMatrixTransform *>(item->getRelNode());
			if(!itembot || !itembot->getVisiable())
				continue;
			pos = itembot->getTrans();
			pos[2] += 5.0;
			if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
				continue;
			headCanvas = NULL;
			itemData->getParam(WCHDATA_JXJNpcItemType, param);
			npcItemType = *(unsigned char *)param;
			if (npcItemType!=NPC_Spring && npcItemType!=NPC_SourceCar && npcItemType!=NPC_ExtraG && npcItemType!=NPC_ExtraF && npcItemType!=NPC_ExtraQ) 
				continue;

			itemData->getParam(WCHDATA_ItemState, param);
			itemstate = *(unsigned char *)param;
			if (NPC_SourceCar == npcItemType && itemstate == IS_Dead)
				continue;

			if (NPC_Spring == npcItemType)
			{
				headCanvas = m_springNpcCanvasMap[itr->first];
			}
			else if (NPC_SourceCar == npcItemType)
			{
				headCanvas = m_sourceCarNpcCanvasMap[itr->first];
			}
			else if (NPC_ExtraG == npcItemType)
			{
				headCanvas = m_extraGNpcCanvasMap[itr->first];
			}
			else if (NPC_ExtraF == npcItemType)
			{
				headCanvas = m_extraFNpcCanvasMap[itr->first];
			}
			else if (NPC_ExtraQ == npcItemType)
			{
				headCanvas = m_extraQNpcCanvasMap[itr->first];
			}
			if (!headCanvas.valid())
			{
				if (NPC_Spring == npcItemType)
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_springItemCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					m_springNpcCanvasMap[itr->first] = headCanvas;
					crLoadManager::getInstance()->requestAddNode(canvasRoot, headCanvas.get(), false);
				}
				else if (NPC_SourceCar == npcItemType)
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_souceCarItemCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					m_sourceCarNpcCanvasMap[itr->first] = headCanvas;
					crLoadManager::getInstance()->requestAddNode(canvasRoot, headCanvas.get(), false);
				}
				else if(NPC_ExtraG == npcItemType)
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_extraGCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					m_extraGNpcCanvasMap[itr->first] = headCanvas;
					crLoadManager::getInstance()->requestAddNode(canvasRoot, headCanvas.get(), false);
				}
				else if(NPC_ExtraF == npcItemType)
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_extraFCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					m_extraFNpcCanvasMap[itr->first] = headCanvas;
					crLoadManager::getInstance()->requestAddNode(canvasRoot, headCanvas.get(), false);
				}
				else if(NPC_ExtraQ == npcItemType)
				{
					headCanvas = dynamic_cast<crCanvasNode *>(m_extraQCanvasTemp->clone(crCopyOp::DEEP_COPY_NODES | crCopyOp::DEEP_COPY_DATAS));
					headCanvas->setCanFocus(false);
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					headCanvas->setMsgTraverse(KM_All);
					m_extraQNpcCanvasMap[itr->first] = headCanvas;
					crLoadManager::getInstance()->requestAddNode(canvasRoot, headCanvas.get(), false);
				}
			}

			if(headCanvas.valid())
			{
				m_visiableCanvasNodeList.push_back(headCanvas.get());
				sceneView->projectObjectIntoWindow(pos,window);
				pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
				pos[2] = 0.0f;
				headCanvas->setPosition(pos);
				headCanvas->setVisiable(true);

				if (NPC_Spring == npcItemType )
				{
					swSpring = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_itemSpringSw));
					if (itemstate == IS_Dead)
					{
						swSpring->setActiveSwitchSet(1);
					}
					else
					{
						swSpring->setActiveSwitchSet(0);
					}

				}
			}
		}
		crMyPlayerData::getInstance()->unlockInRangeItemMap();

	}
}
/////////////////////////////////////////
//
//crJXJSelectRoleUseSkillMethod
//
/////////////////////////////////////////
crJXJSelectRoleUseSkillMethod::crJXJSelectRoleUseSkillMethod():
	m_this(NULL),
	m_index(0){}
crJXJSelectRoleUseSkillMethod::crJXJSelectRoleUseSkillMethod(const crJXJSelectRoleUseSkillMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_index(handle.m_index)
{
}
void crJXJSelectRoleUseSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJSelectRoleUseSkillMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	}
}

void crJXJSelectRoleUseSkillMethod::operator()(crHandle &handle)
{
	// 	void *param;
	// 	crData *cameraData = m_this->getDataClass();
	// 	cameraData->excHandle(MAKEINT64(WCH_LockData,1));
	// 	cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	// 	SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	// 	if(!selectMyRoles->empty())
	// 	{
	// 		crRole *role = (*selectMyRoles)[0].get();
	// 		crData *roleData = role->getDataClass();
	// 		roleData->excHandle(MAKEINT64(WCH_LockData,1));
	// 		roleData->getParam(WCHDATA_ItemState,param);
	// 		unsigned char itemstate = *((unsigned char*)param);
	// 		if(itemstate != IS_Dead)
	// 		{
	// 			int aboutUseID = 0;
	// 			roleData->getParam(WCHDATA_SkillMap,param);
	// 			SkillMap *skillmap = (SkillMap *)param;
	// 			roleData->getParam(WCHDATA_EquipOnMap,param);
	// 			EquipOnMap *equipOnMap = (EquipOnMap *)param;
	// 			int i = 0;
	// 			int index = m_index;
	// 			if(index<skillmap->size())
	// 			{
	// 				SkillMap::iterator itr = skillmap->begin();
	// 				while(i<index)
	// 				{
	// 					i++;
	// 					itr++;
	// 				}
	// 				aboutUseID = itr->second;
	// 			}
	// 			else
	// 			{
	// 				index -= skillmap->size();
	// 				if(index<equipOnMap->size())
	// 				{
	// 					EquipOnMap::iterator itr = equipOnMap->begin();
	// 					while(i<index)
	// 					{
	// 						i++;
	// 						itr++;
	// 					}
	// 					aboutUseID = itr->second;
	// 
	// 				}
	// 			}
	// 			if(aboutUseID!=0)
	// 			{
	// 				crItemChild *itemChild = role->findChildItem(aboutUseID);
	// 				crInstanceItem *item = itemChild->getInstanceItem();
	// 
	// 				UseItemParam useItemParam;
	// 				useItemParam.m_user = role;
	// 				useItemParam.m_target = NULL;
	// 				unsigned short useResult = UR_None;
	// 				item->doEvent(WCH_UseItemCheck,MAKEINT64(&useItemParam,&useResult));
	// 				if(useResult == UR_Succeed)
	// 				{
	// 					roleData->inputParam(WCHDATA_AboutToUseItemID,&aboutUseID);
	// 				}
	// 			}
	// 		}
	// 		roleData->excHandle(MAKEINT64(WCH_LockData,0));
	// 	}
	// 	cameraData->excHandle(MAKEINT64(WCH_LockData,0));
	void *param;
	crData *cameraData = m_this->getDataClass();
	//CRCore::ScopedLock<crData> lock(*cameraData);
	//cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	//SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	crVector2i equips = crVector2i(-1,-1);
	crTableIO::StrVec itemrecord;
	ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
	if(!itemtab.valid()) return;
	crMyPlayerData *me = crMyPlayerData::getInstance();
	crData *playerdata = me->getPlayerGameData()->getDataClass();
	playerdata->getParam(WCHDATA_JXJFormationInfoVec,param);
	FormationInfoVec *myteam = (FormationInfoVec *)param;
	m_index%=3;

	crRole *role = crMyPlayerData::getInstance()->getLoadedRoleByIndex(m_index);
	if (role && role->getDataClass())
	{
		crData *roleData = role->getDataClass();
		int roleid = role->getRoleID();
		roleData->excHandle(MAKEINT64(WCH_LockData, 1));
		roleData->getParam(WCHDATA_ItemState, param);
		unsigned char itemstate = *((unsigned char*)param);
		unsigned int guisestate = GS_Normal;
		role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		roleData->getParam(WCHDATA_RTHP,param);
		float rthp = *(float*)param;

		if( itemstate != IS_Dead && rthp>0.0f && 
			!(guisestate & GS_Silent) && !(guisestate & GS_Confusion) && 
			!(guisestate & GS_Sheep) && !(guisestate & GS_OnHorse) && 
			/*!(guisestate & GS_Disarm) &&*/ !(guisestate & GS_Scare) && 
			/*!(guisestate & GS_Nihility) &&*/ !(guisestate & GS_Swoon) &&
			!(guisestate & GS_Stagnate) && !(guisestate & GS_Taunt) && 
			!(guisestate & GS_ExtraShifting)/* && !(guisestate & GS_NoAttack)*/ )
		{ //不需要判断 itemid 是否为0，在此之前并未设置itemid
			int abstractID = 0;
			int aboutUseID = 0;
			for (FormationInfoVec::iterator itr = myteam->begin();
				itr != myteam->end();
				++itr)
			{
				if (roleid == (*itr)->getRoleID())
				{
					equips = (*itr)->getEquips();
					break;
				}
			}
			if (equips[0] > 0)
			{
				if (itemtab->queryOneRecord(0, crArgumentParser::appItoa(equips[0]), itemrecord) >= 0)
				{
					abstractID = atoi(itemrecord[itemtab->getTitleIndex("abstractid")].c_str());
				}
			}
			if (abstractID != 0)
			{
				roleData->getParam(WCHDATA_EquipOnMap, param);
				EquipOnMap *equipOnMap = (EquipOnMap *)param;
				crItemChild *itemChild = role->findChildItem(equipOnMap->find(abstractID)->second);
				if (itemChild && itemChild->isLoaded())
				{
					crInstanceItem *item = itemChild->getInstanceItem();
					aboutUseID = item->getInstanceItemID();
					UseItemParam useItemParam;
					useItemParam.m_user = role;
					useItemParam.m_target = NULL;
					unsigned short useResult = UR_None;
					item->doEvent(WCH_UseItemCheck, MAKEINT64(&useItemParam, &useResult));
					if (useResult == UR_Succeed)
					{
						//roleData->inputParam(WCHDATA_AboutToUseItemID,&aboutUseID);
						AboutUseItemPair useItempair(role, aboutUseID);
						cameraData->inputParam(WCHDATA_JXJRoleAboutToUseItemID, &useItempair);
					}
				}
			}
		}
		roleData->excHandle(MAKEINT64(WCH_LockData, 0));
	}
}
/////////////////////////////////////////
//
//crJXJGetRoleUseSkillMethod
//
/////////////////////////////////////////
crJXJGetRoleUseSkillMethod::crJXJGetRoleUseSkillMethod():
	m_this(NULL){}
crJXJGetRoleUseSkillMethod::crJXJGetRoleUseSkillMethod(const crJXJGetRoleUseSkillMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJGetRoleUseSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJGetRoleUseSkillMethod::addParam(int i, const std::string& str)
{
}

void crJXJGetRoleUseSkillMethod::operator()(crHandle &handle)
{
	int _case = 0;
	bool isselect = true;
	void *param;
	crData *cameraData = m_this->getDataClass();
	if(!cameraData) return;
	CRCore::ScopedLock<crData> lock(*cameraData);
	cameraData->getParam(WCHDATA_JXJCameraOperator,param);
	unsigned short attackToPos = *(unsigned short *)param;

	//cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	//SelectMyRoleVec *selemyroles = (SelectMyRoleVec*)param;

	if(attackToPos == Cam_AttackToPos || attackToPos == Cam_MoveToPos || attackToPos == Cam_Signal || attackToPos == Cam_Patrol)
	{
		_case = 3;
	}
	else if(attackToPos == Cam_Default)
	{
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		//cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
		//SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
		cameraData->getParam(WCHDATA_JXJRoleAboutToUseItemID,param);
		AboutUseItemPair *useItemPair = (AboutUseItemPair *)param;

		//if(selemyroles->size()==0) _case=1;

		if(useItemPair)
		{
			crRole *role = useItemPair->first.get();
			crVector3 pos;
			crMatrixTransform *bot;
			if(role)
			{
				crData *roleData = role->getDataClass();
				int itemid = useItemPair->second;
				unsigned int guisestate = GS_Normal;
				role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				roleData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				roleData->getParam(WCHDATA_RTHP,param);
				float rthp = *(float*)param;

				if( itemstate != IS_Dead && rthp>0.0f && itemid != 0 && 
					!(guisestate & GS_Silent) && !(guisestate & GS_Confusion) && 
					!(guisestate & GS_Sheep) && !(guisestate & GS_OnHorse) && 
					/*!(guisestate & GS_Disarm) &&*/ !(guisestate & GS_Scare) && 
					/*!(guisestate & GS_Nihility) &&*/ !(guisestate & GS_Swoon) &&
					!(guisestate & GS_Stagnate) && !(guisestate & GS_Taunt) && 
					!(guisestate & GS_ExtraShifting)/* && !(guisestate & GS_NoAttack)*/ )
				{
					crItemChild *itemChild = role->findChildItem(itemid);
					if(itemChild && itemChild->isLoaded())
					{
						unsigned short range = 0;
						crInstanceItem *item = itemChild->getInstanceItem();
						crData *itemData = item->getDataClass();

						itemData->getParam(WCHDATA_ItemUseRange,param);
						if(param)
						{
							range = *(unsigned short *)param;
							if(range == 0)
							{
								//直接释放技能
								bot = dynamic_cast<crMatrixTransform *>(role->getRelNode());
								if(bot && bot->getVisiable())
								{
									pos = role->getPosition()+role->getDir() * 0.5f;
									unsigned char itemstate = IS_UseItem;
									roleData->inputParam(WCHDATA_ItemState,&itemstate);
									unsigned char targettype = Target_Coord;
									roleData->inputParam(WCHDATA_TargetType,&targettype);
									//int playerid = myPlayer->getPlayerID();
									//int roleid = role->getRoleID();
									//roleData->inputParam(WCHDATA_TargetID,NULL);
									//roleData->inputParam(WCHDATA_TargetRoleID,NULL);							
									roleData->inputParam(WCHDATA_TargetPos,&pos);	
									roleData->inputParam(WCHDATA_AboutToUseItemID,&itemid);
									_case = 4;
								}
							}
							else
							{
								itemData->getParam(WCHDATA_ItemUseScope,param);
								if(param)
								{//作用范围
									short scope = *(short *)param;
									if(scope>=0)//>=0
									{//范围施法
										_case = 2;
									}
									else if(scope < 0)
									{//目标施法
										_case = 1;
									}
								}
								else
								{
									_case = 1;
								}
							}
						}
					}
				}
			}
		}
	}
	handle.outputParam(0,&_case);
}
/////////////////////////////////////////
//
//crJXJHideUseSkillDecalMethod
//
/////////////////////////////////////////
crJXJHideUseSkillDecalMethod::crJXJHideUseSkillDecalMethod():
	m_this(NULL){}
crJXJHideUseSkillDecalMethod::crJXJHideUseSkillDecalMethod(const crJXJHideUseSkillDecalMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJHideUseSkillDecalMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJHideUseSkillDecalMethod::addParam(int i, const std::string& str)
{
}

void crJXJHideUseSkillDecalMethod::operator()(crHandle &handle)
{
	void *param;
	crData *cameraData = m_this->getDataClass();
	cameraData->getParam(WCHDATA_JXJUseSkillDecal,param);
	crNode *decalNode = (crNode *)param;
	cameraData->getParam(WCHDATA_JXJUseSkillRangeNodeMap,param);
	SkillRangeNodeMap *skillRangeNodeMap = (SkillRangeNodeMap *)param;
	if(decalNode)
	{
		//crDecalUpdateCallback *callback = dynamic_cast<crDecalUpdateCallback *>(decalNode->getUpdateCallback("DecalUpdate"));
		//if(callback)
		//{
		//	callback->setVisiable(false);
		//}
		crMatrixTransform * skillRangeMatrix = dynamic_cast<crMatrixTransform *>(decalNode);
		if(skillRangeMatrix)
		{
			skillRangeMatrix->setVisiable(false);
		}
	}
	if(!skillRangeNodeMap->empty())
	{
		SkillRangeNodeMap::iterator itr_node = skillRangeNodeMap->begin();
		for(;itr_node!=skillRangeNodeMap->end();itr_node++)
		{
			if(itr_node->second.valid())
			{
				crMatrixTransform * skillRangeMatrix = dynamic_cast<crMatrixTransform *>(itr_node->second.get());
				if(skillRangeMatrix)
				{
					skillRangeMatrix->setVisiable(false);
				}
			}
		}

	}
}
/////////////////////////////////////////
//
//crJXJUseSkillMethod
//
/////////////////////////////////////////
crJXJUseSkillMethod::crJXJUseSkillMethod():
	m_this(NULL){}
crJXJUseSkillMethod::crJXJUseSkillMethod(const crJXJUseSkillMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUseSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJUseSkillMethod::addParam(int i, const std::string& str)
{
}

void crJXJUseSkillMethod::operator()(crHandle &handle)
{
	void *param;
	crData *cameraData = m_this->getDataClass();
	CRCore::ScopedLock<crData> lock(*cameraData);
	//cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	//SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	cameraData->getParam(WCHDATA_JXJRoleAboutToUseItemID,param);
	AboutUseItemPair *useItemPair = (AboutUseItemPair *)param;
	crRole *role = useItemPair->first.get();
	if(role)
	{
		crData *roleData = role->getDataClass();
		int itemid = useItemPair->second;
		if(itemid != 0)
		{
			crItemChild *itemChild = role->findChildItem(itemid);
			if(itemChild && itemChild->isLoaded())
			{
				crInstanceItem *item = itemChild->getInstanceItem();
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemUseScope,param);
				short scope = 0;
				if(param)
				{
					scope = *(short *)param;
				}
				if(scope>0)
				{

				}
				else
				{//check Target

				}
			}
			roleData->inputParam(WCHDATA_AboutToUseItemID,NULL);
			cameraData->inputParam(WCHDATA_JXJRoleAboutToUseItemID,NULL);
		}
	}
}
/////////////////////////////////////////
//
//crJXJCancelUseSkillMethod
//
/////////////////////////////////////////
crJXJCancelUseSkillMethod::crJXJCancelUseSkillMethod(){}
crJXJCancelUseSkillMethod::crJXJCancelUseSkillMethod(const crJXJCancelUseSkillMethod& handle):
	crMethod(handle)
{
}
void crJXJCancelUseSkillMethod::inputParam(int i, void *param)
{

}

void crJXJCancelUseSkillMethod::addParam(int i, const std::string& str)
{
}

void crJXJCancelUseSkillMethod::operator()(crHandle &handle)
{
	//void *param;
	ref_ptr<crCamera>camera = crCameraManager::getInstance()->getMainCamera();
	if(camera.valid())
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		if(cameraData)
		{
			cameraData->inputParam(WCHDATA_JXJRoleAboutToUseItemID,NULL);
			//cameraData->excHandle(MAKEINT64(WCH_LockData,1));
			//void *param;
			//cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
			//SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
			//crRole *myRole;
			//crData *roleData;
			////unsigned char itemstate = IS_Stop;
			//for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
			//	itr != selectMyRoles->end();
			//	++itr )
			//{
			//	myRole = itr->get();
			//	roleData = myRole->getDataClass();
			//	roleData->inputParam(WCHDATA_AboutToUseItemID,NULL);
			//	//roleData->inputParam(WCHDATA_ItemState,&itemstate);
			//}
			//cameraData->excHandle(MAKEINT64(WCH_LockData,0));

			//crRole *role = NULL;

			//crSetObjectOutlineColorModeVisitor selectNodeVisitor(crObject::OL_Black);
			//crMyPlayerData::getInstance()->lockMyRoleNpcMap();
			//crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
			//for (crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
			//	itr != myRoles.end();
			//	++itr)
			//{
			//	role = itr->second.first.get();
			//	role->getRelNode()->accept(selectNodeVisitor);

			//}
			//crMyPlayerData::getInstance()->unlockMyRoleNpcMap();

			//crMyPlayerData::getInstance()->lockInRangePlayerMap();
			//crMyPlayerData::InRangePlayerMap &playerMap = crMyPlayerData::getInstance()->getInRangePlayerMap();
			//for (crMyPlayerData::InRangePlayerMap::iterator itr = playerMap.begin();
			//	itr != playerMap.end();
			//	++itr)
			//{
			//	role = itr->second.first.get();
			//	role->getRelNode()->accept(selectNodeVisitor);
			//}
			//crMyPlayerData::getInstance()->unlockInRangePlayerMap();

			//crInstanceItem *item;
			//crMyPlayerData::getInstance()->lockInRangeNpcMap();
			//crMyPlayerData::InRangeNpcMap &npcMap = crMyPlayerData::getInstance()->getInRangeNpcMap();
			//for (crMyPlayerData::InRangeNpcMap::iterator itr = npcMap.begin();
			//	itr != npcMap.end();
			//	++itr)
			//{
			//	item = itr->second.first.get();
			//	item->getRelNode()->accept(selectNodeVisitor);
			//}
			//crMyPlayerData::getInstance()->unlockInRangeNpcMap();
		}
	}
}
/////////////////////////////////////////
//
//crJXJBattleFormationMethod
//
/////////////////////////////////////////
crJXJBattleFormationMethod::crJXJBattleFormationMethod():
	m_this(NULL),
	m_ea(NULL),
	m_key(49){}
crJXJBattleFormationMethod::crJXJBattleFormationMethod(const crJXJBattleFormationMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_ea(NULL),
	m_key(handle.m_key)
{
}
void crJXJBattleFormationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}

void crJXJBattleFormationMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_key = (char)(atoi(str.c_str()));
		break;
	}
}

void crJXJBattleFormationMethod::operator()(crHandle &handle)
{
	void *param;
	crData *cameraData = m_this->getDataClass();
	CRCore::ScopedLock<crData> lock(*cameraData);
	cameraData->getParam(WCHDATA_JXJBattleFormation,param);
	BattleFormationMap *battleFormationMap = (BattleFormationMap *)param;
	ItemVec& itemvec = (*battleFormationMap)[m_key];
	cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	if(m_ea->getModKeyMask() & crGUIEventAdapter::MODKEY_CTRL)
	{
		itemvec.clear();
		crInstanceItem *item;
		for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
			itr != selectMyRoles->end();
			++itr )
		{
			item = itr->get();
			itemvec.push_back(item);
		}
	}
	else
	{
		if(itemvec.empty()) return;

		// 		bool isSame = true;
		// 		do 
		// 		{
		// 			if(itemvec.size() != selectMyRoles->size())
		// 			{
		// 				isSame = false;
		// 				break;
		// 			}
		// 			for(int i=0; i<itemvec.size();i++)
		// 			{
		// 				if(dynamic_cast<crRole *>(itemvec[i].get()) != (*selectMyRoles)[i].get())
		// 				{
		// 					isSame = false;
		// 					break;
		// 				}
		// 			}
		// 		} while (0);
		// 		if(isSame)
		// 		{
		// 			if(!selectMyRoles->empty())
		// 			{
		// 				crRole *role = (*selectMyRoles)[0].get();
		// 				crVector3 pos = role->getPosition();
		// 				m_this->doEvent(WCH_CameraFocus,MAKEINT64(&pos,NULL));
		// 			}
		// 		}
		// 		else
		{
			//清除之前选中的自己人
			crNode *fxNode;
			crDecalUpdateCallback *callback;
			for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
				itr != selectMyRoles->end();
				++itr )
			{
				fxNode = (*itr)->findSceneFxNode("$SelectDecal");
				if(fxNode)
				{
					callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
					if(callback)
					{
						callback->setVisiable(false);
					}
				}
			}
			selectMyRoles->resize(0);
			crRole *role;
			for( ItemVec::iterator itr = itemvec.begin();
				itr != itemvec.end();
				++itr )
			{
				role = dynamic_cast<crRole *>(itr->get());
				if(role)
				{
					unsigned int guisestate = GS_Normal;
					role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
					{
						continue;
					}
					fxNode = role->findSceneFxNode("$SelectDecal");
					if(fxNode)
					{
						callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
						if(callback)
						{
							callback->setVisiable(true);
						}
					}
					selectMyRoles->push_back(role);
				}
			}

			bool isDoubleKeyDown = false;
			cameraData->getParam(WCHDATA_JXJKeyDownEventInfo,param);
			ref_ptr<CRProducer::crGUIEventAdapter> keyInfo = (CRProducer::crGUIEventAdapter *)param;
			if( keyInfo.valid() && m_ea &&
				keyInfo.get()->getKey() == m_ea->getKey() && m_ea->time()-keyInfo->time()<=0.5f)
				isDoubleKeyDown = true;
			cameraData->inputParam(WCHDATA_JXJKeyDownEventInfo,m_ea);

			if(!selectMyRoles->empty() && isDoubleKeyDown)
			{
				role = (*selectMyRoles)[0].get();
				crVector3 pos = role->getPosition();
				m_this->doEvent(WCH_CameraFocus,MAKEINT64(&pos,NULL));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCameraFocusMethod
//
/////////////////////////////////////////
crJXJCameraFocusMethod::crJXJCameraFocusMethod():
	m_this(NULL),
	m_onlyFocusMe(false){}
crJXJCameraFocusMethod::crJXJCameraFocusMethod(const crJXJCameraFocusMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_onlyFocusMe(false)
{
}
void crJXJCameraFocusMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCameraFocusMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_onlyFocusMe = atoi(str.c_str());
		break;
	}
}

void crJXJCameraFocusMethod::operator()(crHandle &handle)
{
	void *param;
	crData *cameraData = m_this->getDataClass();
	CRCore::ScopedLock<crData> lock(*cameraData);
	cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	if(!selectMyRoles->empty())
	{
		crRole *role = (*selectMyRoles)[0].get();
		crVector3 pos = role->getPosition();
		m_this->doEvent(WCH_CameraFocus,MAKEINT64(&pos,NULL));
	}
	else if(!m_onlyFocusMe)
	{
		cameraData->getParam(WCHDATA_SelectItem,param);
		crInstanceItem *selectItem = (crInstanceItem *)param;
		if(selectItem)
		{
			crVector3 pos = selectItem->getPosition();
			m_this->doEvent(WCH_CameraFocus,MAKEINT64(&pos,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJScenarioCameraFocusPosMethod
//
/////////////////////////////////////////
crJXJScenarioCameraFocusPosMethod::crJXJScenarioCameraFocusPosMethod(){}
crJXJScenarioCameraFocusPosMethod::crJXJScenarioCameraFocusPosMethod(const crJXJScenarioCameraFocusPosMethod& handle):
	crMethod(handle),
	m_pos(handle.m_pos)
{
}
void crJXJScenarioCameraFocusPosMethod::inputParam(int i, void *param)
{
}

void crJXJScenarioCameraFocusPosMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_pos);
		break;
	}
}

void crJXJScenarioCameraFocusPosMethod::operator()(crHandle &handle)
{
	ref_ptr<crCamera> cam = crCameraManager::getInstance()->getMainCamera();
	if(cam.valid() && cam->getAttachedNode())
	{
		crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(cam->getAttachedNode());
		if(cameraNode)
			cameraNode->doEvent(WCH_CameraFocus,MAKEINT64(&m_pos,NULL));
	}
}
/////////////////////////////////////////
//
//crJXJScenarioCameraFocusMeMethod
//
/////////////////////////////////////////
crJXJScenarioCameraFocusMeMethod::crJXJScenarioCameraFocusMeMethod(){}
crJXJScenarioCameraFocusMeMethod::crJXJScenarioCameraFocusMeMethod(const crJXJScenarioCameraFocusMeMethod& handle):
	crMethod(handle)
{
}
void crJXJScenarioCameraFocusMeMethod::inputParam(int i, void *param)
{
}

void crJXJScenarioCameraFocusMeMethod::addParam(int i, const std::string& str)
{
}

void crJXJScenarioCameraFocusMeMethod::operator()(crHandle &handle)
{
	ref_ptr<crCamera> cam = crCameraManager::getInstance()->getMainCamera();
	if(cam.valid() && cam->getAttachedNode())
	{
		crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(cam->getAttachedNode());
		if(cameraNode)
		{
			void *param;
			ref_ptr<crData> cameraData = cameraNode->getDataClass();
			if(cameraData.valid())
			{
				CRCore::ScopedLock<crData> lock(*cameraData);
				cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
				SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
				if(!selectMyRoles->empty())
				{
					crRole *role = (*selectMyRoles)[0].get();
					crVector3 pos = role->getPosition();
					cameraNode->doEvent(WCH_CameraFocus,MAKEINT64(&pos,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAttackToPosMethod
//
/////////////////////////////////////////
crJXJAttackToPosMethod::crJXJAttackToPosMethod():
	m_this(NULL){}
crJXJAttackToPosMethod::crJXJAttackToPosMethod(const crJXJAttackToPosMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJAttackToPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJAttackToPosMethod::addParam(int i, const std::string& str)
{
}

void crJXJAttackToPosMethod::operator()(crHandle &handle)
{
	void *param;
	bool isatttack = false;
	crData *cameraData = m_this->getDataClass();
	cameraData->getParam(WCHDATA_JXJCameraOperator,param);
	unsigned short attackToPos = *(unsigned short *)param;

	attackToPos = Cam_AttackToPos;
	isatttack = true;

	cameraData->inputParam(WCHDATA_JXJCameraOperator,&attackToPos);
	handle.outputParam(0,&attackToPos);
}
/////////////////////////////////////////
//
//crJXJIsAttackToPosMethod
//
/////////////////////////////////////////
crJXJIsAttackToPosMethod::crJXJIsAttackToPosMethod(){}
crJXJIsAttackToPosMethod::crJXJIsAttackToPosMethod(const crJXJIsAttackToPosMethod& handle):
	crMethod(handle)
{
}
void crJXJIsAttackToPosMethod::inputParam(int i, void *param)
{
}

void crJXJIsAttackToPosMethod::addParam(int i, const std::string& str)
{
}

void crJXJIsAttackToPosMethod::operator()(crHandle &handle)
{
	unsigned short attackToPos = Cam_Default;
	bool moveTopos = Cam_Default;
	bool isAttack = false;
	void *param;
	crCamera *camera = crCameraManager::getInstance()->getCurrentCamera();
	crData *cameraData = camera->getAttachedNode()->getDataClass();
	if(cameraData)
	{
		cameraData->getParam(WCHDATA_JXJCameraOperator,param);
		if(param)
			attackToPos = *(unsigned short *)param;
		isAttack =  ((attackToPos == Cam_AttackToPos)||(attackToPos == Cam_MoveToPos)||(attackToPos == Cam_Signal) || (attackToPos == Cam_Patrol))?true:false;
	}
	handle.outputParam(0,&isAttack);
}
/////////////////////////////////////////
//
//crJXJCancelAttackToPosMethod
//
/////////////////////////////////////////
crJXJCancelAttackToPosMethod::crJXJCancelAttackToPosMethod():
	m_this(NULL){}
crJXJCancelAttackToPosMethod::crJXJCancelAttackToPosMethod(const crJXJCancelAttackToPosMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJCancelAttackToPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCancelAttackToPosMethod::addParam(int i, const std::string& str)
{
}

void crJXJCancelAttackToPosMethod::operator()(crHandle &handle)
{
	void* param;
	unsigned short attackToPos;
	ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
	if(camera.valid())
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		cameraData->getParam(WCHDATA_JXJCameraOperator,param);
		attackToPos = *(unsigned short*)param;
		if(attackToPos == Cam_AttackToPos)
		{
			attackToPos = Cam_Default;
			cameraData->inputParam(WCHDATA_JXJCameraOperator,&attackToPos);
		}
	}	
}
/////////////////////////////////////////
//
//crJXJCancelCameraOperatorMethod
//
/////////////////////////////////////////
crJXJCancelCameraOperatorMethod::crJXJCancelCameraOperatorMethod():
	m_this(NULL){}
crJXJCancelCameraOperatorMethod::crJXJCancelCameraOperatorMethod(const crJXJCancelCameraOperatorMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJCancelCameraOperatorMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCancelCameraOperatorMethod::addParam(int i, const std::string& str)
{
}

void crJXJCancelCameraOperatorMethod::operator()(crHandle &handle)
{
	unsigned short attackToPos;
	ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
	if(camera.valid())
	{
		crData *cameraData = camera->getAttachedNode()->getDataClass();
		attackToPos = Cam_Default;
		cameraData->inputParam(WCHDATA_JXJCameraOperator,&attackToPos);
	}	
}
/////////////////////////////////////////
//
//crJXJRoleLoadDataAttrFromTabMethod
//
/////////////////////////////////////////
crJXJRoleLoadDataAttrFromTabMethod::crJXJRoleLoadDataAttrFromTabMethod():
	m_tableid(WCHDATA_RoleDataAttrTab){}
crJXJRoleLoadDataAttrFromTabMethod::crJXJRoleLoadDataAttrFromTabMethod(const crJXJRoleLoadDataAttrFromTabMethod& handle):
	crMethod(handle),
	m_tableid(handle.m_tableid)
{
}
void crJXJRoleLoadDataAttrFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJRoleLoadDataAttrFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	}
}

void crJXJRoleLoadDataAttrFromTabMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	ref_ptr<crTableIO> dataAttrTab = crGlobalHandle::gData()->gGlobalTable(m_tableid);
	if(dataAttrTab.valid() && dynamic_cast<crRoleData *>(data))
	{
		int sightid = dataAttrTab->getTitleIndex("视野");
		int guardid = dataAttrTab->getTitleIndex("警戒");
		int eyeheightid = dataAttrTab->getTitleIndex("眼睛高度");
		int hpid = dataAttrTab->getTitleIndex("HP");
		int mpid = dataAttrTab->getTitleIndex("MP");
		int attackid = dataAttrTab->getTitleIndex("攻击力");
		int defendid = dataAttrTab->getTitleIndex("护甲");
		int defendtypeid = dataAttrTab->getTitleIndex("护甲类型");
		int magicdefendid = dataAttrTab->getTitleIndex("法术抗性");
		int speedid = dataAttrTab->getTitleIndex("移动速度");
		int attackspeedid = dataAttrTab->getTitleIndex("攻击速度");
		int skillspeedid = dataAttrTab->getTitleIndex("施法速度");//CD缩减
		int halfLengthsid = dataAttrTab->getTitleIndex("半径");
		int guiseid = dataAttrTab->getTitleIndex("外形状态");
		int attackaitemid = dataAttrTab->getTitleIndex("attackid");
		//int skillaitemid = dataAttrTab->getTitleIndex("skillid");
		int critid = dataAttrTab->getTitleIndex("暴击");
		int parryid = dataAttrTab->getTitleIndex("格挡");
		int dodgeid = dataAttrTab->getTitleIndex("闪避");
		//int armycountid = dataAttrTab->getTitleIndex("数量");
		int stealthid = dataAttrTab->getTitleIndex("潜行");
		int stealthspyid = dataAttrTab->getTitleIndex("反潜行");
		int hitratioid = dataAttrTab->getTitleIndex("命中率");
		int levelid = dataAttrTab->getTitleIndex("等级");
		int trooptypeid = dataAttrTab->getTitleIndex("兵种");
		//int baseenmitid = dataAttrTab->getTitleIndex("基础仇恨");
		crTableIO::StrVec record;
		//int id = m_this->getInstanceItemID();
		//if(m_tableid == WCHDATA_RoleDataAttrTab)
		int addmpid = dataAttrTab->getTitleIndex("普通攻击增加MP");
		int damagempid = dataAttrTab->getTitleIndex("受击增加MP");
		int id = m_this->getAbstractItemID();
		if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
		{
			if(trooptypeid>0)
			{
				unsigned char type = (unsigned char)atoi(record[trooptypeid].c_str());
				data->inputParam(WCHDATA_JXJTroopType,&type);
			}
			if(sightid>0)
			{
				float range = atof(record[sightid].c_str());
				range /= crGlobalHandle::gData()->gUnitScale();
				short sightRange = (short)range;
				data->inputParam(WCHDATA_SightRange,&sightRange);
			}
			if(guardid>0)
			{
				float range = atof(record[guardid].c_str());
				range /= crGlobalHandle::gData()->gUnitScale();
				short guardRange = (short)range;
				data->inputParam(WCHDATA_GuardRange,&guardRange);
			}
			if(eyeheightid>0)
			{
				float height = atof(record[eyeheightid].c_str());
				height /= crGlobalHandle::gData()->gUnitScale();
				short eyeHeight = (short)height;
				data->inputParam(WCHDATA_EyeHeight,&eyeHeight);
			}
			if(hpid>0)
			{
				int hp = atoi(record[hpid].c_str());
				data->inputParam(WCHDATA_HP,&hp);
			}
			if(mpid>0)
			{
				int mp = atoi(record[mpid].c_str());
				data->inputParam(WCHDATA_MP,&mp);
			}
			if(attackid>0)
			{
				int attack = atoi(record[attackid].c_str());
				data->inputParam(WCHDATA_Attack,&attack);
			}
			if(defendid>0)
			{
				int defend = atoi(record[defendid].c_str());
				data->inputParam(WCHDATA_Defend,&defend);
			}
			if(defendtypeid>0)
			{
				unsigned char defendtype = (unsigned char)(atoi(record[defendtypeid].c_str()));
				data->inputParam(WCHDATA_ArmourType,&defendtype);
			}
			if(magicdefendid>0)
			{
				short defend = atoi(record[magicdefendid].c_str());
				data->inputParam(WCHDATA_MagicDefend,&defend);
			}
			if(speedid>0)
			{
				float speed = atof(record[speedid].c_str());
				speed /= crGlobalHandle::gData()->gUnitScale();
				short _speed = (short)speed;
				data->inputParam(WCHDATA_Speed,&_speed);
			}
			if(attackspeedid>0)
			{
				short aspeed = (short)(atoi(record[attackspeedid].c_str()));
				data->inputParam(WCHDATA_AttackSpeed,&aspeed);
			}
			if(skillspeedid>0)
			{
				short sspeed = (short)(atoi(record[skillspeedid].c_str()));
				data->inputParam(WCHDATA_SkillSpeed,&sspeed);
			}
			if(halfLengthsid>0)
			{
				crVector3 length;
				crArgumentParser::appAtoVec(record[halfLengthsid],length);
				data->inputParam(WCHDATA_HalfPhysicsBox,&length);
			}
			if(guiseid>0)
			{
				unsigned int gs = (unsigned int)(atoi(record[guiseid].c_str()));
				data->inputParam(WCHDATA_GuiseState,&gs);
			}
			void *param;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			if(attackaitemid>0)
			{
				int attackid = atoi(record[attackaitemid].c_str());
				if(attackid>0)
				{
					data->getParam(WCHDATA_AttackMap,param);
					AttackMap *attackMap = (AttackMap *)param;
					(*attackMap)[attackid] = 0;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//if(skillaitemid>0)
			//{
			//	int skillid = atoi(record[skillaitemid].c_str());
			//	if(skillid>0)
			//	{
			//		data->getParam(WCHDATA_SkillMap,param);
			//		SkillMap *skillMap = (SkillMap *)param;
			//		(*skillMap)[skillid] = 0;
			//		//data->getParam(WCHDATA_EquipOnMap,param);
			//		//EquipOnMap *equipOnMap = (EquipOnMap *)param;
			//		//(*equipOnMap).insert(std::make_pair(skillid,0));
			//	}
			//}
			if(critid>0)
			{
				short crit = (short)(atoi(record[critid].c_str()));
				data->inputParam(WCHDATA_Crit,&crit);
			}
			if(parryid>0)
			{
				short parry = (short)(atoi(record[parryid].c_str()));
				data->inputParam(WCHDATA_Parry,&parry);
			}
			if(dodgeid>0)
			{
				short dodge = (short)(atoi(record[dodgeid].c_str()));
				data->inputParam(WCHDATA_Dodge,&dodge);
			}
			//if(armycountid>0)
			//{
			//	unsigned short armyCount = (unsigned short)(atoi(record[armycountid].c_str()));
			//	if(armyCount==0) armyCount = 1;
			//	data->inputParam(WCHDATA_JXJArmyCount,&armyCount);
			//}
			if(stealthid>0)
			{
				float stealth = atof(record[stealthid].c_str());
				stealth /= crGlobalHandle::gData()->gUnitScale();
				short _stealth = (short)stealth;
				data->inputParam(WCHDATA_Stealth,&_stealth);
			}
			if(stealthspyid>0)
			{
				float stealthspy = atof(record[stealthspyid].c_str());
				stealthspy /= crGlobalHandle::gData()->gUnitScale();
				short _stealthspy = (short)stealthspy;
				data->inputParam(WCHDATA_StealthSpy,&_stealthspy);
			}
			if(hitratioid>0)
			{
				short hitratio = (short)(atoi(record[hitratioid].c_str()));
				data->inputParam(WCHDATA_Hitratio,&hitratio);
			}
			if(levelid>0)
			{
				unsigned char level = (unsigned char)(atoi(record[levelid].c_str()));
				data->inputParam(WCHDATA_Level,&level);
			}
			//if(baseenmitid>0)
			//{
			//	int enmit = atoi(record[baseenmitid].c_str());
			//	data->inputParam(WCHDATA_BaseEnmity,&enmit);
			//}
			if (addmpid > 0)
			{
				short addmp = atoi(record[addmpid].c_str());
				data->inputParam(WCHDATA_JXJAttackGainMP,&addmp);
			}
			if (damagempid > 0)
			{
				short addmp = atoi(record[damagempid].c_str());
				data->inputParam(WCHDATA_JXJDamageGainMP,&addmp);
			}
		}
		else
		{
			if(m_this->getItemtype() == crInstanceItem::Role)
			{
				CRCore::notify(CRCore::FATAL)<<"RoleDataAttr表里没有配置，AbstractItemID="<<m_this->getAbstractItemID()<<" InstanceItemID="<<m_this->getInstanceItemID()<<std::endl;
				//sprintf(gDebugInfo->buf(),"RoleDataAttr表里没有配置，AbstractItemID=%d InstanceItemID=%d\n\0",m_this->getAbstractItemID(),m_this->getInstanceItemID());
				//gDebugInfo->debugInfo(CRCore::FATAL);
			}
			else
			{
				CRCore::notify(CRCore::FATAL)<<"NpcDataAttr表里没有配置，AbstractItemID="<<m_this->getAbstractItemID()<<" InstanceItemID="<<m_this->getInstanceItemID()<<std::endl;
				//sprintf(gDebugInfo->buf(),"NpcDataAttr表里没有配置，AbstractItemID=%d InstanceItemID=%d\n\0",m_this->getAbstractItemID(),m_this->getInstanceItemID());
				//gDebugInfo->debugInfo(CRCore::FATAL);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRoleLoadInbornAttrFromTabMethod
//
/////////////////////////////////////////
crJXJRoleLoadInbornAttrFromTabMethod::crJXJRoleLoadInbornAttrFromTabMethod():
	m_tableid(WCHDATA_RoleInbornAttrTab),
m_inbornAbatractID(0){}
crJXJRoleLoadInbornAttrFromTabMethod::crJXJRoleLoadInbornAttrFromTabMethod(const crJXJRoleLoadInbornAttrFromTabMethod& handle):
	crMethod(handle),
	m_tableid(handle.m_tableid),
	m_inbornAbatractID(handle.m_inbornAbatractID)
{
}
void crJXJRoleLoadInbornAttrFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJRoleLoadInbornAttrFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	case 1:
		m_inbornAbatractID = atoi(str.c_str());
		break;
	}
}

void crJXJRoleLoadInbornAttrFromTabMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	ref_ptr<crTableIO> dataAttrTab = crGlobalHandle::gData()->gGlobalTable(m_tableid);
	if(dataAttrTab.valid() && dynamic_cast<crRoleData *>(data))
	{
		int ignoredefendid = dataAttrTab->getTitleIndex("穿透");
		int ignoremagicdefendid = dataAttrTab->getTitleIndex("法术穿透");
		int ignoredodgeid = dataAttrTab->getTitleIndex("无视闪避");
		int physicsbackid = dataAttrTab->getTitleIndex("反弹物伤");
		int magicbackid = dataAttrTab->getTitleIndex("反弹法伤");
		int physicsabsorbid = dataAttrTab->getTitleIndex("物理吸血");
		int magicabsorbid = dataAttrTab->getTitleIndex("法术吸血");
		int critswordid = dataAttrTab->getTitleIndex("暴击剑");
		int sputteringid = dataAttrTab->getTitleIndex("溅射");
		int physicsdmid = dataAttrTab->getTitleIndex("物伤加深");
		int skilldmid = dataAttrTab->getTitleIndex("法伤加深");
		int equipindex = dataAttrTab->getTitleIndex("equipid");
		crTableIO::StrVec record;
		int id = m_this->getInstanceItemID();
		if(m_tableid == WCHDATA_RoleInbornAttrTab)
			id = m_this->getAbstractItemID();
		if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
		{
			if(ignoredefendid>0)
			{
				short ignoredefend = (short)(atoi(record[ignoredefendid].c_str()));
				data->inputParam(WCHDATA_InbornIgnoreDefend,&ignoredefend);
			}
			if(ignoremagicdefendid>0)
			{
				short ignoredefend = (short)(atoi(record[ignoremagicdefendid].c_str()));
				data->inputParam(WCHDATA_InbornIgnoreMagicDefend,&ignoredefend);
			}
			if(ignoredodgeid>0)
			{
				unsigned char ignoredodge = (unsigned char)(atoi(record[ignoredodgeid].c_str()));
				data->inputParam(WCHDATA_InbornIgnoreDodge,&ignoredodge);
			}
			if(physicsbackid>0)
			{
				short attackDamageBack = (short)(atoi(record[physicsbackid].c_str()));
				data->inputParam(WCHDATA_InbornAttackDamageBack,&attackDamageBack);
			}
			if(magicbackid>0)
			{
				short skillback = (short)(atoi(record[magicbackid].c_str()));
				data->inputParam(WCHDATA_InbornSkillDamageBack,&skillback);
			}
			if(physicsabsorbid>0)
			{
				short physicsabsorb = (short)(atoi(record[physicsabsorbid].c_str()));
				data->inputParam(WCHDATA_InbornAttackAbsorbHP,&physicsabsorb);
			}
			if(magicabsorbid>0)
			{
				short magicabsorb = (short)(atoi(record[magicabsorbid].c_str()));
				data->inputParam(WCHDATA_InbornSkillAbsorbHP,&magicabsorb);
			}
			if(critswordid>0)
			{
				short critsword = (short)(atoi(record[critswordid].c_str()));
				data->inputParam(WCHDATA_InbornCritPower,&critsword);
			}
			if(sputteringid>0)
			{
				crVector2s vec2;
				if(crArgumentParser::appAtoVec(record[sputteringid],vec2))
				{
					void *param;
					data->getParam(WCHDATA_InbornSputtering,param);
					_crInt32 sput = *(_crInt32*)param;
					_crInt32 sputtering;
					if(sput != 0)
					{
						_crInt16 area = LOINT32(sput);
						_crInt16 percent = HIINT32(sput);
						//if(area>0)
						//	area = CRCore::minimum(area,(short)vec2[0]);
						//else
							area = (short)vec2[0];
						percent += (short)vec2[1];
						sputtering = MAKEINT32(area,percent);
					}
					else
					{
						sputtering = MAKEINT32((short)vec2[0],(short)vec2[1]);
					} 
					data->inputParam(WCHDATA_InbornSputtering,&sputtering);
				}
			}
			if(physicsdmid>0)
			{
				short attackDamage = (short)(atoi(record[physicsdmid].c_str()));
				data->inputParam(WCHDATA_InbornAttackDamage,&attackDamage);
			}
			if(skilldmid>0)
			{
				short skillDamage = (short)(atoi(record[skilldmid].c_str()));
				data->inputParam(WCHDATA_InbornSkillDamage,&skillDamage);
			}
			if(equipindex>0)
			{
				int equipid = atoi(record[equipindex].c_str());
				if(equipid>0)
				{
					void *param;
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_EquipOnMap,param);
					EquipOnMap *equipOnMap = (EquipOnMap *)param;
					(*equipOnMap).insert(std::make_pair(equipid,0));
					data->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
	if(m_inbornAbatractID>0)
	{
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_EquipOnMap,param);
		EquipOnMap *equipOnMap = (EquipOnMap *)param;
		(*equipOnMap).insert(std::make_pair(m_inbornAbatractID,0));
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSkillLoadDataAttrFromTabMethod
//
/////////////////////////////////////////
crJXJSkillLoadDataAttrFromTabMethod::crJXJSkillLoadDataAttrFromTabMethod(){}
crJXJSkillLoadDataAttrFromTabMethod::crJXJSkillLoadDataAttrFromTabMethod(const crJXJSkillLoadDataAttrFromTabMethod& handle):
	crMethod(handle)
{
}
void crJXJSkillLoadDataAttrFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJSkillLoadDataAttrFromTabMethod::addParam(int i, const std::string& str)
{
}

void crJXJSkillLoadDataAttrFromTabMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	ref_ptr<crTableIO> dataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SkillDataAttrTab);
	if(dynamic_cast<crJXJSkillData *>(data) && dataAttrTab.valid())
	{
		int dtypeid = dataAttrTab->getTitleIndex("DataType");
		int levelid = dataAttrTab->getTitleIndex("等级");
		int cdid = dataAttrTab->getTitleIndex("CD");
		int ptid = dataAttrTab->getTitleIndex("吟唱");
		int radiusid = dataAttrTab->getTitleIndex("使用半径");
		int scopeid = dataAttrTab->getTitleIndex("作用范围");
		int damageid = dataAttrTab->getTitleIndex("伤害");
		int percentDamageid = dataAttrTab->getTitleIndex("千分比伤害");
		int damagetypeid = dataAttrTab->getTitleIndex("伤害类型");
		int needmpid = dataAttrTab->getTitleIndex("消耗MP");
		int needhpid = dataAttrTab->getTitleIndex("消耗HP");
		int targettypeid = dataAttrTab->getTitleIndex("对象类型");
		int durationid = dataAttrTab->getTitleIndex("攻击有效时间");
		int equipbufid = dataAttrTab->getTitleIndex("被动Buf");
		int targetbufid = dataAttrTab->getTitleIndex("目标Buf");
		int userbufid = dataAttrTab->getTitleIndex("使用者Buf");
		int dmcountid = dataAttrTab->getTitleIndex("伤害个数");
		int usemplimitid = dataAttrTab->getTitleIndex("最低MP限制");
		crTableIO::StrVec record;
		if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getAbstractItemID()),record)>=0)
		{
			if(dtypeid>0)
			{
				unsigned char datatype = DT_Attack;
				std::string str = record[dtypeid];
				if(str == "DT_Attack")
				{
					datatype = DT_Attack;
				}
				else if(str == "DT_Skill")
				{
					datatype = DT_Skill;
				}
				else if(str == "DT_AttackThing")
				{
					datatype = DT_AttackThing;
				}
				data->inputParam(WCHDATA_DataType,&datatype);
			}
			if(levelid>0)
			{
				unsigned char lv = (unsigned char)(atoi(record[levelid].c_str()));
				data->inputParam(WCHDATA_SkillLevel,&lv);
			}
			if(cdid>0)
			{
				float cd = atof(record[cdid].c_str());
				data->inputParam(WCHDATA_CDTime,&cd);
			}
			if(ptid>0)
			{
				crVector2 vec;
				crArgumentParser::appAtoVec(record[ptid],vec);
				//float pt = atof(record[ptid].c_str());
				data->inputParam(WCHDATA_UseItemProtectTime,&vec[0]);
				data->inputParam(WCHDATA_ChantTime,&vec[1]);
			}
			if(radiusid>0)
			{
				float range = atof(record[radiusid].c_str());
				//range = CRCore::maximum(range,crGlobalHandle::gData()->gMinItemUseRange());
				range /= crGlobalHandle::gData()->gUnitScale();
				unsigned short itemUseRange = (unsigned short)range;
				data->inputParam(WCHDATA_ItemUseRange,&itemUseRange);
			}
			if(scopeid>0)
			{
				float range = atof(record[scopeid].c_str());
				range /= crGlobalHandle::gData()->gUnitScale();
				short itemUseScope = (short)range;
				data->inputParam(WCHDATA_ItemUseScope,&itemUseScope);
			}
			if(damageid>0)
			{
				int damage = atoi(record[damageid].c_str());
				data->inputParam(WCHDATA_Damage,&damage);
			}
			if(percentDamageid>0)
			{
				unsigned short percentDamage = atoi(record[percentDamageid].c_str());
				data->inputParam(WCHDATA_JXJPercentDamage,&percentDamage);
			}
			if(damagetypeid>0)
			{
				unsigned char damagetype = (unsigned char)(atoi(record[damagetypeid].c_str()));
				data->inputParam(WCHDATA_DamageType,&damagetype);
			}
			if(needmpid>0)
			{
				unsigned short needMP = (unsigned short)(atoi(record[needmpid].c_str()));
				data->inputParam(WCHDATA_NeedMP,&needMP);
			}
			if (usemplimitid > 0)
			{
				unsigned short useMPLimit = (unsigned short)(atoi(record[usemplimitid].c_str()));
				data->inputParam(WCHDATA_JXJUseMpValLimit,&useMPLimit);
			}
			if(needhpid>0)
			{
				unsigned short needHP = (unsigned short)(atoi(record[needhpid].c_str()));
				data->inputParam(WCHDATA_NeedHP,&needHP);
			}
			if(targettypeid>0)
			{
				unsigned char targetType = (unsigned char)(atoi(record[targettypeid].c_str()));
				data->inputParam(WCHDATA_TargetType,&targetType);
			}
			if(durationid>0)
			{
				float duration = atof(record[durationid].c_str());
				data->inputParam(WCHDATA_Duration,&duration);
			}
			if(equipbufid>0)
			{
				//int targetExtraID = atoi(record[targetbufid].c_str());
				crVector2s vec2;
				crArgumentParser::appAtoVec(record[equipbufid],vec2);
				_crInt32 equipExtraID = MAKEINT32(vec2[0],vec2[1]);
				data->inputParam(WCHDATA_EquipExtraID,&equipExtraID);
			}
			if(targetbufid>0)
			{
				//int targetExtraID = atoi(record[targetbufid].c_str());
				crVector2s vec2;
				crArgumentParser::appAtoVec(record[targetbufid],vec2);
				_crInt32 targetExtraID = MAKEINT32(vec2[0],vec2[1]);
				data->inputParam(WCHDATA_TargetExtraID,&targetExtraID);
			}
			if(userbufid>0)
			{
				//int userExtraID = atoi(record[userbufid].c_str());
				crVector2s vec2;
				crArgumentParser::appAtoVec(record[userbufid],vec2);
				_crInt32 userExtraID = MAKEINT32(vec2[0],vec2[1]);
				data->inputParam(WCHDATA_UserExtraID,&userExtraID);
			}
			if(dmcountid>0)
			{
				unsigned char dmcount = (unsigned char)(atoi(record[dmcountid].c_str()));
				data->inputParam(WCHDATA_DamageCount,&dmcount);
			}
		}
		else
		{
			//CRCore::notify(CRCore::FATAL)<<"SkillDataAttr表里没有配置，ID="<<m_this->getAbstractItemID()<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crJXJEquipLoadDataAttrFromTabMethod
//
/////////////////////////////////////////
crJXJEquipLoadDataAttrFromTabMethod::crJXJEquipLoadDataAttrFromTabMethod(){}
crJXJEquipLoadDataAttrFromTabMethod::crJXJEquipLoadDataAttrFromTabMethod(const crJXJEquipLoadDataAttrFromTabMethod& handle):
	crMethod(handle)
{
}
void crJXJEquipLoadDataAttrFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJEquipLoadDataAttrFromTabMethod::addParam(int i, const std::string& str)
{
}

void crJXJEquipLoadDataAttrFromTabMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO> dataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_EquipDataAttrTab);
	if(dataAttrTab.valid())
	{
		int attackspeedid = dataAttrTab->getTitleIndex("攻速");
		int skillcdid = dataAttrTab->getTitleIndex("CD缩减");
		int movespeedid = dataAttrTab->getTitleIndex("移动速度");
		int defendid = dataAttrTab->getTitleIndex("护甲值");
		int magicdefendid = dataAttrTab->getTitleIndex("法术抗性");
		int parryid = dataAttrTab->getTitleIndex("格挡几率");
		int attackid = dataAttrTab->getTitleIndex("攻击力");
		int hpid = dataAttrTab->getTitleIndex("生命值");
		int critid = dataAttrTab->getTitleIndex("暴击率");
		int dodgeid = dataAttrTab->getTitleIndex("闪避率");
		int buildattackid = dataAttrTab->getTitleIndex("攻城攻击力");
		int attackdistid = dataAttrTab->getTitleIndex("攻击距离");
		int hitratioid = dataAttrTab->getTitleIndex("命中率");
		int ignoredefendid = dataAttrTab->getTitleIndex("穿透");
		int ignoremagicdefendid = dataAttrTab->getTitleIndex("法术穿透");
		int stealthid = dataAttrTab->getTitleIndex("潜行");
		int stealthspyid = dataAttrTab->getTitleIndex("反潜行");
		int sightid = dataAttrTab->getTitleIndex("视野");
		int ignoredodgeid = dataAttrTab->getTitleIndex("无视闪避");
		int physicsbackid = dataAttrTab->getTitleIndex("反弹物伤");
		int magicbackid = dataAttrTab->getTitleIndex("反弹法伤");
		int physicsabsorbid = dataAttrTab->getTitleIndex("物理吸血");
		int magicabsorbid = dataAttrTab->getTitleIndex("法术吸血");
		int critswordid = dataAttrTab->getTitleIndex("暴击剑");
		int sputteringid = dataAttrTab->getTitleIndex("溅射");
		int physicsdmid = dataAttrTab->getTitleIndex("物伤加成");
		int skilldmid = dataAttrTab->getTitleIndex("法伤加成");
		crTableIO::StrVec record;
		if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getAbstractItemID()),record)>=0)
		{
			crData *data = m_this->getDataClass();
			if(attackspeedid>0)
			{
				short attackspeed = (short)(atoi(record[attackspeedid].c_str()));
				data->inputParam(WCHDATA_EquipAttackSpeed,&attackspeed);
			}
			if(skillcdid>0)
			{
				short skillspeed = (short)(atoi(record[skillcdid].c_str()));
				data->inputParam(WCHDATA_EquipSkillSpeed,&skillspeed);
			}
			if(movespeedid>0)
			{
				short movespeed = (short)(atoi(record[movespeedid].c_str()));
				data->inputParam(WCHDATA_EquipSpeed,&movespeed);
			}
			if(defendid>0)
			{
				short defend = (short)(atoi(record[defendid].c_str()));
				data->inputParam(WCHDATA_EquipDefend,&defend);
			}
			if(magicdefendid>0)
			{
				short defend = (short)(atoi(record[magicdefendid].c_str()));
				data->inputParam(WCHDATA_EquipMagicDefend,&defend);
			}
			if(parryid>0)
			{
				short parry = (short)(atoi(record[parryid].c_str()));
				data->inputParam(WCHDATA_EquipParry,&parry);
			}
			if(attackid>0)
			{
				short attack = (short)(atoi(record[attackid].c_str()));
				data->inputParam(WCHDATA_EquipAttack,&attack);
			}
			if(hpid>0)
			{
				short hp = (short)(atoi(record[hpid].c_str()));
				data->inputParam(WCHDATA_EquipHP,&hp);
			}
			if(critid>0)
			{
				short crit = (short)(atoi(record[critid].c_str()));
				data->inputParam(WCHDATA_EquipCrit,&crit);
			}
			if(dodgeid>0)
			{
				short dodge = (short)(atoi(record[dodgeid].c_str()));
				data->inputParam(WCHDATA_EquipDodge,&dodge);
			}
			if(buildattackid>0)
			{
				short attack = (short)(atoi(record[buildattackid].c_str()));
				data->inputParam(WCHDATA_EquipBuildAttack,&attack);
			}
			if(attackdistid>0)
			{
				short dist = (short)(atoi(record[attackdistid].c_str()));
				data->inputParam(WCHDATA_EquipAttackDist,&dist);
			}
			if(hitratioid>0)
			{
				short hitratio = (short)(atoi(record[hitratioid].c_str()));
				data->inputParam(WCHDATA_EquipHitratio,&hitratio);
			}
			if(ignoredefendid>0)
			{
				short ignoredefend = (short)(atoi(record[ignoredefendid].c_str()));
				data->inputParam(WCHDATA_EquipIgnoreDefend,&ignoredefend);
			}
			if(ignoremagicdefendid>0)
			{
				short ignoredefend = (short)(atoi(record[ignoremagicdefendid].c_str()));
				data->inputParam(WCHDATA_EquipIgnoreMagicDefend,&ignoredefend);
			}
			if(stealthid>0)
			{
				short stealth = (short)(atoi(record[stealthid].c_str()));
				data->inputParam(WCHDATA_EquipStealth,&stealth);
			}
			if(stealthspyid>0)
			{
				short stealthspy = (short)(atoi(record[stealthspyid].c_str()));
				data->inputParam(WCHDATA_EquipStealthSpy,&stealthspy);
			}
			if(sightid>0)
			{
				short sightrange = (short)(atoi(record[sightid].c_str()));
				data->inputParam(WCHDATA_EquipSightRange,&sightrange);
			}
			if(ignoredodgeid>0)
			{
				unsigned char ignoredodge = (unsigned char)(atoi(record[ignoredodgeid].c_str()));
				data->inputParam(WCHDATA_EquipIgnoreDodge,&ignoredodge);
			}
			if(physicsbackid>0)
			{
				short physicsback = (short)(atoi(record[physicsbackid].c_str()));
				data->inputParam(WCHDATA_EquipAttackDamageBack,&physicsback);
			}
			if(magicbackid>0)
			{
				short magicback = (short)(atoi(record[magicbackid].c_str()));
				data->inputParam(WCHDATA_EquipSkillDamageBack,&magicback);
			}
			if(physicsabsorbid>0)
			{
				short physicsabsorb = (short)(atoi(record[physicsabsorbid].c_str()));
				data->inputParam(WCHDATA_EquipAttackAbsorbHP,&physicsabsorb);
			}
			if(magicabsorbid>0)
			{
				short magicabsorb = (short)(atoi(record[magicabsorbid].c_str()));
				data->inputParam(WCHDATA_EquipSkillAbsorbHP,&magicabsorb);
			}
			if(critswordid>0)
			{
				unsigned char critsword = (unsigned char)(atoi(record[critswordid].c_str()));
				data->inputParam(WCHDATA_EquipCritSword,&critsword);
			}
			if(sputteringid>0)
			{
				//unsigned char critsword = (unsigned char)(atoi(record[sputteringid].c_str()));
				crVector2s vec2;
				crArgumentParser::appAtoVec(record[sputteringid],vec2);
				_crInt32 sputtering = MAKEINT32(vec2[0],vec2[1]);
				data->inputParam(WCHDATA_EquipSputtering,&sputtering);
			}
			if(physicsdmid>0)
			{
				short physicsdm = (short)(atoi(record[physicsdmid].c_str()));
				data->inputParam(WCHDATA_EquipAttackDamage,&physicsdm);
			}
			if(skilldmid>0)
			{
				short skilldm = (short)(atoi(record[skilldmid].c_str()));
				data->inputParam(WCHDATA_EquipSkillDamage,&skilldm);
			}
		}
		else
		{
			//CRCore::notify(CRCore::FATAL)<<"EquipDataAttr表里没有配置，ID="<<m_this->getAbstractItemID()<<std::endl;
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoadNpcPatrolFromTabMethod
//
/////////////////////////////////////////
crJXJLoadNpcPatrolFromTabMethod::crJXJLoadNpcPatrolFromTabMethod(){}
crJXJLoadNpcPatrolFromTabMethod::crJXJLoadNpcPatrolFromTabMethod(const crJXJLoadNpcPatrolFromTabMethod& handle):
	crMethod(handle)
{
}
void crJXJLoadNpcPatrolFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJLoadNpcPatrolFromTabMethod::addParam(int i, const std::string& str)
{
}

void crJXJLoadNpcPatrolFromTabMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO> dataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcPatrolTab);
	if(dataAttrTab.valid())
	{
		float scale = crGlobalHandle::gData()->gUnitScale();
		void *param;
		crData *data = m_this->getDataClass();
		crVector2 vec2;
		crTableIO::StrVec record;
		if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getInstanceItemID()),record)>=0)
		{
			int columncount = dataAttrTab->getColumnCount();

			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_PatrolPointVec,param);
			PatrolPointVec *patrolPointVec = (PatrolPointVec *)param;
			if(patrolPointVec)
			{
				patrolPointVec->clear();
				for( int i = 2; i<columncount; )
				{
					if(!record[i].empty())
					{
						vec2[0] = atof(record[i++].c_str()) * scale;
						vec2[1] = atof(record[i++].c_str()) * scale;
						patrolPointVec->push_back(vec2);
					}
					else
					{
						break;
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
		else
		{
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_PatrolPointVec,param);
			PatrolPointVec *patrolPointVec = (PatrolPointVec *)param;
			if(patrolPointVec)
			{
				patrolPointVec->clear();
				vec2[0] = m_this->getPosx()* scale;
				vec2[1] = m_this->getPosy()* scale;
				patrolPointVec->push_back(vec2);
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerMoveToMethod
//
/////////////////////////////////////////
crJXJPlayerMoveToMethod::crJXJPlayerMoveToMethod():
	m_this(NULL),
	m_inputPos(true){}
crJXJPlayerMoveToMethod::crJXJPlayerMoveToMethod(const crJXJPlayerMoveToMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_inputPos(handle.m_inputPos),
	m_targetPos(handle.m_targetPos)
{
}
void crJXJPlayerMoveToMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(m_inputPos && param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_targetPos = *(crVector3*)(LOINT64(param64));
		}
		break;
	}
}
void crJXJPlayerMoveToMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_targetPos);
		m_inputPos = false;
		break;
	}
}
void crJXJPlayerMoveToMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this) && crRunGameHandle::getInstance()->isInGame())
	{
		unsigned int guisestate = GS_Normal;
		m_this->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_Garrison || guisestate & GS_Fetter || guisestate & GS_Swoon || guisestate & GS_Stagnate || guisestate & GS_ExtraShifting || guisestate & GS_Confusion)
		{//不可移动
			return;
		}
		void *param;
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if(camera.valid())
		{
			crData *cameraData = camera->getAttachedNode()->getDataClass();
			cameraData->getParam(WCHDATA_JXJCameraOperator,param);
			unsigned short attackToPos = *(unsigned short *)param;
			cameraData->inputParam(WCHDATA_JXJCameraOperator,NULL);

			crData *data = m_this->getDataClass();
			unsigned char itemstate = attackToPos==Cam_AttackToPos?IS_AttackToPos:IS_MoveToPos;
			data->inputParam(WCHDATA_ItemState,&itemstate);
			data->inputParam(WCHDATA_TargetPos,&m_targetPos);
			data->inputParam(WCHDATA_MoveToPos,&m_targetPos);
			unsigned char targettype = Target_Coord;
			data->inputParam(WCHDATA_TargetType,&targettype);
			crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
			//crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			//if(netConductor)
			//{
			//	ref_ptr<crStreamBuf>stream = new crStreamBuf;
			//	stream->createBuf(14);
			//	stream->_writeUChar(targettype);
			//	stream->_writeUChar(itemstate);
			//	stream->_writeVec3(m_targetPos);
			//	crPlayerEventPacket packet;
			//	crPlayerEventPacket::buildRequestPacket(packet,m_this->getRoleID(),WCH_NetControl2,stream.get());
			//	netConductor->getNetManager()->sendPacket("all",packet);
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetItemRTDataMethod
//
/////////////////////////////////////////
crJXJGetItemRTDataMethod::crJXJGetItemRTDataMethod(){}
crJXJGetItemRTDataMethod::crJXJGetItemRTDataMethod(const crJXJGetItemRTDataMethod& handle):
	crMethod(handle)
{
}
void crJXJGetItemRTDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_outstream = (CRCore::ref_ptr<crStreamBuf> *)(LOINT64(param64));
		}
		else
		{
			m_outstream = NULL;
		}
		break;
	}
}
void crJXJGetItemRTDataMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetItemRTDataMethod::operator()(crHandle &handle)
{
	if(m_outstream)
	{
		void *param;
		crData *thisData = m_this->getDataClass();

		*m_outstream = new crStreamBuf;
		//if(m_this->getItemtype() == crInstanceItem::Role)
		//	(*m_outstream)->createBuf(44);
		//else
		unsigned char itemtype = m_this->getItemtype();
		if(itemtype == crInstanceItem::Role)
			(*m_outstream)->createBuf(256);//256
		else if(itemtype == crInstanceItem::Npc)
			(*m_outstream)->createBuf(49);//49
		else
			(*m_outstream)->createBuf(26);

		(*m_outstream)->_writeFloat(m_this->getPosx());
		(*m_outstream)->_writeFloat(m_this->getPosy());
		//(*m_outstream)->_writeFloat(m_this->getPosz());
		(*m_outstream)->_writeFloat(m_this->getDirx());
		(*m_outstream)->_writeFloat(m_this->getDiry());
		(*m_outstream)->_writeFloat(m_this->getDirz());//20

		thisData->getParam(WCHDATA_GuiseState,param);
		unsigned int guisestate = *(unsigned int*)param;
		(*m_outstream)->_writeUInt(guisestate);//4
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char*)param;
		(*m_outstream)->_writeUChar(itemstate);//1
		thisData->getParam(WCHDATA_Camp,param);
		unsigned char camp = *(unsigned char*)param;
		(*m_outstream)->_writeUChar(camp);//1
		if(itemtype==crInstanceItem::Npc || itemtype==crInstanceItem::Role)
		{
			thisData->getParam(WCHDATA_TargetType,param);
			unsigned char targetType = *(unsigned char*)param;
			(*m_outstream)->_writeUChar(targetType);//1
			if(targetType & Target_Instance || targetType & Target_StaticNpc/* || targetType & Target_StaticItem*/)
			{
				thisData->getParam(WCHDATA_TargetID,param);
				int targetid = *(int*)param;
				(*m_outstream)->_writeInt(targetid);//4
				if(targetType & Target_Role)
				{
					thisData->getParam(WCHDATA_TargetRoleID,param);
					int targetroleid = *(int*)param;
					(*m_outstream)->_writeInt(targetroleid);//4
				}
			}
			else
			{
				thisData->getParam(WCHDATA_TargetPos,param);
				crVector3 targetPos = *(crVector3*)param;
				(*m_outstream)->_writeVec3(targetPos);//12
			}

			//thisData->getParam(WCHDATA_FollowDistance,param);
			//float followDistance = *(float*)param;
			//(*m_outstream)->_writeFloat(followDistance);//4

			thisData->getParam(WCHDATA_RTHP,param);
			float rthp = *((float*)param);
			(*m_outstream)->_writeFloat(rthp);//4
			thisData->getParam(WCHDATA_RTMP,param);
			float rtmp = *((float*)param);
			(*m_outstream)->_writeFloat(rtmp);//4
			thisData->getParam(WCHDATA_JXJRTArmyCount,param);
			/*unsigned short*/int rtcount = *((/*unsigned short*/int*)param);
			(*m_outstream)->_writeInt(rtcount);//2

			if(itemtype == crInstanceItem::Role)
			{//如果是玩家，还需要同步一些额外的信息
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_AttackMap,param);
				AttackMap *attackMap = (AttackMap *)param;
				(*m_outstream)->_writeUChar(attackMap->size());
				for( AttackMap::iterator itr = attackMap->begin();
					itr != attackMap->end();
					++itr )
				{
					(*m_outstream)->_writeInt(itr->first);
					(*m_outstream)->_writeInt(itr->second);
				}
				//thisData->getParam(WCHDATA_SkillMap,param);
				//SkillMap *skillMap = (SkillMap *)param;
				//(*m_outstream)->_writeUChar(skillMap->size());
				//for( SkillMap::iterator itr = skillMap->begin();
				//	itr != skillMap->end();
				//	++itr )
				//{
				//	(*m_outstream)->_writeInt(itr->first);
				//	(*m_outstream)->_writeInt(itr->second);
				//}
				thisData->getParam(WCHDATA_EquipOnMap,param);
				EquipOnMap *equipOnMap = (EquipOnMap *)param;
				(*m_outstream)->_writeUChar(equipOnMap->size());
				for( EquipOnMap::iterator itr = equipOnMap->begin();
					itr != equipOnMap->end();
					++itr )
				{
					(*m_outstream)->_writeInt(itr->first);
					(*m_outstream)->_writeInt(itr->second);
				}
				//////extra
				//thisData->getParam(WCHDATA_ExtraData,param);
				//if(param)
				//{
				//	crData *extraData = (crData *)param;
				//	extraData->excHandle(MAKEINT64(WCH_LockData,1));
				//	extraData->getParam(WCHDATA_ExtraIDMap,param);
				//	ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
				//	(*m_outstream)->_writeUChar(extraIDMap->size());
				//	for( ExtraIDMap::iterator itr = extraIDMap->begin();
				//		itr != extraIDMap->end();
				//		++itr )
				//	{
				//		(*m_outstream)->_writeShort(itr->first);
				//		(*m_outstream)->_writeShort(itr->second);
				//	}
				//	extraData->excHandle(MAKEINT64(WCH_LockData,0));
				//}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvItemRTDataMethod
//
/////////////////////////////////////////
crJXJRecvItemRTDataMethod::crJXJRecvItemRTDataMethod(){}
crJXJRecvItemRTDataMethod::crJXJRecvItemRTDataMethod(const crJXJRecvItemRTDataMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvItemRTDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvItemRTDataMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
		//case 0:
		//m_staticRoot = (bool)(atoi(str.c_str()));
		//	break;
	case 0:
		m_strCanvas = str;
		break;
	}
}

void crJXJRecvItemRTDataMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	unsigned char itemstate = IS_None;
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(m_stream.valid() && scene)
	{
		float x = m_stream->_readFloat();
		float y = m_stream->_readFloat();
		//pos[2] = m_stream->_readFloat();
		float scale = crGlobalHandle::gData()->gUnitScale();
		float z = scene->getPosZ(m_this->getLayerID(),x*scale,y*scale,m_this->getZoffset()*scale);
		m_this->setPosxy(x,y);
		m_this->setPosz(z/scale);
		crVector3 dir;
		dir[0] = m_stream->_readFloat();
		dir[1] = m_stream->_readFloat();
		dir[2] = m_stream->_readFloat();
		m_this->setDir(dir);
		unsigned int guisestate = m_stream->_readUInt();
		itemstate = m_stream->_readUChar();
		if(itemstate == IS_Relive)
		{
			data->excHandle(MAKEINT64(WCH_InitData,m_this));
			//itemstate = IS_Defend;
			data->inputParam(WCHDATA_AboutToUseItemID,NULL);
			float dt = 0.1f;
			m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Idle,&dt));
		}
		else if(itemstate != IS_Dead)
		{
			void *param;
			data->getParam(WCHDATA_ItemState,param);
			if(param)
			{
				unsigned char curstate = *(unsigned char *)param;
				if(curstate == IS_Dead)
				{
					data->excHandle(MAKEINT64(WCH_InitData,m_this));
					data->inputParam(WCHDATA_AboutToUseItemID,NULL);
				}
			}
		}
		data->inputParam(WCHDATA_ItemState,&itemstate);
		data->inputParam(WCHDATA_GuiseState,&guisestate);
		unsigned char camp = m_stream->_readUChar();
		data->inputParam(WCHDATA_Camp,&camp);
	}
	crNode *relNode = m_this->getRelNode();
	unsigned char itemtype = m_this->getItemtype();
	if(m_stream.valid() && itemtype>=crInstanceItem::Npc && itemtype<=crInstanceItem::Role)
	{
		if(relNode)
		{
			m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
			//node->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,crGlobalHandle::gData()->gItemVisiableDelay()));
			if(crMyPlayerData::getInstance()->isTeammateAndShareSight(m_this))
			{
				relNode->setVisiable(true);
				relNode->setEnableIntersect(true);
			}
		}
		unsigned char targetType = m_stream->_readUChar();
		data->inputParam(WCHDATA_TargetType, &targetType);
		crVector3 targetPos;
		if(targetType & Target_Instance || targetType & Target_StaticNpc/* || targetType & Target_StaticItem*/)
		{
			int targetid = m_stream->_readInt();
			data->inputParam(WCHDATA_TargetID,&targetid);
			if(targetType & Target_Role)
			{
				int targetroleid = m_stream->_readInt();
				data->inputParam(WCHDATA_TargetRoleID,&targetroleid);
			}
		}
		else
		{
			targetPos = m_stream->_readVec3();
			data->inputParam(WCHDATA_TargetPos,&targetPos);
		}
		//float followDistance = m_stream->_readFloat();
		//data->inputParam(WCHDATA_FollowDistance,&followDistance);

		float rthp = m_stream->_readFloat();
		data->inputParam(WCHDATA_RTHP,&rthp);
		float rtmp = m_stream->_readFloat();
		data->inputParam(WCHDATA_RTMP,&rtmp);
		/*unsigned short*/int rtcount = m_stream->_readInt();
		data->inputParam(WCHDATA_JXJRTArmyCount,&rtcount);
		float dt = 0.1f;
		m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_None,&dt));
		//if(relNode)
		//{
		//	if(!(targetType & Target_Instance) && itemstate >= IS_Move/* && itemstate <= IS_Patrol*/)
		//	{
		//		//float speed = 0;
		//		//m_this->doEvent(MAKEINT64(WCH_GetSpeed,NULL),MAKEINT64(&speed,NULL));
		//		//float relspeed = speed * crGlobalHandle::gData()->gUnitScale();
		//		//if(m_this == crMyPlayerData::getInstance()->getRole())
		//		//	node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&targetPos,&relspeed));
		//		//else
		//		//	node->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&targetPos,&relspeed));
		//		crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->recvPathFindRequest(m_this);
		//	}
		//	//else
		//	//{
		//	//	crVector3 nullpos;
		//	//	float speed = 0.0f;
		//	//	if(m_this == crMyPlayerData::getInstance()->getRole())
		//	//		node->doEvent(WCH_NetMoveToTarget,MAKEINT64(&nullpos,&speed));
		//	//	else
		//	//		node->doEvent(WCH_NetMoveToTarget2,MAKEINT64(&nullpos,&speed));
		//	//}
		//}
		if(itemtype == crInstanceItem::Role)
		{//如果是玩家，还应检查其身上装备的同步问题， 玩家的NetStream变化问题
			data->excHandle(MAKEINT64(WCH_LockData,1));
			unsigned char size;
			unsigned char i;
			int int1,int2;
			void *param;
			data->getParam(WCHDATA_AttackMap,param);
			AttackMap *attackMap = (AttackMap *)param;
			size = m_stream->_readUChar();
			attackMap->clear();
			for(i = 0; i<size; i++)
			{
				int1 = m_stream->_readInt();
				int2 = m_stream->_readInt();
				attackMap->insert(std::make_pair(int1,int2));
			}
			//data->getParam(WCHDATA_SkillMap,param);
			//SkillMap *skillMap = (SkillMap *)param;
			//size = m_stream->_readUChar();
			//skillMap->clear();
			//for(i = 0; i<size; i++)
			//{
			//	int1 = m_stream->_readInt();
			//	int2 = m_stream->_readInt();
			//	skillMap->insert(std::make_pair(int1,int2));
			//}
			data->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap *equipOnMap = (EquipOnMap *)param;
			size = m_stream->_readUChar();
			equipOnMap->clear();
			for(i = 0; i<size; i++)
			{
				int1 = m_stream->_readInt();
				int2 = m_stream->_readInt();
				equipOnMap->insert(std::make_pair(int1,int2));
			}
			//////extra
			//data->getParam(WCHDATA_ExtraData,param);
			//if(param)
			//{
			//	short extid,extpri;
			//	crData *extraData = (crData *)param;
			//	extraData->excHandle(MAKEINT64(WCH_LockData,1));
			//	extraData->getParam(WCHDATA_ExtraIDMap,param);
			//	ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
			//	size = m_stream->_readUChar();
			//	ExtraIDMap::iterator extitr;
			//	for( ExtraIDMap::iterator itr = extraIDMap->begin();
			//		itr != extraIDMap->end();
			//		++itr )
			//	{
			//		extid = m_stream->_readShort();
			//		extpri = m_stream->_readShort();
			//		extitr = extraIDMap->find(extid);
			//		if(extitr == extraIDMap->end())
			//		{

			//		}
			//	}
			//	extraData->excHandle(MAKEINT64(WCH_LockData,0));
			//}
			data->excHandle(MAKEINT64(WCH_LockData,0));

			data->excHandle(MAKEINT64(WCH_CheckNetData,m_this));

			ref_ptr<crCanvasNode > battleLoardCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strCanvas);
			if(battleLoardCanvas.valid())
			{
				crData *canvasData = battleLoardCanvas->getDataClass();
				if(canvasData)
				{
					canvasData->excHandle(MAKEINT64(WCH_LockData,1));
					canvasData->getParam(WCHDATA_JXJRoomMemberInfoMap,param);
					RoomMemberInfoMap *infoMap = (RoomMemberInfoMap *)param;
					RoomMemberInfoMap::iterator itr_info = infoMap->find(m_this->getID());

					if(itr_info != infoMap->end() )
					{
						itr_info->second->setValid(false);
					}

					canvasData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
		else if(itemstate == IS_Relive)
		{
			itemstate = IS_Stop;
			data->inputParam(WCHDATA_ItemState,&itemstate);
		}
		m_this->doEvent(WCH_CheckAndRackEquipOnMesh);
	}
	else
	{//只在loaditem的时候才会触发接收一次
		if(relNode)
		{
			m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
			if(m_this->getItemtype() != crInstanceItem::LocalItem)
			{
				if(crMyPlayerData::getInstance()->isTeammateAndShareSight(m_this))
				{
					relNode->setVisiable(true);
					relNode->setEnableIntersect(true);
				}
			}
			else
			{
				relNode->setVisiable(true);
				relNode->setEnableIntersect(true);
			}
		}

		//if(relNode)
		//{
		//	m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(relNode,crMatterObject::MD_FullMatrix));
		//	void *param;
		//	data->getParam(WCHDATA_ItemState,param);
		//	unsigned char itemstate = *(unsigned char *)param;
		//	if(itemstate == IS_ItemLoad)
		//	{
		//		itemstate = IS_None;
		//		data->inputParam(WCHDATA_ItemState,&itemstate);
		//		const std::string &resScript = m_this->getAbstractItem()->getResScript();
		//		if(!resScript.empty())
		//		{
		//			CREncapsulation::loadItemCfg(resScript,dynamic_cast<crGroup *>(relNode)/*,m_staticRoot*/);
		//			crData *nodeData = relNode->getDataClass();
		//			if(nodeData)
		//			{
		//				nodeData->inputParam(WCHDATA_Item,m_this);
		//			}
		//		}
		//		else
		//		{
		//			CRCore::notify(CRCore::FATAL)<<"crLoadItemMethod(): resScript是空的 "<<std::endl;
		//		}
		//	}
		//if(m_staticRoot)
		//{
		//	relNode->setVisiable(true);
		//	relNode->setEnableIntersect(true);
		//}
		//if(m_stream.valid() && !m_stream->eof())
		//{
		//	itemstate = m_stream->_readUChar();
		//	data->inputParam(WCHDATA_ItemState,&itemstate);
		//}
		//}
	}
	//CRCore::notify(CRCore::ALWAYS)<<"crRecvItemRTDataMethod pos = "<<pos<<std::endl;
}
/////////////////////////////////////////
//
//crJXJSetFubenBirthPointMethod
//
/////////////////////////////////////////
crJXJSetFubenBirthPointMethod::crJXJSetFubenBirthPointMethod():
	m_birthpoint(0)
{
}
crJXJSetFubenBirthPointMethod::crJXJSetFubenBirthPointMethod(const crJXJSetFubenBirthPointMethod& handle):
	crMethod(handle),
	m_birthpoint(handle.m_birthpoint)
{
}
void crJXJSetFubenBirthPointMethod::inputParam(int i, void *param)
{
}
void crJXJSetFubenBirthPointMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_birthpoint = (char)(atoi(str.c_str()));
		break;
	}
}
void crJXJSetFubenBirthPointMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(1);
		stream->_writeChar(m_birthpoint);
		crPlayerDataSceneEventPacket packet;
		crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvFubenBirthPoint,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvFubenBirthPointMethod
//
/////////////////////////////////////////
crJXJRecvFubenBirthPointMethod::crJXJRecvFubenBirthPointMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenBirthPointMethod::crJXJRecvFubenBirthPointMethod(const crJXJRecvFubenBirthPointMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvFubenBirthPointMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenBirthPointMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvFubenBirthPointMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == SceneServer)
		{
			char index = m_stream->_readChar();
			int playerid = m_this->getPlayerID();
			crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
			ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && playerData->getPlayerGameData() && playerData->getRoomID()!=0)
			{
				crNetDataManager *netDataManager = sceneServer->getNetDataManager();
				crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crRoom* room = callback->findRoom(playerData->getRoomID());
				if(room)
				{
					crRoomPlayer *roomPlayer = room->getMember(playerid);
					if(roomPlayer)
					{
						playerData->getPlayerGameData()->doEvent(WCH_PlayerJoinRoom);
						roomPlayer->setBirthPointIndex(index);
						room->setReady(roomPlayer);
						playerData->getPlayerGameData()->doEvent(WCH_JXJInitFubenPlayerReliveCount);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAnimationEventTestMethod
//
/////////////////////////////////////////
crJXJAnimationEventTestMethod::crJXJAnimationEventTestMethod(){}
crJXJAnimationEventTestMethod::crJXJAnimationEventTestMethod(const crJXJAnimationEventTestMethod& handle):
	crMethod(handle)
{
}
void crJXJAnimationEventTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_animation = (crAnimationPathCallback *)(LOINT64(param64));
			m_cp = (crAnimationPath::ControlPoint *)(HIINT64(param64));
		}
		break;
	}
}

void crJXJAnimationEventTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_bot1 = str;
		break;
	case 1:
		m_bot2 = str;
		break;
	}
}

void crJXJAnimationEventTestMethod::operator()(crHandle &handle)
{
	if(!m_body1.valid())
	{
		crGroup *root = crSceneManager::getInstance()->getStaticRoot();
		if(root)
		{
			crCollectNodeBYNameVisitor collector(MATRIXTRANSFORM);
			collector.insertNodeNameId(m_bot1);
			collector.insertNodeNameId(m_bot2);
			root->accept(collector);
			crSearchNodeBYClassNameVisitor visitor;
			NodeArray &nodeArray = collector.getResult();
			for( NodeArray::iterator itr = nodeArray.begin();
				itr != nodeArray.end();
				++itr )
			{
				visitor.reset();
				visitor.insertClassNameId("CreBodyNode");
				(*itr)->accept(visitor);
				if((*itr)->getName() == m_bot1)
				{
					m_body1 = dynamic_cast<CreBodyNode *>(visitor.getResult());
				}
				else
				{
					m_body2 = dynamic_cast<CreBodyNode *>(visitor.getResult());
				}
			}
		}
	}
	double time = m_animation->getAnimationTime();
	if(time>3.0f && time<3.1f)
	{
		if(m_body1.valid())
		{
			ActionRequest* action = m_body1->getBody()->getActionPrototype( "ACT_Attack" );
			if (action)
			{
				action->setPrioritized(false);
				m_body1->getBody()->executeAction(action, false);
			}
		}
	}
	else if(time>5.0f && time<5.1f)
	{
		if(m_body2.valid())
		{
			ActionRequest* action = m_body2->getBody()->getActionPrototype( "ACT_Attack" );
			if (action)
			{
				action->setPrioritized(false);
				m_body2->getBody()->executeAction(action, false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJTeamEnterRoomMethod
//
/////////////////////////////////////////
crJXJTeamEnterRoomMethod::crJXJTeamEnterRoomMethod(){}
crJXJTeamEnterRoomMethod::crJXJTeamEnterRoomMethod(const crJXJTeamEnterRoomMethod& handle):
	crMethod(handle)
{
}
void crJXJTeamEnterRoomMethod::inputParam(int i, void *param)
{
}

void crJXJTeamEnterRoomMethod::addParam(int i, const std::string& str)
{
}

void crJXJTeamEnterRoomMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
		if(room)
		{
			void *param;
			crData *data = myPlayer->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			if(!myTeam->empty())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				room->getRoomData(stream);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvTeamEnterRoom,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvTeamEnterRoomMethod
//
/////////////////////////////////////////
crJXJRecvTeamEnterRoomMethod::crJXJRecvTeamEnterRoomMethod():
	m_netType(GameClient_Game){}
crJXJRecvTeamEnterRoomMethod::crJXJRecvTeamEnterRoomMethod(const crJXJRecvTeamEnterRoomMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvTeamEnterRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTeamEnterRoomMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvTeamEnterRoomMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			if(!myTeam->empty())
			{
				TeamMemberVec::iterator itr = myTeam->begin();
				if(playerid == (*itr)->getPlayerID())
				{
					ref_ptr<crGameServerPlayerData> memberPlayerData;
					crPlayerDataEventPacket packet;
					for( ++itr; itr != myTeam->end(); ++itr)
					{
						memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
						if(memberPlayerData.valid())
						{
							crPlayerDataEventPacket::buildReplyPacket_p(packet,(*itr)->getPlayerID(),WCH_JXJRecvTeamEnterRoom,m_stream.get());
							gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
						}
					}
				}
				//ref_ptr<crGameServerPlayerData> memberPlayerData;
				//crPlayerDataEventPacket packet;
				//for(TeamMemberVec::iterator itr = myTeam->begin(); itr != myTeam->end(); ++itr)
				//{
				//	memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
				//	if(memberPlayerData.valid())
				//	{
				//		crPlayerDataEventPacket::buildReplyPacket_p(packet,(*itr)->getPlayerID(),WCH_JXJRecvTeamEnterRoom,m_stream.get());
				//		gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
				//	}
				//}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
		else if(m_netType == GameClient_Game)
		{
			ref_ptr<crRoom> room = new crRoom(NULL);
			crMyPlayerData::getInstance()->lockRoomMap();
			RoomMap &roomMap = crMyPlayerData::getInstance()->getRoomMap();
			roomMap.clear();
			room->setRoomData(m_stream.get());
			roomMap[room->getRoomID()] = room.get();
			crMyPlayerData::getInstance()->unlockRoomMap();
			crMyPlayerData::getInstance()->setSelectedRoom(room.get());
			int sceneid = room->getSceneID();
			if(sceneid>0)
			{
				//crMyPlayerData::getInstance()->setLoginGameSceneMode(2);
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1060,NULL));
				crLoginScenePacket packet;
				crLoginScenePacket::buildRequestPacket(packet,sceneid,WCH_JXJRecvTeamEnterRoom);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPreEnterSceneRoomMethod
//
/////////////////////////////////////////
crJXJPreEnterSceneRoomMethod::crJXJPreEnterSceneRoomMethod(){}
crJXJPreEnterSceneRoomMethod::crJXJPreEnterSceneRoomMethod(const crJXJPreEnterSceneRoomMethod& handle):
	crMethod(handle)
{
}
void crJXJPreEnterSceneRoomMethod::inputParam(int i, void *param)
{
}

void crJXJPreEnterSceneRoomMethod::addParam(int i, const std::string& str)
{
}

void crJXJPreEnterSceneRoomMethod::operator()(crHandle &handle)
{
	bool success = false;
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	crRole *role = crMyPlayerData::getInstance()->getSelectedGameRole();
	if(role && room && room->isCanJoin())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			//std::string str = "登陆房间...";
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1001,NULL));
			crPreEnterSceneRoomPacket packet;
			crPreEnterSceneRoomPacket::buildRequestPacket(packet,room->getRoomID(),crMyPlayerData::getInstance()->getCharacterName());
			netConductor->getNetManager()->sendPacket("all",packet);
			success = true;
		}
	}
	handle.outputParam(0,&success);
	//if(taskCanceled)
	//{
	//std::string str = "登陆房间失败...";
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1002,NULL));
	//}
}
/////////////////////////////////////////
//
//crJXJGameServerDropedMethod
//
/////////////////////////////////////////
crJXJGameServerDropedMethod::crJXJGameServerDropedMethod():
	m_this(NULL),
	m_playerData(NULL){}
crJXJGameServerDropedMethod::crJXJGameServerDropedMethod(const crJXJGameServerDropedMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_playerData(NULL)
{
}
void crJXJGameServerDropedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerData = (crGameServerPlayerData *)(LOINT64(param64));
		}
		else
		{
			m_playerData = NULL;
		}
		break;
	}
}

void crJXJGameServerDropedMethod::addParam(int i, const std::string& str)
{
}

void crJXJGameServerDropedMethod::operator()(crHandle &handle)
{
	void *param;
	int playerid = m_this->getPlayerID();
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	ref_ptr<crJXJUpdateOnlineTime> updateOnlineTime = new crJXJUpdateOnlineTime;
	updateOnlineTime->buildUpdateSql(playerid);
	crDBSavePacket packet;
	crDBSavePacket::buildRequestPacket(packet,updateOnlineTime.get(),-1);
	dbConductor->getNetManager()->sendPacket("all",packet);

	crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
	gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
	gsBrainData->getParam(WCHDATA_JXJOnBattleUIPlayerSet,param);
	OnBattleUIPlayerSet *onBattleUIPlayerSet = (OnBattleUIPlayerSet *)param;
	onBattleUIPlayerSet->erase(playerid);
	gsBrainData->getParam(WCHDATA_JXJOnChengfangUIPlayerMap,param);
	OnChengfangUIPlayerMap *onChengfangUIPlayerMap = (OnChengfangUIPlayerMap *)param;
	OnChengfangUIPlayerSet::iterator cfItr;
	for( OnChengfangUIPlayerMap::iterator itr = onChengfangUIPlayerMap->begin();
		itr != onChengfangUIPlayerMap->end();
		++itr )
	{
		cfItr = itr->second.find(playerid);
		if(cfItr != itr->second.end())
		{
			itr->second.erase(cfItr);
			break;
		}
	}

	crData *data = m_this->getDataClass();
	if (data)
	{
		data-> getParam(WCHDATA_JXJConsortiaID,param);
		int mygroupid = *(int *)param;
		gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
		ConsortiaMap *consortiamap = (ConsortiaMap *)param;
		ConsortiaMap::iterator myitr = consortiamap->find(mygroupid);
		if (myitr != consortiamap->end() && myitr->second.valid())
		{
			crData *groupData = myitr->second->getDataClass();
			if (groupData)
			{
				groupData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
				ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
				ConsortiaMemberMap::iterator finditr = membermap->find(playerid);
				if (finditr != membermap->end() && finditr->second.valid())
				{
					finditr->second->setLoginTime(time(0));
				}
			}
		}
	}

	gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));

	////离开组队
	//crData *data = m_this->getDataClass();
	//data->getParam(WCHDATA_JXJTeamLeaderID,param);
	//int leaderid = *(int *)param;
	//if(leaderid>0)
	//{
	//	data->inputParam(WCHDATA_JXJTeamLeaderID,0);
	//	int playerid = m_this->getPlayerID();
	//	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	//	ref_ptr<crGameServerPlayerData> leaderPlayerData;
	//	if(playerid == leaderid)
	//	{
	//		leaderPlayerData = m_playerData;
	//	}
	//	else
	//	{
	//		leaderPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderid));
	//	}
	//	if(leaderPlayerData.valid())
	//	{
	//		ref_ptr<crPlayerGameData> leaderData = leaderPlayerData->getPlayerGameData();
	//		if(leaderData.valid() && leaderData->getDataClass())
	//		{
	//			void *param;
	//			crData *ldata = leaderData->getDataClass();
	//			ldata->excHandle(MAKEINT64(WCH_LockData,1));
	//			ldata->getParam(WCHDATA_JXJMyTeam,param);
	//			TeamMemberVec *myTeam = (TeamMemberVec *)param;
	//			crPlayerDataEventPacket packet;
	//			ref_ptr<crGameServerPlayerData> memberPlayer;
	//			ref_ptr<crPlayerGameData> memberData;
	//			ref_ptr<crStreamBuf> stream = new crStreamBuf;
	//			stream->createBuf(4);
	//			stream->_writeInt(playerid);
	//			crPlayerGameData *playerGameData;
	//			crData *gameData;
	//			for( TeamMemberVec::iterator itr = myTeam->begin();
	//				itr != myTeam->end();
	//				++itr )
	//			{
	//				if((*itr)->getPlayerID() != playerid)
	//				{
	//					memberPlayer = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
	//					if(memberPlayer.valid())
	//					{
	//						crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJClientRecvLeaveTeam,stream.get());
	//						gameServer->getNetManager()->sendPacket(memberPlayer->getPlayerConnectServerAddress(),packet);
	//						if(playerid == leaderid)
	//						{//队长离开
	//							playerGameData = memberPlayer->getPlayerGameData();
	//							if(playerGameData && playerGameData->getDataClass())
	//							{
	//								gameData = playerGameData->getDataClass();
	//								gameData->inputParam(WCHDATA_JXJTeamLeaderID,0);
	//							}
	//						}
	//					}
	//				}
	//			}
	//			if(playerid == leaderid)
	//			{
	//				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
	//				serverData->excHandle(MAKEINT64(WCH_LockData,1));
	//				serverData->getParam(WCHDATA_JXJGSTeamMap,param);
	//				GSTeamMap *gsTeamMap = (GSTeamMap *)param;
	//				for( GSTeamMap::iterator itr = gsTeamMap->begin();
	//					itr != gsTeamMap->end();
	//					++itr )
	//				{
	//					if(itr->second == playerid)
	//					{
	//						gsTeamMap->erase(itr);
	//						break;
	//					}
	//				}
	//				serverData->excHandle(MAKEINT64(WCH_LockData,0));
	//				myTeam->clear();
	//				ldata->inputParam(WCHDATA_JXJFubenOrChengchiType,0);
	//				ldata->inputParam(WCHDATA_JXJFubenOrChengchiID,0);
	//			}
	//			else
	//			{
	//				TeamMemberVec::iterator itr = myTeam->begin();
	//				for( ++itr;
	//					itr != myTeam->end();
	//					++itr )
	//				{
	//					if((*itr)->getPlayerID() == playerid)
	//					{
	//						myTeam->erase(itr);
	//						break;
	//					}
	//				}
	//			}
	//			ldata->excHandle(MAKEINT64(WCH_LockData,0));
	//		}
	//	}
	//}
}
/////////////////////////////////////////
//
//crJXJSceneServerDropedMethod
//
/////////////////////////////////////////
crJXJSceneServerDropedMethod::crJXJSceneServerDropedMethod():
	m_this(NULL),
	m_playerData(NULL){}
crJXJSceneServerDropedMethod::crJXJSceneServerDropedMethod(const crJXJSceneServerDropedMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_playerData(NULL)
{
}
void crJXJSceneServerDropedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerData = (crSceneServerPlayerData *)(LOINT64(param64));
		}
		else
		{
			m_playerData = NULL;
		}
		break;
	}
}

void crJXJSceneServerDropedMethod::addParam(int i, const std::string& str)
{
}

void crJXJSceneServerDropedMethod::operator()(crHandle &handle)
{
	if(m_playerData)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		ref_ptr<crStreamBuf> stream;
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene* scene = callback->findScene(m_playerData->getSceneID());
		stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(scene->getExternSceneType());
		//if(type == FT_Fuben)
		//{//如果是副本,计算兵力百分比返还
		//	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		//	unsigned short fubenid = *(unsigned short *)param;

		//}
		crPlayerDataEventPacket packet;
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServerLine = m_playerData->getGameServerLineConductor();
		if(gameServerLine)
		{
			////兵力百分比返还
			//void *param;
			//crData * roleData = NULL;
			//int roleid = 0;
			//ref_ptr<crStreamBuf> stream_scene = new crStreamBuf;
			//crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			//crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			//
			//ref_ptr<crTableIO> troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			//int experienceIndex = troopsTab->getTitleIndex("死亡经验系数");
			//float experienceFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleExperienceFactor,0).c_str());
			//float fubenArmyBackFactor = 0.0f;
			//float experience = 0.0f;
			//unsigned short count = 0,rtCount = 0;
			//crTableIO::StrVec record;

			//crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			//CRNetApp::crRoom* room = callback->findRoom(m_playerData->getRoomID());
			//if(room)
			//{
			//	crData *roomData = room->getDataClass();
			//	roomData->getParam(WCHDATA_JXJBattleID,param);
			//	int battleid = *(int *)param;
			//	unsigned short fubenid = HIINT32(battleid);
			//	ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			//	if(fubentab)
			//	{
			//		int index = fubentab->getTitleIndex("兵力返还");
			//		if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0 && index>=0)
			//		{
			//			fubenArmyBackFactor = atof(record[index].c_str());
			//			if(fubenArmyBackFactor>1.0f) fubenArmyBackFactor = 1.0f;
			//		}
			//	}
			//}

			//crSceneServerPlayerData::RoleMap & roleMap = m_playerData->getRoleMap();
			//stream_scene->createBuf(5+6*roleMap.size());
			//stream_scene->_writeUChar(roleMap.size());
			//crSceneServerPlayerData::RoleMap::iterator itr_role = roleMap.begin();
			//for (;itr_role!=roleMap.end();itr_role++)
			//{
			//	roleid = itr_role->second->getRoleID();
			//	roleData = itr_role->second->getDataClass();
			//	if(roleData)
			//	{
			//		roleData->getParam(WCHDATA_JXJArmyCount,param);
			//		count = *(unsigned short *)param;
			//		roleData->getParam(WCHDATA_JXJRTArmyCount,param);
			//		rtCount = *(unsigned short *)param;

			//		rtCount+=(unsigned short)((count-rtCount)*fubenArmyBackFactor);
			//	}

			//	if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa(itr_role->second->getAbstractItemID()),record)>=0 && experienceIndex>=0)
			//	{
			//		experience += experienceFactor * atof(record[experienceIndex].c_str()) * (count-rtCount);
			//	}

			//	stream_scene->_writeInt(roleid);
			//	stream_scene->_writeUShort(rtCount);
			//}
			//stream_scene->_writeInt((int)experience);

			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvLeaveScene,stream.get());
			gameServerLine->getNetManager()->sendPacket("all",packet);

			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvLeaveTeam,NULL);
			gameServerLine->getNetManager()->sendPacket("all",packet);
		}
		if(!m_playerData->getPlayerConnectServerAddress().empty())
		{
			crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
			ref_ptr<crStreamBuf> clientstream = new crStreamBuf;
			if(stream.valid())
			{
				clientstream->createBuf(4+stream->getBufSize());
				clientstream->_writeInt(playerid);
				clientstream->write(stream->getBuf(),stream->getBufSize());
			}
			else
			{
				clientstream->createBuf(4);
				clientstream->_writeInt(playerid);
			}
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvLeaveTeam,clientstream.get());
			sceneServer->getNetManager()->sendPacket(m_playerData->getPlayerConnectServerAddress(),packet);


			////兵力百分比返还
			//void *param;
			//crData * roleData = NULL;
			//int roleid = 0;
			//ref_ptr<crStreamBuf> stream_scene = new crStreamBuf;
			//crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			//crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			//
			//ref_ptr<crTableIO> troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			//int experienceIndex = troopsTab->getTitleIndex("死亡经验系数");
			//float experienceFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleExperienceFactor,0).c_str());
			//float fubenArmyBackFactor = 0.0f;
			//float experience = 0.0f;
			//unsigned short count = 0,rtCount = 0;
			//crTableIO::StrVec record;

			//crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			//CRNetApp::crRoom* room = callback->findRoom(m_playerData->getRoomID());
			//if(room)
			//{
			//	crData *roomData = room->getDataClass();
			//	roomData->getParam(WCHDATA_JXJBattleID,param);
			//	int battleid = *(int *)param;
			//	unsigned short fubenid = HIINT32(battleid);
			//	ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			//	if(fubentab)
			//	{
			//		int index = fubentab->getTitleIndex("兵力返还");
			//		if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0 && index>=0)
			//		{
			//			fubenArmyBackFactor = atof(record[index].c_str());
			//			if(fubenArmyBackFactor>1.0f) fubenArmyBackFactor = 1.0f;
			//		}
			//	}
			//}

			//crSceneServerPlayerData::RoleMap & roleMap = m_playerData->getRoleMap();
			//stream_scene->createBuf(5+6*roleMap.size());
			//stream_scene->_writeUChar(roleMap.size());
			//crSceneServerPlayerData::RoleMap::iterator itr_role = roleMap.begin();
			//for (;itr_role!=roleMap.end();itr_role++)
			//{
			//	roleid = itr_role->second->getRoleID();
			//	roleData = itr_role->second->getDataClass();
			//	if(roleData)
			//	{
			//		roleData->getParam(WCHDATA_JXJArmyCount,param);
			//		count = *(unsigned short *)param;
			//		roleData->getParam(WCHDATA_JXJRTArmyCount,param);
			//		rtCount = *(unsigned short *)param;

			//		rtCount+=(unsigned short)((count-rtCount)*fubenArmyBackFactor);
			//	}

			//	if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa(itr_role->second->getAbstractItemID()),record)>=0 && experienceIndex>=0)
			//	{
			//		experience += experienceFactor * atof(record[experienceIndex].c_str()) * (count-rtCount);
			//	}

			//	stream_scene->_writeInt(roleid);
			//	stream_scene->_writeUShort(rtCount);
			//}
			//stream_scene->_writeInt((int)experience);


			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvLeaveScene,stream.get());
			sceneServer->getNetManager()->sendPacket(m_playerData->getPlayerConnectServerAddress(),packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvLeaveSceneMethod
//
/////////////////////////////////////////
crJXJRecvLeaveSceneMethod::crJXJRecvLeaveSceneMethod():
	m_netType(GameClient_Game){}
crJXJRecvLeaveSceneMethod::crJXJRecvLeaveSceneMethod(const crJXJRecvLeaveSceneMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvLeaveSceneMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_netType = HIINT64(param64);
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		break;
	}
}

void crJXJRecvLeaveSceneMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvLeaveSceneMethod::operator()(crHandle &handle)
{
	if(m_netType == GameServer)
	{
		void *param;
		//////////////////////////////////////////////////////////////////////////
		crData *data = m_this->getDataClass();

		bool hasarms = false;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		for( FormationInfoVec::iterator itr = formationInfoVec->begin();
			itr != formationInfoVec->end();
			++itr )
		{
			if((*itr)->getCount()>0)
			{
				hasarms = true;
				break;
			}
		}
		data->getParam(WCHDATA_JXJSavedFormationIndex,param);
		unsigned char savedformationindex = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
		SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
		if(savedformationindex < savedformationVec->size())
			(*savedformationVec)[savedformationindex].second = *formationInfoVec;
		data->excHandle(MAKEINT64(WCH_LockData,0));

		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		if(type == FT_Chengchi)
		{
			data->getParam(WCHDATA_JXJBattleRoomID,param);
			_crInt64 battleroomid = *(_crInt64 *)param;
			if(battleroomid!=0)
			{
				//if(hasarms)
				{
					int playerid = m_this->getPlayerID();
					int battleid = LOINT64(battleroomid);
					int roomid = HIINT64(battleroomid);
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
					gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
					OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
					char found = 0;//1表示战场结束退出，2表示提前退出
					for( OpenBattleMap::iterator itr = openBattleMap->find(battleid);
						itr != openBattleMap->end() && itr->first == battleid;
						++itr )
					{
						if(itr->second.second.first == roomid)
						{
							for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
								pitr != itr->second.first.first.end();
								++pitr )
							{
								if(*pitr == playerid)
								{
									found = 1;
									itr->second.first.first.erase(pitr);
									break;
								}
							}
							if(!found && !itr->second.first.first.empty())
							{//是守方并且攻方还有人在
								for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
									pitr != itr->second.first.second.end();
									++pitr )
								{
									if(*pitr == playerid)
									{
										found = 1;
										itr->second.first.second.erase(pitr);
										break;
									}
								}
							}
							if(found)
							{
								if(itr->second.second.second > 1.0f)
								{//房间的剩余时间大于1s
									found = 2;
								}
								break;
							}
						}
					}
					if(hasarms && found == 2)
					{
						gsBrainData->getParam(WCHDATA_JXJBattleDropPlayerMap,param);
						BattleDropPlayerMap *battleDropPlayerMap = (BattleDropPlayerMap *)param;
						(*battleDropPlayerMap)[playerid].first = battleid;
						data->getParam(WCHDATA_JXJVipLv,param);
						unsigned char vipLevel = *(unsigned char *)param;
						(*battleDropPlayerMap)[playerid].second = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLeaveBattlePunish, vipLevel).c_str());

					}
					gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
		else if(type == FT_Fuben)
		{
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short fubenid = *(unsigned short *)param;

			bool isGroupFuBen = false;

			crTableIO::StrVec record;
			ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			if (fubentab.valid())
			{
				int chaptureIdx = fubentab->getTitleIndex("chapterid");
				if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
				{
					if (atoi(record[chaptureIdx].c_str()) == 1) // 军团副本结算
					{
						isGroupFuBen = true;
						ref_ptr<crStreamBuf > stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(fubenid);
						stream->seekBegin();
						m_this->doEvent(WCH_JXJRecvJunTuanFuBenSettleGetReward,MAKEINT64(stream.get(),GameServer));
					}
				}
			}
			if (!isGroupFuBen)
			{
				std::map<int,unsigned short> rtInfoMap;
				int experience = 0;
				int extSceneType = 0;
				//读取数据
				if(m_stream)
				{
					extSceneType = m_stream->_readInt();
					if(!m_stream->eof())
					{
						int roleid;
						short count;
						unsigned char size = m_stream->_readUChar();
						for (int i = 0;i<size;i++)
						{
							roleid = m_stream->_readInt();
							count = m_stream->_readUShort();
							rtInfoMap.insert(std::make_pair(roleid,count));
						}
						experience = m_stream->_readInt();
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,1));
				if(extSceneType == Ext_Xumu)
				{
					data->getParam(WCHDATA_JXJFormationInfoVec,param);
					FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
					data->getParam(WCHDATA_JXJSavedFormationIndex,param);
					unsigned char savedformationindex = *(unsigned char *)param;
					data->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
					SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
					if(savedformationindex < savedformationVec->size()) 
						(*savedformationVec)[savedformationindex].second.clear();
					formationInfoVec->clear();
				}
				else
				{
					std::map<int,unsigned short>::iterator itr_map;
					data->getParam(WCHDATA_JXJFormationInfoVec,param);
					FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
					data->getParam(WCHDATA_JXJSavedFormationIndex,param);
					unsigned char savedformationindex = *(unsigned char *)param;
					data->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
					SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
					bool sizevalid = savedformationindex < savedformationVec->size();
					FormationInfoVec::iterator itr = formationInfoVec->begin();
					for (;itr!=formationInfoVec->end();itr++)
					{
						itr_map = rtInfoMap.find(itr->get()->getRoleID());
						if(itr_map!=rtInfoMap.end())
						{
							itr->get()->setCount(itr_map->second);
						}				
					}
					if(sizevalid)(*savedformationVec)[savedformationindex].second = *formationInfoVec;
				}
				if(experience>0)
				{
					ref_ptr<crPlayerRewardData> reward_info = new crPlayerRewardData;
					reward_info->setPlayerID(m_this->getPlayerID());
					reward_info->setType(GP_RewardGameEnd);
					reward_info->setExperience(experience);
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJCreateRewardMail,MAKEINT64(reward_info.get(),NULL));
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}

			// 			crRole *mainrole = m_this->getMainRole();
			// 			if(mainrole && mainrole->getDataClass())
			// 			{
			// 				crData *mainroleData = mainrole->getDataClass();
			// 				mainroleData->getParam(WCHDATA_Level,param);
			// 				unsigned char lv = *(unsigned char *)param;
			// 				if(lv == 1)
			// 				{
			// 					data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			// 					unsigned short fubenid = *(unsigned short *)param;
			// 					data->getParam(WCHDATA_JXJVipLv,param);
			// 					unsigned char vipLevel = *(unsigned char *)param;
			// 					if(fubenid == atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuFubenID, vipLevel).c_str()))
			// 					{
			// 						
			// 					}
			// 				}
			// 			}
		}
		data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
		data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
		data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
		data->inputParam(WCHDATA_JXJInspireLevel,NULL);
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
		if(playerData.valid())
		{
			playerData->setSceneID(0);
		}
	}
	else if(m_netType == GameClient_Game)
	{
		crData *data = m_this->getDataClass();
		void *param;
		std::map<int,unsigned short> rtInfoMap;
		std::map<int,unsigned short>::iterator itr_map;
		int extSceneType = 0;
		//int experience = 0;
		//读取数据
		if(m_stream)
		{
			extSceneType = m_stream->_readInt();
			if(!m_stream->eof())
			{
				int roleid;
				short count;
				unsigned char size = m_stream->_readUChar();
				for (int i = 0;i<size;i++)
				{
					roleid = m_stream->_readInt();
					count = m_stream->_readUShort();
					rtInfoMap.insert(std::make_pair(roleid,count));
				}
				//experience = m_stream->_readInt();
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,1));
		if(extSceneType == Ext_Battle)
		{
			data->getParam(WCHDATA_JXJFormationInfoVec,param);
			FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
			data->getParam(WCHDATA_JXJSavedFormationIndex,param);
			unsigned char savedformationindex = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
			SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
			if(savedformationindex < savedformationVec->size()) 
				(*savedformationVec)[savedformationindex].second = *formationInfoVec;
		}
		else if(extSceneType == Ext_Xumu)
		{
			data->getParam(WCHDATA_JXJFormationInfoVec,param);
			FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
			data->getParam(WCHDATA_JXJSavedFormationIndex,param);
			unsigned char savedformationindex = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
			SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
			if(savedformationindex < savedformationVec->size()) 
				(*savedformationVec)[savedformationindex].second.clear();
			formationInfoVec->clear();
		}
		else
		{
			data->getParam(WCHDATA_JXJFormationInfoVec,param);
			FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
			data->getParam(WCHDATA_JXJSavedFormationIndex,param);
			unsigned char savedformationindex = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
			SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
			bool sizevalid = savedformationindex < savedformationVec->size();
			FormationInfoVec::iterator itr = formationInfoVec->begin();
			for (;itr!=formationInfoVec->end();itr++)
			{
				itr_map = rtInfoMap.find(itr->get()->getRoleID());
				if(itr_map!=rtInfoMap.end())
				{
					itr->get()->setCount(itr_map->second);
				}				
			}
			if(sizevalid)(*savedformationVec)[savedformationindex].second = *formationInfoVec;
		}
		data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
		data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
		data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
		data->inputParam(WCHDATA_JXJInspireLevel,NULL);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJLeaveBattleAndTeamMethod
//
/////////////////////////////////////////
crJXJLeaveBattleAndTeamMethod::crJXJLeaveBattleAndTeamMethod(){}
crJXJLeaveBattleAndTeamMethod::crJXJLeaveBattleAndTeamMethod(const crJXJLeaveBattleAndTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJLeaveBattleAndTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}

void crJXJLeaveBattleAndTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJLeaveBattleAndTeamMethod::operator()(crHandle &handle)
{
	void *param;
	//////////////////////////////////////////////////////////////////////////
	//离开战场
	int playerid = m_this->getPlayerID();
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char type = *(unsigned char *)param;
	if(type == FT_Chengchi)
	{
		data->getParam(WCHDATA_JXJBattleRoomID,param);
		_crInt64 battleroomid = *(_crInt64 *)param;
		if(battleroomid!=0)
		{
			int battleid = LOINT64(battleroomid);
			int roomid = HIINT64(battleroomid);
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
			OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			char found = 0;//1表示战场结束退出，2表示提前退出
			for( OpenBattleMap::iterator itr = openBattleMap->find(battleid);
				itr != openBattleMap->end() && itr->first == battleid;
				++itr )
			{
				if(itr->second.second.first == roomid)
				{
					for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
						pitr != itr->second.first.first.end();
						++pitr )
					{
						if(*pitr == playerid)
						{
							found = 1;
							itr->second.first.first.erase(pitr);
							break;
						}
					}
					if(!found)
					{
						for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
							pitr != itr->second.first.second.end();
							++pitr )
						{
							if(*pitr == playerid)
							{
								found = 1;
								itr->second.first.second.erase(pitr);
								break;
							}
						}
					}
					if(found)
					{
						if(itr->second.second.second > 1.0f)
						{//房间的剩余时间大于1s
							found = 2;
						}
						break;
					}
				}
			}
			gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
		}
		else
		{//离开排队系统
			bool found = false;
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short chengchiid = *(unsigned short *)param;
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char myShili = *(unsigned char *)param;
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJChengChiMap,param);
			ChengchiMap *chengchiMap = (ChengchiMap *)param;
			ChengchiMap::iterator itr = chengchiMap->find(chengchiid);
			if(itr != chengchiMap->end())
			{
				_crInt32 battleid;
				gsBrainData->getParam(WCHDATA_JXJDefendDequeMap,param);
				DefendDequeMap *defendDequeMap = (DefendDequeMap *)param;
				for( DefendDequeMap::iterator ditr = defendDequeMap->begin();
					ditr != defendDequeMap->end();
					++ditr )
				{
					battleid = ditr->first;
					if(HIINT32(battleid) == chengchiid)
					{
						BattleDeque &battleDeque = ditr->second;
						for( BattleDeque::iterator bitr = battleDeque.begin();
							bitr != battleDeque.end();
							++bitr )
						{
							if(*bitr == playerid)
							{
								battleDeque.erase(bitr);
								found = true;
								break;
							}
						}
						if(found)
							break;
					}
				}
				if(!found)
				{//我是攻方
					gsBrainData->getParam(WCHDATA_JXJAttackDequeMap,param);
					AttackDequeMap *attackDequeMap = (AttackDequeMap *)param;
					for( AttackDequeMap::iterator aitr = attackDequeMap->begin();
						aitr != attackDequeMap->end();
						++aitr )
					{
						battleid = aitr->first;
						if(HIINT32(battleid) == chengchiid)
						{
							BattleDeque &battleDeque = aitr->second;
							for( BattleDeque::iterator bitr = battleDeque.begin();
								bitr != battleDeque.end();
								++bitr )
							{
								if(*bitr == playerid)
								{
									battleDeque.erase(bitr);
									found = true;
									if(battleDeque.size() == 0)
										crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerBattDequeUpdata,MAKEINT64(MAKEINT32(chengchiid,0),battleid));

									break;
								}
							}
							if(found)
								break;
						}
					}
				}
				if(!found)
				{
					gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
					OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
					OpenBattleMap::iterator oitr;
					BattlePlayer::iterator bpitr;
					for( oitr = openBattleMap->begin();
						oitr != openBattleMap->end();
						++oitr )
					{
						battleid = oitr->first;
						if(HIINT32(battleid) == chengchiid)
						{
							if(LOINT16(LOINT32(battleid))==myShili)
							{//攻方
								for( bpitr = oitr->second.first.first.begin();
									bpitr != oitr->second.first.first.end();
									++bpitr )
								{
									if(*bpitr == playerid)
									{
										oitr->second.first.first.erase(bpitr);
										found = true;
										break;
									}
								}
							}
							else if(HIINT16(LOINT32(battleid))==myShili)
							{//我是守方
								for( bpitr = oitr->second.first.second.begin();
									bpitr != oitr->second.first.second.end();
									++bpitr )
								{
									if(*bpitr == playerid)
									{
										oitr->second.first.second.erase(bpitr);
										found = true;
										break;
									}
								}
							}
							if(found == true)
								break;
						}
					}
				}
			}
			gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
	else if(type == FT_Fuben)
	{
	}
	data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
	data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
	data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
	data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
	//离开组队
	data->getParam(WCHDATA_JXJTeamLeaderID,param);
	int leaderid = *(int *)param;
	if(leaderid!=0)
	{
		data->inputParam(WCHDATA_JXJTeamLeaderID,0);
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 

		ref_ptr<crPlayerGameData> leaderData;
		if(leaderid == playerid)
		{
			leaderData = m_this;
		}
		else
		{
			ref_ptr<crGameServerPlayerData> leaderPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderid));
			if(leaderPlayerData.valid())
			{
				leaderData = leaderPlayerData->getPlayerGameData();
			}
		}
		if(leaderData.valid() && leaderData->getDataClass())
		{
			crData *ldata = leaderData->getDataClass();
			ldata->excHandle(MAKEINT64(WCH_LockData,1));
			ldata->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			crPlayerDataEventPacket packet;
			ref_ptr<crGameServerPlayerData> memberPlayer;
			ref_ptr<crPlayerGameData> memberData;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(playerid);
			crPlayerGameData *playerGameData;
			crData *gameData;
			for( TeamMemberVec::iterator itr = myTeam->begin();
				itr != myTeam->end();)
			{
				if((*itr)->getPlayerID() != playerid)
				{
					memberPlayer = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
					if(memberPlayer.valid())
					{
						crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJClientRecvLeaveTeam,stream.get());
						gameServer->getNetManager()->sendPacket(memberPlayer->getPlayerConnectServerAddress(),packet);
						if(playerid == leaderid)
						{//队长离开
							playerGameData = memberPlayer->getPlayerGameData();
							if(playerGameData && playerGameData->getDataClass())
							{
								gameData = playerGameData->getDataClass();
								gameData->inputParam(WCHDATA_JXJTeamLeaderID,0);
							}
						}
					}
					++itr;
				}
				else
				{
					itr = myTeam->erase(itr);
				}
			}
			if(playerid == leaderid)
			{
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJGSTeamMap,param);
				GSTeamMap *gsTeamMap = (GSTeamMap *)param;
				for( GSTeamMap::iterator itr = gsTeamMap->begin();
					itr != gsTeamMap->end();
					++itr )
				{
					if(itr->second == playerid)
					{
						gsTeamMap->erase(itr);
						break;
					}
				}
				serverData->excHandle(MAKEINT64(WCH_LockData,0));
				myTeam->clear();
			}
			ldata->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
	if(playerData.valid())
	{
		playerData->setSceneID(0);
	}
}
/////////////////////////////////////////
//
//crJXJClientSceneServerAbnormalMethod
//
/////////////////////////////////////////
crJXJClientSceneServerAbnormalMethod::crJXJClientSceneServerAbnormalMethod(){}
crJXJClientSceneServerAbnormalMethod::crJXJClientSceneServerAbnormalMethod(const crJXJClientSceneServerAbnormalMethod& handle):
	crMethod(handle)
{
}
void crJXJClientSceneServerAbnormalMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}

void crJXJClientSceneServerAbnormalMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientSceneServerAbnormalMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
	data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
	data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
	data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
}
/////////////////////////////////////////
//
//crJXJBattleRoomAheadCloseMethod
//
/////////////////////////////////////////
crJXJBattleRoomAheadCloseMethod::crJXJBattleRoomAheadCloseMethod(){}
crJXJBattleRoomAheadCloseMethod::crJXJBattleRoomAheadCloseMethod(const crJXJBattleRoomAheadCloseMethod& handle):
	crMethod(handle)
{
}
void crJXJBattleRoomAheadCloseMethod::addParam(int i, const std::string& str)
{
}
void crJXJBattleRoomAheadCloseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJBattleRoomAheadCloseMethod::operator()(crHandle &handle)
{
	bool canClose = false;
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJBattleID,param);
	int battleid = *(int *)param;
	unsigned char offenseShiliid = (unsigned char)(LOINT16(LOINT32(battleid)));
	unsigned short chengchiid = (unsigned short)(HIINT32(battleid));
	ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	crTableIO::StrVec record;
	if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
	{
		int timeid = chengchiTab->getTitleIndex("时间");
		int time2id = chengchiTab->getTitleIndex("进场时间");
		float time = atof(record[timeid].c_str());
		float time2 = atof(record[time2id].c_str());
		time2 = time - time2;
		if(m_this->timeRemain()<time2)
		{//不能进场了
			//判断攻方是否没有了
			bool found = false;
			m_this->lockPlayerList();
			crRoom::PlayerList &playerList = m_this->getPlayerList();
			crRoomPlayer *roomPlayer;
			for( crRoom::PlayerList::iterator itr = playerList.begin();
				itr != playerList.end();
				++itr )
			{
				roomPlayer = itr->get();
				if(roomPlayer->getGroupID() == offenseShiliid)
				{
					found = true;
					break;
				}
			}
			m_this->unlockPlayerList();
			if(!found)
			{
				canClose = true;
			}
		}
	}
	else
	{
		canClose = true;
	}
	handle.outputParam(0,&canClose);
}
///////////////////////////////////////////
////
////crJXJBattleEnemyCheckMethod
////
///////////////////////////////////////////
//crJXJBattleEnemyCheckMethod::crJXJBattleEnemyCheckMethod(){}
//crJXJBattleEnemyCheckMethod::crJXJBattleEnemyCheckMethod(const crJXJBattleEnemyCheckMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJBattleEnemyCheckMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJBattleEnemyCheckMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom *)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_itempair = (std::pair<crInstanceItem *,crInstanceItem *> *)(LOINT64(param64));
//			m_isEnemy = (char *)(HIINT64(param64));
//		}
//		else
//		{
//			m_itempair = NULL;
//			m_isEnemy = NULL;
//		}
//		break;
//	}
//}
//void crJXJBattleEnemyCheckMethod::operator()(crHandle &handle)
//{
//	crInstanceItem *thisItem, *targetItem;
//	thisItem = m_itempair->first;
//	targetItem = m_itempair->second;
//	if( thisItem->getItemtype() != crInstanceItem::Role && targetItem->getItemtype() != crInstanceItem::Role)
//	{
//		*m_isEnemy = 1;
//		return;
//	}
//	unsigned char thisGroupid = 0;
//	unsigned char targetGroupid = 0;
//	if(thisItem->getItemtype() == crInstanceItem::Role)
//	{
//		crRole *thisRole = dynamic_cast<crRole *>(thisItem);
//		ref_ptr<crRoomPlayer> thisRoomPlayer = m_this->getMember(thisRole->getPlayerID());
//		if(thisRoomPlayer.valid())
//		{
//			thisGroupid = thisRoomPlayer->getGroupID();
//		}
//	}
//	if(targetItem->getItemtype() == crInstanceItem::Role)
//	{
//		crRole *targetRole = dynamic_cast<crRole *>(targetItem);
//		ref_ptr<crRoomPlayer> targetRoomPlayer = m_this->getMember(targetRole->getPlayerID());
//		if(targetRoomPlayer.valid())
//		{
//			targetGroupid = targetRoomPlayer->getGroupID();
//		}
//	}
//	if(thisGroupid != 0 && targetGroupid != 0)
//	{
//		if(thisGroupid == targetGroupid)
//		{//队友
//			*m_isEnemy = 1;
//		}
//		else
//		{//敌人
//			*m_isEnemy = -1;
//		}
//		return;
//	}
//	void *param;
//	crData *data = m_this->getDataClass();
//	data->getParam(WCHDATA_JXJBattleID,param);
//	int battleid = *(int *)param;
//	unsigned char defenceShiliid = (unsigned char)(HIINT16(LOINT32(battleid)));
//	if(thisGroupid != 0)
//	{
//		if(thisGroupid == defenceShiliid)
//		{//守方和NPC是队友
//			*m_isEnemy = 1;
//		}
//		else
//		{
//			*m_isEnemy = -1;
//		}
//		return;
//	}
//	if(targetGroupid == defenceShiliid)
//	{//NPC和守方是队友
//		*m_isEnemy = 1;
//	}
//	else
//	{
//		*m_isEnemy = -1;
//	}
//}
///////////////////////////////////////////
////
////crJXJBattleDefenceSightMethod
////
///////////////////////////////////////////
//crJXJBattleDefenceSightMethod::crJXJBattleDefenceSightMethod(){}
//crJXJBattleDefenceSightMethod::crJXJBattleDefenceSightMethod(const crJXJBattleDefenceSightMethod& handle):
//	crMethod(handle),
//	m_itemidVec(handle.m_itemidVec)
//{
//}
//void crJXJBattleDefenceSightMethod::addParam(int i, const std::string& str)
//{
//	int id = atoi(str.c_str());
//	if(id > 0)
//	{
//		m_itemidVec.push_back(id);
//	}
//}
//void crJXJBattleDefenceSightMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom *)param;
//		break;
//	}
//}
//void crJXJBattleDefenceSightMethod::operator()(crHandle &handle)
//{
//	if(!m_itemidVec.empty())
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->getParam(WCHDATA_JXJBattleID,param);
//		int battleid = *(int *)param;
//		unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
//		//m_this->lockSightInfoMap();
//		CRNetApp::crScene *scene = m_this->getScene();
//		if(scene)
//		{
//			crSightInfo *sightInfo = m_this->getOrCreateSightInfo(defenceShili);
//			crInstanceItem *item;
//			crData *itemData;
//			int roomid = m_this->getRoomID();
//			for( IDVec::iterator itr = m_itemidVec.begin();
//				itr != m_itemidVec.end();
//				++itr )
//			{
//				item = scene->findRoomItem(roomid,*itr);
//				if(item && item->getItemtype() == crInstanceItem::Npc)
//				{
//					itemData = item->getDataClass();
//					if(itemData)
//						itemData->inputParam(WCHDATA_Camp,&defenceShili);
//					sightInfo->addEyeItem(item);
//				}
//			}
//		}
//		//m_this->unlockSightInfoMap();
//	}
//}
///////////////////////////////////////////
////
////crJXJBattleDefenceSightFromTabMethod
////
///////////////////////////////////////////
//crJXJBattleDefenceSightFromTabMethod::crJXJBattleDefenceSightFromTabMethod():
//m_id(0){}
//crJXJBattleDefenceSightFromTabMethod::crJXJBattleDefenceSightFromTabMethod(const crJXJBattleDefenceSightFromTabMethod& handle):
//	crMethod(handle),
//	m_id(handle.m_id)
//{
//}
//void crJXJBattleDefenceSightFromTabMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_id = atoi(str.c_str());
//		break;
//	}
//}
//void crJXJBattleDefenceSightFromTabMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom *)param;
//		break;
//	}
//}
//void crJXJBattleDefenceSightFromTabMethod::operator()(crHandle &handle)
//{
//	CRNetApp::crScene *scene = m_this->getScene();
//	if(scene)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		//data->getParam(WCHDATA_RoomProgress,param);
//		//short progress = *(short *)param;
//		data->getParam(WCHDATA_JXJReliveItemMap,param);
//		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
//
//		data->getParam(WCHDATA_JXJBattleID,param);
//		int battleid = *(int *)param;
//		unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
//		//m_this->lockSightInfoMap();
//		crSightInfo *sightInfo = m_this->getOrCreateSightInfo(defenceShili);
//		crInstanceItem *item;
//		crData *itemData;
//		int roomid = m_this->getRoomID();
//		ReliveItemMap::iterator itr = reliveItemMap->find(m_id);
//		for( ;
//			itr != reliveItemMap->end() && itr->first == m_id;
//			++itr )
//		{
//			item = scene->findRoomItem(roomid,itr->second->getInstanceID());
//			if(item && item->getItemtype() == crInstanceItem::Npc)
//			{
//				itemData = item->getDataClass();
//				if(itemData)
//					itemData->inputParam(WCHDATA_Camp,&defenceShili);
//				sightInfo->addEyeItem(item);
//			}
//		}
//		//m_this->unlockSightInfoMap();
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
///////////////////////////////////////////
////
////crJXJCreateNpcSightFromTabMethod
////
///////////////////////////////////////////
//crJXJCreateNpcSightFromTabMethod::crJXJCreateNpcSightFromTabMethod():
//	m_id(0),
//m_camp(2){}
//crJXJCreateNpcSightFromTabMethod::crJXJCreateNpcSightFromTabMethod(const crJXJCreateNpcSightFromTabMethod& handle):
//	crMethod(handle),
//	m_id(handle.m_id),
//	m_camp(handle.m_camp)
//{
//}
//void crJXJCreateNpcSightFromTabMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_id = atoi(str.c_str());
//		break;
//	case 1:
//		m_camp = (unsigned char)(atoi(str.c_str()));
//		break;
//	}
//}
//void crJXJCreateNpcSightFromTabMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom *)param;
//		break;
//	}
//}
//void crJXJCreateNpcSightFromTabMethod::operator()(crHandle &handle)
//{
//	CRNetApp::crScene *scene = m_this->getScene();
//	if(scene)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJReliveItemMap,param);
//		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
//		//m_this->lockSightInfoMap();
//		crSightInfo *sightInfo = m_this->getOrCreateSightInfo(m_camp);
//		crInstanceItem *item;
//		crData *itemData;
//		int roomid = m_this->getRoomID();
//		ReliveItemMap::iterator itr = reliveItemMap->find(m_id);
//		for( ;
//			itr != reliveItemMap->end() && itr->first == m_id;
//			++itr )
//		{
//			item = scene->findRoomItem(roomid,itr->second->getInstanceID());
//			if(item && item->getItemtype() == crInstanceItem::Npc)
//			{
//				itemData = item->getDataClass();
//				if(itemData)
//					itemData->inputParam(WCHDATA_Camp,&m_camp);
//				sightInfo->addEyeItem(item);
//			}
//		}
//		//m_this->unlockSightInfoMap();
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJLoadBattleRoomDataMethod
//
/////////////////////////////////////////
crJXJLoadBattleRoomDataMethod::crJXJLoadBattleRoomDataMethod(){}
crJXJLoadBattleRoomDataMethod::crJXJLoadBattleRoomDataMethod(const crJXJLoadBattleRoomDataMethod& handle):
	crMethod(handle)
{
}
void crJXJLoadBattleRoomDataMethod::inputParam(int i, void *param)
{
}

void crJXJLoadBattleRoomDataMethod::addParam(int i, const std::string& str)
{
}

void crJXJLoadBattleRoomDataMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(room && scene && !room->getDataClass())
	{
		std::string roomdata = crGlobalHandle::getInstance()->getScenarioDir()+scene->getSceneName()+".cfg";
		ref_ptr<crData> data = CREncapsulation::loadData(roomdata);
		room->setDataClass(data.get());
		if(data.valid())
		{
			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
			void *param;
			crData *gameData = playerGameData->getDataClass();
			gameData->getParam(WCHDATA_JXJBattleRoomID,param);
			_crInt64 battleroomid = *(_crInt64 *)param;
			int battleid = LOINT64(battleroomid);
			data->inputParam(WCHDATA_JXJBattleID,&battleid);
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoadFubenRoomDataMethod
//
/////////////////////////////////////////
crJXJLoadFubenRoomDataMethod::crJXJLoadFubenRoomDataMethod(){}
crJXJLoadFubenRoomDataMethod::crJXJLoadFubenRoomDataMethod(const crJXJLoadFubenRoomDataMethod& handle):
	crMethod(handle)
{
}
void crJXJLoadFubenRoomDataMethod::inputParam(int i, void *param)
{
}

void crJXJLoadFubenRoomDataMethod::addParam(int i, const std::string& str)
{
}

void crJXJLoadFubenRoomDataMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(room && scene && !room->getDataClass())
	{
		std::string roomdata = crGlobalHandle::getInstance()->getScenarioDir()+scene->getSceneName()+".cfg";
		ref_ptr<crData> data = CREncapsulation::loadData(roomdata);
		room->setDataClass(data.get());
	}
}
/////////////////////////////////////////
//
//crJXJBattleKillStatsMethod
//
/////////////////////////////////////////
crJXJBattleKillStatsMethod::crJXJBattleKillStatsMethod():
	m_deadArmy(0)
{
}
crJXJBattleKillStatsMethod::crJXJBattleKillStatsMethod(const crJXJBattleKillStatsMethod& handle):
	crMethod(handle),
	m_deadArmy(handle.m_deadArmy)
{
}
void crJXJBattleKillStatsMethod::addParam(int i, const std::string& str)
{
}
void crJXJBattleKillStatsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_deadArmy = *(short *)(LOINT64(param64));
			m_itempair = (std::pair<crInstanceItem *,crInstanceItem *> *)(HIINT64(param64));
		}
		else
		{
			m_itempair = NULL;
		}
		break;
	}
}
void crJXJBattleKillStatsMethod::operator()(crHandle &handle)
{
	if(m_deadArmy>0)
	{
		void *param;
		crData *deaditemData = NULL;
		ref_ptr<crInstanceItem> deaditem = m_itempair->first;
		ref_ptr<crInstanceItem> fireitem = m_itempair->second;
		crRole *deadRole = dynamic_cast<crRole *>(deaditem.get());
		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		if(fireitem.valid())
		{
			_crInt64 ownerid = fireitem->getOwnerID();
			if(ownerid!=0)
			{
				int id = LOINT64(ownerid);
				int roleid = HIINT64(ownerid);
				if(roleid>0)
				{//玩家
					ref_ptr<crSceneServerPlayerData> ownerplayerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(id));
					if(ownerplayerData.valid())
					{
						fireitem = ownerplayerData->getRole(roleid);
					}
				}
				else
				{//npc
					crSceneServerCallback *netcallback = dynamic_cast<crSceneServerCallback *>(netConductor->getNetDataManager()->getNetCallback());
					CRNetApp::crScene *scene = netcallback->findScene(fireitem->getSceneID());
					if(scene)
					{
						fireitem = scene->findSceneItem(id,fireitem->getRoomID());
					}
				}
			}
		}
		ref_ptr<crRole>fireRole;
		if(fireitem.valid() && fireitem->getPlayerID()>0) 
			fireRole = dynamic_cast<crRole *>(fireitem.get());
		int playerid = -1;

		crData *data = m_this->getDataClass();
		//CRCore::ScopedLock<crData> lock(*data);
		data->getParam(WCHDATA_JXJBattleStatsMap,param);
		BattleStatsMap *battleStatsMap = (BattleStatsMap *)param;
		unsigned char roomType = 0;
		data->getParam(WCHDATA_JXJRoomType,param);
		roomType = *(unsigned char *)param;

		if (deadRole)
		{
			if (deadRole->getDataClass())
			{
				deaditemData = deadRole->getDataClass();
			}
			else
			{
				return;
			}
		}
		else if(deaditem.valid())
		{
			if (deaditem->getDataClass())
			{
				deaditemData = deaditem->getDataClass();
			}
			else
			{
				return;
			}
		}
		ref_ptr<crSceneServerPlayerData> playerData;
		if(deadRole)
		{
			float rthp = 0.0f;
			deaditemData->getParam(WCHDATA_RTHP, param);
			rthp = *(float*)param;
			playerid = deadRole->getPlayerID();
			playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			data->lock();
			CRCore::ref_ptr<crJXJBattleStats> playerBattleStats;
			{
				BattleStatsMap::iterator itr = battleStatsMap->find(playerid);
				if (itr != battleStatsMap->end())
					playerBattleStats = itr->second;
				else if (playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
				{
					crPlayerGameData *playerGameData = playerData->getPlayerGameData();
					crData *gameData = playerGameData->getDataClass();
					gameData->getParam(WCHDATA_JXJShiliID, param);
					unsigned char shiliid = *(unsigned char *)param;

					playerBattleStats = new crJXJBattleStats(playerid, shiliid);
					playerBattleStats->setCharacterName(playerData->getCharacterName());
					(*battleStatsMap)[playerid] = playerBattleStats;
				}
			}
			data->unlock();

			if (playerBattleStats.valid())
			{
				playerBattleStats->addDeadMap(deadRole->getAbstractItemID(), m_deadArmy);
				if(rthp<=0.0f)
				{
					playerBattleStats->addDeadBuDuiC(1);
				}
			}

			if (roomType == 3)
			{
				if (fireRole.valid() && rthp <= 0.0f)
				{//杀死玩家，积分变化
					int attackid = fireRole->getPlayerID();
					
					if (fireRole->getPlayerGameData() && fireRole->getPlayerGameData()->getDataClass())
					{
						std::string attactname = fireRole->getIName();
						ref_ptr<crData> attactdata = fireRole->getPlayerGameData()->getDataClass();
						attactdata->getParam(WCHDATA_JXJShiliID,param);
						unsigned char attshiliid = *(unsigned char *)param;

						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(12 + attactname.size());
						stream->_writeUChar(2);
						stream->_writeUChar(1);
						stream->_writeShort(m_deadArmy);
						stream->_writeInt(attackid);
						stream->_writeString(attactname);

						ref_ptr<crPlayerDataEventPacket> packet = new crPlayerDataEventPacket;
						crPlayerDataEventPacket::buildReplyPacket(*packet, 0, WCH_JXJRecvWorldFuBenData, stream.get());
						m_this->sendRoomMessage(packet.get(),attshiliid);
					}
				}
			}
			else if (roomType == 1 && playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
			{//国战里国家官员被击杀
				crPlayerGameData *playerGameData = playerData->getPlayerGameData();
				crData *gameData = playerGameData->getDataClass();
				gameData->getParam(WCHDATA_JXJPlayerGuanZhi,param);
				unsigned char guanzhi = *(unsigned char *)param;

				//国家官员被击杀
				if (guanzhi==1 || guanzhi==2 || guanzhi==3)
				{
					bool isdeadall = true;
					ref_ptr<crData> itemData;
					crSceneServerPlayerData::RoleMap &roleMap = playerData->getRoleMap();
					for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
						ritr != roleMap.end();
						++ritr )
					{
						ref_ptr<crInstanceItem> item = dynamic_cast<crInstanceItem *>(ritr->second.get());
						itemData = item->getDataClass();
						if(itemData.valid())
						{
							itemData->getParam(WCHDATA_ItemState,param);
							unsigned char itemstate = *(unsigned char *)param;
							if(itemstate != IS_Dead)
								isdeadall = false;
						}
					}
					if (isdeadall)
					{
						std::string deadplayer = playerGameData->getCharacterName();
						gameData->getParam(WCHDATA_JXJShiliID, param);
						unsigned char deadshili = *(unsigned char *)param;
						playerBattleStats->addkilledtimes(1);

						std::string fireplayer;
						if(fireRole.valid())
						{
							fireplayer = fireRole->getIName();
							//ref_ptr<crPlayerGameData> playgadata = fireRole->getPlayerGameData();
							//if(playgadata.valid())
							//{
							//	fireplayer = playgadata->getCharacterName();
							//	//playgadata->getDataClass()->getParam(WCHDATA_JXJShiliID,param);
							//	//fireshili =  *(unsigned char *)param;
							//}
						}
						else
							fireplayer = "npc";
						
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(11+deadplayer.size()+fireplayer.size());
						stream->_writeUChar(1);
						stream->_writeUChar(deadshili);
						stream->_writeUChar(guanzhi);
						stream->_writeUChar(playerBattleStats->getkilledtimes());
						stream->_writeString(fireplayer);
						stream->_writeString(deadplayer);

						ref_ptr<crPlayerDataEventPacket> packet = new crPlayerDataEventPacket;
						crPlayerDataEventPacket::buildReplyPacket(*packet,0,WCH_JXJRecvBattleBrocast,stream.get());
						m_this->sendRoomMessage(packet.get());
					}
				}
			}
		}

		int npcCount = 0;
		int bossCount = 0;
		if(fireRole.valid())
		{
			int firebingzhong = fireRole->getAbstractItemID();
			bool isxiaoguai = false;
			playerid = fireRole->getPlayerID();
			playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			std::string attackname = fireRole->getIName();//getPlayerGameData()->getCharacterName();
			unsigned char fireroletype = fireRole->getItemtype();
			data->lock();
			CRCore::ref_ptr<crJXJBattleStats> playerBattleStats;
			{
				BattleStatsMap::iterator itr = battleStatsMap->find(playerid);
				if (itr != battleStatsMap->end())
					playerBattleStats = itr->second;
				else if (playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
				{
					crPlayerGameData *playerGameData = playerData->getPlayerGameData();
					crData *gameData = playerGameData->getDataClass();
					gameData->getParam(WCHDATA_JXJShiliID, param);
					unsigned char shiliid = *(unsigned char *)param;

					playerBattleStats = new crJXJBattleStats(playerid, shiliid);
					playerBattleStats->setCharacterName(playerData->getCharacterName());
					(*battleStatsMap)[playerid] = playerBattleStats;
				}
			}
			data->unlock();
			if (playerBattleStats.valid())
			{
				if(deadRole)
				{
					if(firebingzhong!=20019 && firebingzhong!=20020 && firebingzhong!=20021 &&firebingzhong!=20022)
						playerBattleStats->addTroopsKillCount(firebingzhong, m_deadArmy);

					playerBattleStats->addKillArmyCount(deadRole->getAbstractItemID(), m_deadArmy);
					//itemData = deadRole->getDataClass();
					deaditemData->getParam(WCHDATA_RTHP,param);
					float rthp = *(float*)param;
					if(rthp<=0.0f)
					{
						playerBattleStats->addKillCount(1);

						data->getParam(WCHDATA_JXJRoomFistBloodPlayer,param);
						int * firstBloodPlayerId = (int *)param;
						if(*firstBloodPlayerId == 0)
						{
							*firstBloodPlayerId = playerid;
							//通告
						}
					}
				}
				else
				{
					unsigned int guisestate = GS_Normal;
					deaditem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if(guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock)
					{
						playerBattleStats->addBuildingKillArmyCount(deaditem->getAbstractItemID(), m_deadArmy);
						//itemData = deaditem->getDataClass();
						deaditemData->getParam(WCHDATA_RTHP,param);
						float rthp = *(float*)param;
						if(rthp<=0.0f)
						{
							deaditemData->getParam(WCHDATA_JXJNpcItemType,param);
							unsigned char npcItemType = *(unsigned char *)param;
							std::string itemName = deaditem->getIName();
							
							if(npcItemType == NPC_ZhengTing)
								playerBattleStats->addKillZhengTing(1);
							else if(npcItemType == NPC_JianTa)
							{
								playerBattleStats->addKillTower(1);
								if(firebingzhong==20019 || firebingzhong==20020 || firebingzhong==20021 || firebingzhong==20022)
									playerBattleStats->addTroopsKillCount(firebingzhong, 1);
							}
							else if(npcItemType == NPC_ChengMen)
								playerBattleStats->addKillDoor(1);

							playerBattleStats->addBuildingKillCount(1);
							//战场通告摧毁建筑
							if(roomType==1)
							{
								std::string playerName = playerBattleStats->getPlayerName();

								ref_ptr<crStreamBuf> stream = new crStreamBuf;
								stream->createBuf(9+itemName.size()+playerName.size());
								stream->_writeUChar(4);
								stream->_writeChar(0);
								stream->_writeString(playerName);
								stream->_writeString(itemName);

								ref_ptr<crPlayerDataEventPacket> packet = new crPlayerDataEventPacket;
								crPlayerDataEventPacket::buildReplyPacket(*packet,0,WCH_JXJRecvBattleBrocast,stream.get());
								m_this->sendRoomMessage(packet.get());
							}
						}
					}
					else
					{
						if(firebingzhong!=20019 && firebingzhong!=20020 && firebingzhong!=20021 &&firebingzhong!=20022)
							playerBattleStats->addTroopsKillCount(firebingzhong, m_deadArmy);

						playerBattleStats->addNpcKillArmyCount(deaditem->getAbstractItemID(), m_deadArmy);
						//itemData = deaditem->getDataClass();
						deaditemData->getParam(WCHDATA_RTHP,param);
						float rthp = *(float*)param;
						if(rthp<=0.0f)
						{
							deaditemData->getParam(WCHDATA_JXJNpcItemType,param);
							unsigned char npcItemType = *(unsigned char *)param;
							if (npcItemType == NPC_Boss)
							{
								playerBattleStats->addBossKillCount(1);
								bossCount = playerBattleStats->getBosskillCount();
								//战场通告杀死BOSS
								if(roomType==1)
								{
									std::string itemName = deaditem->getIName();
									std::string playerName = playerBattleStats->getPlayerName();

									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(9+itemName.size()+playerName.size());
									stream->_writeUChar(4);
									stream->_writeChar(1);
									stream->_writeString(playerName);
									stream->_writeString(itemName);

									ref_ptr<crPlayerDataEventPacket> packet = new crPlayerDataEventPacket;
									crPlayerDataEventPacket::buildReplyPacket(*packet,0,WCH_JXJRecvBattleBrocast,stream.get());
									m_this->sendRoomMessage(packet.get());
								}
							}
							else
							{
								isxiaoguai = true;
								playerBattleStats->addNpcKillCount(1);
								npcCount = playerBattleStats->getNpcKillCount();
							}
						}
					}
				}
			}
			if (isxiaoguai && roomType==3)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(10+attackname.size());
				stream->_writeUChar(4);
				stream->_writeUChar(1);
				stream->_writeInt(playerid);
				stream->_writeString(attackname);

				ref_ptr<crPlayerDataEventPacket> packet = new crPlayerDataEventPacket;
				crPlayerDataEventPacket::buildReplyPacket(*packet,0,WCH_JXJRecvWorldFuBenData,stream.get());
				m_this->sendRoomMessage(packet.get(),playerBattleStats->getShiliID());
			}
		}
		else if(roomType == 2)//副本中把友军杀死的也算玩家
		{//fuben qu battleStatsMap begin role, role item shifoushi diren, 
			data->lock();
			CRCore::ref_ptr<crJXJBattleStats> playerBattleStats;
			playerid = 0;
			if (!battleStatsMap->empty())
			{
				BattleStatsMap::iterator itr = battleStatsMap->begin();
				playerid = itr->first;
				playerBattleStats = itr->second;
			}
			data->unlock();
			if (playerid>0)
			{
				playerData = dynamic_cast<crSceneServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
				if (playerData.valid())
				{
					crSceneServerPlayerData::RoleMap &roleMap = playerData->getRoleMap();
					crSceneServerPlayerData::RoleMap::iterator itr_role = roleMap.begin();
					if(itr_role!=roleMap.end())
					{
						char isEnemy = 0;
						itr_role->second->doEvent(WCH_EnemyCheck,MAKEINT64(deaditem.get(),&isEnemy));
						if(isEnemy!=1)//敌人
						{
							unsigned int guisestate = GS_Normal;
							deaditem->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
							if(guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock)
							{
								playerBattleStats->addBuildingKillArmyCount(deaditem->getAbstractItemID(), m_deadArmy);
								//itemData = deaditem->getDataClass();
								deaditemData->getParam(WCHDATA_RTHP,param);
								float rthp = *(float*)param;
								if(rthp<=0.0f)
								{
									playerBattleStats->addBuildingKillCount(1);
								}
							}
							else
							{
								playerBattleStats->addNpcKillArmyCount(deaditem->getAbstractItemID(), m_deadArmy);
								//itemData = deaditem->getDataClass();
								deaditemData->getParam(WCHDATA_RTHP,param);
								float rthp = *(float*)param;
								if(rthp<=0.0f)
								{
									deaditemData->getParam(WCHDATA_JXJNpcItemType, param);
									unsigned char npcItemType = *(unsigned char *)param;
									if (npcItemType == NPC_Boss)
									{
										playerBattleStats->addBossKillCount(1);
										bossCount = playerBattleStats->getBosskillCount();
									}
									else
									{
										playerBattleStats->addNpcKillCount(1);
										npcCount = playerBattleStats->getNpcKillCount();
									}
								}
							}
						}
					}
				}
			}
		}
		if (roomType == 2 && playerData.valid() && (npcCount != 0 || bossCount != 0))
		{
			//发包给客户端
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(8);
			stream->_writeInt(npcCount);
			stream->_writeInt(bossCount);
			crRoomEventPacket  packet;
			crRoomEventPacket::buildRequestPacket(packet, WCH_JXJRecvFubenKillInfo, stream.get());
			netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet);
		}
	}
}

/////////////////////////////////////////
//
//crJXJBattlePlayerLeaveMethod
//
/////////////////////////////////////////
crJXJBattlePlayerLeaveMethod::crJXJBattlePlayerLeaveMethod():
	m_playerid(0){}
crJXJBattlePlayerLeaveMethod::crJXJBattlePlayerLeaveMethod(const crJXJBattlePlayerLeaveMethod& handle):
	crMethod(handle),
	m_playerid(handle.m_playerid)
{
}
void crJXJBattlePlayerLeaveMethod::addParam(int i, const std::string& str)
{
}
void crJXJBattlePlayerLeaveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerid = LOINT64(param64);
		}
		break;
	}
}
void crJXJBattlePlayerLeaveMethod::operator()(crHandle &handle)
{
	if(m_playerid>0 && m_this->getDataClass())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJBattleStatsMap,param);
		BattleStatsMap *battleStatsMap = (BattleStatsMap *)param;
		if(battleStatsMap)
		{
			BattleStatsMap::iterator itr = battleStatsMap->find(m_playerid);
			if(itr!=battleStatsMap->end())
			{//判断玩家是否死光
				itr->second->setStats(0);
			}
		}
		data->getParam(WCHDATA_JXJBattleRBuffId,param);
		bool needsend = false;
		crVector2i* battleRbuffids = (crVector2i *)param;
		if((*battleRbuffids)[0] == m_playerid)
		{
			needsend = true;
			(*battleRbuffids)[0] = 0;
		}
		else if((*battleRbuffids)[1] == m_playerid)
		{
			needsend = true;
			(*battleRbuffids)[1] = 0;
		}
		if(needsend)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(12);
			stream->_writeInt(0);
			stream->_writeVec2i(*battleRbuffids);

			crJXJBattleRBuffPacket packet;
			crJXJBattleRBuffPacket::buildReplyPacket(packet,stream.get());
			m_this->sendPacketToAll(packet,m_playerid);
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}

/////////////////////////////////////////
//
//crJXJFubenPlayerLeaveMethod
//
/////////////////////////////////////////
crJXJFubenPlayerLeaveMethod::crJXJFubenPlayerLeaveMethod():
	m_playerid(0){}
crJXJFubenPlayerLeaveMethod::crJXJFubenPlayerLeaveMethod(const crJXJFubenPlayerLeaveMethod& handle):
	crMethod(handle),
	m_playerid(handle.m_playerid)
{
}
void crJXJFubenPlayerLeaveMethod::addParam(int i, const std::string& str)
{
}
void crJXJFubenPlayerLeaveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerid = LOINT64(param64);
		}
		break;
	}
}
void crJXJFubenPlayerLeaveMethod::operator()(crHandle &handle)
{
	if(m_playerid>0 && m_this->getDataClass())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJBattleStatsMap,param);
		BattleStatsMap *battleStatsMap = (BattleStatsMap *)param;
		if( m_this->getGameRunning() && battleStatsMap)
		{
			BattleStatsMap::iterator itr = battleStatsMap->find(m_playerid);
			if(itr!=battleStatsMap->end())
				battleStatsMap->erase(itr);
			//记录下玩家离开时副本进度
			data->getParam(WCHDATA_JXJBattleID,param);
			int battleid = *(int *)param;
			unsigned short fubenid = HIINT32(battleid);
			data->getParam(WCHDATA_RoomProgress,param);
			short progress = *(short *)param;
			std::string logdata = "玩家提前离开副本(fubenid|进度)"+crArgumentParser::appVectoa(crVector2i(fubenid,progress),'|');
			GameLogData gamelog(Log_LeaveFuben,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_playerid,&gamelog));
		}
		// 		data->getParam(WCHDATA_JXJBattleID,param);
		// 		int battleid = *(int *)param;
		// 		unsigned short fubenid = HIINT32(battleid);
		// 
		// 		crNetConductor *serverConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		// 		crNetDataManager *netDataManager = serverConductor->getNetDataManager();
		// 		ref_ptr<crSceneServerPlayerData> playerSceneData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(m_playerid));
		// 
		// 		if(playerSceneData.valid())
		// 		{
		// 			crPlayerGameData * playerGameData = playerSceneData->getPlayerGameData();
		// 			if(playerGameData)
		// 			{
		// 				crData *playerData = playerGameData->getDataClass();
		// 				if(playerData)
		// 				{
		// 					float fubenArmyBackFactor = 0.0f;
		// 					unsigned short conut = 0;
		// 					crTableIO::StrVec record;
		// 					ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		// 					if(fubentab)
		// 					{
		// 						int index = fubentab->getTitleIndex("兵力返还");
		// 						if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) && index>=0)
		// 						{
		// 							fubenArmyBackFactor = atof(record[index].c_str());
		// 							if(fubenArmyBackFactor>1.0f) fubenArmyBackFactor = 1.0f;
		// 						}
		// 					}
		// 					playerData->excHandle(MAKEINT64(WCH_LockData,1));
		// 					playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
		// 					FormationInfoVec *formationVec = (FormationInfoVec *)param;
		// 
		// 					crSceneServerPlayerData::RoleMap::iterator itr_role;
		// 					FormationInfoVec::iterator itr = formationVec->begin();
		// 					for (;itr!=formationVec->end();itr++)
		// 					{
		// 						conut = itr->get()->getCount();
		// 						itr->get()->setCount((unsigned short)(conut * fubenArmyBackFactor));
		// 					}
		// 					playerData->excHandle(MAKEINT64(WCH_LockData,0));
		// 				}
		// 			}
		// 		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}

/////////////////////////////////////////
//
//crJXJBattleSettleMethod
//
/////////////////////////////////////////
crJXJBattleSettleMethod::crJXJBattleSettleMethod():
	m_progress(0){}
crJXJBattleSettleMethod::crJXJBattleSettleMethod(const crJXJBattleSettleMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress)
{
}
void crJXJBattleSettleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = (short)(atoi(str.c_str()));
		break;
	}
}
void crJXJBattleSettleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJBattleSettleMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJBattleID,param);
	int battleid = *(int *)param;
	unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
	unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
	//战报需统计数据：1，battleid 2，isWin 3.双方投入兵力 4.双方死伤兵力5沙地前三死伤前三名字数据
	int ashiliTotalrtCount = 0;
	int ashiliTotalDeadCount = 0;
	int dshiliTotalrtCount = 0;
	int dshiliTotalDeadCount = 0;
	int ashiliTotalkillNpcCount = 0;
	int dshiliTotalkillNpcCount = 0;
	crRoomPlayer *member = NULL;
	ref_ptr<crSceneServerPlayerData> memberdata;
	int roomplayerid = 0;
	crData *roleData;
	crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *sceneServerDataManager = sceneServer->getNetDataManager();
	m_this->lockPlayerList();
	crRoom::PlayerList &playerList = m_this->getPlayerList();
	for (crRoom::PlayerList::iterator itr = playerList.begin();
		itr != playerList.end();
		++itr)
	{
		member = itr->get();
		roomplayerid = member->getPlayerID();
		unsigned char key = member->getGroupID();
		memberdata = dynamic_cast<crSceneServerPlayerData *>(sceneServerDataManager->getPlayerData(roomplayerid));
		if (memberdata.valid())
		{
			unsigned char shili = member->getGroupID();
			crSceneServerPlayerData::RoleMap &roleMap = memberdata->getRoleMap();
			for (crSceneServerPlayerData::RoleMap::iterator it = roleMap.begin();
				it != roleMap.end();
				it++)
			{
				roleData = it->second->getDataClass();
				if (roleData)
				{
					roleData->getParam(WCHDATA_JXJRTArmyCount, param);
					/*unsigned short*/int armyRTCount = *(/*unsigned short*/int *)param;
					if (armyRTCount > 0)
					{
						if (shili == attackShili)
							ashiliTotalrtCount += armyRTCount;
						else if (shili == defenceShili)
							dshiliTotalrtCount += armyRTCount;
					}
				}
			}
		}
	}
	m_this->unlockPlayerList();
	/////////////////////战报需统计数据结束

	data->getParam(WCHDATA_RoomProgress,param);
	short progress = *(short *)param;

	//data->getParam(WCHDATA_JXJRoomFistBloodPlayer,param);
	//int firstBloodPlayerID = *(int *)param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJBattleStatsMap,param);
	BattleStatsMap battleStatsMap = *(BattleStatsMap *)param;
	data->getParam(WCHDATA_JXJBattleTotalNpcCount, param);
	NpcTotalCountMap npcTotalMap = *(NpcTotalCountMap *)param;
	data->excHandle(MAKEINT64(WCH_LockData,0));
	//std::map<int,std::pair<float,float> > playerScoreExperienceMap;
	//float demageFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleDemageFactor,0).c_str());
	//float killFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleKillFactor,0).c_str());
	//float bulidingDemageFactor =  atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleBulidingDemageFactor,0).c_str());
	//float bulidingKillFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleBulidingKillFactor,0).c_str());
	//float totalFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleTotalFactor,0).c_str());
	//float firstBloodScore = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleFirstBloodScore,0).c_str());
	float experienceFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleExperienceFactor,0).c_str());
	//ref_ptr<crTableIO> troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
	ref_ptr<crTableIO> roledataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);
	ref_ptr<crTableIO> npcdataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
	int rolescoreIndex = roledataAttrTab->getTitleIndex("积分系数");
	int roleexperienceIndex = roledataAttrTab->getTitleIndex("死亡经验系数");
	int npcscoreIndex = npcdataAttrTab->getTitleIndex("积分系数");
	//int npcexperienceIndex = roledataAttrTab->getTitleIndex("死亡经验系数");
	//计算玩家杀敌积分
	float killscore = 0.0f;
	int deadCount = 0;
	float experience = 0.0f;
	int killcount = 0;
	int buduicount = 0;
	//计算玩家国战相关成就
	int killplayer = 0;
	int killnpc = 0;
	int selfdead = 0;
	int killhall = 0;
	int killtower = 0;
	int killdoor = 0;
	int killboss = 0;
	int killgongbing = 0;
	int killbubing = 0;
	int killqibing = 0;
	int killqixie = 0;
	std::map<int,CRCore::crVector3i> troopsinfomap;
	std::map<int,CRCore::crVector3i>::iterator troopitr;


	crTableIO::StrVec record;
	//战报相关数据
	std::string roomName = m_this->getName();
	ref_ptr<crStreamBuf> reportstream = new crStreamBuf;
	reportstream->createBuf(27 + roomName.size() + battleStatsMap.size() * 45);
	reportstream->_writeInt(battleid);//4
	reportstream->_writeString(roomName);//4+
	reportstream->_writeBool(progress == m_progress);//true表示攻方胜利//1
	reportstream->_writeUShort(battleStatsMap.size());//2
	//玩家自己数据
	//计算玩家经验奖励
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(15+battleStatsMap.size()*41);
	stream->_writeInt(0);//recvid//4
	stream->_writeInt(battleid);//4
	stream->_writeInt(m_this->getRoomID());//4
	//stream->_writeBool(progress == m_progress);//true表示攻方胜利//1
	if(progress == m_progress)
		stream->_writeChar(1);//1表示攻方胜利//1
	else
	{
		data->getParam(WCHDATA_JXJCampBirthPointMap,param);
		JXJCampBirthpointMap *campMap = (JXJCampBirthpointMap *)param;
		JXJCampBirthpointMap::iterator itrA = campMap->find(attackShili);
		if ((itrA == campMap->end() || (itrA != campMap->end() && itrA->second.empty())))
		{//攻方丢失所有出生点
			stream->_writeChar(-1);//-1表示攻方丢失所有据点,失败
		}
		else
		{
			stream->_writeChar(0);//0表示攻方失败
		}
	}
	stream->_writeUShort(battleStatsMap.size());//2

	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);

	ref_ptr<crTableIO>dataNPCAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
	int bingzhongindex = dataNPCAttrTab->getTitleIndex("兵种");
	ref_ptr<crTableIO> troopTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
	int trooptypeIndex = troopTab->getTitleIndex("兵种");
	crTableIO::StrVec troopsrecord;
	std::vector<std::string> NPCAttrrecord;
	int bingzhongid = 0;

	for( BattleStatsMap::iterator itr_info = battleStatsMap.begin();
		itr_info!=battleStatsMap.end();
		itr_info++)
	{
		//score = 0.0f;
		killscore = 0.0f;
		deadCount = 0;
		killcount = 0;
		experience = 0.0f;
		buduicount = 0;
		//一血分数
		// 		if(itr_info->first == *firstBloodPlayerID)
		// 		{
		// 			score += firstBloodScore;
		// 			*firstBloodPlayerID = 0;
		// 		}

		//人头分
		// 		killcount+=itr_info->second->getKillCount();
		// 		killcount+=itr_info->second->getNpcKillCount();
		// 		score += killFactor * killcount * totalFactor;

		//统计总兵力信息


		//箭塔伤害分
		//score += bulidingDemageFactor * totalFactor * itr_info->second->getBulidingDemage();

		//计算玩家国战相关成就
		killplayer = 0;
		killnpc = 0;
		selfdead = 0;
		killhall = 0;
		killtower = 0;
		killdoor = 0;
		killboss = 0;
		killgongbing = 0;
		killbubing = 0;
		killqibing = 0;
		killqixie = 0;
		troopsinfomap.clear();

		//杀敌分 功勋计算
		killhall = itr_info->second->getKillZhengTing();
		killtower = itr_info->second->getKillTower();
		killdoor = itr_info->second->getKillDoor();
		killboss = itr_info->second->getBosskillCount();
		KillArmyInfoMap & troopkillInfoMap = itr_info->second->getTroopsKillMap();

		KillArmyInfoMap & killInfoMap = itr_info->second->getKillArmyInfoMap();
		KillArmyInfoMap & killNpcInfoMap = itr_info->second->getNpcKillArmyMap();
		KillArmyInfoMap & deadInfoMap = itr_info->second->getDeadCount();
		KillArmyInfoMap & killBulidingMap = itr_info->second->getBuildingKillArmyMap();
		KillArmyInfoMap::iterator itr_kill = killInfoMap.begin();
		for (;itr_kill!=killInfoMap.end();itr_kill++)
		{
			if(rolescoreIndex>=0 && roledataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(itr_kill->first),record)>=0)
			{
				killscore +=/* demageFactor **/ atof(record[rolescoreIndex].c_str()) * (itr_kill->second);
			}

			killcount += itr_kill->second;

			killplayer += itr_kill->second;
			troopsinfomap.insert(std::make_pair(itr_kill->first,crVector3i(itr_kill->second,0,0)));
			/*if ((itr_kill->first >= 20001 && itr_kill->first <= 20006) || (itr_kill->first >= 20505 && itr_kill->first <= 20507) || itr_kill->first == 20023)
			killgongbing += itr_kill->second;

			if ((itr_kill->first >= 20007 && itr_kill->first <= 20012) || (itr_kill->first >= 20500 && itr_kill->first <= 20504))
			killbubing += itr_kill->second;

			if ((itr_kill->first >= 20013 && itr_kill->first <= 20018) || (itr_kill->first >= 20508 && itr_kill->first <= 20510))
			killqibing += itr_kill->second;

			if ((itr_kill->first >= 20019 && itr_kill->first <= 20021) || (itr_kill->first >= 20505 && itr_kill->first <= 20507))
			killqixie += itr_kill->second;*/

			if(troopTab->queryOneRecord(0,crArgumentParser::appItoa(itr_kill->first),troopsrecord) >= 0)
			{
				bingzhongid = atoi(troopsrecord[trooptypeIndex].c_str());
				if(bingzhongid == 0)
					killbubing += itr_kill->second;
				else if(bingzhongid == 1)
					killgongbing += itr_kill->second;
				else if(bingzhongid == 2)
					killqibing += itr_kill->second;
				else if(bingzhongid == 3)
					killqixie += itr_kill->second;
			}
		}

		itr_kill = killNpcInfoMap.begin();
		for (;itr_kill!=killNpcInfoMap.end();itr_kill++)
		{
			if(npcscoreIndex>=0 && npcdataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(itr_kill->first),record)>=0)
			{
				killscore += /*demageFactor **/ atof(record[npcscoreIndex].c_str()) * (itr_kill->second);
			}
			killcount += itr_kill->second;

			if (itr_info->second->getShiliID() == attackShili)
			{
				ashiliTotalkillNpcCount += itr_kill->second;
			}
			else if (itr_info->second->getShiliID() == defenceShili)
			{
				dshiliTotalkillNpcCount += itr_kill->second;
			}

			killnpc += itr_kill->second;

			/*if ((itr_kill->first >= 20001 && itr_kill->first <= 20006) || (itr_kill->first >= 20505 && itr_kill->first <= 20507) || itr_kill->first == 20023)
			killgongbing += itr_kill->second;

			if ((itr_kill->first >= 20007 && itr_kill->first <= 20012) || (itr_kill->first >= 20500 && itr_kill->first <= 20504))
			killbubing += itr_kill->second;

			if ((itr_kill->first >= 20013 && itr_kill->first <= 20018) || (itr_kill->first >= 20508 && itr_kill->first <= 20510))
			killqibing += itr_kill->second;

			if ((itr_kill->first >= 20019 && itr_kill->first <= 20021) || (itr_kill->first >= 20505 && itr_kill->first <= 20507))
			killqixie += itr_kill->second;*/

			if(dataNPCAttrTab->queryOneRecord(0,crArgumentParser::appItoa(itr_kill->first),NPCAttrrecord) >= 0)
			{
				bingzhongid = atoi(NPCAttrrecord[bingzhongindex].c_str());
				if(bingzhongid == 0)
					killbubing += itr_kill->second;
				else if(bingzhongid == 1)
					killgongbing += itr_kill->second;
				else if(bingzhongid == 2)
					killqibing += itr_kill->second;
				else if(bingzhongid == 3)
					killqixie += itr_kill->second;
			}
		}

		itr_kill = killBulidingMap.begin();
		for (;itr_kill!=killBulidingMap.end();itr_kill++)
		{
			if(npcscoreIndex>=0 && npcdataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(itr_kill->first),record)>=0)
			{
				killscore += /*bulidingKillFactor **/ atof(record[npcscoreIndex].c_str()) * (itr_kill->second);
			}
			killcount += itr_kill->second;
		}

		//score += killscore /** totalFactor*/;

		//经验奖励计算

		itr_kill = deadInfoMap.begin();
		for (;itr_kill!=deadInfoMap.end();itr_kill++)
		{
			if(roleexperienceIndex>=0 && roledataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(itr_kill->first),record)>=0)
			{
				experience += experienceFactor * atof(record[roleexperienceIndex].c_str()) * (itr_kill->second);
			}
			deadCount += itr_kill->second;

			selfdead += itr_kill->second;
			troopitr = troopsinfomap.find(itr_kill->first);
			if(troopitr != troopsinfomap.end())
				troopitr->second[1] = itr_kill->second;
			else
				troopsinfomap.insert(std::make_pair(itr_kill->first,crVector3i(0,itr_kill->second,0)));
		}

		itr_kill = troopkillInfoMap.begin();
		for (;itr_kill!=troopkillInfoMap.end();itr_kill++)
		{
			troopitr = troopsinfomap.find(itr_kill->first);
			if(troopitr != troopsinfomap.end())
				troopitr->second[2] = itr_kill->second;
			else
				troopsinfomap.insert(std::make_pair(itr_kill->first,crVector3i(0,0,itr_kill->second)));
		}

		buduicount = itr_info->second->getDeadBuDuiC();
		int isdeadall = 0;
		memberdata = dynamic_cast<crSceneServerPlayerData *>(sceneServerDataManager->getPlayerData(itr_info->first));
		if (memberdata.valid())
		{
			crSceneServerPlayerData::RoleMap &roleMap = memberdata->getRoleMap();
			for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
				ritr != roleMap.end();
				++ritr )
			{
				ref_ptr<crInstanceItem> item = dynamic_cast<crInstanceItem *>(ritr->second.get());
				ref_ptr<crData> itemData = item->getDataClass();
				if(itemData.valid())
				{
					itemData->getParam(WCHDATA_ItemState,param);
					unsigned char itemstate = *(unsigned char *)param;
					if(itemstate == IS_Dead)
						isdeadall++;
				}
			}
		}
		buduicount = buduicount + 3 - isdeadall;

		//playerScoreExperienceMap.insert(std::make_pair(itr_info->first,std::make_pair(score,experience)));
		stream->_writeInt(itr_info->first);//4
		stream->_writeUChar(itr_info->second->getShiliID());//shiliid
		stream->_writeFloat(killscore);//4
		stream->_writeFloat(experience);//4
		stream->_writeString(itr_info->second->getPlayerName());//20
		stream->_writeInt(killcount);
		stream->_writeInt(deadCount);

		reportstream->_writeInt(itr_info->first);//4
		reportstream->_writeInt(killcount);//4
		reportstream->_writeInt(deadCount);//4

		reportstream->_writeUChar(itr_info->second->getShiliID());

		reportstream->_writeFloat(killscore);//4
		reportstream->_writeFloat(experience);//4
		reportstream->_writeString(itr_info->second->getPlayerName());//20

		reportstream->_writeInt(buduicount);

		if (itr_info->second->getShiliID() == attackShili)
		{
			ashiliTotalDeadCount += deadCount;
		}
		else if (itr_info->second->getShiliID() == defenceShili)
		{
			dshiliTotalDeadCount += deadCount;
		}

		ref_ptr<crStreamBuf> achievestream = new crStreamBuf;
		achievestream->createBuf(44+troopsinfomap.size()*16);
		achievestream->_writeInt(killplayer);
		achievestream->_writeInt(killnpc);
		achievestream->_writeInt(selfdead);
		achievestream->_writeInt(killdoor);
		achievestream->_writeInt(killhall);
		achievestream->_writeInt(killtower);
		achievestream->_writeInt(killboss);
		achievestream->_writeInt(killgongbing);
		achievestream->_writeInt(killbubing);
		achievestream->_writeInt(killqibing);
		achievestream->_writeInt(killqixie);
		achievestream->_writeUShort(troopsinfomap.size());
		for (std::map<int,CRCore::crVector3i>::iterator itr = troopsinfomap.begin();itr != troopsinfomap.end();itr++)
		{
			achievestream->_writeInt(itr->first);
			achievestream->_writeVec3i(itr->second);
		}

		crPlayerDataEventPacket achievepacket;
		crPlayerDataEventPacket::buildReplyPacket(achievepacket,itr_info->second->getPlayerID(),WCH_JXJGuoZhanAchievement,achievestream.get());
		netConductor->getNetManager()->sendPacket("all",achievepacket);
	}

	for (NpcTotalCountMap::iterator itr_npc = npcTotalMap.begin(); \
		itr_npc != npcTotalMap.end(); itr_npc++)
	{
		if (itr_npc->first == attackShili)
		{
			ashiliTotalrtCount += itr_npc->second - dshiliTotalkillNpcCount;
			ashiliTotalDeadCount += dshiliTotalkillNpcCount;
		}
		else if (itr_npc->first == defenceShili)
		{
			dshiliTotalrtCount += itr_npc->second - ashiliTotalkillNpcCount;
			dshiliTotalDeadCount += ashiliTotalkillNpcCount;
		}
	}

	reportstream->_writeInt(ashiliTotalrtCount);//4
	reportstream->_writeInt(ashiliTotalDeadCount);//4
	reportstream->_writeInt(dshiliTotalrtCount);//4
	reportstream->_writeInt(dshiliTotalDeadCount);//4

	//crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);

	crJXJBattleSettlePacket packet;
	crJXJBattleSettlePacket::buildRequestPacket(packet,stream.get());
	netConductor->getNetManager()->sendPacket("all",packet);
	m_this->sendPacketToAll(packet);

	crJXJBattleReportPacket reportPacket;
	crJXJBattleReportPacket::buildRequestPacket(reportPacket, reportstream.get());
	netConductor->getNetManager()->sendPacket("all", reportPacket);
	m_this->sendPacketToAll(reportPacket);
}
/////////////////////////////////////////
//
//crJXJRecvBattleSettleMethod
//
/////////////////////////////////////////
crJXJRecvBattleSettleMethod::crJXJRecvBattleSettleMethod(){}
crJXJRecvBattleSettleMethod::crJXJRecvBattleSettleMethod(const crJXJRecvBattleSettleMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBattleSettleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBattleSettleMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvBattleSettleMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//int deadCoe = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleDeadCoefficient, 0).c_str());
		//int killCoe = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleKillCoefficient, 0).c_str());
		float rewardCBFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleCBRewardFactor, 0).c_str());
		float rewardExploitFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleExploitRewardFactor, 0).c_str());
		m_stream->_readInt();
		_crInt32 battleid = m_stream->_readInt();
		int roomid = m_stream->_readInt();
		char winstats = m_stream->_readChar();//1表示攻防胜利,0表示失败,-1表示丢失所有据点
		bool win = winstats==1;//true表示攻方胜利
		unsigned short mapsize = m_stream->_readUShort();
		BattleStatsMap battleStatsMap;
		ref_ptr<crJXJBattleStats> battleStats;
		int playerid = 0;
		int totalkillcount = 0;
		float playerScore = 0.0f;
		float playerExperience = 0.0f;
		std::string playerCharacterName;
		int playerkilledcount = 0;
		int playerdeadcount = 0;
		unsigned char shiliid = 0;
		unsigned char ashili = (unsigned char)(LOINT16(LOINT32(battleid)));
		unsigned char dshili = (unsigned char)(HIINT16(LOINT32(battleid)));
		unsigned short chengchiid = HIINT32(battleid);
		int ashiliKill = 0;
		int dshiliKill = 0; 
		//BattleSettle battle_settle;
		BattleSettleMap battleSettleMapWinner; //win
		BattleSettleMap battleSettleMapLoser;  //lose
		float killValue = 0.0f;
		void *param;
		crData *data = m_this->getDataClass();
		crJXJShili *jxjShili;
		crData *shiliData;
		PeopleMap *peopleMap = NULL;
		PeopleMap::iterator peoItr;
		bool shiliModify = true;
		int chengchiRewardIndex = 3;//0,魏 1蜀 2吴 3群
		//通告
		// 		data->getParam(WCHDATA_JXJShiliWei,param);
		// 		crJXJShili *shiliWei = (crJXJShili *)param;
		// 		data->getParam(WCHDATA_JXJShiliShu,param);
		// 		crJXJShili *shiliShu = (crJXJShili *)param;
		// 		data->getParam(WCHDATA_JXJShiliWu,param);
		// 		crJXJShili *shiliWu = (crJXJShili *)param;
		// 		int weiID = shiliWei->getID();
		// 		int shuID = shiliShu->getID();
		// 		int wuID = shiliWu->getID();
		// 
		// 		std::string strAttack,strDefend;
		// 		if(ashili == weiID)
		// 		{
		// 			strAttack = "魏";
		// 		}
		// 		else if(ashili == shuID)
		// 		{
		// 			strAttack = "蜀";
		// 		}
		// 		else if(ashili == wuID)
		// 		{
		// 			strAttack = "吴";
		// 		}
		// 		if(dshili == weiID)
		// 		{
		// 			strDefend = "魏";
		// 			chengchiRewardIndex = 0;
		// 		}
		// 		else if(dshili == shuID)
		// 		{
		// 			strDefend = "蜀";
		// 			chengchiRewardIndex = 1;
		// 		}
		// 		else if(dshili == wuID)
		// 		{
		// 			strDefend = "吴";
		// 			chengchiRewardIndex = 2;
		// 		}
		// 		else
		// 		{
		// 			chengchiRewardIndex = 3;
		// 		}
		crTableIO::StrVec record;
		std::string strChengchiName,strMessage,tempStr,noticeStr;
		ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
		if(chengchiTab.valid() && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0 && chengchiTab->getTitleIndex("名字")>0 )
		{
			strChengchiName = record[chengchiTab->getTitleIndex("名字")];
		}
		// 		if(!strDefend.empty())
		// 			tempStr = strDefend+std::string("国");
		// 
		// 		if(win)
		// 		{
		// 			if(!tempStr.empty())
		// 				strMessage = std::string("恭喜")+strAttack+std::string("国在")+tempStr+std::string("[")+strChengchiName+std::string("]之战中击败")+tempStr+std::string("攻城胜利！");
		// 			else
		// 				strMessage = std::string("恭喜")+strAttack+std::string("国在攻下")+tempStr+std::string("[")+strChengchiName+std::string("]");
		// 		}
		// 		else
		// 		{
		// 			if(!tempStr.empty())
		// 				strMessage = std::string("恭喜")+tempStr+std::string("[")+strChengchiName+std::string("]之战中抵挡住")+strAttack+std::string("国猛烈攻势！");
		// 		}
		// 
		// 		ref_ptr<crJXJChatMessageInfo> dchatInfo = new crJXJChatMessageInfo("[通告]",strMessage,0,0);
		// 		crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKEINT64(dchatInfo.get(),NULL));
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJOpenBattle,param);
		bool *openBattle = (bool *)param;
		BattleRankingMap *attackBattleRankingMap = NULL;
		BattleRankingMap *defendBattleRankingMap = NULL;
		BattleRankingMap *winBattleRankingMap = NULL;
		BattleRankingMap *lostBattleRankingMap = NULL;
		ref_ptr<crBattleRanking> battleRanking;
		if(*openBattle)
		{//需要统计战场积分
			if(ashili>=c_startShiliID)
			{
				data->getParam(WCHDATA_JXJBattleRankingMapWei+ashili-c_startShiliID,param);
				attackBattleRankingMap = (BattleRankingMap *)param;
				data->getParam(WCHDATA_JXJBattleRankingVerWei+ashili-c_startShiliID,param);
				char* aver = (char *)param;
				(*aver)++;
			}
			if(dshili>=c_startShiliID)
			{
				data->getParam(WCHDATA_JXJBattleRankingMapWei+dshili-c_startShiliID,param);
				defendBattleRankingMap = (BattleRankingMap *)param;
				data->getParam(WCHDATA_JXJBattleRankingVerWei+dshili-c_startShiliID,param);
				char* dver = (char *)param;
				(*dver)++;
			}
			if (win)
			{
				winBattleRankingMap = attackBattleRankingMap;
				lostBattleRankingMap = defendBattleRankingMap;
			}
			else
			{
				winBattleRankingMap = defendBattleRankingMap;
				lostBattleRankingMap = attackBattleRankingMap;
			}
		}
		//中央公告
		m_this->doEvent(WCH_JXJBattleInfoCenterNoticeCreate,MAKEINT64(battleid,&win));
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
		ref_ptr<crGameServerPlayerData> playerData;
		PlayerBattleInfo playerBattleInfo;
		std::vector<int> playerIDVec;
		int killNum = 0;
		int deadNum = 0;
		int _type = 0;
		unsigned char setGuoZhanVictoryTimes = 0; //0 表示不设置，1表示攻城胜利，2表示守城胜利
		for ( int i = 0; i<mapsize; i++ )
		{
			playerid = m_stream->_readInt();//4
			shiliid = m_stream->_readUChar();
			playerScore = m_stream->_readFloat();
			playerExperience = m_stream->_readFloat();
			playerCharacterName = m_stream->_readString();
			playerkilledcount = m_stream->_readInt();
			playerdeadcount = m_stream->_readInt();
			playerBattleInfo.playerID = playerid;
			//playerBattleInfo.playerScore = playerScore;
			playerBattleInfo.playerExperience = playerExperience;

			if(shiliid == ashili)
			{
				if(win)
				{//记录国战中攻城胜利次数
					setGuoZhanVictoryTimes = 1;
					battleSettleMapWinner.insert(std::make_pair(playerScore,playerBattleInfo));
				}
				else
				{
					battleSettleMapLoser.insert(std::make_pair(playerScore,playerBattleInfo));
				}
				if(attackBattleRankingMap)
				{//
					battleRanking = NULL;
					for( BattleRankingMap::iterator britr = attackBattleRankingMap->begin();
						britr != attackBattleRankingMap->end();
						++britr )
					{
						if(britr->second->getPlayerID() == playerid)
						{
							battleRanking = britr->second;
							attackBattleRankingMap->erase(britr);
							break;
						}
					}
					if(!battleRanking.valid())
					{
						battleRanking = new crBattleRanking;
						battleRanking->setPlayerID(playerid);
						battleRanking->setName(playerCharacterName);
					}
					battleRanking->addJifeng(playerScore);
					battleRanking->addKillCount(playerkilledcount);
					battleRanking->addDeadCount(playerdeadcount);
					attackBattleRankingMap->insert(std::make_pair(battleRanking->getJifeng(),battleRanking));
				}
			}
			else
			{
				if(win)
				{
					battleSettleMapLoser.insert(std::make_pair(playerScore,playerBattleInfo));
				}
				else
				{
					//记录国战中守城胜利次数
					setGuoZhanVictoryTimes = 2;
					battleSettleMapWinner.insert(std::make_pair(playerScore,playerBattleInfo));
				}
				if(defendBattleRankingMap)
				{//
					battleRanking = NULL;
					for( BattleRankingMap::iterator britr = defendBattleRankingMap->begin();
						britr != defendBattleRankingMap->end();
						++britr )
					{
						if(britr->second->getPlayerID() == playerid)
						{
							battleRanking = britr->second;
							defendBattleRankingMap->erase(britr);
							break;
						}
					}
					if(!battleRanking.valid())
					{
						battleRanking = new crBattleRanking;
						battleRanking->setPlayerID(playerid);
						battleRanking->setName(playerCharacterName);
					}
					battleRanking->addJifeng(playerScore);
					battleRanking->addKillCount(playerkilledcount);
					battleRanking->addDeadCount(playerdeadcount);
					defendBattleRankingMap->insert(std::make_pair(battleRanking->getJifeng(),battleRanking));
				}
			}
			data->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
			jxjShili = (crJXJShili *)param;
			if(jxjShili)
			{
				shiliData = jxjShili->getDataClass();
				shiliData->excHandle(MAKEINT64(WCH_LockData,1));
				shiliData->getParam(WCHDATA_JXJPeopleMap,param);
				peopleMap = (PeopleMap *)param;
				peoItr = peopleMap->find(playerid);
				if(peoItr != peopleMap->end())
				{
					if (peoItr->second.valid())
					{
						killNum = peoItr->second->getKillNum();
						INTLIMITADD(killNum,playerkilledcount,INT_MAX);
						peoItr->second->setKillNum(killNum);
						deadNum = peoItr->second->getDeadTroopsNum();
						INTLIMITADD(deadNum,playerdeadcount,INT_MAX);
						peoItr->second->setDeadTroopsNum(deadNum);
					}
				}
				shiliData->inputParam(WCHDATA_JXJShiliModify,&shiliModify);
				shiliData->excHandle(MAKEINT64(WCH_LockData,0));
			}

			if (playerScore > 0)
			{
				playerIDVec.push_back(playerid);
			}

		}
		if(win)
		{///攻防胜利，损失城防值
			ref_ptr<crJXJChengfangInfo> chengfangInfo;
			data->getParam(WCHDATA_JXJChengChiMap,param);
			ChengchiMap *chengchimap = (ChengchiMap *)param;
			ChengchiMap::iterator itr = chengchimap->find(chengchiid);
			if(itr != chengchimap->end())
			{
				chengfangInfo = itr->second;//(*chengchimap)[chengchiid];
				unsigned char chengzhu = chengfangInfo->changeShiliChengfang(ashili,dshili);
				if(chengzhu != dshili)
					m_this->doEvent(WCH_JXJCityBelongCheck,MAKEINT64(battleid,0));
				data->inputParam(WCHDATA_JXJChengchiModifySet,&chengchiid);

				//通知所有玩家,城防值变化
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(16);
				stream->_writeUShort(chengchiid);
				chengfangInfo->buildStream(stream);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,0,WCH_JXJRecvChengchiChange,stream.get());
				crNetDataManager *netDataManager = gameServer->getNetDataManager();
				netDataManager->sendPacketToAllPlayer(packet);
				//if((*chengchimap)[chengchiid].second > 100)
				//{
				//	(*chengchimap)[chengchiid].second -= 100;
				//	data->inputParam(WCHDATA_JXJChengchiModifySet,&chengchiid);
				//}
				//else
				//{
				//	(*chengchimap)[chengchiid].second = 0;
				//	chengchiChange = true;
				//}
			}
		}
		data->getParam(WCHDATA_JXJBattleScoreMap,param);
		BattleScoreMap *battleScoreMap = (BattleScoreMap *)param;
		ShiliScoreMap &shiliScoreMap = (*battleScoreMap)[chengchiid];
		ShiliScoreMap::iterator itr = shiliScoreMap.find(ashili);
		if(itr == shiliScoreMap.end())
		{
			shiliScoreMap[ashili] = std::make_pair(win?1:0,ashiliKill);
		}
		else
		{
			if(win) itr->second.first += 1;
			itr->second.second += ashiliKill;
		}
		itr = shiliScoreMap.find(dshili);
		if(itr == shiliScoreMap.end())
		{
			shiliScoreMap[dshili] = std::make_pair(win?0:1,dshiliKill);
		}
		else
		{
			if(!win) itr->second.first += 1;
			itr->second.second += dshiliKill;
		}
		//战场关闭
		data->getParam(WCHDATA_JXJOpenBattleMap,param);
		OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
		OpenBattleMap::iterator oitr = openBattleMap->find(battleid);
		BattleDropPlayerMap *battleDropPlayerMap;
		float punishtime = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLeaveBattlePunish, 0).c_str());
		for(; oitr != openBattleMap->end() && oitr->first == battleid; ++oitr)
		{
			if(oitr->second.second.first == roomid)
			{//如果攻防失败,并且战场剩余时间
				if(winstats==-1)
				{//攻方算逃兵
					for( BattlePlayer::iterator pitr = oitr->second.first.first.begin();
						pitr != oitr->second.first.first.end();
						++pitr )
					{
						data->getParam(WCHDATA_JXJBattleDropPlayerMap,param);
						battleDropPlayerMap = (BattleDropPlayerMap *)param;
						(*battleDropPlayerMap)[*pitr].first = battleid;
						(*battleDropPlayerMap)[*pitr].second = punishtime;
					}
				}
				oitr->second.second.second = 0.0f;
				break;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		//玩家奖励计算、、金钱、、经验、、功勋、、其他、、
		//根据玩家杀敌数目多少

		int index = 1;
		int my_index = -1;
		std::map< int,ref_ptr<crPlayerRewardData> > playerRewardInfoMap;
		BattleSettleMap::iterator itr_settlemap = battleSettleMapWinner.begin();
		ref_ptr<crTableIO> chengchiTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
		ref_ptr<crTableIO> battleRewardTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBattleRewardTab);
		crTableIO::StrVec record_reward,record_reward_base,record_reward_extra;
		crVector3i vec3;
		crVector4 rewardCeo;
		if(chengchiTable.valid() && chengchiTable->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record_reward)>=0)
		{
			int rewardIndex = chengchiTable->getTitleIndex("城池等级系数");
			if(rewardIndex>=0)
			{
				crArgumentParser::appAtoVec(record_reward[rewardIndex],rewardCeo);
			}
		}
		int expindex = battleRewardTable->getTitleIndex("经验");
		int countryindex = battleRewardTable->getTitleIndex("国家贡献");
		int exploitindex = battleRewardTable->getTitleIndex("功勋");
		int itemindex = battleRewardTable->getTitleIndex("物品");

		ref_ptr<crPlayerRewardData> reward_info;
		ref_ptr<crBagItemData> itemdata;
		while(itr_settlemap!=battleSettleMapWinner.end())
		{
			reward_info = new crPlayerRewardData;
			my_index = index;
			if(index>20) my_index = 21;
			if(battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(0),record_reward_base)>=0 && battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(my_index),record_reward_extra)>=0)
			{
				//reward_info->setExperience(atoi(record_reward_base[expindex].c_str())+atoi(record_reward_extra[expindex].c_str()));
				reward_info->setExperience(itr_settlemap->second.playerExperience);
				//reward_info->setCountryContribution(atoi(record_reward_base[countryindex].c_str())+atoi(record_reward_extra[countryindex].c_str())\
				//	+(int)(itr_settlemap->first * rewardCeo[chengchiRewardIndex]*rewardCBFactor));
				reward_info->setExploit(atoi(record_reward_base[exploitindex].c_str())+atoi(record_reward_extra[exploitindex].c_str())\
					+ (int)(itr_settlemap->first));
				reward_info->setScore(itr_settlemap->first);
				if(crArgumentParser::appAtoVec(record_reward_extra[itemindex],vec3) && vec3[0]>0)
				{
					itemdata = new crBagItemData;
					itemdata->setItemID(vec3[0]);
					itemdata->setEquipMagic(vec3[1]);
					itemdata->setItemCount(vec3[2]);
					reward_info->getRewardItemsVec().push_back(itemdata);
				}
				reward_info->setPlayerID(itr_settlemap->second.playerID);
				reward_info->setType(GP_RewardGameEnd);

				if(!strChengchiName.empty())
				{
					reward_info->getDescribtion() = std::string("在国战[")+strChengchiName+std::string("]中");
				}

				if(winBattleRankingMap)
				{//
					for (BattleRankingMap::iterator britr = winBattleRankingMap->begin();
						britr != winBattleRankingMap->end();
						++britr )
					{
						if (britr->second->getPlayerID() == reward_info->getPlayerID())
						{
							britr->second->addExploit(reward_info->getExploit());
							break;
						}
					}
				}
			}
			playerRewardInfoMap[itr_settlemap->second.playerID] = reward_info;
			itr_settlemap++;
			index++;
		}
		//失败
		itr_settlemap = battleSettleMapLoser.begin();
		index = 1;
		while (itr_settlemap!=battleSettleMapLoser.end())
		{
			ref_ptr<crPlayerRewardData> reward_info = new crPlayerRewardData;
			my_index = index+100;
			if(index>20) my_index = 121;
			if(battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(100),record_reward_base)>=0 && battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(my_index),record_reward_extra)>=0)
			{
				//reward_info->setExperience(atoi(record_reward_base[expindex].c_str())+atoi(record_reward_extra[expindex].c_str()));
				reward_info->setExperience(itr_settlemap->second.playerExperience);
				//reward_info->setCountryContribution(atoi(record_reward_base[countryindex].c_str())+atoi(record_reward_extra[countryindex].c_str())\
				//	+(int)(itr_settlemap->first *rewardCeo[chengchiRewardIndex]*rewardCBFactor));
				reward_info->setExploit(atoi(record_reward_base[exploitindex].c_str())+atoi(record_reward_extra[exploitindex].c_str())\
					+ (int)(itr_settlemap->first));
				reward_info->setScore(itr_settlemap->first);
				if(crArgumentParser::appAtoVec(record_reward_extra[itemindex],vec3) && vec3[0]>0)
				{
					itemdata = new crBagItemData;
					itemdata->setItemID(vec3[0]);
					itemdata->setEquipMagic(vec3[1]);
					itemdata->setItemCount(vec3[2]);
					reward_info->getRewardItemsVec().push_back(itemdata);
				}

				reward_info->setPlayerID(itr_settlemap->second.playerID);
				reward_info->setType(GP_RewardGameEnd);

				if(lostBattleRankingMap)
				{//
					for (BattleRankingMap::iterator britr = lostBattleRankingMap->begin();
						britr != lostBattleRankingMap->end();
						++britr )
					{
						if (britr->second->getPlayerID() == reward_info->getPlayerID())
						{
							britr->second->addExploit(reward_info->getExploit());
							break;
						}
					}
				}
			}
			playerRewardInfoMap[itr_settlemap->second.playerID] = reward_info;
			itr_settlemap++;
			index++;
		}

		for (std::vector<int>::iterator pIDVitr = playerIDVec.begin();pIDVitr != playerIDVec.end();++pIDVitr)
		{
			//增加活跃度/////////////////////////////////
			playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(*pIDVitr));
			if (playerData.valid())
			{
				crPlayerGameData *playersgamedata = playerData->getPlayerGameData();
				if (playersgamedata)
				{
					playersgamedata->doEvent(WCH_JXJRecvHuoyuedu, MAKEINT64(HYD_BattleGround, 1));
					//playerData->getPlayerGameData()->doEvent(WCH_JXJRecvGuoZhanJiFen, MAKEINT64(&playerScore, NULL));
					//累计参加过的国战次数+1
					_type = 2;	//攻城掠地活动
					playersgamedata->doEvent(WCH_JXJUpdate7DayHuoDong,MAKEINT64(_type,NULL));
					_type = 3;	//血战沙场活动
					playersgamedata->doEvent(WCH_JXJUpdate7DayHuoDong,MAKEINT64(_type,NULL));
					_type = 4;	//视死如归活动
					playersgamedata->doEvent(WCH_JXJUpdate7DayHuoDong,MAKEINT64(_type,NULL));
				}
			}
			///////////////////////////////////////////////
		}

		//服务器处理奖励信息并且发包到客户端
		//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		std::map< int,ref_ptr<crPlayerRewardData> >::iterator itr_reward = playerRewardInfoMap.begin();
		//ref_ptr<crGameServerPlayerData> playerData;
		crData *pgData;
		while (itr_reward!=playerRewardInfoMap.end())
		{
			playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(itr_reward->first));
			if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
			{
				pgData = playerData->getPlayerGameData()->getDataClass();
				pgData->excHandle(MAKEINT64(WCH_LockData,1));
				itr_reward->second->setType(GP_RewardGameEnd);
				playerData->getPlayerGameData()->doEvent(WCH_JXJRecvPlayerRewardInfo,MAKEINT64(itr_reward->second.get(),NULL));
				pgData->getParam(WCHDATA_JXJCountryBattleTimes,param);//国战完成次数
				unsigned short* countryBattleTimes = (unsigned short*)param;
				if (*countryBattleTimes < USHRT_MAX)
				{
					*countryBattleTimes += 1;
				}
				
				pgData->excHandle(MAKEINT64(WCH_LockData,0));

				//if (setGuoZhanVictoryTimes != 0)
				{//记录国战中胜利次数（对应成就）
					pgData->excHandle(MAKEINT64(WCH_LockData,1));
					if (setGuoZhanVictoryTimes == 1)
					{
						pgData->getParam(WCHDATA_JXJGuoZhanAttackVictoryTimes,param);
						if (param)
						{
							unsigned char *attackVictoryTimes = (unsigned char *)param;
							if (*attackVictoryTimes < UCHAR_MAX)
							{//只记录到101场
								*attackVictoryTimes += 1;
							}
						}
					}
					if (setGuoZhanVictoryTimes == 2)
					{
						pgData->getParam(WCHDATA_JXJGuoZhanDefendVictoryTimes,param);
						if (param)
						{
							unsigned char *defendVictoryTimes = (unsigned char *)param;
							if (*defendVictoryTimes < UCHAR_MAX)
							{//只记录到101场
								*defendVictoryTimes += 1;
							}
						}
					}
					pgData->excHandle(MAKEINT64(WCH_LockData,0));
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeUChar(setGuoZhanVictoryTimes);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJSetGuoZhanVictoryTimes,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

					playerData->getPlayerGameData()->doEvent(WCHDATA_JXJRecvCountryBattleTimes);
				}
			}
			else
			{
				itr_reward->second->setHuoyuedu(1);
				itr_reward->second->setwarcounts(true);
				m_this->doEvent(WCH_JXJCreateRewardMail,MAKEINT64(itr_reward->second.get(),NULL));
			}
			itr_reward++;

			
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvBattleSettleMethod
//
/////////////////////////////////////////
struct ClientPlayerBattleInfo
{
	int playerID;
	float playerExperience;
	std::string playerCharacterName;
};
crJXJClientRecvBattleSettleMethod::crJXJClientRecvBattleSettleMethod(){}
crJXJClientRecvBattleSettleMethod::crJXJClientRecvBattleSettleMethod(const crJXJClientRecvBattleSettleMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_frameTitle(handle.m_frameTitle)
{
}
void crJXJClientRecvBattleSettleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvBattleSettleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_frameTitle = str;
		break;
	case 2:
		m_settleList = str;
		break;
	case 3:
		m_Title1 = str;
		break;
	case 4:
		m_Title2 = str;
		break;
	case 5:
		m_Title3 = str;
		break;
	case 6:
		m_Title4 = str;
		break;
	case 7:
		m_count1 = str;
		break;
	case 8:
		m_count2 = str;
		break;
	case 9:
		m_count3 = str;
		break;
	case 10:
		m_count4 = str;
		break;
	case 11:
		m_switch = str;
		break;
	case 12:
		m_charactersize = atof(str.c_str());
		break;
	case 13:
		m_sizex = atof(str.c_str());
		break;
	case 14:
		m_sizey = atof(str.c_str());
		break;
	case 15:
		m_linespacing = atof(str.c_str());
		break;
	case 16:
		m_underlinespacing = atof(str.c_str());
		break;
	case 17:
		m_uplinespacing = atof(str.c_str());
		break;
	case 18:
		m_list[0] = str;
		break;
	case 19:
		m_list[1] = str;
		break;
	case 20:
		m_list[2] = str;
		break;
	case 21:
		m_list[3] = str;
		break;
	case 22:
		m_list[4] = str;
		break;
	}
}

void crJXJClientRecvBattleSettleMethod::operator()(crHandle &handle)
{
	bool win = false;
	if(m_stream.valid())
	{
		void *param;
		float rewardCBFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleCBRewardFactor, 0).c_str());
		float rewardExploitFactor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleExploitRewardFactor, 0).c_str());
		int chengchiRewardIndex = 3;//0,魏 1蜀 2吴 3群
		crData *data = m_this->getDataClass();
		int battleid = m_stream->_readInt();
		int roomid = m_stream->_readInt();
		char winstats = m_stream->_readChar();//1表示攻防胜利,0失败,-1丢失所有据点
		win = winstats == 1;//true表示攻方胜利
		unsigned short mapsize = m_stream->_readUShort();
		std::multimap< float,ClientPlayerBattleInfo,std::greater<float>> battleInfoMap;
		unsigned char shiliid = 0;
		unsigned char ashili = (unsigned char)(LOINT16(LOINT32(battleid)));
		unsigned char dshili = (unsigned char)(HIINT16(LOINT32(battleid)));
		unsigned short chengchiid = HIINT32(battleid);
		int playerkilledcount = 0;
		int playerdeadcount = 0;
		crPlayerGameData * myPlayerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		if(myPlayerGameData)
		{
			crData *playerData = myPlayerGameData->getDataClass();
			if(playerData)
			{
				int mydeadcount = 0;
				int myplayerid = myPlayerGameData->getPlayerID();
				playerData->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				if(myshiliid == dshili) win = !win;

				ClientPlayerBattleInfo playerBattleInfo;
				float playerScore = 0.0f;
				for ( int i = 0; i<mapsize; i++ )
				{
					playerBattleInfo.playerID = m_stream->_readInt();//4
					shiliid = m_stream->_readUChar();//1
					playerScore = m_stream->_readFloat();
					playerBattleInfo.playerExperience = m_stream->_readFloat();
					playerBattleInfo.playerCharacterName = m_stream->_readString();
					playerkilledcount = m_stream->_readInt();
					playerdeadcount = m_stream->_readInt();

					if(shiliid == myshiliid)
					{
						battleInfoMap.insert(std::make_pair(playerScore,playerBattleInfo));
					}
					if(myplayerid == playerBattleInfo.playerID)
						mydeadcount = playerdeadcount;
				}
				ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				ref_ptr<crCanvasNode >canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if(canvas.valid() && itemtab.valid())
				{
					ref_ptr<crStaticTextWidgetNode> frameTitle = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_frameTitle));
					ref_ptr<crMultiSwitch> mulitSwitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
					if(mulitSwitch.valid())
						mulitSwitch->setActiveSwitchSet((unsigned int)win);

					frameTitle->setAlignment(CRText::crText::CENTER_CENTER);
					frameTitle->setColor(crVector4(255.0,255.0,255.0,255.0));

					playerData->excHandle(MAKEINT64(WCH_LockData,1));
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
					playerData->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
					playerData->inputParam(WCHDATA_JXJBattleRoomID,NULL);
					playerData->inputParam(WCHDATA_JXJTeamLeaderID,NULL);
					playerData->getParam(WCHDATA_JXJMyTeam,param);
					TeamMemberVec *myTeam = (TeamMemberVec *)param;
					myTeam->clear();
					playerData->excHandle(MAKEINT64(WCH_LockData,0));

					ref_ptr<crTableWidgetNode> settleList = dynamic_cast<crTableWidgetNode *>(canvas->getChildNode(m_settleList));
					ref_ptr<crListBoxWidgetNode> listItems=NULL;
					for (int i =0;i<5;i++)
					{
						listItems = dynamic_cast<crListBoxWidgetNode *>(canvas->getWidget(m_list[i]));
						if (listItems.valid())
						{
							listItems->setCharacterSize(m_charactersize);
							listItems->setFontSize(crVector2f(m_sizex,m_sizey));
							listItems->setLineSpacing(m_linespacing);
							listItems->setUnderLineSpacing(m_underlinespacing);
							listItems->setUpLineSpacing(m_uplinespacing);//
						}
					}


					ref_ptr<crTableIO> battleRewardTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBattleRewardTab);
					ref_ptr<crTableIO> chengchiTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
					ref_ptr<crTableIO> playershilitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
					crTableIO::StrVec record_reward,record_reward_base,record_reward_extra;

					int expindex = battleRewardTable->getTitleIndex("经验");
					int countryindex = battleRewardTable->getTitleIndex("国家贡献");
					int exploitindex = battleRewardTable->getTitleIndex("功勋");
					int itemIndex = battleRewardTable->getTitleIndex("物品");

					unsigned short index = 1;
					short baseRewardIndex = -1;
					unsigned short rewardIndex = 0;
					short myRewardIndex = -1;
					int score = 0;
					int experience = 0;
					crTableIO::StrVec record;
					crTableIO::StrVec record_item;
					if(win)
					{
						baseRewardIndex = 0;
					}
					else
					{
						baseRewardIndex = 100;
					}

					std::multimap< float,ClientPlayerBattleInfo,std::greater<float>>::iterator itr = battleInfoMap.begin();
					while (itr!=battleInfoMap.end())
					{
						rewardIndex = index;
						if(rewardIndex>20) rewardIndex = 20;

						if(itr->second.playerID == myPlayerGameData->getPlayerID())
						{
							myRewardIndex = baseRewardIndex + rewardIndex;
							score = (int)(itr->first);
							experience = itr->second.playerExperience;
						}

						settleList->addData(0,index-1,crArgumentParser::appItoa(index));
						settleList->addData(1,index-1,itr->second.playerCharacterName);
						if(playershilitab->queryOneRecord(0,crArgumentParser::appItoa(myshiliid),record)>=0)
						{
							int shilinameindex = playershilitab->getTitleIndex("name");
							settleList->addData(2,index-1,record[shilinameindex]);
						}
						settleList->addData(3,index-1,crArgumentParser::appItoa(itr->first));

						if(battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(baseRewardIndex + rewardIndex),record_reward)>=0)
						{
							crVector3i vec3;
							if( crArgumentParser::appAtoVec(record_reward[itemIndex],vec3) &&
								itemtab->queryOneRecord(0,crArgumentParser::appItoa(vec3[0]),record_item)>=0)
							{
								std::string strInfo = record_item[itemtab->getTitleIndex("name")]+std::string("*")+crArgumentParser::appItoa(vec3[2]);
								settleList->addData(4,index-1,strInfo);
							}
						}
						++index;
						++itr;
					}

					ref_ptr<crStaticTextWidgetNode> count1 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getChildNode(m_count1));
					ref_ptr<crStaticTextWidgetNode> count2 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getChildNode(m_count2));
					ref_ptr<crStaticTextWidgetNode> count3 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getChildNode(m_count3));
					ref_ptr<crStaticTextWidgetNode> count4 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getChildNode(m_count4));

					crVector2i vec2;
					crVector4 rewardCeo;
					if(chengchiTable.valid() && chengchiTable->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record_reward)>=0)
					{
						int rewardIndex = chengchiTable->getTitleIndex("城池等级系数");
						if(rewardIndex>=0)
						{
							crArgumentParser::appAtoVec(record_reward[rewardIndex],rewardCeo);
						}
					}

					if(count1.valid())
						count1->setString(std::string("0"));
					if(count2.valid())
						count2->setString(std::string("0"));
					if(count3.valid())
						count3->setString(std::string("0"));
					if(count4.valid())
						count4->setString(std::string("0"));


					if(battleRewardTable.valid() && battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(baseRewardIndex),record_reward_base)>=0 &&\
						battleRewardTable->queryOneRecord(0,crArgumentParser::appItoa(myRewardIndex),record_reward_extra)>=0)
					{

						std::string reward_exprience = crArgumentParser::appItoa(experience);
						std::string reward_gold = crArgumentParser::appItoa(atoi(record_reward_base[countryindex].c_str())+atoi(record_reward_extra[countryindex].c_str())+\
							(int)(score * rewardCeo[chengchiRewardIndex]*rewardCBFactor));
						std::string reward_other_one = crArgumentParser::appItoa(atoi(record_reward_base[exploitindex].c_str())+atoi(record_reward_extra[exploitindex].c_str())+\
							+ score);

						crVector3i vec3;
						crArgumentParser::appAtoVec(record_reward_extra[itemIndex],vec3);

						
						std::string deadstr = crArgumentParser::appItoa(mydeadcount);
						int deadsize = CRCore::minimum((int)deadstr.size(),5);
						std::string spacestr1[5] = {"     ","    ","   ","  "," "};

						std::string strtex = " 死兵数量："+deadstr+spacestr1[deadsize-1]+"死兵经验："+reward_exprience;
						if(count1.valid())
							count1->setString(strtex);
							//count1->setString(reward_exprience);
						if(count2.valid())
							count2->setString(reward_gold);
						if(count3.valid())
							count3->setString(reward_other_one);
						if(count4.valid() && itemtab->queryOneRecord(0,crArgumentParser::appItoa(vec3[0]),record_item))
							count4->setString(crArgumentParser::appItoa(vec3[2]));

					}

					ref_ptr<crCamera>camera = CRPhysics::crCameraManager::getInstance()->getMainCamera();
					if(camera.valid())
					{
						crData *camadata = camera->getAttachedNode()->getDataClass();
						playerData->getParam(WCHDATA_JXJVipLv,param);
						unsigned char vipLevel = *(unsigned char *)param;
						short timer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJExitTimerLimit,vipLevel).c_str());
						camadata->inputParam(WCHDATA_JXJTimer,&timer);
					}
				}
			}
		}
	}
	handle.outputParam(0,&win);
}
/////////////////////////////////////////
//
//crJXJFubenSettleMethod
//
/////////////////////////////////////////
crJXJFubenSettleMethod::crJXJFubenSettleMethod():
	m_progress(0){}
crJXJFubenSettleMethod::crJXJFubenSettleMethod(const crJXJFubenSettleMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress)
{
}
void crJXJFubenSettleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = (short)(atoi(str.c_str()));
		break;
	}
}
void crJXJFubenSettleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJFubenSettleMethod::operator()(crHandle &handle)
{
	void *param;
	int playerid;

	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJBattleID,param);
	int battleid = *(int *)param;
	unsigned short fubenid = HIINT32(battleid);
	data->getParam(WCHDATA_RoomProgress,param);
	short progress = *(short *)param;
	data->getParam(WCHDATA_JXJBattleStatsMap,param);
	BattleStatsMap battleStatsMap = *(BattleStatsMap *)param;
	data->getParam(WCHDATA_JXJFubenStarsMap, param);
	FubenStarMap starMap = *(FubenStarMap *)param;

	data->getParam(WCHDATA_JXJScenarioVariableMap,param);
	ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
	ScenarioVariableMap::iterator svmitr = variableMap->find("boshu");
	float circle = 1.0f;
	if (svmitr != variableMap->end())
	{
		circle = svmitr->second;
	}

	data->excHandle(MAKEINT64(WCH_LockData, 0));


	CRCore::ref_ptr<crJXJBattleStats> tempBattleStats;
	m_this->lockPlayerList();
	crRoom::PlayerList &playerList = m_this->getPlayerList();
	for (crRoom::PlayerList::iterator itr = playerList.begin();
		itr != playerList.end();
		++itr)
	{
		playerid = itr->get()->getPlayerID();

		if (battleStatsMap.find(playerid) == battleStatsMap.end())
		{
			tempBattleStats = new crJXJBattleStats(playerid, itr->get()->getGroupID());
			tempBattleStats->addNpcKillCount(0);
			tempBattleStats->addBossKillCount(0);

			battleStatsMap.insert(std::make_pair(playerid, tempBattleStats));
		}
	}
	m_this->unlockPlayerList();

	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(13+battleStatsMap.size()*13);
	stream->_writeUShort(fubenid);//or playerid
	stream->_writeBool(progress == m_progress);//true表示攻方胜利
	stream->_writeUShort(battleStatsMap.size());

	unsigned char starCount = 0;
	FubenStarMap::iterator itr_star;
	for( BattleStatsMap::iterator itr = battleStatsMap.begin();
		itr != battleStatsMap.end();
		++itr )
	{
		starCount = 0;
		itr_star = starMap.find(itr->first);
		if (itr_star != starMap.end())
		{
			starCount = itr_star->second;
		}

		stream->_writeInt(itr->first);//4
		stream->_writeInt(itr->second->getNpcKillCount());//4
		stream->_writeInt(itr->second->getBosskillCount());//4
		stream->_writeUChar(starCount);//1
	}
	stream->_writeInt(m_this->getRoomID());//
	stream->_writeFloat(circle);
	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
	crJXJFubenSettlePacket packet;
	crJXJFubenSettlePacket::buildRequestPacket(packet,stream.get());
	netConductor->getNetManager()->sendPacket("all",packet);
	// 	void *param;
	// 	crData *data = m_this->getDataClass();
	// 	data->excHandle(MAKEINT64(WCH_LockData,1));
	// 	data->getParam(WCHDATA_JXJBattleID,param);
	// 	int battleid = *(int *)param;
	// 	unsigned short fubenid = HIINT32(battleid);
	// 	data->getParam(WCHDATA_RoomProgress,param);
	// 	short progress = *(short *)param;
	// 	data->getParam(WCHDATA_JXJBattleStatsMap,param);
	// 	BattleStatsMap *battleStatsMap = (BattleStatsMap *)param;
	// 	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	// 	stream->createBuf(9+battleStatsMap->size()*36);
	// 	stream->_writeInt(0);//recvid
	// 	stream->_writeUShort(fubenid);//or playerid
	// 	stream->_writeBool(progress == m_progress);//true表示攻方胜利
	// 	stream->_writeUShort(battleStatsMap->size());
	// 	crJXJBattleStats *battleStats;
	// 	for( BattleStatsMap::iterator itr = battleStatsMap->begin();
	// 		itr != battleStatsMap->end();
	// 		++itr )
	// 	{
	// 		battleStats = itr->second.get();
	// 		stream->_writeInt(itr->first);//4
	// 		stream->_writeUChar(battleStats->getShiliID());//1
	// 		stream->_writeChar(battleStats->getStats());//1
	// 		stream->_writeInt(battleStats->getDeadCount());//4
	// 		stream->_writeInt(battleStats->getNpcKillCount());//4
	// 		stream->_writeShort(battleStats->getBuildingKillCount());//2
	// 		stream->_writeString(battleStats->getPlayerName());
	// 	}
	// 	data->excHandle(MAKEINT64(WCH_LockData,0));
	// 
	// 	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
	// 	crJXJFubenSettlePacket packet;
	// 	crJXJFubenSettlePacket::buildRequestPacket(packet,stream.get());
	// 	netConductor->getNetManager()->sendPacket("all",packet);
	// 
	// 	m_this->sendPacketToAll(packet);
}
/////////////////////////////////////////
//
//crJXJRecvFubenSettleMethod
//
/////////////////////////////////////////
crJXJRecvFubenSettleMethod::crJXJRecvFubenSettleMethod(){}
crJXJRecvFubenSettleMethod::crJXJRecvFubenSettleMethod(const crJXJRecvFubenSettleMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvFubenSettleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenSettleMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvFubenSettleMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		m_stream->_readInt();
		unsigned short fubenid = m_stream->_readUShort();
		bool win = m_stream->_readBool();//true表示攻方胜利
		unsigned short mapsize = m_stream->_readUShort();
		BattleStatsMap battleStatsMap;
		ref_ptr<crJXJBattleStats> battleStats;
		int playerid;
		unsigned char shiliid;

		for ( int i = 0; i<mapsize; i++ )
		{
			playerid = m_stream->_readInt();//4
			shiliid = m_stream->_readUChar();//1
			battleStats = new crJXJBattleStats(playerid,shiliid);
			char player_state = m_stream->_readChar();
			battleStats->setStats(player_state);
			//battleStats->addDeadMap(m_stream->_readInt());
			battleStats->addNpcKillCount(m_stream->_readInt());
			//battleStats->addBuildingKillCount(m_stream->_readShort());
			std::string character_name = m_stream->_readString();
			battleStats->setCharacterName(character_name);
			battleStatsMap[playerid] = battleStats;
		}
		//////////////////////////////////////////////////////////////////////////
		std::map<int,std::pair<char,ref_ptr<crPlayerRewardData>>> playerRewardInfoMap;
		ref_ptr<crTableIO> fubenRewardTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenRewardTab);
		crTableIO::DataVec record_reward;
		BattleStatsMap::iterator itr_stats = battleStatsMap.begin();
		int expindex = fubenRewardTable->getTitleIndex("经验");
		int itemindex = fubenRewardTable->getTitleIndex("材料");
		int countindex = fubenRewardTable->getTitleIndex("材料数量");
		crVector2i vec2;
		ref_ptr<crBagItemData> itemdata;
		int count;
		while (itr_stats!=battleStatsMap.end())
		{
			ref_ptr<crPlayerRewardData> reward_info = new crPlayerRewardData;
			fubenRewardTable->queryRecords(0,crArgumentParser::appItoa(fubenid),record_reward);
			int index = (win)?1:0;
			if(!record_reward.empty())
			{
				reward_info->setExperience(atoi(record_reward[index][expindex].c_str()));
				crArgumentParser::appAtoVec(record_reward[index][itemindex],vec2);
				count = atoi(record_reward[index][countindex].c_str());
				if(vec2[0]>0 && count>0)
				{
					itemdata = new crBagItemData;
					itemdata->setItemID(vec2[0]);
					itemdata->setEquipMagic(vec2[1]);
					itemdata->setItemCount(count);
					reward_info->getRewardItemsVec().push_back(itemdata);
				}
				reward_info->setPlayerID(itr_stats->first);
				reward_info->setType(GP_RewardGameEnd);
			}
			char playerState = itr_stats->second->getStats();
			playerRewardInfoMap[itr_stats->first] = std::make_pair(playerState,reward_info);
			itr_stats++;
		}
		//////////////////////////////////////////////////////////////////////////
		//void *param;
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		std::map<int,std::pair<char,ref_ptr<crPlayerRewardData>>>::iterator itr_reward = playerRewardInfoMap.begin();
		ref_ptr<crGameServerPlayerData> playerData;
		crData *pgData;
		while (itr_reward!=playerRewardInfoMap.end())
		{
			playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(itr_reward->first));
			if(playerData.valid() && playerData->getPlayerGameData())
			{
				pgData = playerData->getPlayerGameData()->getDataClass();
				pgData->excHandle(MAKEINT64(WCH_LockData,1));
				itr_reward->second.second->setType(GP_RewardFubenEnd);
				playerData->getPlayerGameData()->doEvent(WCH_JXJRecvPlayerRewardInfo,MAKEINT64(itr_reward->second.second.get(),NULL));
				pgData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			else
			{
				m_this->doEvent(WCH_JXJCreateRewardMail,MAKEINT64(itr_reward->second.second.get(),NULL));
			}
			itr_reward++;
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvFubenSettleMethod
//
/////////////////////////////////////////
crJXJClientRecvFubenSettleMethod::crJXJClientRecvFubenSettleMethod(){}
crJXJClientRecvFubenSettleMethod::crJXJClientRecvFubenSettleMethod(const crJXJClientRecvFubenSettleMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_frameTitle(handle.m_frameTitle)
{
}
void crJXJClientRecvFubenSettleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvFubenSettleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_frameTitle = str;
		break;
	case 2:
		m_VorFInput = str;
		break;
	case 3:
		m_experienceInput = str;
		break;
	case 4:
		m_magicBoxCountInput = str;
		break;
	case 5:
		m_magicBoxImage = str;
		break;
	case 6:
		m_btnAgainSwitch = str;
		break;
	case 7:
		m_archimentInput = str;
		break;
	}
}

void crJXJClientRecvFubenSettleMethod::operator()(crHandle &handle)
{
	bool win = false;
	if(m_stream.valid())
	{
		unsigned short fubenid = m_stream->_readUShort();
		win = m_stream->_readBool();//true表示攻方胜利
		unsigned short mapsize = m_stream->_readUShort();
		BattleStatsMap battleStatsMap;
		ref_ptr<crJXJBattleStats> battleStats;
		int playerid;
		unsigned char shiliid;

		int ashiliKill = 0;
		int dshiliKill = 0; 
		std::string charactername;
		for ( int i = 0; i<mapsize; i++ )
		{
			playerid = m_stream->_readInt();//4
			shiliid = m_stream->_readUChar();//1
			battleStats = new crJXJBattleStats(playerid,shiliid);
			battleStats->setStats(m_stream->_readChar());
			//			battleStats->addDeadMap(m_stream->_readInt());
			battleStats->addNpcKillCount(m_stream->_readInt());
			//battleStats->addBuildingKillCount(m_stream->_readShort());
			battleStats->setCharacterName(m_stream->_readString());
			battleStatsMap[playerid] = battleStats;
		}
		ref_ptr<crCanvasNode >canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if(canvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> frameTitle = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_frameTitle));

			ref_ptr<crMultiSwitch> btnSwitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_btnAgainSwitch));
			ref_ptr<crStaticTextWidgetNode> VorFInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_VorFInput)); 
			if(VorFInput.valid())
			{
				if(win)
				{
					VorFInput->setString(L"恭喜您获得胜利，您将获得奖励！");
					btnSwitch->setActiveSwitchSet(0);
					//提交任务
					//int taskid = 0;
					//ref_ptr<crTableIO> tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
					//if (tasktitletab)
					//{
					//	crTableIO::DataVec recordtask;
					//	int fubenidindex = tasktitletab->getTitleIndex("fubenid");
					//	int taskidindex = tasktitletab->getTitleIndex("taskid");
					//	tasktitletab->queryRecords(fubenidindex,crArgumentParser::appItoa(fubenid),recordtask);
					//	if(!recordtask.empty())
					//	{
					//		for (crTableIO::DataVec::iterator reitr = recordtask.begin();reitr!=recordtask.end();++reitr)
					//		{
					//			taskid = atoi((*reitr)[taskidindex].c_str());
					//			if (taskid > 0)
					//			{
					//				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					//				crPlayerGameData  *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
					//				if(playerData)
					//				{
					//					playerData->doEvent(WCH_JXJReferTask,MAKEINT64((int)taskid,NULL));
					//				}
					//			}
					//		}
					//	}
					//}
				}
				else
				{
					VorFInput->setString(L"您失败了，请再接再厉！");
					btnSwitch->setActiveSwitchSet(1);
				}
			}

			ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			crTableIO::StrVec record;
			if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
			{
				int modeid = fubentab->getTitleIndex("chapterid");
				if (modeid>=0)
				{
					int mode = atoi(record[modeid].c_str());
					if(mode == 3)
					{
						btnSwitch->setActiveSwitchSet(1);
					}
				}
			}
			ref_ptr<crStaticTextWidgetNode> experienceInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_experienceInput));
			ref_ptr<crStaticTextWidgetNode> magicBoxCountInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_magicBoxCountInput));
			ref_ptr<crImageBoxWidgetNode>magicBoxImage = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_magicBoxImage));
			ref_ptr<crStaticTextWidgetNode> archimentInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_archimentInput));
			//奖励计算
			ref_ptr<crTableIO> fubenRewardTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenRewardTab);
			ref_ptr<crTableIO> itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			crTableIO::DataVec record_reward;
			crTableIO::StrVec record_item;
			BattleStatsMap::iterator itr_stats = battleStatsMap.begin();
			fubenRewardTable->queryRecords(0,crArgumentParser::appItoa(fubenid),record_reward);
			int index = (win)?1:0;
			if(!record_reward.empty() && itemTable.valid())
			{
				experienceInput->setString(std::string("经验：")+record_reward[index][fubenRewardTable->getTitleIndex("经验")]);
				archimentInput->setString(std::string("功勋：")+record_reward[index][fubenRewardTable->getTitleIndex("功勋")]);
				int materialID = atoi(record_reward[index][fubenRewardTable->getTitleIndex("材料")].c_str());
				if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(materialID),record_item)>=0)
				{
					magicBoxImage->setImageName(record_item[itemTable->getTitleIndex("icon")]);
				}
				magicBoxCountInput->setString(record_reward[index][fubenRewardTable->getTitleIndex("材料数量")]);
			}
		}
	}
	handle.outputParam(0,&win);
}
///////////////////////////////////////////
////
////crJXJPassSettleMethod
////
///////////////////////////////////////////
//crJXJPassSettleMethod::crJXJPassSettleMethod():
//	m_progress(0){}
//crJXJPassSettleMethod::crJXJPassSettleMethod(const crJXJPassSettleMethod& handle):
//	crMethod(handle),
//	m_progress(handle.m_progress)
//{
//}
//void crJXJPassSettleMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_progress = (short)(atoi(str.c_str()));
//		break;
//	}
//}
//void crJXJPassSettleMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom *)param;
//		break;
//	}
//}
//void crJXJPassSettleMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crData *data = m_this->getDataClass();
//	data->excHandle(MAKEINT64(WCH_LockData,1));
//	data->getParam(WCHDATA_JXJBattleID,param);
//	int battleid = *(int *)param;
//	data->getParam(WCHDATA_RoomProgress,param);
//	short progress = *(short *)param;
//	data->getParam(WCHDATA_JXJBattleStatsMap,param);
//	BattleStatsMap *battleStatsMap = (BattleStatsMap *)param;
//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
//	stream->createBuf(11+battleStatsMap->size()*36);
//	stream->_writeInt(0);//recvid
//	stream->_writeInt(battleid);
//	stream->_writeBool(progress == m_progress);//true表示攻方胜利
//	stream->_writeUShort(battleStatsMap->size());
//	crJXJBattleStats *battleStats;
//	for( BattleStatsMap::iterator itr = battleStatsMap->begin();
//		itr != battleStatsMap->end();
//		++itr )
//	{
//		battleStats = itr->second.get();
//		stream->_writeInt(itr->first);//4
//		stream->_writeUChar(battleStats->getShiliID());//1
//		stream->_writeChar(battleStats->getStats());//1
//		stream->_writeInt(battleStats->getDeadCount());//4
//		stream->_writeInt(battleStats->getNpcKillCount());//4
//		stream->_writeShort(battleStats->getBuildingKillCount());//2
//		stream->_writeString(battleStats->getPlayerName());
//	}
//	data->excHandle(MAKEINT64(WCH_LockData,0));
//
//	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
//	crJXJPassSettlePacket packet;
//	crJXJPassSettlePacket::buildRequestPacket(packet,stream.get());
//	netConductor->getNetManager()->sendPacket("all",packet);
//	m_this->sendPacketToAll(packet);
//}
///////////////////////////////////////////
////
////crJXJRecvPassSettleMethod
////
///////////////////////////////////////////
//crJXJRecvPassSettleMethod::crJXJRecvPassSettleMethod(){}
//crJXJRecvPassSettleMethod::crJXJRecvPassSettleMethod(const crJXJRecvPassSettleMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvPassSettleMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvPassSettleMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvPassSettleMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		m_stream->_readInt();
//		_crInt32 battleid = m_stream->_readInt();
//		bool win = m_stream->_readBool();//true表示攻方胜利
//		unsigned short mapsize = m_stream->_readUShort();
//		BattleStatsMap battleStatsMap;
//		ref_ptr<crJXJBattleStats> battleStats;
//		int playerid;
//		unsigned char shiliid;
//		unsigned char ashili = (unsigned char)(LOINT16(LOINT32(battleid)));
//		unsigned char dshili = (unsigned char)(HIINT16(LOINT32(battleid)));
//		unsigned short chengchiid = HIINT32(battleid);
//		int ashiliKill = 0;
//		int dshiliKill = 0; 
//		std::string charactername;
//		for ( int i = 0; i<mapsize; i++ )
//		{
//			playerid = m_stream->_readInt();//4
//			shiliid = m_stream->_readUChar();//1
//			battleStats = new crJXJBattleStats(playerid,shiliid);
//			char player_state = m_stream->_readChar();
//			battleStats->setStats(player_state);
//			battleStats->addDeadCount(m_stream->_readInt());
//			battleStats->addNpcKillCount(m_stream->_readInt());
//			battleStats->addBuildingKillCount(m_stream->_readShort());
//			std::string character_name = m_stream->_readString();
//			battleStats->setCharacterName(character_name);
//			battleStatsMap[playerid] = battleStats;
//		}
//		//////////////////////////////////////////////////////////////////////////
//		std::map<int,std::pair<char,ref_ptr<crPlayerRewardData>>> playerRewardInfoMap;
//		ref_ptr<crTableIO> fubenRewardTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBattleRewardTab);
//		crTableIO::StrVec record_reward;
//		BattleStatsMap::iterator itr_stats = battleStatsMap.begin();
//		int index = 0;
//		while (itr_stats!=battleStatsMap.end())
//		{
//			ref_ptr<crPlayerRewardData> reward_info = new crPlayerRewardData;
//			RewardItemVec reward_items;
//			index = (win)?1:0;//100为副本难度系数index*100；
//			index+=100;
//			if(fubenRewardTable->queryOneRecord(0,crArgumentParser::appItoa(index),record_reward))
//			{
//				reward_info->setExperience(atoi(record_reward[fubenRewardTable->getTitleIndex("经验")].c_str()));
//				int materialID = atoi(record_reward[fubenRewardTable->getTitleIndex("材料")].c_str());
//				char materialCount = atoi(record_reward[fubenRewardTable->getTitleIndex("材料数量")].c_str());
//				reward_items.push_back(std::make_pair(materialID,materialCount));
//				reward_info->setRewadItemsVec(reward_items);
//				reward_info->setPlayerID(itr_stats->first);
//				reward_info->setType(GP_RewardGameEnd);
//			}
//			char playerState = itr_stats->second->getStats();
//			playerRewardInfoMap[itr_stats->first] = std::make_pair(playerState,reward_info);
//			itr_stats++;
//		}
//		//////////////////////////////////////////////////////////////////////////
//		//void *param;
//		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//		std::map<int,std::pair<char,ref_ptr<crPlayerRewardData>>>::iterator itr_reward = playerRewardInfoMap.begin();
//		ref_ptr<crGameServerPlayerData> playerData;
//		while (itr_reward!=playerRewardInfoMap.end())
//		{
//			playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(itr_reward->first));
//			if(playerData.valid()&&playerData->getPlayerGameData())
//			{
//				playerData->getPlayerGameData()->doEvent(WCH_JXJRecvPlayerRewardInfo,MAKEINT64(itr_reward->second.second.get(),NULL));
//			}
//			else
//			{
//				m_this->doEvent(WCH_JXJCreateRewardMail,MAKEINT64(itr_reward->second.second.get(),NULL));
//			}
//			itr_reward++;
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJClientRecvPassSettleMethod
////
///////////////////////////////////////////
//crJXJClientRecvPassSettleMethod::crJXJClientRecvPassSettleMethod(){}
//crJXJClientRecvPassSettleMethod::crJXJClientRecvPassSettleMethod(const crJXJClientRecvPassSettleMethod& handle):
//	crMethod(handle),
//	m_canvas(handle.m_canvas),
//	m_frameTitle(handle.m_frameTitle)
//{
//}
//void crJXJClientRecvPassSettleMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJClientRecvPassSettleMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_canvas = str;
//		break;
//	case 1:
//		m_frameTitle = str;
//		break;
//	case 2:
//		m_VorFInput = str;
//		break;
//	case 3:
//		m_experienceInput = str;
//		break;
//	case 4:
//		m_magicBoxCountInput = str;
//		break;
//	case 5:
//		m_magicBoxImage = str;
//		break;
//	case 6:
//		m_btnAgain = str;
//		break;
//	}
//}
//
//void crJXJClientRecvPassSettleMethod::operator()(crHandle &handle)
//{
//	bool win = false;
//	if(m_stream.valid())
//	{
//		crData *data = m_this->getDataClass();
//		int battleid = m_stream->_readInt();
//		win = m_stream->_readBool();//true表示攻方胜利
//		unsigned short mapsize = m_stream->_readUShort();
//		BattleStatsMap battleStatsMap;
//		ref_ptr<crJXJBattleStats> battleStats;
//		int playerid;
//		unsigned char shiliid;
//		unsigned char ashili = (unsigned char)(LOINT16(LOINT32(battleid)));
//		unsigned char dshili = (unsigned char)(HIINT16(LOINT32(battleid)));
//		unsigned short chengchiid = HIINT32(battleid);
//		int ashiliKill = 0;
//		int dshiliKill = 0; 
//		std::string charactername;
//		for ( int i = 0; i<mapsize; i++ )
//		{
//			playerid = m_stream->_readInt();//4
//			shiliid = m_stream->_readUChar();//1
//			battleStats = new crJXJBattleStats(playerid,shiliid);
//			battleStats->setStats(m_stream->_readChar());
//			battleStats->addDeadCount(m_stream->_readInt());
//			battleStats->addNpcKillCount(m_stream->_readInt());
//			battleStats->addBuildingKillCount(m_stream->_readShort());
//			battleStats->setCharacterName(m_stream->_readString());
//			battleStatsMap[playerid] = battleStats;
//		}
//		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
//		crStaticTextWidgetNode *frameTitle = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_frameTitle));
//		//frameTitle->setAlignment(CRText::crText::CENTER_CENTER);
//		//frameTitle->setColor(crVector4(255.0,255.0,255.0,255.0));
//		//frameTitle->setString(L"系统提示");
//		crButtonWidgetNode *btnAgain = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_btnAgain));
//		ref_ptr<crStaticTextWidgetNode> VorFInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_VorFInput)); 
//		if(VorFInput)
//		{
//			if(win)
//			{
//				VorFInput->setString(L"恭喜您获得胜利，您将获得经验和宝箱奖励！");
//				btnAgain->setEnable(true);
//			}
//			else
//			{
//				VorFInput->setString(L"很抱歉您未能在本次副本战斗中取得胜利，何不再来一局？");
//				btnAgain->setEnable(false);
//			}
//		}
//
//		crData *mydata = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//
//		crStaticTextWidgetNode *experienceInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_experienceInput));
//		crStaticTextWidgetNode *magicBoxCountInput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_magicBoxCountInput));
//		crImageBoxWidgetNode *magicBoxImage = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_magicBoxImage));
//		//奖励计算
//		ref_ptr<crTableIO> fubenRewardTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBattleRewardTab);
//		ref_ptr<crTableIO> itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//		crTableIO::StrVec record_reward;
//		crTableIO::StrVec record_item;
//		BattleStatsMap::iterator itr_stats = battleStatsMap.begin();
//		int index = 0;
//		while (itr_stats!=battleStatsMap.end())
//		{
//			index =(win)?1:0;//100为副本难度系数index*100；
//			index+=100;
//			if(fubenRewardTable->queryOneRecord(0,crArgumentParser::appItoa(index),record_reward))
//			{
//				experienceInput->setString(record_reward[fubenRewardTable->getTitleIndex("经验")]);
//				int materialID = atoi(record_reward[fubenRewardTable->getTitleIndex("材料")].c_str());
//				if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(materialID),record_item))
//				{
//					magicBoxImage->setImageName(record_item[itemTable->getTitleIndex("icon")]);
//				}
//				magicBoxCountInput->setString(record_reward[fubenRewardTable->getTitleIndex("材料数量")]);
//			}
//			itr_stats++;
//		}
//	}
//	handle.outputParam(0,&win);
//}
/////////////////////////////////////////
//
//crJXJCameraOccludedMethod
//
/////////////////////////////////////////
crJXJCameraOccludedMethod::crJXJCameraOccludedMethod():
	m_this(NULL),
	m_interval(3.0f),
	m_alpha(0.5f),
	m_speed(2.0f){}
crJXJCameraOccludedMethod::crJXJCameraOccludedMethod(const crJXJCameraOccludedMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_interval(handle.m_interval),
	m_alpha(handle.m_alpha),
	m_speed(handle.m_speed)
{
}
void crJXJCameraOccludedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCameraOccludedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	case 1:
		m_alpha = atof(str.c_str());
		break;
	case 2:
		m_speed = atof(str.c_str());
		break;
	}
}

void crJXJCameraOccludedMethod::operator()(crHandle &handle)
{
	crVector3 eye = m_this->getTrans();
	crRole *player;
	crMatrixTransform *bot;
	//crData *itemData;
	//void *param;
	unsigned int guisestate;
	crVector3 pos;
	std::set<crObject *>ObjectSet;
	CRCore::crIntersectVisitor iv;
	CRCore::ref_ptr<CRCore::crLineSegment> lineSegment = new CRCore::crLineSegment;
	crMyPlayerData::getInstance()->lockMyRoleNpcMap();
	crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
	for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
		itr != myRoles.end();
		++itr )
	{
		player = itr->second.first.get();
		bot = dynamic_cast<crMatrixTransform *>(player->getRelNode());
		if(!bot || !bot->getVisiable())
			continue;
		pos = bot->getTrans();
		pos[2]+=bot->getBoundBox().zLength()*0.5f;
		if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
			continue;
		//itemData = player->getDataClass();
		//itemData->getParam(WCHDATA_GuiseState,param);
		//guisestate = *(unsigned char *)param;
		//if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
		//{
		//	continue;
		//}
		guisestate = GS_Normal;
		player->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			continue;
		}
		iv.reset();
		lineSegment->set(eye,pos);
		iv.addLineSegment(lineSegment.get());
		crSceneManager::getInstance()->getStaticRoot()->accept(iv);
		if (iv.hits())
		{
			crIntersectVisitor::HitList &hitList = iv.getHitList(lineSegment.get());
			for( crIntersectVisitor::HitList::iterator hitr = hitList.begin();
				hitr != hitList.end();
				++hitr )
			{
				ObjectSet.insert(hitr->getObject());
			}
		} 
	}
	crMyPlayerData::getInstance()->unlockMyRoleNpcMap();
	//
	crMyPlayerData::getInstance()->lockInRangePlayerMap();
	crMyPlayerData::InRangePlayerMap &playerMap = crMyPlayerData::getInstance()->getInRangePlayerMap();
	for( crMyPlayerData::InRangePlayerMap::iterator itr = playerMap.begin();
		itr != playerMap.end();
		++itr )
	{
		player = itr->second.first.get();
		bot = dynamic_cast<crMatrixTransform *>(player->getRelNode());
		if(!bot || !bot->getVisiable())
			continue;
		pos = bot->getTrans();
		pos[2]+=bot->getBoundBox().zLength()*0.5f;
		if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
			continue;
		//itemData = player->getDataClass();
		//itemData->getParam(WCHDATA_GuiseState,param);
		//guisestate = GS_Normal;
		//if(param)
		//{
		//	guisestate = *(unsigned char *)param;
		//	if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
		//	{
		//		continue;
		//	}
		//}
		guisestate = GS_Normal;
		player->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			continue;
		}
		iv.reset();
		lineSegment->set(eye,pos);
		iv.addLineSegment(lineSegment.get());
		crSceneManager::getInstance()->getStaticRoot()->accept(iv);
		if (iv.hits())
		{
			crIntersectVisitor::HitList &hitList = iv.getHitList(lineSegment.get());
			for( crIntersectVisitor::HitList::iterator hitr = hitList.begin();
				hitr != hitList.end();
				++hitr )
			{
				ObjectSet.insert(hitr->getObject());
			}
		} 
	}
	crMyPlayerData::getInstance()->unlockInRangePlayerMap();
	//npc
	crMyPlayerData::getInstance()->lockInRangeNpcMap();
	crInstanceItem *item;
	crMyPlayerData::InRangeNpcMap &npcMap = crMyPlayerData::getInstance()->getInRangeNpcMap();
	for( crMyPlayerData::InRangeNpcMap::iterator itr = npcMap.begin();
		itr != npcMap.end();
		++itr )
	{
		item = itr->second.first.get();
		bot = dynamic_cast<crMatrixTransform *>(item->getRelNode());
		if(!bot || !bot->getVisiable())
			continue;
		pos = bot->getTrans();
		pos[2]+=bot->getBoundBox().zLength()*0.5f;
		if(!crBrain::getInstance()->getCameraFrustum().contains(pos))
			continue;
		//itemData = item->getDataClass();
		//itemData->getParam(WCHDATA_GuiseState,param);
		//guisestate = GS_Normal;
		//if(param)
		//{
		//	guisestate = *(unsigned char *)param;
		//	if(guisestate == GS_UnVisiable || guisestate == GS_StaticUnVisiable)
		//	{
		//		continue;
		//	}
		//}
		guisestate = GS_Normal;
		item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable)
		{
			continue;
		}
		iv.reset();
		lineSegment->set(eye,pos);
		iv.addLineSegment(lineSegment.get());
		crSceneManager::getInstance()->getStaticRoot()->accept(iv);
		if (iv.hits())
		{
			crIntersectVisitor::HitList &hitList = iv.getHitList(lineSegment.get());
			for( crIntersectVisitor::HitList::iterator hitr = hitList.begin();
				hitr != hitList.end();
				++hitr )
			{
				ObjectSet.insert(hitr->getObject());
			}
		}
	}
	crMyPlayerData::getInstance()->unlockInRangeNpcMap();
	int autotrans = 1;
	crAutoTransCallback *callback;
	for( std::set<crObject *>::iterator itr = ObjectSet.begin();
		itr != ObjectSet.end();
		++itr )
	{
		autotrans = 1;
		if(crArgumentParser::readKeyValue((*itr)->getDescriptions(),"AutoTrans",autotrans) && !autotrans)
			continue;
		callback = dynamic_cast<crAutoTransCallback *>((*itr)->getCullCallback("AutoTrans"));
		if(!callback)
		{
			callback = dynamic_cast<crAutoTransCallback *>(crEventCallbackManager::getInstance()->getEventCallback("AutoTrans"));
			(*itr)->addCullCallback(callback);
		}
		if(callback)
		{
			callback->setAutoTrans(m_interval,m_alpha);
			callback->setSpeed(m_speed);
		}
	}
}
/////////////////////////////////////////
//
//crJXJReliveItemsMethod
//
/////////////////////////////////////////
crJXJReliveItemsMethod::crJXJReliveItemsMethod(){}
crJXJReliveItemsMethod::crJXJReliveItemsMethod(const crJXJReliveItemsMethod& handle):
	crMethod(handle),
	m_itemidVec(handle.m_itemidVec)
{
}
void crJXJReliveItemsMethod::addParam(int i, const std::string& str)
{
	crVector2i vec2;
	crArgumentParser::appAtoVec(str,vec2);
	m_itemidVec.push_back(std::make_pair(vec2[0],vec2[1]));
}
void crJXJReliveItemsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJReliveItemsMethod::operator()(crHandle &handle)
{
	if(!m_itemidVec.empty())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			crInstanceItem *item;
			int roomid = m_this->getRoomID();
			//unsigned char itemstate = IS_Relive;
			void *param;
			crData *thisData;
			PatrolPointVec* patrolPointVec;
			int count;
			char idx;
			crVector2 coord;
			//float coordz;
			crVector3 pos;
			float scale = crGlobalHandle::gData()->gUnitScale();
			unsigned char itemstate;
			for( IDVec::iterator itr = m_itemidVec.begin();
				itr != m_itemidVec.end();
				++itr )
			{
				item = scene->findRoomItem(roomid,(*itr).first);
				if(item && item->getDataClass())
				{
					thisData = item->getDataClass();
					thisData->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate == IS_Dead)
					{
						thisData->excHandle(MAKEINT64(WCH_LockData,1));
						//thisData->inputParam(WCHDATA_ItemState, &itemstate);
						thisData->inputParam(WCHDATA_JXJArmyCount,&((*itr).second));
						thisData->getParam(WCHDATA_PatrolPointVec,param);
						patrolPointVec = (PatrolPointVec*)param;
						if(patrolPointVec && !patrolPointVec->empty())
						{
							thisData->getParam(WCHDATA_PatrolLoopMode,param);
							unsigned char loopmode = *(unsigned char *)param;
							if(loopmode == PL_NoLoop)
							{
								idx = 0;
							}
							else
							{
								count = patrolPointVec->size();
								idx = rangei(0,count).get_random();
								thisData->inputParam(WCHDATA_PatrolIndex,&idx);
							}
							coord = (*patrolPointVec)[idx];
							//coord *= scale;
							//coordz = scene->getPosZ(item->getLayerID(),coord[0],coord[1], item->getZoffset() * scale);
							if(!scene->findWalkablePos(item,coord,c_walkableSearchRange,pos))
							{
								CRCore::notify(CRCore::ALWAYS)<<"crJXJReliveItemsMethod findWalkablePos失败 "<<coord<<std::endl;
							}
							else
							{
								pos/=scale;
								item->setPosxy(pos[0],pos[1]);
								item->setPosz(pos[2]);
							}
						}
						thisData->excHandle(MAKEINT64(WCH_InitData,item));
						thisData->excHandle(MAKEINT64(WCH_LockData,0));
						scene->itemRelive(item);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJReliveItemsFromTabMethod
//
/////////////////////////////////////////
crJXJReliveItemsFromTabMethod::crJXJReliveItemsFromTabMethod():
	m_id(0),
	m_clone(false),
	m_idType(false),
	m_boshu(0)
{}
crJXJReliveItemsFromTabMethod::crJXJReliveItemsFromTabMethod(const crJXJReliveItemsFromTabMethod& handle):
	crMethod(handle),
	m_id(handle.m_id),
	m_clone(handle.m_clone),
	m_varname(handle.m_varname),
	m_idType(handle.m_idType),
	m_boshu(handle.m_boshu)
{
}
void crJXJReliveItemsFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	case 1:
		m_clone = (bool)(atoi(str.c_str()));
		break;
	case 2:
		m_varname = str;
		break;
	case 3:
		crArgumentParser::appAtoVec(str,m_varparam);
		break;
	case 4:
		m_idType = atoi(str.c_str());
		break;
	case 5:
		m_boshu = atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJReliveItemsFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(m_idType && param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_id = LOINT64(param64);
			m_boshu = HIINT64(param64);
		}
		break;
	}
}
void crJXJReliveItemsFromTabMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crInstanceItem> item;
		int roomid = m_this->getRoomID();
		//unsigned char itemstate = IS_Relive;
		PatrolPointVec* patrolPointVec;
		int count;
		char idx;
		crVector2 coord;
		//float coordz;
		crVector3 pos;
		float scale = crGlobalHandle::gData()->gUnitScale();

		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_JXJBattleID,param);
		int battleid = *(int *)param;
		unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
		unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
		unsigned short chengchiid = (unsigned short)(HIINT32(battleid));

		float countFactor = 1.0f;
		float hpFactor = 1.0f;
		float attackFactor = 1.0f;
		crTableIO::StrVec record;
		crVector4i lv;
		//获取系数
		ref_ptr<crTableIO> chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
		ref_ptr<crTableIO> chengchilvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiLvTab);

		data->getParam(WCHDATA_JXJRoomType,param);
		unsigned char roomType = *(unsigned char *)param;

		if(roomType == 1 && chengchiTab.valid() && chengchilvTab.valid())
		{
			int lvIndex = chengchiTab->getTitleIndex("建国后等级");
			if (2 == defenceShili)
			{//降低建国城池等级，占领建国城池后等级恢复正常
				lvIndex = chengchiTab->getTitleIndex("城池等级");
			}
			int countIndex = chengchilvTab->getTitleIndex("数量系数");
			int hpIndex = chengchilvTab->getTitleIndex("HP系数");
			int attackIndex = chengchilvTab->getTitleIndex("攻击系数");
			if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0 && lvIndex>=0)
			{
				crArgumentParser::appAtoVec(record[lvIndex],lv);
				int index = attackShili - c_startShiliID;
				if( index<4 && chengchilvTab->queryOneRecord(0,crArgumentParser::appItoa(lv[index]),record)>=0 )
				{
					if(countIndex>=0)
						countFactor = atof(record[countIndex].c_str());
					if(hpIndex>=0) 
						hpFactor = atof(record[hpIndex].c_str());
					if(attackIndex>=0)
						attackFactor = atof(record[attackIndex].c_str());
				}
			}
		}

		if(roomType == FT_Fuben && m_id > 0 && m_boshu > 0)
		{
			crVector2f factor;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJunTuanFuBenNPCReliveFactor,0),factor);
			unsigned short remainder = m_boshu % 5;
			unsigned short quotient = m_boshu / 5;
			if (remainder == 0)
			{//boss类型NPC，每5波出一批BOSS
				countFactor = 1 + (quotient - 1) * factor[1];
			}
			else
			{//非BOSS类型NPC
				countFactor = 1 + (m_boshu - quotient - 1) * factor[0];
			}
		}		

		ref_ptr<crSightInfo> defenceSightInfo;
		ref_ptr<crSightInfo> attackSightInfo;
		if (roomType != FT_WorldFuben)
		{//世界战场
			defenceSightInfo = m_this->getOrCreateSightInfo(defenceShili);
			attackSightInfo = m_this->getOrCreateSightInfo(attackShili);
		}
		//else
		//{////不共享视野，NPC共用一个视野
		//	defenceSightInfo = m_this->getOrCreateSightInfo(2);
		//}
		crData *itemData;
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));
		if(!m_varname.empty())
		{
			data->getParam(WCHDATA_JXJScenarioVariableMap,param);
			ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
			ScenarioVariableMap::iterator sitr = variableMap->find(m_varname);
			if(sitr != variableMap->end())
			{
				countFactor *= (1.0f+sitr->second * m_varparam[0]);
				hpFactor *= (1.0f+sitr->second * m_varparam[1]);
				attackFactor *= (1.0f+sitr->second * m_varparam[2]);
			}
		}
		//data->getParam(WCHDATA_RoomProgress,param);
		//short progress = *(short *)param;
		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		data->getParam(WCHDATA_JXJBattleTotalNpcCount, param);
		NpcTotalCountMap * totalNpcMap = (NpcTotalCountMap *)param;

		ReliveItemMap::iterator itr = reliveItemMap->find(m_id);
		//unsigned short armcount;
		int armcount; //14、15级城池的政厅和箭塔血量超出65535，显示结果错误，所以更改数据类型
		int* hp;
		int* attack;
		float iscale;
		unsigned char itemstate;
		ref_ptr<crTableIO> dataAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
		int hpid = dataAttrTab->getTitleIndex("HP");
		int attackid = dataAttrTab->getTitleIndex("攻击力");
		int orighp,origattack;
		unsigned char npcType;
		crTableIO::StrVec attrrecord;
		for( ;
			itr != reliveItemMap->end() && itr->first == m_id;
			++itr )
		{
			item = scene->findRoomItem(roomid,itr->second->getInstanceID());
			if(item.valid() && item->getDataClass())
			{
				if(m_clone)
				{
					item = dynamic_cast<crInstanceItem *>(item->clone());
					item->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
					scene->insertSceneItem(item.get());
				}
				itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if (m_clone || itemstate == IS_Dead)
				{
					npcType = itr->second->getNpcItemType();
					itemData->inputParam(WCHDATA_JXJNpcItemType,&npcType);

					if(!itr->second->getName().empty())
						item->setIName(itr->second->getName());
					if(dataAttrTab->queryOneRecord(0,crArgumentParser::appItoa(item->getAbstractItemID()),attrrecord)>=0)
					{
						if(hpid>0)
						{
							orighp = atoi(attrrecord[hpid].c_str());
							itemData->inputParam(WCHDATA_HP,&orighp);
						}
						if(attackid>0)
						{
							origattack = atoi(attrrecord[attackid].c_str());
							itemData->inputParam(WCHDATA_Attack,&origattack);
						}
					}
					//itemData->inputParam(WCHDATA_ItemState, &itemstate);
					itemData->excHandle(MAKEINT64(WCH_LockData,1));
					armcount = itr->second->getCount();
					if(armcount > 1) 
						armcount  = (int)((float)armcount * countFactor);

					itemData->inputParam(WCHDATA_JXJArmyCount,&armcount);
					iscale = itr->second->getHPScale();
					if(iscale!=1.0f)
					{
						itemData->getParam(WCHDATA_HP,param);
						if(param)
						{
							hp = (int *)param;
							if(armcount>1)
								*hp = (int)((float)(*hp) * iscale * hpFactor + 0.5f);
							else
								*hp = (int)((float)(*hp) * iscale * hpFactor * countFactor + 0.5f);
						}
					}
					iscale = itr->second->getAttackScale();
					if(iscale!=1.0f)
					{
						itemData->getParam(WCHDATA_Attack,param);
						if(param)
						{
							attack = (int *)param;
							if(armcount>1)
								*attack = (int)((float)(*attack) * iscale * attackFactor + 0.5f);
							else
								*attack = (int)((float)(*attack) * iscale * attackFactor * countFactor + 0.5f);
						}
					}
					itemData->getParam(WCHDATA_PatrolPointVec,param);
					patrolPointVec = (PatrolPointVec*)param;
					if(patrolPointVec && !patrolPointVec->empty())
					{
						itemData->getParam(WCHDATA_PatrolLoopMode,param);
						unsigned char loopmode = *(unsigned char *)param;
						if(loopmode == PL_NoLoop)
						{
							idx = 0;
						}
						else
						{
							count = patrolPointVec->size();
							idx = rangei(0,count).get_random();
							itemData->inputParam(WCHDATA_PatrolIndex,&idx);
						}
						coord = (*patrolPointVec)[idx];
						//coord *= scale;
						//coordz = scene->getPosZ(item->getLayerID(),coord[0],coord[1], item->getZoffset() * scale);
						if(!scene->findWalkablePos(item.get(),coord,c_walkableSearchRange,pos))
						{
							CRCore::notify(CRCore::ALWAYS)<<"crJXJReliveItemsFromTabMethod findWalkablePos失败 "<<coord<<std::endl;
						}
						else
						{
							pos/=scale;
							item->setPosxy(pos[0],pos[1]);
							item->setPosz(pos[2]);
						}
					}
					itemData->excHandle(MAKEINT64(WCH_InitData,item.get()));
					itemData->excHandle(MAKEINT64(WCH_LockData,0));
					//if(item/* && item->getItemtype() == crInstanceItem::Npc*/)
					//{
					if (roomType != FT_WorldFuben)
					{//共享视野
						switch (itr->second->getCamp())
						{
						case 1:
							if (itemData)
							{
								itemData->inputParam(WCHDATA_Camp, &defenceShili);
								(*totalNpcMap)[defenceShili] += armcount;
							}
							item->setSightInfo(defenceSightInfo.get());//->addEyeItem(item);
							break;
						case 2:
							if (itemData)
							{
								itemData->inputParam(WCHDATA_Camp, &attackShili);
								(*totalNpcMap)[attackShili] += armcount;
							}
							item->setSightInfo(attackSightInfo.get());//attackSightInfo->addEyeItem(item);
							break;
						default:
							break;
						}
					}
					else
					{//不共享视野，NPC共用一个视野
						unsigned char camp = itr->second->getCamp();
						if(camp!=0)
						{
							//ref_ptr<crSightInfo>sightInfo = m_this->getOrCreateSightInfo(camp);
							if (itemData)
							{
								itemData->inputParam(WCHDATA_Camp, &camp);
							}
							if(!item->getSightInfo())
								item->setSightInfo(m_this->getOrCreateSightInfo(camp,true));
						}
					}
					//}
					scene->itemRelive(item.get());
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock
	}
}
/////////////////////////////////////////
//
//crJXJCheckItemsDeadFromTabMethod
//
/////////////////////////////////////////
crJXJCheckItemsDeadFromTabMethod::crJXJCheckItemsDeadFromTabMethod():
	m_id(0){}
crJXJCheckItemsDeadFromTabMethod::crJXJCheckItemsDeadFromTabMethod(const crJXJCheckItemsDeadFromTabMethod& handle):
	crMethod(handle),
	m_id(handle.m_id)
{
}
void crJXJCheckItemsDeadFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	}
}
void crJXJCheckItemsDeadFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJCheckItemsDeadFromTabMethod::operator()(crHandle &handle)
{
	bool condition = true;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		crInstanceItem *item;
		crData *itemData;
		unsigned char itemstate;
		void *param;
		crData *data = m_this->getDataClass();
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_RoomProgress,param);
		//short progress = *(short *)param;
		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_id);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_id;
			++itr )
		{
			item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
			if(item)
			{	
				itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
				{
					condition = false;
					break;
				}
				//guisestate = GS_Normal;
				//item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				//if(!(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable))
				//{
				//	condition = false;
				//	break;
				//}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJCheckItemsDeadFromTab2Method
//
/////////////////////////////////////////
crJXJCheckItemsDeadFromTab2Method::crJXJCheckItemsDeadFromTab2Method():
	m_id(0){}
crJXJCheckItemsDeadFromTab2Method::crJXJCheckItemsDeadFromTab2Method(const crJXJCheckItemsDeadFromTab2Method& handle):
	crMethod(handle),
	m_id(handle.m_id)
{
}
void crJXJCheckItemsDeadFromTab2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	}
}
void crJXJCheckItemsDeadFromTab2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem *)param;
		break;
	}
}
void crJXJCheckItemsDeadFromTab2Method::operator()(crHandle &handle)
{
	bool condition = true;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	crRoom *room = netCallback->findRoom(m_this->getRoomID());
	if(room && room->getGameRunning())
	{
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			crInstanceItem *item;
			crData *itemData;
			unsigned char itemstate;
			void *param;
			crData *data = room->getDataClass();
			scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
			data->excHandle(MAKEINT64(WCH_LockData,1));
			//data->getParam(WCHDATA_RoomProgress,param);
			//short progress = *(short *)param;
			data->getParam(WCHDATA_JXJReliveItemMap,param);
			ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
			ReliveItemMap::iterator itr = reliveItemMap->find(m_id);
			for( ;
				itr != reliveItemMap->end() && itr->first == m_id;
				++itr )
			{
				item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
				if(item)
				{	
					itemData = item->getDataClass();
					itemData->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate != IS_Dead)
					{
						condition = false;
						break;
					}
					//guisestate = GS_Normal;
					//item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					//if(!(guisestate & GS_UnVisiable || guisestate & GS_StaticUnVisiable))
					//{
					//	condition = false;
					//	break;
					//}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock
		}
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJNpcPatrolMethod
//
/////////////////////////////////////////
crJXJNpcPatrolMethod::crJXJNpcPatrolMethod():
	m_taskPointRange(1){}
crJXJNpcPatrolMethod::crJXJNpcPatrolMethod(const crJXJNpcPatrolMethod& handle):
	crMethod(handle),
	m_taskPointRange(handle.m_taskPointRange)
{
}
void crJXJNpcPatrolMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJNpcPatrolMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskPointRange = atof(str.c_str());
		break;
	}
}
void crJXJNpcPatrolMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(!scene) return;
		void *param;
		crData *data = m_this->getDataClass();

		bool patrol = false;
		unsigned char count = 0;
		crVector2 targetPos;
		float scale = crGlobalHandle::gData()->gUnitScale();
		crVector2 myPos(m_this->getPosx(),m_this->getPosy());
		myPos *= scale;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_PatrolPointVec,param);
		PatrolPointVec* patrolPointVec = (PatrolPointVec*)param;
		count = patrolPointVec->size();
		if(count == 0)
		{
			data->excHandle(MAKEINT64(WCH_LockData,0));
			CRCore::notify(CRCore::WARN)<<"crJXJNpcPatrolMethod NPC没有设置巡逻点 npcid = "<<m_this->getInstanceItemID()<<std::endl;
			//sprintf(gDebugInfo->buf(),"crJXJNpcPatrolMethod NPC没有设置巡逻点 npcid =%d\n\0",m_this->getInstanceItemID());
			//gDebugInfo->debugInfo(CRCore::WARN);
			return;
		}
		if(count == 1)
		{
			targetPos[0] = (*patrolPointVec)[0][0];
			targetPos[1] = (*patrolPointVec)[0][1];
			crVector2 vec = targetPos - myPos;
			if (vec.length() > m_taskPointRange)
			{
				patrol = true;
			}
		}
		else
		{
			data->getParam(WCHDATA_PatrolIndex,param);
			char* idx = (char*)param;
			char loopid = abs(*idx);
			data->getParam(WCHDATA_PatrolLoopMode,param);
			unsigned char loopmode = *(unsigned char *)param;
			if(loopid<count)
			{
				targetPos[0] = (*patrolPointVec)[loopid][0];
				targetPos[1] = (*patrolPointVec)[loopid][1];
				crVector2 vec = targetPos - myPos;
				if(vec.length()<=m_taskPointRange)
				{
					(*idx)++;
					if(*idx>=count)
					{
						switch (loopmode)
						{
						case 0:
							*idx = count-1;
							break;
						case 1:
							*idx = 0;
							break;
						case 2:
							*idx = -loopid;
							break;
						}
					}
				}
				patrol = true;
			}
			else
			{
				*idx = 0;
				targetPos[0] = (*patrolPointVec)[*idx][0];
				targetPos[1] = (*patrolPointVec)[*idx][1];
				patrol = true;
			}
			//data->getParam(WCHDATA_PatrolIndex,param);
			//char* idx = (char*)param;
			//if(*idx<count)
			//{
			//	targetPos[0] = (*patrolPointVec)[*idx][0];
			//	targetPos[1] = (*patrolPointVec)[*idx][1];
			//	crVector3 vec = targetPos - myPos;
			//	vec[2] = 0.0f;
			//	if(vec.length2()<m_taskPointRange * m_taskPointRange)
			//	{
			//		(*idx)++;
			//		if(*idx>=count)
			//			*idx = 0;
			//		targetPos[0] = (*patrolPointVec)[*idx][0];
			//		targetPos[1] = (*patrolPointVec)[*idx][1];
			//		patrol = true;
			//	}
			//}
			//else
			//{
			//	*idx = 0;
			//	targetPos[0] = (*patrolPointVec)[*idx][0];
			//	targetPos[1] = (*patrolPointVec)[*idx][1];
			//	patrol = true;
			//}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		//targetPos[2] = scene->getPosZ(m_this->getLayerID(),targetPos[0],targetPos[1],m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale());
		if(patrol)
		{
			crVector3 _targetPos(targetPos[0], targetPos[1], 0.0f);
			data->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char *)(param);
			data->getParam(WCHDATA_TargetPos,param);
			crVector3 oldtargetpos = *(crVector3 *)param;
			oldtargetpos[2] = 0.0f;
			if (itemstate == IS_Stop || (oldtargetpos - _targetPos).length()>m_taskPointRange)
			{
				//CRCore::notify(CRCore::ALWAYS) << "crJXJNpcPatrolMethod count = " << (int)count << " Name = " << m_this->getIName() << " id=" << m_this->getInstanceItemID() << " oldtargetpos:" << oldtargetpos << " _targetPos:" << _targetPos<<std::endl;
				itemstate = IS_AttackToPos;
				unsigned char targettype = Target_Coord;
				data->inputParam(WCHDATA_ItemState,&itemstate);
				data->inputParam(WCHDATA_TargetType,&targettype);
				data->inputParam(WCHDATA_TargetPos, &_targetPos);
				scene->getPathFindingManager()->addPathFindRequest(m_this);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRolePatrolMethod
//
/////////////////////////////////////////
crJXJRolePatrolMethod::crJXJRolePatrolMethod():
	m_taskPointRange(1){}
crJXJRolePatrolMethod::crJXJRolePatrolMethod(const crJXJRolePatrolMethod& handle):
	crMethod(handle),
	m_taskPointRange(handle.m_taskPointRange)
{
}
void crJXJRolePatrolMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRole*)param;
		break;
	}
}
void crJXJRolePatrolMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskPointRange = atof(str.c_str());
		break;
	}
}
void crJXJRolePatrolMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->ifItemIsMe(m_this))
	{
		void *param;
		crData *data = m_this->getDataClass();

		bool patrol = false;
		unsigned char count = 0;
		crVector2 targetPos;
		float scale = crGlobalHandle::gData()->gUnitScale();
		crVector2 myPos(m_this->getPosx(),m_this->getPosy());
		myPos *= scale;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_PatrolPointVec,param);
		PatrolPointVec* patrolPointVec = (PatrolPointVec*)param;
		count = patrolPointVec->size();
		if(!patrolPointVec->empty())
		{
			if(count == 1)
			{
				targetPos[0] = (*patrolPointVec)[0][0];
				targetPos[1] = (*patrolPointVec)[0][1];
				crVector2 vec = targetPos - myPos;
				if (vec.length() > m_taskPointRange)
				{
					patrol = true;
				}
			}
			else
			{
				data->getParam(WCHDATA_PatrolIndex,param);
				char* idx = (char*)param;
				char loopid = abs(*idx);
				data->getParam(WCHDATA_PatrolLoopMode,param);
				unsigned char loopmode = *(unsigned char *)param;
				if(loopid<count)
				{
					targetPos[0] = (*patrolPointVec)[loopid][0];
					targetPos[1] = (*patrolPointVec)[loopid][1];
					crVector2 vec = targetPos - myPos;
					if(vec.length()<=m_taskPointRange)
					{
						(*idx)++;
						if(*idx>=count)
						{
							switch (loopmode)
							{
							case 0:
								*idx = count-1;
								break;
							case 1:
								*idx = 0;
								break;
							case 2:
								*idx = -loopid;
								break;
							}
						}
					}
					patrol = true;
				}
				else
				{
					*idx = 0;
					targetPos[0] = (*patrolPointVec)[*idx][0];
					targetPos[1] = (*patrolPointVec)[*idx][1];
					patrol = true;
				}
			}

		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		if(patrol)
		{
			crVector3 _targetPos(targetPos[0], targetPos[1], 0.0f);
			data->getParam(WCHDATA_ItemState, param);
			unsigned char itemstate = *(unsigned char *)(param);
			data->getParam(WCHDATA_TargetPos,param);
			crVector3 oldtargetpos = *(crVector3 *)param;
			oldtargetpos[2] = 0.0f;
			if (itemstate == IS_Stop || (oldtargetpos - _targetPos).length()>m_taskPointRange)
			{
				unsigned char itemstate = IS_AttackToPos;
				unsigned char targettype = Target_Coord;
				data->inputParam(WCHDATA_ItemState,&itemstate);
				data->inputParam(WCHDATA_TargetType,&targettype);
				data->inputParam(WCHDATA_TargetPos, &_targetPos);
				crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
			}
		}

		//targetPos[2] = scene->getPosZ(m_this->getLayerID(),targetPos[0],targetPos[1],m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale());

	}
}
/////////////////////////////////////////
//
//crJXJRecvServerListMethod
//
/////////////////////////////////////////
crJXJRecvServerListMethod::crJXJRecvServerListMethod(){}
crJXJRecvServerListMethod::crJXJRecvServerListMethod(const crJXJRecvServerListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_serverNo(handle.m_serverNo),
	m_serverName(handle.m_serverName),
	m_stats(handle.m_stats),
	m_telecom(handle.m_telecom),
	m_cnc(handle.m_cnc)
{
}
void crJXJRecvServerListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvServerListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_serverNo = str;
		break;
	case 2:
		m_serverName = str;
		break;
	case 3:
		m_stats = str;
		break;
	case 4:
		m_telecom = str;
		break;
	case 5:
		m_cnc = str;
		break;
	}
}

void crJXJRecvServerListMethod::operator()(crHandle &handle)
{
	bool code = false;
	if(m_stream.valid())
	{
		code = m_stream->_readBool();
		if(code)
		{
			ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if(canvas.valid())
			{
				crData *canvasData = canvas->getDataClass();
				void *param;
				canvasData->getParam(WCHDATA_JXJServerListMap,param);
				ServerListMap *serverListMap = (ServerListMap *)param;
				serverListMap->clear();
				ref_ptr<crQueryServerListData> serverListData;
				unsigned short count = m_stream->_readUShort();
				for( int i = 0; i<count; i++)
				{
					serverListData = new crQueryServerListData;
					serverListData->setServerID(m_stream->_readInt());
					serverListData->setServerName(m_stream->_readString());
					serverListData->setISP(m_stream->_readUChar());
					serverListData->setRemainCount(m_stream->_readUShort());
					serverListMap->insert(std::make_pair(serverListData->getISP(),serverListData.get()));
				}
				if(!serverListMap->empty())canvas->doEvent(WCH_UI_UpdateData);
				//if(!serverListMap->empty())
				//{
				///////////
				//serverListData = serverListMap->begin()->second.get();
				//ref_ptr<crStaticTextWidgetNode> serverNo = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_serverNo));
				//ref_ptr<crStaticTextWidgetNode> serverName = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_serverName));
				//ref_ptr<crStaticTextWidgetNode> stats = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_stats));
				//ref_ptr<crButtonWidgetNode> telecom = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_telecom));
				//ref_ptr<crButtonWidgetNode> cnc = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_cnc));
				//if(serverNo.valid())
				//{
				//	serverNo->setString(std::string("1"));
				//}
				//if(serverName.valid())
				//{
				//	std::string name = serverListData->getServerName();
				//	serverName->setString(name);
				//}
				//if(stats.valid())
				//{
				//	std::string statstr;
				//	int count = serverListData->getRemainCount();
				//	if(count == -1)
				//	{
				//		statstr = "维护";
				//		stats->setColor(crVector4(100,100,100,255));
				//	}
				//	else if(count>3000)
				//	{
				//		statstr = "空闲";
				//		stats->setColor(crVector4(0,255,0,255));
				//	}
				//	else if(count>1000)
				//	{
				//		statstr = "繁忙";
				//		stats->setColor(crVector4(255,255,0,255));
				//	}
				//	else
				//	{
				//		statstr = "爆满";
				//		stats->setColor(crVector4(255,0,0,255));
				//	}
				//	stats->setString(statstr);
				//}
				//if(serverListData->getISP() == 0)
				//{
				//	telecom->setEnable(true);
				//	cnc->setEnable(true);
				//}
				//else if(serverListData->getISP() == 1)
				//{
				//	telecom->setEnable(true);
				//	cnc->setEnable(false);
				//}
				//else
				//{
				//	telecom->setEnable(false);
				//	cnc->setEnable(true);
				//}
				//}
				//else
				//{
				//	crJXJConnectServerQueryPacket packet;
				//	crJXJConnectServerQueryPacket::buildRequestPacket(packet,serverListMap.begin()->second->getServerID());
				//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
				//	netConductor->getNetManager()->sendPacket("all",packet);
				//}
			}
		}
	}
	handle.outputParam(0,&code);
}
/////////////////////////////////////////
//
//crJXJEnterServerMethod
//
/////////////////////////////////////////
crJXJEnterServerMethod::crJXJEnterServerMethod():
	m_isp(1),m_btnid(0){}
crJXJEnterServerMethod::crJXJEnterServerMethod(const crJXJEnterServerMethod& handle):
	crMethod(handle),
	m_isp(handle.m_isp),
	m_btnid(handle.m_btnid)
{
}
void crJXJEnterServerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJEnterServerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_isp = atoi(str.c_str());
		break;
	case 1:
		m_btnid = atoi(str.c_str());
		break;
	}
}

void crJXJEnterServerMethod::operator()(crHandle &handle)
{
	bool backtologin = false;
	ref_ptr<crCanvasNode >canvas = m_this->getParentCanvas();
	if(canvas.valid())
	{
		crData *canvasData = canvas->getDataClass();
		void *param; 
		crMyPlayerData::getInstance()->setISP(m_isp);
		canvasData->getParam(WCHDATA_JXJServerListMap,param);
		ServerListMap *serverListMap = (ServerListMap *)param;
		if(!serverListMap->empty())
		{
			int curpagenum;
			canvasData->getParam(WCHDATA_JXJSelectServerUICurPage,param);
			curpagenum = *(int *)param;
			int serverid = m_btnid+(curpagenum-1)*6;
			ServerListMap::iterator iter = serverListMap->begin();

			for(int i=0;i<serverid;i++)
				iter++;
			crMyPlayerData::getInstance()->setLastServerID(iter->second->getServerID());

			crJXJConnectServerQueryPacket packet;
			crJXJConnectServerQueryPacket::buildRequestPacket(packet,crMyPlayerData::getInstance()->getLastServerID());
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
			if(netConductor)
				netConductor->getNetManager()->sendPacket("all",packet);
			else
			{
				backtologin = true;
			}
		}
		else
		{
			backtologin = true;
		}
	}
	handle.outputParam(0,&backtologin);
}
/////////////////////////////////////////
//
//crJXJWebLoginEnterServerMethod
//
/////////////////////////////////////////
crJXJWebLoginEnterServerMethod::crJXJWebLoginEnterServerMethod(){}
crJXJWebLoginEnterServerMethod::crJXJWebLoginEnterServerMethod(const crJXJWebLoginEnterServerMethod& handle):
	crMethod(handle)
{
}
void crJXJWebLoginEnterServerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJWebLoginEnterServerMethod::addParam(int i, const std::string& str)
{
}

void crJXJWebLoginEnterServerMethod::operator()(crHandle &handle)
{
	crJXJConnectServerQueryPacket packet;
	crJXJConnectServerQueryPacket::buildRequestPacket(packet,crMyPlayerData::getInstance()->getLastServerID());
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJRecvConnectServerMethod
//
/////////////////////////////////////////
crJXJRecvConnectServerMethod::crJXJRecvConnectServerMethod(){}
crJXJRecvConnectServerMethod::crJXJRecvConnectServerMethod(const crJXJRecvConnectServerMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvConnectServerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvConnectServerMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvConnectServerMethod::operator()(crHandle &handle)
{
	bool code = false;
	if(m_stream.valid())
	{
		code = m_stream->_readBool();
		if(code)
		{
			int isp = crMyPlayerData::getInstance()->getISP();
			std::string telecom = m_stream->_readString();
			std::string cnc = m_stream->_readString();
			std::string cmc = m_stream->_readString();
			ref_ptr<crQueryConnectServerData> connectServerData = new crQueryConnectServerData;
			if(isp == 2)
			{//联通
				connectServerData->setIP(cnc);
				connectServerData->setIP2(telecom);
				connectServerData->setIP3(cmc);
			}
			else if(isp == 3)
			{//移动
				connectServerData->setIP(cmc);
				connectServerData->setIP2(telecom);
				connectServerData->setIP3(cnc);
			}
			else
			{//默认电信
				connectServerData->setIP(telecom);
				connectServerData->setIP2(cnc);
				connectServerData->setIP3(cmc);
			}
			connectServerData->setPort(m_stream->_readUShort());
			crMyPlayerData::getInstance()->setConnectServerData(connectServerData.get());
		}
	}
	handle.outputParam(0,&code);
}
/////////////////////////////////////////
//
//crJXJFileVersioncheckThread
//
/////////////////////////////////////////
crJXJFileVersioncheckThread::crJXJFileVersioncheckThread():
	m_done(false)
{
}
crJXJFileVersioncheckThread::~crJXJFileVersioncheckThread() 
{
	while (isRunning()) 
	{
		yieldCurrentThread();
	}
}
void crJXJFileVersioncheckThread::run()
{
	m_done = false;
	m_progress = 0.0f;
	ref_ptr<CREncapsulation::crTableIO> curDynamictab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_DynamicDownloadTab);
	ref_ptr<crTableIO> newDynamictab = crGlobalHandle::gData()->gNewDynamicDownloadTable();
	int rowcount = curDynamictab->getRowCount();
	std::string file;
	std::string curver;
	std::string newver;
	crTableIO::StrVec qrecord;
	crTableIO::DataVec &dataVec = curDynamictab->getDataVec();
	bool needsave = false;
	bool found;
	int i = 0;
	crTableIO::StrVec record;
	record.resize(2);
	crRunGameHandle::StrVec &startupDownloadFiles = crRunGameHandle::getInstance()->getStartupDownloadFileVec();
	float count = startupDownloadFiles.size();
	float step = 0.0f;
	for( crRunGameHandle::StrVec::iterator itr = startupDownloadFiles.begin();
		itr != startupDownloadFiles.end();
		++itr )
	{
		step += 1.0f;
		m_progress = step/count*0.3f;
		newver.clear();
		file = *itr;
		if(newDynamictab.valid() && newDynamictab->queryOneRecord(0,file,qrecord)>=0)
		{
			newver = qrecord[1];
		}
		rowcount = curDynamictab->getRowCount();
		found = false;
		for( i = 0; i<rowcount; i++)
		{
			//if((*curDynamictab)(i,0) == file)
			if(CRIOManager::equalCaseInsensitive((*curDynamictab)(i,0),file))
			{
				(*curDynamictab)(i,1) = newver;
				found = true;
				break;
			}
		}
		if(!found)
		{
			record[0] = file;
			record[1] = newver;
			curDynamictab->addData(record);
		}
		needsave = true;
	}
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	count = dataVec.size();
	step = 0.0f;
	for( crTableIO::DataVec::iterator itr = dataVec.begin();
		itr != dataVec.end(); )
	{
		step += 1.0f;
		m_progress = 0.3f+step/count*0.6f;
		file = (*itr)[0];
		curver = (*itr)[1];
		if(newDynamictab->queryOneRecord(0,file,qrecord)>=0)
		{
			newver = qrecord[1];
			if(newver!=curver)
			{//需要更新文件
				if(curver.size()<32)
				{//第一次做MD5码校验
					stream->loadFromFile2(file);
					curver = stream->getMD5();
					if(newver!=curver)
					{
						DeleteFileA(file.c_str());
						itr = dataVec.erase(itr);
						needsave = true;
						continue;
					}
					(*itr)[1] = curver;
					needsave = true;
				}
				else
				{
					DeleteFileA(file.c_str());
					itr = dataVec.erase(itr);
					needsave = true;
					continue;
				}
			}
			else
			{//文件MD5校验
				stream->loadFromFile2(file);
				if(curver != stream->getMD5())
				{
					DeleteFileA(file.c_str());
					itr = dataVec.erase(itr);
					needsave = true;
					continue;
				}
			}
			++itr;
		}
		else
		{//已经删除文件
			DeleteFileA(file.c_str());
			itr = dataVec.erase(itr);
			needsave = true;
		}
	}
	////////删除版本信息错误的文件
	crTableIO::DataVec &newDataVec = newDynamictab->getDataVec();
	count = newDataVec.size();
	step = 0.0f;
	for( crTableIO::DataVec::iterator itr = newDataVec.begin();
		itr != newDataVec.end();
		++itr )
	{
		step += 1.0f;
		m_progress = 0.9f+step/count*0.1f;
		file = (*itr)[0];
		if(curDynamictab->queryOneRecord(0,file,qrecord)<0)
		{
			if(CRIOManager::fileExists(file))
			{
				DeleteFileA(file.c_str());
			}
		}
	}
	if(needsave)
		curDynamictab->saveToFileStreamNoCook(crGlobalHandle::gData()->gDynamicDownloadTabName(),SM_Copy);
	startupDownloadFiles.clear();
	char gbuf[256];
	sprintf(gbuf,"文件版本信息校验!\n\0");
	gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
	m_done = true;
	m_progress = 1.0f;
}
/////////////////////////////////////////
//
//crJXJMoveFileToDirectoryThread
//
/////////////////////////////////////////
crJXJMoveFileToDirectoryThread::crJXJMoveFileToDirectoryThread():
	m_case(0)
{
}
crJXJMoveFileToDirectoryThread::~crJXJMoveFileToDirectoryThread() 
{
	while (isRunning()) 
	{
		yieldCurrentThread();
	}
}
bool crJXJMoveFileToDirectoryThread::binExtension(const std::string& extension) const
{
	return CRIOManager::equalCaseInsensitive(extension,"dll") ||
		CRIOManager::equalCaseInsensitive(extension,"exe") ||
		CRIOManager::equalCaseInsensitive(extension,"ocx");
}
void crJXJMoveFileToDirectoryThread::run()
{
	m_case = 0;
	std::string notice;
	std::string ext;
	bool needRestart = false;
	crDownloadManager::getInstance()->lockDownloadMap();
	crDownloadManager::DownloadMap &downloadMap = crDownloadManager::getInstance()->getDownloadMap();
	for (crDownloadManager::DownloadMap::iterator itr = downloadMap.begin(); itr != downloadMap.end();)
	{
		if(itr->second->getDownloadState() == crDownload::Done)
		{
			ext = crArgumentParser::getFileExtension(itr->second->getFileName());
			//if(itr->second->getFileName().find("reportbugs") == std::string::npos && binExtension(ext))
			if(itr->second->getFileName().find("bin") != std::string::npos && binExtension(ext))
			{
				needRestart = true;
			}
			else if(itr->second->is7zfile())
			{
				if(itr->second->moveFileToDirectory())
				{
					needRestart = true;
				}
			}
			else
			{
				itr->second->moveFileToDirectory();
			}
			//notice = "正在更新文件:"+itr->second->getFileName()+"，请稍等...";
		}
		itr = downloadMap.erase(itr);
	}
	crDownloadManager::getInstance()->unlockDownloadMap();
	if(needRestart)
	{
		//_case = 4;//自动重启游戏
		notice = "需要自动重启游戏完成更新...";
		m_case = 4;
	}
	else
	{
		//_case = 5;//显示登录界面
		crGlobalHandle::setVersion(crGlobalHandle::getNewVersion());
		notice = "游戏更新完成...";
		m_case = 5;
	}
	//m_progress = 2;//启动版本校验结束
	crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(0,&notice));
}
/////////////////////////////////////////
//
//crJXJGameSetupThread
//
/////////////////////////////////////////
crJXJGameSetupThread::crJXJGameSetupThread(const std::string &setupfile):
	m_done(false),
	m_setupfile(setupfile)
{
}
crJXJGameSetupThread::~crJXJGameSetupThread() 
{
	while (isRunning()) 
	{
		yieldCurrentThread();
	}
}
void crJXJGameSetupThread::run()
{
	m_done = false;
	//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(53,NULL));
	//char buf[256];
	//memset(buf,0,256);
	//sprintf_s(buf,"7zr.exe x -r %s -y",m_setupfile.c_str());
	//PROCESS_INFORMATION pi;
	//STARTUPINFO si; //This is an [in] parameter
	//ZeroMemory(&si, sizeof(si));
	//si.cb = sizeof si; //Only compulsory field
	//si.dwFlags = STARTF_USESHOWWINDOW;
	//si.wShowWindow = SW_HIDE;
	//if(CreateProcess(NULL, buf, NULL,NULL,FALSE,0,NULL, NULL,&si,&pi))
	//{
	//	WaitForSingleObject(pi.hProcess,INFINITE);
	//	CloseHandle(pi.hThread);
	//	CloseHandle(pi.hProcess);
	//}
	//else
	//{
	//	sprintf_s(buf,"解压缩[%s]出错!\0",m_setupfile.c_str());
	//	MessageBox(::GetActiveWindow(),buf,"Creature3D",MB_OK);
	//}
	//DeleteFileA(m_setupfile.c_str());
	ref_ptr<crDownload> download = crDownloadManager::getInstance()->getDownload(m_setupfile);
	if(download.valid())
	{
		download->moveFileToDirectory();
		DeleteFileA("setup.ini");
		crDownloadManager::getInstance()->removeDownload(m_setupfile);
	}
	m_done = true;
}
/////////////////////////////////////////
//
//crJXJStartupDownloadCaseMethod
//
/////////////////////////////////////////
crJXJStartupDownloadCaseMethod::crJXJStartupDownloadCaseMethod():
	m_progress(0),
	m_needRestart(false),
	m_dt(NULL),
	m_speed(1.0f),
	m_setupfile("JXJ.7z"){}
crJXJStartupDownloadCaseMethod::crJXJStartupDownloadCaseMethod(const crJXJStartupDownloadCaseMethod& handle):
	crMethod(handle),
	m_verini(handle.m_verini),
	m_versiontab(handle.m_versiontab),
	m_canvasName(handle.m_canvasName),
	m_progressTextWidget(handle.m_progressTextWidget),
	m_progressWidget(handle.m_progressWidget),
	m_speed(handle.m_speed),
	m_setupfile(handle.m_setupfile),
	m_progressHead(handle.m_progressHead),
	m_visiableRange(handle.m_visiableRange),
	m_needRestart(false),
	m_progress(0),
	m_dt(NULL)
{
}
void crJXJStartupDownloadCaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float *)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJStartupDownloadCaseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_verini = str;
		break;
	case 1:
		m_versiontab = str;
		break;
	case 2:
		m_canvasName = str;
		break;
	case 3:
		m_progressTextWidget = str;
		break;
	case 4:
		m_progressWidget = str;
		break;
	case 5:
		m_speed = atof(str.c_str());
		break;
	case 6:
		m_progressHead = str;
		break;
	case 7:
		crArgumentParser::appAtoVec(str,m_visiableRange);
		break;
	case 8:
		m_setupfile = str;
		break;
	}
}
//void crJXJStartupDownloadCaseMethod::fileVersioncheck()
//{
//}
void crJXJStartupDownloadCaseMethod::operator()(crHandle &handle)
{
	int _case = 0;
	ref_ptr<crDownload> download;
	switch (m_progress)//0:版本校验未启动。1：版本校验启动中。2：版本校验启动结束。
	{
	case -1://下载失败，提示无法连接服务器
		_case = 1;
		break;
	case 0:
		if(CRIOManager::fileExists("setup.ini"))
		{
			m_progress = 8;
			m_download1 = new crDownload(m_setupfile);
			crDownloadManager::getInstance()->addImmediatelyDownloadRequest(m_download1);
			crFilterRenderManager::getInstance()->showCanvas(m_canvasName,true);
		}
		else
		{
			crFilterRenderManager::getInstance()->closeCanvas(m_canvasName);
			download = crDownloadManager::getInstance()->getDownload(m_verini);
			if(download.valid())
			{
				switch (download->getDownloadState())
				{
					//case crDownload::Faild:
					//	_case = 1;//下载失败，提示无法连接服务器
					//	m_progress = -1;//启动版本校验结束
					//	break;
				case crDownload::Done:
					{
						int curver = readVersion(m_verini);
						int newver = readVersion(download->getPkgFileName());
						crGlobalHandle::setVersion(curver);
						crGlobalHandle::setNewVersion(newver);
						if(newver>curver)
						{
							_case = 3;//进入启动更新
							m_progress = 1;
							crFilterRenderManager::getInstance()->showCanvas(m_canvasName,true);
							//CRCore::notify(CRCore::ALWAYS)<<"进入启动更新"<<std::endl;
							char gbuf[256];
							sprintf(gbuf,"进入启动更新,当前版本:%d,最新版本%d\n\0",curver,newver);
							gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);
						}
						else
						{
							_case = 5;//显示登录界面
							m_progress = 2;//启动版本校验结束
							//CRCore::notify(CRCore::ALWAYS)<<"显示登录界面"<<std::endl;
							char gbuf[256];
							sprintf(gbuf,"显示登录界面,当前版本:%d\n\0",curver);
							gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);
						}
						//download->moveFileToDirectory();
						crDownloadManager::getInstance()->removeDownload(m_verini);
						//更新完成后在覆盖版本号
					}
					break;
				default:
					_case = 2;//下载中，提示正在检查更新
					break;
				}
			}
		}
		break;
	case 1:
		download = crDownloadManager::getInstance()->getDownload(m_versiontab);
		switch (download->getDownloadState())
		{
		//case crDownload::Faild:
		//	_case = 1;//下载失败，提示无法连接服务器
		//	m_progress = 2;//启动版本校验结束
		//	break;
		case crDownload::Done:
			{
				crDownloadManager::getInstance()->setCompleteCount(0);
				int startupCount = 0;
				ref_ptr<crTableIO> versiontab = crTableIO::openFile(crDownloadManager::getInstance()->getFileRootDir()+"/"+download->getFileName());
				if(versiontab.valid())
				{
					int curver = crGlobalHandle::getVersion();
					ref_ptr<crGameTask> gameTask;
					int rowcount = versiontab->getRowCount();
					int ver;
					for(int i = 0; i<rowcount; ++i)
					{
						ver = atoi((*versiontab)(i,0).c_str());
						if(ver>curver)
						{
							crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload((*versiontab)(i,1)));
							startupCount++;
						}
					}
				}
				crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(crGlobalHandle::gData()->gDynamicDownloadTabName()));
				startupCount++;
				crDownloadManager::getInstance()->setTaskCount(startupCount);
				//download->moveFileToDirectory();
				crDownloadManager::getInstance()->removeDownload(m_versiontab);
				m_progress = 3;//启动更新下载开始
			}
			break;
		}
		break;
		//case 1:
		//	download = crDownloadManager::getInstance()->getDownload(m_startuptab);
		//	switch (download->getDownloadState())
		//	{
		//	case crDownload::Faild:
		//		_case = 1;//下载失败，提示无法连接服务器
		//		m_progress = 2;//启动版本校验结束
		//		break;
		//	case crDownload::Done:
		//		{
		//			ref_ptr<crTableIO> curStartuptab = crTableIO::openFile(download->getFileName());
		//			//curStartuptab->openFileStream(download->getFileName());
		//			ref_ptr<crTableIO> newStartuptab = crTableIO::openFile(crDownloadManager::getInstance()->getFileRootDir()+"/"+download->getFileName());
		//			//newStartuptab->openFileStream(crDownloadManager::getInstance()->getFileRootDir()+"/"+download->getFileName());
		//			int rowcount = newStartuptab->getRowCount();
		//			std::string updfile;
		//			int newver,curver;
		//			CREncapsulation::crTableIO::StrVec qrecord;
		//			int startupCount = 0;
		//			crDownloadManager::getInstance()->setCompleteCount(0);
		//			for(int i = 0; i<rowcount; i++)
		//			{
		//				updfile = (*newStartuptab)(i,0);
		//				newver = atoi((*newStartuptab)(i,1).c_str());
		//				if(curStartuptab->queryOneRecord(0,updfile,qrecord))
		//				{
		//					curver = atoi(qrecord[1].c_str());
		//					if(newver>curver)
		//					{
		//						crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(updfile));
		//						startupCount++;
		//					}
		//				}
		//				else
		//				{
		//					crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(updfile));
		//					startupCount++;
		//				}
		//			}
		//			crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(crGlobalHandle::gData()->gDynamicDownloadTabName()));
		//			startupCount++;
		//			crDownloadManager::getInstance()->setTaskCount(startupCount);
		//			//download->moveFileToDirectory();
		//			//crDownloadManager::getInstance()->removeDownload(m_startuptab);
		//			m_progress = 3;//启动更新下载开始
		//		}
		//		break;
		//	}
		//	break;
	case 2:////启动版本校验结束
		_case = 6;
		if(crGlobalHandle::argvstr().find("DynamicDownloadRec")!=std::string::npos)
			crDownloadManager::getInstance()->setDynamicDownloadRecord(true);
		break;
	case 3://启动更新下载开始
		{
			m_download1 = crDownloadManager::getInstance()->getCurrentDownload();
			std::string file1;
			//int progress1 = 0;
			ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
			ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
			ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
			std::string str = "总进度:"+crArgumentParser::appItoa(crDownloadManager::getInstance()->getCompleteCount())+"|"+crArgumentParser::appItoa(crDownloadManager::getInstance()->getTaskCount());
			float progress = 0.0f;
			if(m_download1.valid())
			{
				file1 = crArgumentParser::getSimpleFileName(m_download1->getFileName());
				progress = m_download1->getProgress();
				if(canvas.valid() && canvas->getVisiable())
				{
					if(progressWidget.valid()) progressWidget->setProgress(progress/*crDownloadManager::getInstance()->getProgress()*/);
					//str += ",正在下载:"+file1+"进度："+crArgumentParser::appItoa(progress1)+"%";
					str += ",当前下载："+crArgumentParser::appItoa(progress * 100)+"%";
					if(progressTextWidget.valid()) progressTextWidget->setString(str);
				}
			}
			else if(canvas.valid() && canvas->getVisiable())
			{
				progress = crDownloadManager::getInstance()->getProgress();
				if(progressWidget.valid()) progressWidget->setProgress(progress);
				if(progressTextWidget.valid()) progressTextWidget->setString(str);
			}
			if(progressHeadNode.valid() && progressWidget.valid())
			{
				if(progress>m_visiableRange[0] && progress<m_visiableRange[1])
				{
					crVector2 barpos = progressWidget->getBarOffsetPosition();
					progressHeadNode->setPosition(crVector3(barpos[0],barpos[1],0.0f));
					progressHeadNode->setVisiable(true);
				}
				else
				{
					progressHeadNode->setVisiable(false);
				}
			}
			//std::string str = "下载1:"+file1+" 进度："+crArgumentParser::appItoa(progress1)+"%"
			//	+"总体进度"+crArgumentParser::appItoa(m_completeCount)+"|"+crArgumentParser::appItoa(m_startupCount);
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(0,&str));
			if(crDownloadManager::getInstance()->isComplete())
			{
				download = crDownloadManager::getInstance()->getDownload(crGlobalHandle::gData()->gDynamicDownloadTabName());
				if(download.valid())
				{
					switch (download->getDownloadState())
					{
					//case crDownload::Faild:
					//	_case = 1;//下载失败，提示无法连接服务器
					//	m_progress = 2;//启动版本校验结束
					//	crFilterRenderManager::getInstance()->showCanvas(m_canvasName,false);
					//	break;
					case crDownload::Done:
						{
							//download->moveFileToDirectory();
							ref_ptr<crTableIO> dynamictable = crTableIO::openFile(crDownloadManager::getInstance()->getFileRootDir()+"/"+crGlobalHandle::gData()->gDynamicDownloadTabName());
							//dynamictable->openFileNoCook(crDownloadManager::getInstance()->getFileRootDir()+"/"+crGlobalHandle::gData()->gDynamicDownloadTabName());
							CRNetApp::crGlobalHandle::gData()->inputParam(WCHDATA_gNewDynamicDownloadTab,dynamictable.get());
							crDownloadManager::getInstance()->removeDownload(crGlobalHandle::gData()->gDynamicDownloadTabName());
							///删除过期的动态下载文件
							//fileVersioncheck();
							//m_progress = 4;//下载结束，更新文件
							//crFilterRenderManager::getInstance()->showCanvas(m_canvasName,false);
							m_fileversioncheckthread = new crJXJFileVersioncheckThread;
							m_fileversioncheckthread->start();
							if(progressTextWidget.valid())
							{
								std::string str = "正在进行文件校验...";
								progressTextWidget->setString(str);
							}
							if(progressWidget.valid()) progressWidget->setProgress(0.0f);
							m_progress = 7;
							////
						}
						break;
					}
				}
				else
				{
					_case = 1;//下载失败，提示无法连接服务器
					m_progress = 2;//启动版本校验结束
					crFilterRenderManager::getInstance()->showCanvas(m_canvasName,false);
				}
			}
		}
		break;
	case 4://校验文件
		{
			std::string str = "正在校验文件，请稍等...";
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(0,&str));
			std::string ext;
			m_needRestart = false;
			bool exitgame = false;
			char buf[512];
			std::string url;
			crDownloadManager::getInstance()->lockDownloadMap();
			crDownloadManager::DownloadMap &downloadMap = crDownloadManager::getInstance()->getDownloadMap();
			for( crDownloadManager::DownloadMap::iterator itr = downloadMap.begin();
				itr != downloadMap.end();
				++itr )
			{
				if(itr->second->getDownloadState() != crDownload::Done)
				{
					sprintf(buf,"文件%s下载失败，由更新程序重新尝试下载点[是]，手动下载文件点[否]手动下载后请放到jxjpkg目录下。\0",itr->second->getFileName().c_str());
					if(MessageBox(crStartHandler::getInstance()->getWindowHandle(),buf,"将星诀",MB_YESNO)==IDNO)
					{
						url = "http://"+crDownloadManager::getInstance()->getHost()+"/"+itr->second->getPkgFileName();
						ShellExecute(NULL,"open",url.c_str(),NULL,NULL,SW_SHOW);
						exitgame = true;
					}
					else
					{
						m_needRestart = true;
					}
				}
			}
			crDownloadManager::getInstance()->unlockDownloadMap();
			if(exitgame)
			{
				crBrain::getInstance()->doEvent(WCH_EXITGAME);
				m_progress = 2;//启动版本校验结束
			}
			else
			{
				if(m_needRestart)
				{
					_case = 4;//自动重启游戏
					m_progress = 2;//启动版本校验结束
				}
				else
				{
					m_progress = 5;//文件校验结束，更新文件
				}
			}
			break;
		}
	case 5://执行文件拷贝
		{
			//CRCore::crBlockDetectThread::getInstance()->pause();
			Producer::Window hwnd = crStartHandler::getInstance()->getWindowHandle();
			SetWindowLong(hwnd,GWL_STYLE,GetWindowLong(hwnd,GWL_STYLE)&~WS_SYSMENU);
			m_movefilethread = new crJXJMoveFileToDirectoryThread;
			m_movefilethread->start();
			m_progress = 6;
			crFilterRenderManager::getInstance()->showCanvas(m_canvasName,true);
			ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			if(canvas.valid() && canvas->getVisiable())
			{
				ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
				ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
				ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
				if(progressWidget.valid())
				{
					progressWidget->setProgress(0.0f);
				}
				if(progressHeadNode.valid())
				{
					progressHeadNode->setVisiable(false);
				}
				if(progressTextWidget.valid())
				{
					std::string str = "正在更新文件,请稍后...";
					progressTextWidget->setString(str);
				}
			}
			//SetWindowLong(hwnd,GWL_STYLE,GetWindowLong(hwnd,GWL_STYLE)|WS_MINIMIZEBOX);
			//CRCore::crBlockDetectThread::getInstance()->resume();
		}
		break;
	case 6:
		{
			int __case = m_movefilethread->getCase();
			if(__case != 0)
			{
				_case = __case;
				m_progress = 2;//启动版本校验结束
				CRIOManager::copyFile("jxjpkg/jxjversion.ini","./jxjversion.ini");
				CRCore::crDisplaySettings::instance()->restoreFpsControl();
				Producer::Window hwnd = crStartHandler::getInstance()->getWindowHandle();
				SetWindowLong(hwnd,GWL_STYLE,GetWindowLong(hwnd,GWL_STYLE)|WS_SYSMENU);
			}
			else
			{
				CRCore::crDisplaySettings::instance()->setFpsControl(10.0f);
				ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
				if(canvas.valid() && canvas->getVisiable())
				{
					ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
					ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
					if(progressWidget.valid())
					{
						float progress = progressWidget->getProgress();
						progress += *m_dt * m_speed;
						progressWidget->setProgress(progress);
						if(progressHeadNode.valid())
						{
							if(progress>m_visiableRange[0] && progress<m_visiableRange[1])
							{
								crVector2 barpos = progressWidget->getBarOffsetPosition();
								progressHeadNode->setPosition(crVector3(barpos[0],barpos[1],0.0f));
								progressHeadNode->setVisiable(true);
							}
							else
							{
								progressHeadNode->setVisiable(false);
							}
						}
					}
					//ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
					//if(progressTextWidget.valid())
					//{
					//	std::string str = "正在更新文件...";
					//	progressTextWidget->setString(str);
					//}
				}
			}
		}
		break;
	case 7://版本信息校验
		{
			bool _done = m_fileversioncheckthread->getDone();
			if(_done)
			{
				m_progress = 4;//下载结束，更新文件
				CRCore::crDisplaySettings::instance()->restoreFpsControl();
				crFilterRenderManager::getInstance()->showCanvas(m_canvasName,false);
			}
			else
			{
				CRCore::crDisplaySettings::instance()->setFpsControl(10.0f);
				ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
				if(canvas.valid() && canvas->getVisiable())
				{
					ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
					ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
					if(progressWidget.valid())
					{
						float progress = m_fileversioncheckthread->getProgress();
						//progress += *m_dt * m_speed;
						progressWidget->setProgress(progress);
						if(progressHeadNode.valid())
						{
							if(progress>m_visiableRange[0] && progress<m_visiableRange[1])
							{
								crVector2 barpos = progressWidget->getBarOffsetPosition();
								progressHeadNode->setPosition(crVector3(barpos[0],barpos[1],0.0f));
								progressHeadNode->setVisiable(true);
							}
							else
							{
								progressHeadNode->setVisiable(false);
							}
						}
					}
				}
			}
		}
		break;
	case 8:
		{
			std::string file1;
			//int progress1 = 0;
			ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
			ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
			ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
			float progress = 0.0f;
			if(m_download1.valid())
			{
				file1 = crArgumentParser::getSimpleFileName(m_download1->getFileName());
				progress = m_download1->getProgress();
				if(canvas.valid() && canvas->getVisiable())
				{
					if(progressWidget.valid()) progressWidget->setProgress(progress/*crDownloadManager::getInstance()->getProgress()*/);
					//str += ",正在下载:"+file1+"进度："+crArgumentParser::appItoa(progress1)+"%";
					std::string str = "下载文件："+file1+crArgumentParser::appItoa(progress * 100)+"%";
					if(progressTextWidget.valid()) progressTextWidget->setString(str);
				}
			}
			if(progressHeadNode.valid() && progressWidget.valid())
			{
				if(progress>m_visiableRange[0] && progress<m_visiableRange[1])
				{
					crVector2 barpos = progressWidget->getBarOffsetPosition();
					progressHeadNode->setPosition(crVector3(barpos[0],barpos[1],0.0f));
					progressHeadNode->setVisiable(true);
				}
				else
				{
					progressHeadNode->setVisiable(false);
				}
			}
			switch (m_download1->getDownloadState())
			{
				//case crDownload::Faild:
				//	_case = 1;//下载失败，提示无法连接服务器
				//	m_progress = 2;//启动版本校验结束
				//	crFilterRenderManager::getInstance()->showCanvas(m_canvasName,false);
				//	break;
			case crDownload::Done:
				{
					Producer::Window hwnd = crStartHandler::getInstance()->getWindowHandle();
					SetWindowLong(hwnd,GWL_STYLE,GetWindowLong(hwnd,GWL_STYLE)&~WS_SYSMENU);
					m_gamesetupthread = new crJXJGameSetupThread(m_setupfile);
					m_gamesetupthread->start();
					m_progress = 9;
					crFilterRenderManager::getInstance()->showCanvas(m_canvasName,true);
					ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
					if(canvas.valid() && canvas->getVisiable())
					{
						ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
						ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
						ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
						if(progressWidget.valid())
						{
							progressWidget->setProgress(0.0f);
						}
						if(progressHeadNode.valid())
						{
							progressHeadNode->setVisiable(false);
						}
						if(progressTextWidget.valid())
						{
							std::string str = "感谢您安装游戏，正在为您解压游戏文件，请稍后...";
							progressTextWidget->setString(str);
						}
					}
				}
				break;
			}
		}
		break;
	case 9://JXJ.7z解压 第一次安装微端
		{
			bool _done = m_gamesetupthread->getDone();
			if(_done)
			{
				m_progress = 0;//下载结束，更新文件
				CRCore::crDisplaySettings::instance()->restoreFpsControl();
				Producer::Window hwnd = crStartHandler::getInstance()->getWindowHandle();
				SetWindowLong(hwnd,GWL_STYLE,GetWindowLong(hwnd,GWL_STYLE)|WS_SYSMENU);
			}
			else
			{
				CRCore::crDisplaySettings::instance()->setFpsControl(10.0f);
				ref_ptr<crCanvasNode > canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
				if(canvas.valid() && canvas->getVisiable())
				{
					ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
					ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
					if(progressWidget.valid())
					{
						float progress = progressWidget->getProgress();
						progress += *m_dt * m_speed;
						progressWidget->setProgress(progress);
						if(progressHeadNode.valid())
						{
							if(progress>m_visiableRange[0] && progress<m_visiableRange[1])
							{
								crVector2 barpos = progressWidget->getBarOffsetPosition();
								progressHeadNode->setPosition(crVector3(barpos[0],barpos[1],0.0f));
								progressHeadNode->setVisiable(true);
							}
							else
							{
								progressHeadNode->setVisiable(false);
							}
						}
					}
				}
			}
		}
		break;
	}
	handle.outputParam(0,&_case);
}
bool crJXJStartupDownloadCaseMethod::binExtension(const std::string& extension) const
{
	return CRIOManager::equalCaseInsensitive(extension,"dll") ||
		CRIOManager::equalCaseInsensitive(extension,"exe") ||
		CRIOManager::equalCaseInsensitive(extension,"ocx");
}
int crJXJStartupDownloadCaseMethod::readVersion(const std::string &filename)
{
	int ver = 0;
	if( CRIOManager::fileExists( filename ))
	{
		std::ifstream fin(filename.c_str(), std::ios_base::in|std::ios::binary);
		fin.seekg(0, std::ios::end); 
		int count  =  fin.tellg();
		fin.seekg(0, std::ios::beg);
		char *buf = new char[count+1];
		memset(buf,0,count+1);
		fin.read(buf,count);
		crArgumentParser::readKeyValue(buf,"version",ver);
		fin.close();
		delete [] buf;
	}
	return ver;
}
/////////////////////////////////////////
//
//crJXJShowVersionMethod
//
/////////////////////////////////////////
crJXJShowVersionMethod::crJXJShowVersionMethod(){}
crJXJShowVersionMethod::crJXJShowVersionMethod(const crJXJShowVersionMethod& handle):
	crMethod(handle),
	m_versionCanvas(handle.m_versionCanvas),
	m_newVersion(handle.m_newVersion),
	m_iVersion(handle.m_iVersion)
{
}
void crJXJShowVersionMethod::inputParam(int i, void *param)
{
}

void crJXJShowVersionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_versionCanvas = str;
		break;
	case 1:
		m_newVersion = str;
		break;
	case 2:
		m_iVersion = str;
		break;
	}
}
void crJXJShowVersionMethod::operator()(crHandle &handle)
{
	std::string curver = "当前版本："+crArgumentParser::appItoa(crGlobalHandle::getVersion());
	std::string newver = "最新版本："+crArgumentParser::appItoa(crGlobalHandle::getNewVersion());
	ref_ptr<crCanvasNode >canvas = crFilterRenderManager::getInstance()->findCanvas(m_versionCanvas);
	if(canvas.valid())
	{
		ref_ptr<crStaticTextWidgetNode> curVerText = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_iVersion));
		ref_ptr<crStaticTextWidgetNode> newVerText = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_newVersion));
		if(curVerText.valid())
			curVerText->setString(curver);
		if(newVerText.valid())
			newVerText->setString(newver);
		crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
	}
}
/////////////////////////////////////////
//
//crJXJCheckAndDownloadFileMethod
//
/////////////////////////////////////////
crJXJCheckAndDownloadFileMethod::crJXJCheckAndDownloadFileMethod():
	m_downloadFlg(HttpD_None),
	m_downloadPri(true){}
crJXJCheckAndDownloadFileMethod::crJXJCheckAndDownloadFileMethod(const crJXJCheckAndDownloadFileMethod& handle):
	crMethod(handle),
	m_fileName(handle.m_fileName),
	m_downloadFlg(handle.m_downloadFlg),
	m_downloadPri(handle.m_downloadPri)
{
}
void crJXJCheckAndDownloadFileMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		if(param)
		{
			m_fileName = *(std::string *)param;
		}
		else
		{
			m_fileName.clear();
		}
		break;
	case 2:
		m_downloadFlg = param==NULL?HttpD_None:*(int*)param;
		break;
	}
}

void crJXJCheckAndDownloadFileMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_downloadPri = (bool)atoi(str.c_str());
		break;
	}
}

void crJXJCheckAndDownloadFileMethod::operator()(crHandle &handle)
{
	bool needDownload = false;
	if(!m_fileName.empty())
	{
		std::string cookfilename = m_fileName;
		CRIOManager::GetCookedFileName(cookfilename);
		cookfilename = CRIOManager::convertFileNameToUnixStyle(cookfilename);
		ref_ptr<CREncapsulation::crTableIO> curDynamictab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_DynamicDownloadTab);
		ref_ptr<crTableIO> newDynamictab = crGlobalHandle::gData()->gNewDynamicDownloadTable();
		std::string newver;
		std::string curver;
		CREncapsulation::crTableIO::StrVec qrecord;
		if(newDynamictab.valid() && newDynamictab->queryOneRecord(0,cookfilename,qrecord)>=0)
		{
			cookfilename = qrecord[0];
			newver = qrecord[1];
		}
		if(curDynamictab.valid() && curDynamictab->queryOneRecord(0,cookfilename,qrecord)>=0)
		{
			curver = qrecord[1];
		}
		if(!CRIOManager::fileExists(cookfilename))
		{
			needDownload = true;
		}
		else if(!newver.empty() && newver != curver)
		{
			needDownload = true;
			if(curver.empty())
			{//校验已经存在文件的MD5码
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->loadFromFile2(cookfilename);
				curver = stream->getMD5();
				if(newver==curver)
				{
					needDownload = false;
					crTableIO::StrVec record;
					record.resize(2);
					record[0] = cookfilename;
					record[1] = newver;
					curDynamictab->addData(record);
					curDynamictab->saveToFileStreamNoCook(crGlobalHandle::gData()->gDynamicDownloadTabName(),SM_Copy);
				}
			}
		}
		if(needDownload)
		{
			crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
			data->insertHttpDownloadFile(m_downloadFlg,cookfilename/*m_fileName*/);
			if(m_downloadPri)
				crDownloadManager::getInstance()->addImmediatelyDownloadRequest(new crDownload(cookfilename));
			else
				crDownloadManager::getInstance()->addDownloadRequest(new crDownload(cookfilename));
		}
	}
	handle.outputParam(0,&needDownload);
}
/////////////////////////////////////////
//
//crJXJUIDownloadUpdateMethod
//
/////////////////////////////////////////
crJXJUIDownloadUpdateMethod::crJXJUIDownloadUpdateMethod(){}
crJXJUIDownloadUpdateMethod::crJXJUIDownloadUpdateMethod(const crJXJUIDownloadUpdateMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_progressTextWidget(handle.m_progressTextWidget),
	m_progressWidget(handle.m_progressWidget),
	m_progressHead(handle.m_progressHead),
	m_visiableRange(handle.m_visiableRange)
{
}
void crJXJUIDownloadUpdateMethod::inputParam(int i, void *param)
{
}

void crJXJUIDownloadUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_progressTextWidget = str;
		break;
	case 2:
		m_progressWidget = str;
		break;
	case 3:
		m_progressHead = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_visiableRange);
		break;
	}
}
void crJXJUIDownloadUpdateMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode >canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvas.valid() && canvas->getVisiable())
	{
		m_download1 = crDownloadManager::getInstance()->getCurrentDownload();
		ref_ptr<crStaticTextWidgetNode> progressTextWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_progressTextWidget));
		ref_ptr<crProgressWidgetNode> progressWidget = dynamic_cast<crProgressWidgetNode *>(canvas->getWidget(m_progressWidget));
		ref_ptr<crMatrixTransform>  progressHeadNode = dynamic_cast<crMatrixTransform *>(canvas->getChildNode(m_progressHead));
		float progress = 0.0f;
		if(m_download1.valid())
		{
			std::string file1;
			//int progress1 = 0;
			file1 = crArgumentParser::getSimpleFileName(m_download1->getFileName());
			progress = crDownloadManager::getInstance()->getProgress();
			//progress1 = m_download1->getProgress() * 100;
			if(progressWidget.valid()) progressWidget->setProgress(/*m_download1->getProgress()*/progress);
			std::string str = "正在下载:"+file1;//+" 进度："+crArgumentParser::appItoa(progress1)+"%";
			//std::string str = "正在下载文件,请稍等!";
			if(progressTextWidget.valid()) progressTextWidget->setString(str);
			/*CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
			if(noticeText)
			{
			std::string str = "下载:"+file1+" 进度："+crArgumentParser::appItoa(progress1)+"%";
			noticeText->setText(CRIOManager::convertUTF8toUTF16(str).c_str());
			noticeText->setVisiable(true);
			}*/
		}
		if(progressHeadNode.valid() && progressWidget.valid())
		{
			if(progress>m_visiableRange[0] && progress<m_visiableRange[1])
			{
				crVector2 barpos = progressWidget->getBarOffsetPosition();
				progressHeadNode->setPosition(crVector3(barpos[0],barpos[1],0.0f));
				progressHeadNode->setVisiable(true);
			}
			else
			{
				progressHeadNode->setVisiable(false);
			}
		}
	}
	else
	{
		m_download1 = NULL;
	}
}
/////////////////////////////////////////
//
//crJXJAddDownloadTaskMethod
//
/////////////////////////////////////////
crJXJAddDownloadTaskMethod::crJXJAddDownloadTaskMethod():
	m_count(10){}
crJXJAddDownloadTaskMethod::crJXJAddDownloadTaskMethod(const crJXJAddDownloadTaskMethod& handle):
	crMethod(handle),
	m_count(handle.m_count)
{
}
void crJXJAddDownloadTaskMethod::inputParam(int i, void *param)
{
}
void crJXJAddDownloadTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_count = atoi(str.c_str());
		break;
	}
}
void crJXJAddDownloadTaskMethod::operator()(crHandle &handle)
{//空闲下载
	//return;//带宽不足，暂时关闭
	ref_ptr<crTableIO> newDynamictab = crGlobalHandle::gData()->gNewDynamicDownloadTable();
	if(newDynamictab.valid() && newDynamictab->getRowCount() > 0)
	{
		if(crDownloadManager::getInstance()->isIdle())
		{
			crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
			std::string file;
			std::string newver,curver;
			ref_ptr<crTableIO> curDynamictab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_DynamicDownloadTab);
			CREncapsulation::crTableIO::StrVec qrecord;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			bool needsave = false;
			crTableIO::StrVec record;
			record.resize(2);
			for (int i = 0; i<m_count && i<newDynamictab->getRowCount(); )
			{
				file = (*newDynamictab)(i,0);
				newver = (*newDynamictab)(i,1);
				if(curDynamictab.valid() && curDynamictab->queryOneRecord(0,file,qrecord)>=0)
				{
					if(CRIOManager::fileExists(file))
					{
						curver = qrecord[1];
						if(newver == curver)
						{
							newDynamictab->removeRow(i);
							continue;
						}
					}
					else
					{//文件丢失,重新下载
						(*curDynamictab)(i,1).clear();
					}
				}
				else if(CRIOManager::fileExists(file))
				{//curDynamictab文件有可能丢失，避免重新下载 校验已经存在文件的MD5码
					stream->loadFromFile2(file);
					curver = stream->getMD5();
					if(newver==curver)
					{
						needsave = true;
						record[0] = file;
						record[1] = newver;
						curDynamictab->addData(record);
						newDynamictab->removeRow(i);
						continue;
					}
				}
				//需要下载
				if(crDownloadManager::getInstance()->addDownloadRequest(new crDownload(file)))
				{
					data->insertHttpDownloadFile(HttpD_None,file);
					data->startHttpDownloadTask(HttpD_None);
				}
				i++;
			}
			if(needsave)
				curDynamictab->saveToFileStreamNoCook(crGlobalHandle::gData()->gDynamicDownloadTabName(),SM_Copy);
		}
	}
}
////////////////////////////////
//
//crJXJInitSceneMapMethod
//
///////////////////////////////////
crJXJInitSceneMapMethod::crJXJInitSceneMapMethod():
	m_scale(0.5f),
	m_imageSize(256),
	m_staticmap(false)
{
	m_scaleRange.set(0.1,1.0);
}
crJXJInitSceneMapMethod::crJXJInitSceneMapMethod(const crJXJInitSceneMapMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_mapWidgetName(handle.m_mapWidgetName),
	m_imageFile(handle.m_imageFile),
	m_scale(handle.m_scale),
	m_scaleRange(handle.m_scaleRange),
	//m_myIconWidget(handle.m_myIconWidget),
	m_imageSize(handle.m_imageSize),
	m_staticmap(handle.m_staticmap),
	m_rotmapWidget(handle.m_rotmapWidget)
{
}

void crJXJInitSceneMapMethod::inputParam(int i, void *param)
{
}

void crJXJInitSceneMapMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_mapWidgetName = str;
		break;
	case 2:
		m_imageFile = str;
		break;
	case 3:
		m_scale = atof(str.c_str());
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_scaleRange);
		break;
		//case 5:
		//	m_myIconWidget = str;
		//	break;
	case 5:
		m_imageSize = atof(str.c_str());
		break;
	case 6:
		m_staticmap = (bool)(atoi(str.c_str()));
		break;
	case 7:
		m_rotmapWidget = str;
		break;
	}
}

void crJXJInitSceneMapMethod::operator()(crHandle &handle)
{
	do 
	{
		if(m_imageFile.empty())
			break;
		ref_ptr<crCanvasNode >canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
		if(!canvas)
			break;
		ref_ptr<crImageBoxWidgetNode>widget = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_mapWidgetName));
		if(!widget)
			break;
		widget->setImageName(m_imageFile);
		crStateSet *stateset = widget->getImageStateSet();
		if(!m_staticmap)
		{
			crTexMat *tm = new crTexMat;
			tm->setMatrix(crMatrix::scale(m_scale,m_scale,1.0f));
			stateset->setTextureAttribute(0, tm);
		}
		//float pxpm;
		if(m_imageFile.compare("RTT") == 0)
		{
			crTexture *rtt = crShaderManager::getInstance()->getGiTexture();
			if(rtt)
			{
				stateset->setTextureAttributeAndModes(0,rtt,crStateAttribute::ON);
			}
			else
			{//MAPFILE
				CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
				ref_ptr<crTableIO> table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
				if(scene && table.valid())
				{
					int sceneid = scene->getSceneID();
					crTableIO::StrVec record;
					if(table->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
					{
						int mapindex = table->getTitleIndex("小地图");
						if(mapindex>0)
						{
							widget->setImageName(record[mapindex]);
						}
					}
				}
			}
		}
		else if(m_imageFile.compare("MAPFILE")==0)
		{
			CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
			ref_ptr<crTableIO> table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SceneTab);
			if(scene && table.valid())
			{
				int sceneid = scene->getSceneID();
				crTableIO::StrVec record;
				if(table->queryOneRecord(0,crArgumentParser::appItoa(sceneid),record)>=0)
				{
					int mapindex = table->getTitleIndex("小地图");
					if(mapindex>0)
					{
						widget->setImageName(record[mapindex]);
					}
				}
			}
		}
		crMyPlayerData::getInstance()->setMapScaleRange(m_scaleRange);
		crMyPlayerData::getInstance()->setMapScale(m_scale);
		const crVector3i &worldSize = crBrain::getInstance()->getWorldSize();
		const crBoundingBox &bbox = widget->getBoundBox();
		const crMatrix &scaleMat = crDisplaySettings::instance()->getUIScaleMatrix();
		const crMatrix &invScaleMat = crDisplaySettings::instance()->getInvUIScaleMatrix();
		crVector3 scale(1.0f,1.0f,1.0f);
		bool needScale = false;
		if(worldSize[0] > worldSize[1])
		{
			scale[1] = float(worldSize[1])/float(worldSize[0]);
			needScale = true;
		}
		else if(worldSize[0] < worldSize[1])
		{
			scale[0] = float(worldSize[0])/float(worldSize[1]);
			needScale = true;
		}
		crVector3 trans = widget->getBound().center();
		crMatrix put_mat = crMatrix::translate(trans);
		crMatrix inv_put = crMatrix::inverse(put_mat);
		crMatrix rotmat;
		if(needScale)
		{
			rotmat.postMult(inv_put);
			rotmat.postMult(crMatrix::scale(scale));
			rotmat.postMult(put_mat);
			widget->setMatrix(rotmat);
			widget->setEnableMatrix(true);
		}
		ref_ptr<crWidgetNode>rotMapWidget = canvas->getWidget(m_rotmapWidget);
		if(rotMapWidget.valid())
		{
			ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
			if(camera.valid())
			{
				//crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(camera->getAttachedNode());
				//crVector3 campos = cameraNode->getTrans();
				//crMatrixf rotation = cameraNode->getMatrix();
				//CRProducer::crViewer *viewer = crKeyboardMouseHandle::getInstance()->getBindViewer();
				crMatrix viewerMat = camera->getCameraMatrix();//viewer->getViewCameraNode();
				viewerMat.setTrans(0.0f,0.0f,0.0f);
				crVector3 camDir = (-Y_AXIS * viewerMat).normalize();
				camDir[2] = 0.0f;
				camDir.normalize();
				CRCore::crMatrix newMat;
				if(camDir == crVector3(0.0f,0.0f,0.0f))
				{
					camDir[1] = -1.0f;
				}
				if(camDir[1] > 0.999)
				{
					newMat.makeRotate(-CRCore::Y_AXIS,camDir);
					CRCore::crVector3d ep,center,up;
					newMat.getLookAt(ep,center,up);
					if(center[2]>0.0f)
					{
						center = -center;
					}
					newMat.makeLookAt(ep,center,up);
				}
				else
					newMat.makeRotate(-CRCore::Y_AXIS,camDir);
				//crQuat quat = rotation.getRotate();
				//float x,y,z;
				//quat.getRadians(x,y,z);
				//if(angle<PI_4)
				//	angle = 0;
				//else if(angle<PI_4*3.0f)
				//	angle = -PI_2;
				//else if(angle<PI_4*5.0f)
				//	angle = -PI;
				//else if(angle<PI_4*7.0f)
				//	angle = -PI_2*3.0f;
				//CRCore::crMatrix newMat;
				//newMat.makeRotate(y,crVector3(0,0,1));

				rotmat.makeIdentity();
				rotmat.postMult(inv_put);
				rotmat.postMult(invScaleMat * newMat * scaleMat);
				rotmat.postMult(put_mat);
				rotMapWidget->setMatrix(rotmat);
				rotMapWidget->setEnableMatrix(true);
				rotMapWidget->setCanFocus(false);
				//if(angle<PI_4)
				//	angle = 0;
				//else if(angle<PI_4*3.0f)
				//	angle = PI_2;
				//else if(angle<PI*5.0f)
				//	angle = PI;
				//else if(angle<PI*7.0f)
				//	angle = PI_2*3.0f;
				//newMat.makeRotate(angle,crVector3(0,0,1));
				//rotmat.makeIdentity();
				//rotmat.postMult(inv_put);
				//rotmat.postMult(invScaleMat * newMat * scaleMat);
				//rotmat.postMult(put_mat);
				//rotMap2Widget->setMatrix(rotmat);
				//rotMap2Widget->setEnableMatrix(true);
			}
		}
	} while (0);
}
/////////////////////////////////////////
//
//crJXJDamenCollideMethod
//
/////////////////////////////////////////
crJXJDamenCollideMethod::crJXJDamenCollideMethod():
	m_this(NULL),
	m_item(NULL){}
crJXJDamenCollideMethod::crJXJDamenCollideMethod(const crJXJDamenCollideMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_item(NULL)
{
}
void crJXJDamenCollideMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = (crInstanceItem *)(LOINT64(param64));
		}
		break;
	}
}
void crJXJDamenCollideMethod::addParam(int i, const std::string& str)
{
}
void crJXJDamenCollideMethod::operator()(crHandle &handle)
{
	bool isEnemy = 0;
	m_item->doEvent(WCH_EnemyCheck,MAKEINT64(m_this,&isEnemy));
	if(isEnemy == 1)
	{
		crData *data = m_this->getDataClass();
		unsigned int guisestate = GS_StaticNoneBlock;
		data->inputParam(WCHDATA_GuiseState,&guisestate);

		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeUInt(guisestate);//
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crPlayerServerEventPacket packet;
			crPlayerServerEventPacket::buildRequestPacket(packet,WCH_JXJRecvCollideState,m_this,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCollideStateMethod
//
/////////////////////////////////////////
crJXJRecvCollideStateMethod::crJXJRecvCollideStateMethod():
	m_this(NULL),
	m_netType(GameClient_Game){}
crJXJRecvCollideStateMethod::crJXJRecvCollideStateMethod(const crJXJRecvCollideStateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_netType(GameClient_Game)
{
}
void crJXJRecvCollideStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvCollideStateMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvCollideStateMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		unsigned int guiseState = m_stream->_readUInt();
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_GuiseState,param);
		unsigned int lastGuiseState = *(unsigned int *)param;
		if(guiseState != lastGuiseState)
		{
			data->inputParam(WCHDATA_GuiseState,&guiseState);
			if(m_netType == SceneServer)
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
				if(scene)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeUInt(guiseState);//
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_JXJRecvCollideState,stream.get());
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJDamenServerUpdateMethod
//
/////////////////////////////////////////
crJXJDamenServerUpdateMethod::crJXJDamenServerUpdateMethod():
	m_dt(NULL),
	m_laststate(GS_Normal),
	m_nonblockTimer(0.0f),
	m_nonblockInterval(5.0f){}
crJXJDamenServerUpdateMethod::crJXJDamenServerUpdateMethod(const crJXJDamenServerUpdateMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_laststate(GS_Normal),
	m_nonblockTimer(0.0f),
	m_nonblockInterval(handle.m_nonblockInterval)
{
}
void crJXJDamenServerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJDamenServerUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nonblockInterval = atof(str.c_str());
		break;
	}
}

void crJXJDamenServerUpdateMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_GuiseState,param);
	unsigned int gs = *(unsigned int *)param;
	if(m_laststate != gs)
	{
		m_laststate = gs;
		if(gs == GS_StaticNoneBlock)
		{
			m_nonblockTimer = m_nonblockInterval;
		}
	}
	else if(m_laststate == GS_StaticNoneBlock)
	{
		m_nonblockTimer -= *m_dt;
		if(m_nonblockTimer<0.0f)
		{
			m_nonblockTimer = 0.0f;
			m_laststate = GS_Static;
			data->inputParam(WCHDATA_GuiseState, &m_laststate);
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
			if(scene)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeUInt(m_laststate);//
				crItemEventPacket packet;
				crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_JXJRecvCollideState,stream.get());
				scene->sendPacketToItemNeighbor(m_this,packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJDamenClientUpdateMethod
//
/////////////////////////////////////////
crJXJDamenClientUpdateMethod::crJXJDamenClientUpdateMethod(){}
crJXJDamenClientUpdateMethod::crJXJDamenClientUpdateMethod(const crJXJDamenClientUpdateMethod& handle):
	crMethod(handle)
{
}
void crJXJDamenClientUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJDamenClientUpdateMethod::addParam(int i, const std::string& str)
{
}

void crJXJDamenClientUpdateMethod::operator()(crHandle &handle)
{//获取目标位置，移动到目标位子自动停下
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_GuiseState,param);
	unsigned int gs = *(unsigned int *)param;
	if(gs & GS_StaticNoneBlock)
	{
		crGroup *bot = dynamic_cast<crGroup *>(m_this->getRelNode());
		ref_ptr<crMultiSwitch> damen = dynamic_cast<crMultiSwitch *>(bot->getChild(0));
		if(damen.valid()) damen->setActiveSwitchSet(1);
	}
	else if(gs & GS_Static)
	{
		crGroup *bot = dynamic_cast<crGroup *>(m_this->getRelNode());
		ref_ptr<crMultiSwitch> damen = dynamic_cast<crMultiSwitch *>(bot->getChild(0));
		if(damen.valid()) damen->setActiveSwitchSet(0);
	}
}
/////////////////////////////////////////
//
//crJXJCloseTargetItemMethod
//
/////////////////////////////////////////
crJXJCloseTargetItemMethod::crJXJCloseTargetItemMethod():
	m_recloseDist(5.0f),
	m_lastTargetItem(NULL){}
crJXJCloseTargetItemMethod::crJXJCloseTargetItemMethod(const crJXJCloseTargetItemMethod& handle):
	crMethod(handle),
	m_recloseDist(handle.m_recloseDist),
	m_lastTargetItem(NULL)
{
}
void crJXJCloseTargetItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJCloseTargetItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_recloseDist = atof(str.c_str());
		break;
	}
}
void crJXJCloseTargetItemMethod::operator()(crHandle &handle)
{
	crData *thisData = m_this->getDataClass();
	do 
	{
		void *param;
		thisData->getParam(WCHDATA_ItemState,param);
		unsigned char itemstate = *(unsigned char *)param;
		if(itemstate < IS_CloseTarget || itemstate > IS_CloseTargetTouch)
		{
			m_lastTargetItem = NULL;
			return;
		}
		thisData->getParam(WCHDATA_TargetType,param);
		unsigned char targetType = *(unsigned char *)param;
		if(!(targetType & Target_Instance) && !(targetType & Target_StaticNpc)/* && !(targetType & Target_StaticItem)*/)
		{
			m_lastTargetItem = NULL;
			break;
		}
		ref_ptr<crInstanceItem> targetItem;
		if(crGlobalHandle::isClient()) 
		{
			ref_ptr<crMatrixTransform> targetNode;
			m_this->clientGetTarget(targetItem,targetNode);
		}
		else
		{
			targetItem = m_this->serverGetTarget();
		}
		if(!targetItem.valid())
		{
			//if(crGlobalHandle::isClient())
			//{//是否需要向服务器查询目标坐标
			//	itemstate = IS_Stop;
			//	thisData->inputParam(WCHDATA_ItemState,&itemstate);
			//	break;
			//}
			//else
			//{
			//	itemstate = IS_Stop;
			//	thisData->inputParam(WCHDATA_ItemState,&itemstate);
			//	break;
			//}
			itemstate = IS_Stop;
			thisData->inputParam(WCHDATA_ItemState,&itemstate);
			m_lastTargetItem = NULL;
			break;
		}
		//CRCore::crVector3 lastTargetPos;
		//thisData->getParam(WCHDATA_TargetPos,param);
		//lastTargetPos = *(crVector3 *)param;

		crVector3 myPos = m_this->getPosition();
		crVector3 targetPos = targetItem->getPosition();
		crVector3 targetDir = targetPos - myPos;
		//targetDir[2] = 0.0f;
		float mindist = m_this->getMinDistance(/*NULL*/targetItem.get());
		float dist = targetDir.length() - mindist;
		thisData->getParam(WCHDATA_FollowDistance,param);
		float followDistance = *(float *)param;
		crInstanceItem::crPathFinder *pathFinder = m_this->getOrCreatePathFinder();
		if (dist>followDistance && (pathFinder->isBestPathEmpty() || targetItem != m_lastTargetItem || (crVector2(targetPos[0], targetPos[1]) - crVector2(m_lastTargetPos[0],m_lastTargetPos[1])).length()>m_recloseDist/* || (pathFinder->isPortPathEmpty() && pathFinder->isWaypointEmpty())*/))
		{
			crVector3 newPos;
			CRNetApp::crScene *scene = NULL;
			if(crGlobalHandle::isClient()) 
			{
				scene = crMyPlayerData::getInstance()->getScene();
			}
			else
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				scene = netCallback->findScene(m_this->getSceneID());
			}
			if(scene && scene->findNonblockPos(m_this,crVector2(targetPos[0],targetPos[1]),mindist+5.0f,newPos))
			{
				//newPos = targetPos;
				//if(newPos == myPos)
				//{//会影响到效率
				//	newPos = myPos + targetDir.normalize() * 1.0f;
				//}
				if((crVector2(newPos[0],newPos[1])-crVector2(myPos[0],myPos[1])).length()>0.1f)
				{
					thisData->inputParam(WCHDATA_TargetPos,&newPos);
					m_lastTargetPos = targetPos;
					m_lastTargetItem = targetItem.get();
					if(crGlobalHandle::isClient()) 
					{
						crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(m_this);
					}
					else
					{
						scene->getPathFindingManager()->addPathFindRequest(m_this);
					}
				}
			}
		}
	} while (0);
}
/////////////////////////////////////////
//
//crJXJSaveFubenProgressMethod
//
/////////////////////////////////////////
crJXJSaveFubenProgressMethod::crJXJSaveFubenProgressMethod():
	m_lastprogress(0){}
crJXJSaveFubenProgressMethod::crJXJSaveFubenProgressMethod(const crJXJSaveFubenProgressMethod& handle):
	crMethod(handle),
	m_lastprogress(0)
{
}
void crJXJSaveFubenProgressMethod::addParam(int i, const std::string& str)
{
}
void crJXJSaveFubenProgressMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJSaveFubenProgressMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_RoomProgress,param);
	short progress = *(short *)param;
	if(m_lastprogress != progress)
	{
		m_lastprogress = progress;
		data->getParam(WCHDATA_JXJSaveProgressSet,param);
		SaveProgressSet saveProgressSet = *(SaveProgressSet *)param;
		if(saveProgressSet.find(progress) != saveProgressSet.end())
		{
			data->getParam(WCHDATA_JXJBattleID,param);
			int battleid = *(int *)param;
			unsigned short fubenid = HIINT32(battleid);
			ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
			streamBuf->createBuf(4);
			streamBuf->_writeUShort(fubenid);
			streamBuf->_writeShort(progress);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,0,WCH_JXJRecvSaveFubenProgress,streamBuf.get());
			ref_ptr<crStreamBuf> packetStream = packet.getStreamBuf();
			int bufsize = packetStream->getBufSize();
			//int playerid;
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
			//crPlayerGameData *playerGameData;
			//crData *playerData;
			////short* curFubenProgress;
			m_this->lockPlayerList();
			CRNetApp::crRoom::PlayerList playerList = m_this->getPlayerList();
			m_this->unlockPlayerList();
			//crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer);
			//crNetDataManager *netDataManager = sceneServer->getNetDataManager();
			//crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			//ref_ptr<crSceneServerPlayerData> player;
			for( CRNetApp::crRoom::PlayerList::iterator itr = playerList.begin();
				itr != playerList.end();
				++itr )
			{
				//playerGameData = (*itr)->getPlayerGameData();
				//if(playerGameData && playerGameData->getDataClass())
				//{
				//	player = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerGameData->getPlayerID()));
				//	if(player.valid())
				//	{
				//		playerData = playerGameData->getDataClass();
				//		//playerData->getParam(WCHDATA_JXJCurFubenProgress,param);
				//		//curFubenProgress = (short *)param;
				//		//*curFubenProgress = progress;
				//		playerData->inputParam(WCHDATA_JXJCurFubenProgress,&progress);
				//		callback->savePlayerData(player.get());
				//	}
				//}
				packetStream->seekBegin();
				packetStream->_writeInt((*itr)->getPlayerID());
				packetStream->setBufSize(bufsize);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			m_this->sendPacketToAll(packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSaveFubenProgressMethod
//
/////////////////////////////////////////
crJXJRecvSaveFubenProgressMethod::crJXJRecvSaveFubenProgressMethod():
	m_netType(GameClient_Game){}
crJXJRecvSaveFubenProgressMethod::crJXJRecvSaveFubenProgressMethod(const crJXJRecvSaveFubenProgressMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSaveFubenProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSaveFubenProgressMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSaveFubenProgressMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer || m_netType == GameClient_Game)
		{
			unsigned short fubenid = m_stream->_readUShort();
			short progress = m_stream->_readShort();
			void *param;
			crData *data = m_this->getDataClass();
			//data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			//unsigned char type = *(unsigned char *)param;
			//data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			//unsigned short fubenid = *(unsigned short *)param;
			if(/*type == FT_Fuben && */fubenid>0)
			{
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJFubenProgressMap,param);
				FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
				if(fubenProgress)
				{
					ref_ptr<crTableIO> tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
					ref_ptr<crTableIO> chaptertab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChapterTab);
					ref_ptr<crTableIO> techtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
					crTableIO::StrVec record;
					crTableIO::StrVec techrecord;
					crTableIO::StrVec chapterrecord;
					if(tab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
					{
						ref_ptr<crFubenInfo> fubeninfo;
						FubenProgressMap::iterator itr = fubenProgress->find(fubenid);
						if(itr != fubenProgress->end())
						{
							fubeninfo = itr->second.get();
							fubeninfo->setFubenProgress(progress);
						}
						else
						{
							fubeninfo = new crFubenInfo;
							fubeninfo->setFubenProgress(progress);
							fubeninfo->setComplete(0);
							(*fubenProgress)[fubenid] = fubeninfo;//std::make_pair(progress,0);
						}
						if(progress>0)
						{
							bool ifnewpass = false;
							unsigned char btnnew = 1;
							int progressid = tab->getTitleIndex("结束进度");
							int qianzhifubenindex = techtab->getTitleIndex("前置副本");
							int chapteridindex = tab->getTitleIndex("chapterid");
							int modeindex = chaptertab->getTitleIndex("mode");
							unsigned char curcompletecount = 0;
							crVector4s closevec;
							crArgumentParser::appAtoVec(record[progressid],closevec);
							for(int i = 0; i<4; i++)
							{
								if(progress==closevec[i])
								{//副本结束，进度重置，并设置完成标识符
									curcompletecount = fubeninfo->getComplete();
									if (curcompletecount == 0)
									{
										ifnewpass = true;
										curcompletecount += 2;
									}
									else
									{
										curcompletecount += 1;
									}
									if (curcompletecount > c_MaxFubenCompleteCount)
									{
										curcompletecount = c_MaxFubenCompleteCount;
									}
									fubeninfo->setFubenProgress(0);
									fubeninfo->setComplete(curcompletecount);
									//是否开启新科技
									if(ifnewpass && techtab->queryOneRecord(qianzhifubenindex,crArgumentParser::appItoa(fubenid),techrecord) >= 0)
									{
										data->inputParam(WCHDATA_JXJIfTechBtnNew,&btnnew);
									}
									//增加活跃度
									if (m_netType == GameServer)
									{
										if (chaptertab->queryOneRecord(0, record[chapteridindex], chapterrecord) >= 0)
										{
											if (atoi(chapterrecord[modeindex].c_str()) > 0)
											{
												m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKEINT64(HYD_Mingjiangzhilu, 1));
											}
										}
									}
									break;
								}
							}
						}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetFubenIDMethod
//
/////////////////////////////////////////
crJXJSetFubenIDMethod::crJXJSetFubenIDMethod()
{
}
crJXJSetFubenIDMethod::crJXJSetFubenIDMethod(const crJXJSetFubenIDMethod& handle):
	crMethod(handle)
{
}
void crJXJSetFubenIDMethod::inputParam(int i, void *param)
{
}
void crJXJSetFubenIDMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetFubenIDMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short fubenid = *(unsigned short *)param;
		do 
		{
			if(fubenid==0)
				break;
			crTableIO::StrVec record;
			if(type == FT_Fuben)
			{
				ref_ptr<crTableIO> fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
				if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)<0)
				{
					break;
				}
			}
			if(type == FT_WorldFuben)
			{
				ref_ptr<crTableIO> fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJWorldFubenab);
				if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)<0)
				{
					break;
				}
			}

			ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
			streamBuf->createBuf(3);
			streamBuf->_writeUShort(fubenid);
			streamBuf->_writeUChar(type);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvFubenID,streamBuf.get());
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			netConductor->getNetManager()->sendPacket("all",packet);
		} while (0);
	}
}
/////////////////////////////////////////
//
//crJXJRecvFubenIDMethod
//
/////////////////////////////////////////
crJXJRecvFubenIDMethod::crJXJRecvFubenIDMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenIDMethod::crJXJRecvFubenIDMethod(const crJXJRecvFubenIDMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvFubenIDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenIDMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvFubenIDMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned short fubenid = m_stream->_readUShort();
			unsigned char type = m_stream->_readUChar();
			do 
			{
				if(fubenid==0)
					break;
				crTableIO::StrVec record;
				if(type == FT_Fuben)
				{
					ref_ptr<crTableIO> fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
					if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)<0)
					{
						break;
					}
				}
				if(type == FT_WorldFuben)
				{
					ref_ptr<crTableIO> fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJWorldFubenab);
					if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)<0)
					{
						break;
					}
				}

				crData *data = m_this->getDataClass();
				data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
				data->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);
			} while (0);
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvPlayerLeaveSceneMethod
////
///////////////////////////////////////////
//crJXJRecvPlayerLeaveSceneMethod::crJXJRecvPlayerLeaveSceneMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvPlayerLeaveSceneMethod::crJXJRecvPlayerLeaveSceneMethod(const crJXJRecvPlayerLeaveSceneMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvPlayerLeaveSceneMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvPlayerLeaveSceneMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvPlayerLeaveSceneMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			crData *data = m_this->getDataClass();
//			data->inputParam(WCHDATA_JXJFubenID,NULL);
//			data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
//			data->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
//			data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
//		}
//		if(m_netType == GameClient_Game)
//		{
//			crData *data = m_this->getDataClass();
//			data->inputParam(WCHDATA_JXJFubenID,NULL);
//			data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
//			data->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
//			data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJCheckFubenProgressMethod
////
///////////////////////////////////////////
//crJXJCheckFubenProgressMethod::crJXJCheckFubenProgressMethod(){}
//crJXJCheckFubenProgressMethod::crJXJCheckFubenProgressMethod(const crJXJCheckFubenProgressMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJCheckFubenProgressMethod::inputParam(int i, void *param)
//{
//}
//
//void crJXJCheckFubenProgressMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJCheckFubenProgressMethod::operator()(crHandle &handle)
//{
//	bool taskCanceled = false;
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	void *param;
//	crData *data = myPlayer->getDataClass();
//	data->excHandle(MAKEINT64(WCH_LockData,1));
//	data->getParam(WCHDATA_JXJFubenID,param);
//	unsigned short fubenid = *(unsigned short *)param;
//	data->getParam(WCHDATA_JXJFubenProgressMap,param);
//	FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
//	if(fubenProgress)
//	{
//		FubenProgressMap::iterator itr = fubenProgress->find(fubenid);
//		if(itr != fubenProgress->end())
//		{
//			ref_ptr<crTableIO> tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
//			int progressid = tab->getTitleIndex("结束进度");
//			crTableIO::StrVec record;
//			if(tab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record))
//			{
//				if(itr->second >= atoi(record[progressid].c_str()))
//				{
//					taskCanceled = true;
//				}
//			}
//		}
//	}
//	data->excHandle(MAKEINT64(WCH_LockData,0));
//	if(taskCanceled)
//	{
//		std::string str = "该副本任务已经完成！";
//		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(&str,NULL));
//	}
//	handle.outputParam(0,&taskCanceled);
//}
/////////////////////////////////////////
//
//crJXJSetFubenProgressMethod
//
/////////////////////////////////////////
crJXJSetFubenProgressMethod::crJXJSetFubenProgressMethod():
	m_this(NULL),
	m_creator(NULL){}
crJXJSetFubenProgressMethod::crJXJSetFubenProgressMethod(const crJXJSetFubenProgressMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_creator(NULL)
{
}
void crJXJSetFubenProgressMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetFubenProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_creator = (crSceneServerPlayerData *)(LOINT64(param64));
		}
		else
		{
			m_creator = NULL;
		}
		break;
	}
}
void crJXJSetFubenProgressMethod::operator()(crHandle &handle)
{
	if(m_creator)
	{
		crPlayerGameData *myPlayer = m_creator->getPlayerGameData();
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short fubenid = *(unsigned short *)param;
		ref_ptr<crTableIO> tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		crTableIO::StrVec record;
		if(type == FT_Fuben && fubenid>0 && tab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
		{
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *(unsigned char*)param;
			int battleid = MAKEINT32(MAKEINT16(shiliid,2),fubenid);//NPC势力ID=2
			crData *roomdata = m_this->getDataClass();
			roomdata->inputParam(WCHDATA_JXJBattleID,&battleid);

			short progress = 0;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJFubenProgressMap,param);
			FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
			if(fubenProgress)
			{
				FubenProgressMap::iterator itr = fubenProgress->find(fubenid);
				if(itr != fubenProgress->end())
				{////////副本完成标志被错误设置
					//ref_ptr<crFubenInfo> fubeninfo = itr->second.get();
					//if(fubeninfo->getFubenProgress()>0)
					//{
					//	int progressid = tab->getTitleIndex("结束进度");
					//	unsigned char curcompletecount = 0;
					//	crVector4s closevec;
					//	crArgumentParser::appAtoVec(record[progressid],closevec);
					//	//int maxprogress = atoi(record[progressid].c_str());
					//	for(int i = 0; i<4; i++)
					//	{
					//		if (curcompletecount == 0)
					//		{
					//			curcompletecount += 2;
					//		}
					//		else
					//		{
					//			curcompletecount += 1;
					//		}
					//		if (curcompletecount > c_MaxFubenCompleteCount)
					//		{
					//			curcompletecount = c_MaxFubenCompleteCount;
					//		}
					//		if(fubeninfo->getFubenProgress()==closevec[i])
					//		{//副本结束，进度重置，并设置完成标识符
					//			fubeninfo->setFubenProgress(0);
					//			fubeninfo->setComplete(curcompletecount);
					//			break;
					//		}
					//	}
					//}
					progress = itr->second->getFubenProgress();
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			roomdata->inputParam(WCHDATA_RoomProgress,&progress);
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenProgressAdvanceCheckMethod
//
/////////////////////////////////////////
crJXJFubenProgressAdvanceCheckMethod::crJXJFubenProgressAdvanceCheckMethod():
	m_progress(0){}
crJXJFubenProgressAdvanceCheckMethod::crJXJFubenProgressAdvanceCheckMethod(const crJXJFubenProgressAdvanceCheckMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress)
{
}
void crJXJFubenProgressAdvanceCheckMethod::inputParam(int i, void *param)
{
}

void crJXJFubenProgressAdvanceCheckMethod::addParam(int i, const std::string& str)
{
	switch (m_progress)
	{
	case 0:
		m_progress = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJFubenProgressAdvanceCheckMethod::operator()(crHandle &handle)
{
	bool bln = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	void *param;
	crData *data = myPlayer->getDataClass();
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char type = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
	unsigned short fubenid = *(unsigned short *)param;
	if(type == FT_Fuben && fubenid>0)
	{
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFubenProgressMap,param);
		FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
		if(fubenProgress)
		{
			FubenProgressMap::iterator itr = fubenProgress->find(fubenid);
			if(itr != fubenProgress->end())
			{
				if(itr->second->getFubenProgress() >= m_progress)
				{
					bln = false;
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	handle.outputParam(0,&bln);
}
/////////////////////////////////////////
//
//crJXJGainGiftsPackKeyMethod
//
/////////////////////////////////////////
crJXJGainGiftsPackKeyMethod::crJXJGainGiftsPackKeyMethod():
	m_this(NULL),
	m_output(NULL)
{
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	if(stream->loadFromFile2(crGlobalHandle::getInstance()->getGameDir()+"giftkey.dat"))
		m_giftKey = stream->_readUShort();
	else
		m_giftKey = 0;
	m_lastsavekey = m_giftKey;
}
crJXJGainGiftsPackKeyMethod::crJXJGainGiftsPackKeyMethod(const crJXJGainGiftsPackKeyMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL),
	m_giftKey(handle.m_giftKey),
	m_lastsavekey(handle.m_lastsavekey)
{
}
void crJXJGainGiftsPackKeyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (std::string *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGainGiftsPackKeyMethod::addParam(int i, const std::string& str)
{
}
void crJXJGainGiftsPackKeyMethod::operator()(crHandle &handle)
{
	//static unsigned short s_giftKey = 0;
	if(m_output)
	{
		bool success = false;
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJGiftsPackKeySet,param);
		GiftsPackKeySet *giftsKeySet = (GiftsPackKeySet *)param;

		std::string code;
		crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
		ref_ptr<crGiftsPackKeyValidQueryData> giftsPackKeyValidQuery = new crGiftsPackKeyValidQueryData;
		int count;
		do
		{
			code = CRNet::gainCode(11);
			code += crArgumentParser::appItoa(m_giftKey);
			m_giftKey++;
			if(giftsKeySet->find(code) != giftsKeySet->end())
				continue;

			giftsPackKeyValidQuery->buildQuerySql(code);

			dbSession->executeQuery(giftsPackKeyValidQuery.get());
			crDataBase::QueryResultVec &giftsPackKeyValidQueryResultVec = dbSession->getQueryResult();
			count = 0;
			if(!giftsPackKeyValidQueryResultVec.empty())
			{
				giftsPackKeyValidQuery = dynamic_cast<crGiftsPackKeyValidQueryData *>(giftsPackKeyValidQueryResultVec[0].get());
				count = giftsPackKeyValidQuery->getCount();
			}
			success = count == 0;
			giftsKeySet->insert(code);
			dbSession->releaseQuery();
		} while (!success);
		gameglobaldb->endSession(dbSession.get());

		data->excHandle(MAKEINT64(WCH_LockData,0));
		*m_output = code;
		if(m_giftKey - m_lastsavekey>50)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(2);
			stream->_writeUShort(m_giftKey);
			stream->seekBegin();
			stream->saveToFile2(crGlobalHandle::getInstance()->getGameDir()+"giftkey.dat");
			m_lastsavekey = m_giftKey;
		}
	}
}
/////////////////////////////////////////
//
//crJXJCreateGiftsPackDisposeMethod
//
/////////////////////////////////////////
crJXJCreateGiftsPackDisposeMethod::crJXJCreateGiftsPackDisposeMethod():
	m_this(NULL),
	m_availableTime(0.02f){}
crJXJCreateGiftsPackDisposeMethod::crJXJCreateGiftsPackDisposeMethod(const crJXJCreateGiftsPackDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_availableTime(handle.m_availableTime)
{
}
void crJXJCreateGiftsPackDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJCreateGiftsPackDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_availableTime = atof(str.c_str());
		break;
	}
}

void crJXJCreateGiftsPackDisposeMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJCreateGiftsPackDeque,param);
		CreateGiftsPackDeque *disposeDeq = (CreateGiftsPackDeque *)param;
		if(!disposeDeq->empty())
		{
			//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			//crNetDataManager *netDataManager = gameServer->getNetDataManager();
			//ref_ptr<crGameServerPlayerData> playerData;
			//			crPlayerGameData *playerGameData;
			//			crData *gameData;
			const CRCore::Timer& timer = *CRCore::Timer::instance();
			CRCore::Timer_t start_tick = timer.tick();
			float elapsedTime = 0.0f;

			ref_ptr<crInsertGiftsPack> insertPackets = new crInsertGiftsPack;

			//crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
			//ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
			//			int insertid;
			crDBSavePacket packet;
			CRCore::ref_ptr<crCreateGiftsPack> giftsPacket;
			std::string key;
			int playerid;
			CRCore::ref_ptr<crStreamBuf> streamBuf;
			while(elapsedTime<m_availableTime && !disposeDeq->empty())
			{
				giftsPacket = disposeDeq->front();
				disposeDeq->pop_front();
				key = giftsPacket->getKey();
				playerid = giftsPacket->getPlayerID();
				streamBuf = giftsPacket->getStreamBuf();
				insertPackets->buildUpdateSql(key,streamBuf.get(),playerid);

				crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,insertPackets.get());
				dbConductor->getNetManager()->sendPacket("all",packet);
				//if(dbSession->executeUpdate(insertPackets.get()))
				//{
				//	dbSession->commit();
				//}

				elapsedTime = timer.delta_s(start_tick,timer.tick());
			}
			//gameglobaldb->endSession(dbSession.get());
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJGameServerMaintenanceMethod
//
/////////////////////////////////////////
crJXJGameServerMaintenanceMethod::crJXJGameServerMaintenanceMethod():
	m_lasttimer(0L)
{
}
crJXJGameServerMaintenanceMethod::crJXJGameServerMaintenanceMethod(const crJXJGameServerMaintenanceMethod& handle):
	crMethod(handle),
	m_lasttimer(0L)
{
}
void crJXJGameServerMaintenanceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJGameServerMaintenanceMethod::addParam(int i, const std::string& str)
{
}
void crJXJGameServerMaintenanceMethod::operator()(crHandle &handle)
{
	time_t t = time(0);
	int dt = t - m_lasttimer;
	if(dt>86400)
	{
		std::string opentime = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaintenanceTime, 0);
		char tmp[20];
		strftime( tmp, sizeof(tmp), "%H:%M:%S\0", localtime(&t) );
		crVector3i opentm,curtm;
		crArgumentParser::appTimetoVec(opentime,opentm);
		crArgumentParser::appTimetoVec(tmp,curtm);
		if(curtm[0]==opentm[0])
		{
			m_lasttimer = t;
			//开始维护服务器
			m_this->doEvent(WCH_JXJServerMaintenance);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRankingSaveMethod
//
/////////////////////////////////////////
crJXJRankingSaveMethod::crJXJRankingSaveMethod()
{
}
crJXJRankingSaveMethod::crJXJRankingSaveMethod(const crJXJRankingSaveMethod& handle):
	crMethod(handle)
{
}
void crJXJRankingSaveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJRankingSaveMethod::addParam(int i, const std::string& str)
{
}
void crJXJRankingSaveMethod::operator()(crHandle &handle)
{
	m_this->doEvent(WCH_JXJRankingSave);
}
/////////////////////////////////////////
//
//crJXJGiftspackTabMaintenanceMethod
//
/////////////////////////////////////////
crJXJGiftspackTabMaintenanceMethod::crJXJGiftspackTabMaintenanceMethod()
{
}
crJXJGiftspackTabMaintenanceMethod::crJXJGiftspackTabMaintenanceMethod(const crJXJGiftspackTabMaintenanceMethod& handle):
	crMethod(handle)
{
}
void crJXJGiftspackTabMaintenanceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJGiftspackTabMaintenanceMethod::addParam(int i, const std::string& str)
{
}
void crJXJGiftspackTabMaintenanceMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJGiftsPackKeySet,param);
		GiftsPackKeySet *giftsKeySet = (GiftsPackKeySet *)param;

		crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
		ref_ptr<crGiftsPackOverdueQueryData> giftsPackOverdueQuery = new crGiftsPackOverdueQueryData;

		int overdue = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGiftspackTabOverdue, 0).c_str());
		giftsPackOverdueQuery->buildQuerySql(overdue);
		dbSession->executeQuery(giftsPackOverdueQuery.get());
		crDataBase::QueryResultVec &giftsPackOverdueQueryResultVec = dbSession->getQueryResult();
		int id;
		std::string key;
		ref_ptr<crRemoveGiftsPack> removeGiftsPack = new crRemoveGiftsPack;
		crDBSavePacket packet;
		for( crDataBase::QueryResultVec::iterator itr = giftsPackOverdueQueryResultVec.begin();
			itr != giftsPackOverdueQueryResultVec.end();
			++itr )
		{
			giftsPackOverdueQuery = dynamic_cast<crGiftsPackOverdueQueryData *>(itr->get());
			id = giftsPackOverdueQuery->getID();
			key = giftsPackOverdueQuery->getKey();
			giftsKeySet->erase(key);

			//removeGiftsPack->buildUpdateSql(id);
			//crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,removeGiftsPack.get());
			//dbConductor->getNetManager()->sendPacket("all",packet);
		}
		dbSession->releaseQuery();

		removeGiftsPack->buildUpdateSql_Overdue(overdue);
		if(dbSession->executeUpdate(removeGiftsPack.get()))
		{//成功
			dbSession->commit();
		}
		gameglobaldb->endSession(dbSession.get());

		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJMailTabMaintenanceMethod
//
/////////////////////////////////////////
crJXJMailTabMaintenanceMethod::crJXJMailTabMaintenanceMethod()
{
}
crJXJMailTabMaintenanceMethod::crJXJMailTabMaintenanceMethod(const crJXJMailTabMaintenanceMethod& handle):
	crMethod(handle)
{
}
void crJXJMailTabMaintenanceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJMailTabMaintenanceMethod::addParam(int i, const std::string& str)
{
}
void crJXJMailTabMaintenanceMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		int overdue = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMailTabOverdue,0).c_str());
		ref_ptr<crRemoveMail> removeMail = new crRemoveMail;
		crDBSavePacket packet;
		removeMail->buildUpdateSql_Overdue(overdue);
		crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,removeMail.get());
		dbConductor->getNetManager()->sendPacket("all",packet);

		//crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		//ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
		//ref_ptr<crMailOverdueQueryData> mailOverdueQuery = new crMailOverdueQueryData;
		//int overdue = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMailTabOverdue,0).c_str());
		//mailOverdueQuery->buildQuerySql(overdue);
		//dbSession->executeQuery(mailOverdueQuery.get());
		//crDataBase::QueryResultVec &mailOverdueQueryResultVec = dbSession->getQueryResult();
		//int id;
		//std::string key;
		//ref_ptr<crRemoveMail> removeMail = new crRemoveMail;
		//crDBSavePacket packet;
		//for( crDataBase::QueryResultVec::iterator itr = mailOverdueQueryResultVec.begin();
		//	itr != mailOverdueQueryResultVec.end();
		//	++itr )
		//{
		//	mailOverdueQuery = dynamic_cast<crMailOverdueQueryData *>(itr->get());
		//	id = mailOverdueQuery->getID();

		//	removeMail->buildUpdateSql(id);
		//	crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,removeMail.get());
		//	dbConductor->getNetManager()->sendPacket("all",packet);
		//}
		//dbSession->releaseQuery();
		//gameglobaldb->endSession(dbSession.get());
	}
}
/////////////////////////////////////////
//
//crJXJGamelogMaintenanceMethod
//
/////////////////////////////////////////
crJXJGamelogMaintenanceMethod::crJXJGamelogMaintenanceMethod()
{
}
crJXJGamelogMaintenanceMethod::crJXJGamelogMaintenanceMethod(const crJXJGamelogMaintenanceMethod& handle):
	crMethod(handle)
{
}
void crJXJGamelogMaintenanceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJGamelogMaintenanceMethod::addParam(int i, const std::string& str)
{
}
void crJXJGamelogMaintenanceMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
		ref_ptr<crGamelogOverdueQueryData> logOverdueQuery = new crGamelogOverdueQueryData;
		int overdue = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGamelogOverdue,0).c_str());
		logOverdueQuery->buildQuerySql(overdue);
		dbSession->executeQuery(logOverdueQuery.get());
		crDataBase::QueryResultVec &logOverdueQueryResultVec = dbSession->getQueryResult();
		int id;
		std::string key;
		ref_ptr<crRemoveGameLog> removelog = new crRemoveGameLog;
		crDBSavePacket packet;
		for( crDataBase::QueryResultVec::iterator itr = logOverdueQueryResultVec.begin();
			itr != logOverdueQueryResultVec.end();
			++itr )
		{
			logOverdueQuery = dynamic_cast<crGamelogOverdueQueryData *>(itr->get());
			id = logOverdueQuery->getID();

			removelog->buildUpdateSql(id);
			crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,removelog.get());
			dbConductor->getNetManager()->sendPacket("all",packet);
		}
		dbSession->releaseQuery();
		gameglobaldb->endSession(dbSession.get());
	}
}
/////////////////////////////////////////
//
//crJXJExtraMoveSpeedPercentMethod
//
/////////////////////////////////////////
crJXJExtraMoveSpeedPercentMethod::crJXJExtraMoveSpeedPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraMoveSpeedPercentMethod::crJXJExtraMoveSpeedPercentMethod(const crJXJExtraMoveSpeedPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraMoveSpeedPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraMoveSpeedPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraMoveSpeedPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraSpeedPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraAttackPercentMethod
//
/////////////////////////////////////////
crJXJExtraAttackPercentMethod::crJXJExtraAttackPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraAttackPercentMethod::crJXJExtraAttackPercentMethod(const crJXJExtraAttackPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraAttackPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraAttackPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraAttackPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraAttackPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraGuiseMethod
//
/////////////////////////////////////////
crJXJExtraGuiseMethod::crJXJExtraGuiseMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0),
	m_start(false),
	m_timer(0.0f){}
crJXJExtraGuiseMethod::crJXJExtraGuiseMethod(const crJXJExtraGuiseMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f)
{
}
void crJXJExtraGuiseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraGuiseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = 1<<(unsigned int)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraGuiseMethod::operator()(crHandle &handle)
{
	void *param;
	crData *thisData = m_this->getDataClass();
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		if(m_extraValue == GS_Hide)
		{
			if(m_duration - m_timer>0.5f)
			{
				thisData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				if(itemstate == IS_UseItem)
				{
					m_timer = -1.0f;
					return;
				}
			}
			else
			{
				unsigned char itemstate = IS_Stop;
				thisData->inputParam(WCHDATA_ItemState,&itemstate);
			}
		}
		else if(m_extraValue == GS_Taunt)
		{//目标锁定嘲讽者
			if(m_fireItem.valid())
			{
				if(m_this->isMainAI())
				{
					unsigned char targettype = m_fireItem->getItemtype()==crInstanceItem::Role?Target_Role:Target_Npc;
					thisData->inputParam(WCHDATA_TargetType,&targettype);
					thisData->inputParam(WCHDATA_TargetNode,m_fireItem->getRelNode());
					int targetid = m_fireItem->getID();
					int targetroleid = m_fireItem->getRoleID();
					thisData->inputParam(WCHDATA_TargetID,&targetid);
					thisData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
					crVector3 targetPos = m_fireItem->getPosition();
					thisData->inputParam(WCHDATA_TargetPos,&targetPos);
				}
				crData *targetData = m_fireItem->getDataClass();
				if(targetData)
				{
					targetData->getParam(WCHDATA_ItemState,param);
					unsigned char targetItemState = *(unsigned char *)param;
					if(targetItemState == IS_Dead)
					{//目标死亡
						m_timer = -1.0f;
						return;
					}
				}
			}
			else
			{
				m_timer = -1.0f;
				return;
			}
		}
		if(!crGlobalHandle::isClient())
		{//状态buf由服务器设置然后同步给客户端
			if(m_extraValue == GS_TrueSight)
			{//对范围内隐身单位施放GS_UnHide
				ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
				if(hitSight.valid())
				{
					std::vector< ref_ptr<crInstanceItem> > SPItemVec;
					crVector3 hitpos = m_this->getPosition();
					crVector3 itempos;
					ref_ptr<crInstanceItem> item;
					unsigned int guisestate = GS_Normal;
					float sightRange = 0;
					m_this->doEvent(MAKEINT64(WCH_GetSightRange,NULL),MAKEINT64(&sightRange,NULL));
					sightRange *= crGlobalHandle::gData()->gUnitScale();
					hitSight->lockItemEyeMap();
					crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
					for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
						itr != itemEyeMap.end();
						++itr )
					{
						item = itr->second;
						if(m_this != item.get())
						{
							guisestate = GS_Normal;
							item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
							if( guisestate & GS_Hide && !(guisestate & GS_UnHide) )
							{
								itempos = item->getPosition();
								if((itempos - hitpos).length() < sightRange)
								{
									SPItemVec.push_back(item);
								}
							}
						}
					}
					hitSight->unlockItemEyeMap();

					ref_ptr<crSceneServerPlayerData> playerdata;
					hitSight->lockPlayerEyeMap();
					crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
					for( crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
						itr != playerEyeMap.end();
						++itr )
					{
						playerdata = itr->second;
						crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
						for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
							ritr != roleMap.end();
							++ritr )
						{
							item = dynamic_cast<crInstanceItem *>(ritr->second.get());
							if(m_this != item.get())
							{
								guisestate = GS_Normal;
								item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
								if( guisestate & GS_Hide && !(guisestate & GS_UnHide) )
								{
									itempos = item->getPosition();
									if((itempos - hitpos).length() < sightRange)
									{
										SPItemVec.push_back(item);
									}
								}
							}
						}
					}
					hitSight->unlockPlayerEyeMap();
					for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
						itr != SPItemVec.end();
						++itr )
					{
						(*itr)->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(Ext_TrueSight,-1),m_this));
					}
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_ExtraGuise,param);
			unsigned int* extra = (unsigned int *)param;
			if(extra)
				*extra |= m_extraValue;
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraGuiseMethod
//
/////////////////////////////////////////
crJXJExtraGuiseCheckMethod::crJXJExtraGuiseCheckMethod() :
m_extraValue(0){}
crJXJExtraGuiseCheckMethod::crJXJExtraGuiseCheckMethod(const crJXJExtraGuiseCheckMethod& handle) :
crMethod(handle),
m_extraValue(handle.m_extraValue)
{
}
void crJXJExtraGuiseCheckMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraGuiseCheckMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_extraValue = 1 << (unsigned int)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraGuiseCheckMethod::operator()(crHandle &handle)
{
	bool hasguise = false;

	unsigned int guisestate = GS_Normal;
	m_this->doEvent(WCH_GetGuiseState, MAKEINT64(&guisestate, NULL));
	hasguise = guisestate & m_extraValue;
	handle.outputParam(0, &hasguise);
}
/////////////////////////////////////////
//
//crJXJExtraDefendPercentMethod
//
/////////////////////////////////////////
crJXJExtraDefendPercentMethod::crJXJExtraDefendPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraDefendPercentMethod::crJXJExtraDefendPercentMethod(const crJXJExtraDefendPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraDefendPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraDefendPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraDefendPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraDefendPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDefendPerSecondMethod
//
/////////////////////////////////////////
crJXJExtraDefendPerSecondMethod::crJXJExtraDefendPerSecondMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_addValue(0){}
crJXJExtraDefendPerSecondMethod::crJXJExtraDefendPerSecondMethod(const crJXJExtraDefendPerSecondMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_addValue(0)
{
}
void crJXJExtraDefendPerSecondMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJExtraDefendPerSecondMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraDefendPerSecondMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
		m_addValue = 0;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		if(m_timer<0.0f)
		{
			m_dtrec += m_timer;
			m_addValue += m_extraValue * m_dtrec;
			m_dtrec = 0.0f;
			//m_start = false;
			//m_timer = 0.0f;

		}
		else if(m_dtrec>=1.0f)
		{
			m_addValue += m_extraValue;
			m_dtrec -= 1.0f;
		}
		if(m_addValue!=0)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_ExtraDefend,param);
			short* extra = (short *)param;
			*extra += m_addValue;
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraMagicDefendPercentMethod
//
/////////////////////////////////////////
crJXJExtraMagicDefendPercentMethod::crJXJExtraMagicDefendPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f){}
crJXJExtraMagicDefendPercentMethod::crJXJExtraMagicDefendPercentMethod(const crJXJExtraMagicDefendPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f)
{
}
void crJXJExtraMagicDefendPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJExtraMagicDefendPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraMagicDefendPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraMagicDefendPercent,param);
		short* extra = (short *)param;
		*extra += m_extraValue;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDamageMethod
//
/////////////////////////////////////////
crJXJExtraDamageMethod::crJXJExtraDamageMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),m_overlapCount(1){}
crJXJExtraDamageMethod::crJXJExtraDamageMethod(const crJXJExtraDamageMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),m_overlapCount(1)
{
}
void crJXJExtraDamageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraDamageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = atof(str.c_str());
		break;
	}
}

void crJXJExtraDamageMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		float damage = 0.0f;
		if(m_timer<0.0f)
		{
			m_dtrec += m_timer;
			damage = m_extraValue * m_dtrec * (float)m_overlapCount;
			m_dtrec = 0.0f;
			//m_start = false;
			//m_timer = 0.0f;

		}
		else if(m_dtrec>=1.0f)
		{
			damage = m_extraValue * (float)m_overlapCount;
			m_dtrec -= 1.0f;
		}
		if(damage!=0.0f)
		{
			DamagePair dp(damage,std::make_pair(SkillDM,0));//ExtraDM

			//ref_ptr<crInstanceItem> dmItem = m_fireItem.get();
			//if(m_fireItem.valid() && m_fireItem->getDataClass())
			//{//检查寄生
			//	void *param;
			//	crData *fireData = m_fireItem->getDataClass();
			//	fireData->getParam(WCHDATA_JXJExtraParasiticItem_RD,param);
			//	if(param)
			//	{
			//		dmItem = (crInstanceItem *)param;
			//	}
			//}
			m_this->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_fireItem.get()));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDamageAttackMethod
//
/////////////////////////////////////////
crJXJExtraDamageAttackMethod::crJXJExtraDamageAttackMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_baseDamage(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_firedamage(0.0f){}
crJXJExtraDamageAttackMethod::crJXJExtraDamageAttackMethod(const crJXJExtraDamageAttackMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_baseDamage(handle.m_baseDamage),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_firedamage(0.0f)
{
}
void crJXJExtraDamageAttackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		{
			m_fireItem = (crInstanceItem*)param;
			m_firedamage = 0.0f;
			if(m_fireItem.valid() && m_fireItem->getDataClass())
			{
				m_fireItem->doEvent(MAKEINT64(WCH_GetDamage,0),MAKEINT64(&m_firedamage,NULL));
				ref_ptr<crData>fireData = m_fireItem->getDataClass();
				if(fireData.valid())
				{
					////////计算伤害
					void *param;
					fireData->getParam(WCHDATA_JXJRTArmyCount,param);
					float armcount = *(/*unsigned short*/int *)param;
					fireData->getParam(WCHDATA_JXJArmyCount,param);
					float maxarmcount = *(/*unsigned short*/int *)param;
					m_firedamage *= (armcount+maxarmcount)/2.0f;
				}
			}
		}
		break;
	}
}

void crJXJExtraDamageAttackMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = atof(str.c_str());
		break;
	case 2:
		m_baseDamage = atof(str.c_str());
		break;
	}
}

void crJXJExtraDamageAttackMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		float damage = 0.0f;

		if(m_timer<0.0f)
		{
			m_dtrec += m_timer;
			damage = (m_firedamage * m_extraValue + m_baseDamage) * m_dtrec;
			m_dtrec = 0.0f;
			//m_start = false;
			//m_timer = 0.0f;

		}
		else if(m_dtrec>=1.0f)
		{
			damage = m_firedamage * m_extraValue + m_baseDamage;
			m_dtrec -= 1.0f;
		}
		if(damage!=0.0f)
		{
			DamagePair dp(damage,std::make_pair(SkillDM,0));//ExtraDM

			//ref_ptr<crInstanceItem> dmItem = m_fireItem.get();
			//if(m_fireItem.valid() && m_fireItem->getDataClass())
			//{//检查寄生
			//	void *param;
			//	crData *fireData = m_fireItem->getDataClass();
			//	fireData->getParam(WCHDATA_JXJExtraParasiticItem_RD,param);
			//	if(param)
			//	{
			//		dmItem = (crInstanceItem *)param;
			//	}
			//}
			m_this->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_fireItem.get()));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDamageAttackOnceMethod
//
/////////////////////////////////////////
crJXJExtraDamageAttackOnceMethod::crJXJExtraDamageAttackOnceMethod():
	m_dt(NULL),
	m_extraValue(0.0f),
	m_baseDamage(0.0f),
	m_start(0),
	m_firedamage(0.0f){}
crJXJExtraDamageAttackOnceMethod::crJXJExtraDamageAttackOnceMethod(const crJXJExtraDamageAttackOnceMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_extraValue(handle.m_extraValue),
	m_baseDamage(handle.m_baseDamage),
	m_start(0),
	m_firedamage(0.0f)
{
}
void crJXJExtraDamageAttackOnceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		{
			m_fireItem = (crInstanceItem*)param;
			m_firedamage = 0.0f;
			if(m_fireItem.valid())
			{
				void *param;
				ref_ptr<crData> fireData = m_fireItem->getDataClass();
				if(fireData.valid())
				{
					fireData->getParam(WCHDATA_JXJExtraParasiticItem,param);
					if(param)
					{
						m_fireItem = (crInstanceItem *)param;
						fireData = m_fireItem->getDataClass();
					}
					if(m_fireItem.valid() && fireData.valid())
					{
						m_fireItem->doEvent(MAKEINT64(WCH_GetDamage,0),MAKEINT64(&m_firedamage,NULL));
						////////计算伤害
						fireData->getParam(WCHDATA_JXJRTArmyCount,param);
						float armcount = *(int *)param;
						fireData->getParam(WCHDATA_JXJArmyCount,param);
						float maxarmcount = *(int *)param;
						m_firedamage *= (armcount+maxarmcount)/2.0f;
					}
				}
			}
		}
		break;
	}
}

void crJXJExtraDamageAttackOnceMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_extraValue = atof(str.c_str());
		break;
	case 1:
		m_baseDamage = atof(str.c_str());
		break;
	}
}

void crJXJExtraDamageAttackOnceMethod::operator()(crHandle &handle)
{
	if(m_start==0)
	{
		m_start = 1;
	}
	if(m_start==1)
	{
		float damage = m_firedamage * m_extraValue + m_baseDamage;
		if(damage!=0.0f)
		{
			DamagePair dp(damage,std::make_pair(SkillDM,0));//ExtraDM

			m_this->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_fireItem.get()));
		}
		m_start = 2;//结束
	}
}
/////////////////////////////////////////
//
//crJXJExtraCureHPMethod
//
/////////////////////////////////////////
crJXJExtraCureHPMethod::crJXJExtraCureHPMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_percent(0.0),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_overlapCount(1),
	m_maxhp(0.0f){}
crJXJExtraCureHPMethod::crJXJExtraCureHPMethod(const crJXJExtraCureHPMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_percent(handle.m_percent),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_overlapCount(1),
	m_maxhp(0.0f)
{
}
void crJXJExtraCureHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraCureHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = atof(str.c_str());
		break;
	case 2:
		m_percent = atof(str.c_str());
		break;
	}
}

void crJXJExtraCureHPMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
		m_maxhp = 0.0f;
		m_this->doEvent(MAKEINT64(WCH_GetHP, NULL), MAKEINT64(&m_maxhp, NULL));
		crData *thisData = m_this->getDataClass();
		void *param;
		thisData->getParam(WCHDATA_JXJArmyCount, param);
		int armyCount = *(/*unsigned short*/int *)param;
		m_maxhp *= armyCount;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		float cure = 0.0f;
		if(m_timer<0.0f)
		{
			m_dtrec += m_timer;
			cure = (m_maxhp * m_percent + m_extraValue) * m_dtrec * (float)m_overlapCount;
			m_dtrec = 0.0f;
			//m_start = false;
			//m_timer = 0.0f;
		}
		else if(m_dtrec>=1.0f)
		{
			cure = (m_maxhp * m_percent + m_extraValue) * (float)m_overlapCount;
			m_dtrec -= 1.0f;
		}
		if(cure!=0.0f)
		{
			m_this->doEvent(WCH_CureHP,MAKEINT64(&cure,NULL/*m_fireItem.get()*/));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDodgePercentMethod
//
/////////////////////////////////////////
crJXJExtraDodgePercentMethod::crJXJExtraDodgePercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraDodgePercentMethod::crJXJExtraDodgePercentMethod(const crJXJExtraDodgePercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraDodgePercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraDodgePercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraDodgePercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraDodgePercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDodgeMethod
//
/////////////////////////////////////////
crJXJExtraDodgeMethod::crJXJExtraDodgeMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraDodgeMethod::crJXJExtraDodgeMethod(const crJXJExtraDodgeMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraDodgeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraDodgeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraDodgeMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraDodge,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraAttackSpeedMethod
//
/////////////////////////////////////////
crJXJExtraAttackSpeedMethod::crJXJExtraAttackSpeedMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraAttackSpeedMethod::crJXJExtraAttackSpeedMethod(const crJXJExtraAttackSpeedMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraAttackSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraAttackSpeedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraAttackSpeedMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraAttackSpeed,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}

/////////////////////////////////////////
//
//crJXJExtraAttackSpeedMethod
//
/////////////////////////////////////////
crJXJExtraSkillSpeedMethod::crJXJExtraSkillSpeedMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraSkillSpeedMethod::crJXJExtraSkillSpeedMethod(const crJXJExtraSkillSpeedMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraSkillSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraSkillSpeedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraSkillSpeedMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraSkillSpeed,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}

/////////////////////////////////////////
//
//crJXJExtraHPMethod
//
/////////////////////////////////////////
crJXJExtraHPMethod::crJXJExtraHPMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraHPMethod::crJXJExtraHPMethod(const crJXJExtraHPMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraHPMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraHP,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}

/////////////////////////////////////////
//
//crJXJExtraRTHPMethod
//
/////////////////////////////////////////
crJXJExtraRTHPMethod::crJXJExtraRTHPMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f){}
crJXJExtraRTHPMethod::crJXJExtraRTHPMethod(const crJXJExtraRTHPMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f)
{
}
void crJXJExtraRTHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case 3:
		m_output = (bool*)param;
		break;
	}
}

void crJXJExtraRTHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraRTHPMethod::operator()(crHandle &handle)
{
	void *param;
	crData *thisData = m_this->getDataClass();
	thisData->excHandle(MAKEINT64(WCH_LockData,1));
	thisData->getParam(WCHDATA_ExtraRTHP,param);
	float* extra = (float *)param;

	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;

		*extra = m_extraValue;
	}
	else if(m_duration>0.0f)
	{
		m_timer -= *m_dt;
		if(m_timer<0.0f)
		{
			*m_output = true;
			m_start = false;
			m_timer = 0.0f;

			*extra = 0.0f;
		}
	}
	if(*extra<=0.0f)
	{
		*m_output = true;
		m_start = false;
		m_timer = 0.0f;

		*extra = 0.0f;
	}
	thisData->excHandle(MAKEINT64(WCH_LockData,0));
}

/////////////////////////////////////////
//
//crJXJExtraIgnoreDefendMethod
//
/////////////////////////////////////////
crJXJExtraIgnoreDefendMethod::crJXJExtraIgnoreDefendMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraIgnoreDefendMethod::crJXJExtraIgnoreDefendMethod(const crJXJExtraIgnoreDefendMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraIgnoreDefendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraIgnoreDefendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraIgnoreDefendMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraIgnoreDefend,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}

/////////////////////////////////////////
//
//crJXJExtraIgnoreMagicDefendMethod
//
/////////////////////////////////////////
crJXJExtraIgnoreMagicDefendMethod::crJXJExtraIgnoreMagicDefendMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraIgnoreMagicDefendMethod::crJXJExtraIgnoreMagicDefendMethod(const crJXJExtraIgnoreMagicDefendMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraIgnoreMagicDefendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraIgnoreMagicDefendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraIgnoreMagicDefendMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraIgnoreMagicDefend,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}

/////////////////////////////////////////
//
//crJXJExtraAttackDamageBackMethod
//
/////////////////////////////////////////
crJXJExtraAttackDamageBackMethod::crJXJExtraAttackDamageBackMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraAttackDamageBackMethod::crJXJExtraAttackDamageBackMethod(const crJXJExtraAttackDamageBackMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraAttackDamageBackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraAttackDamageBackMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraAttackDamageBackMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraAttackDamageBack,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}
/////////////////////////////////////////
//
//crJXJExtraSkillDamageBackMethod
//
/////////////////////////////////////////
crJXJExtraSkillDamageBackMethod::crJXJExtraSkillDamageBackMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraSkillDamageBackMethod::crJXJExtraSkillDamageBackMethod(const crJXJExtraSkillDamageBackMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraSkillDamageBackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraSkillDamageBackMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraSkillDamageBackMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraSkillDamageBack,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}
/////////////////////////////////////////
//
//crJXJExtraAttackAbsorbHPMethod
//
/////////////////////////////////////////
crJXJExtraAttackAbsorbHPMethod::crJXJExtraAttackAbsorbHPMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraAttackAbsorbHPMethod::crJXJExtraAttackAbsorbHPMethod(const crJXJExtraAttackAbsorbHPMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraAttackAbsorbHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraAttackAbsorbHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraAttackAbsorbHPMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraAttackAbsorbHP,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}
/////////////////////////////////////////
//
//crJXJExtraAttackAbsorbHPMethod
//
/////////////////////////////////////////
crJXJExtraSkillAbsorbHPMethod::crJXJExtraSkillAbsorbHPMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraSkillAbsorbHPMethod::crJXJExtraSkillAbsorbHPMethod(const crJXJExtraSkillAbsorbHPMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraSkillAbsorbHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraSkillAbsorbHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraSkillAbsorbHPMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraSkillAbsorbHP,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}

/////////////////////////////////////////
//
//crJXJExtraSkillDemageMethod
//
/////////////////////////////////////////
crJXJExtraSkillDemageMethod::crJXJExtraSkillDemageMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraSkillDemageMethod::crJXJExtraSkillDemageMethod(const crJXJExtraSkillDemageMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraSkillDemageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraSkillDemageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraSkillDemageMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraSkillDamage,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}

/////////////////////////////////////////
//
//crJXJExtraAttackDemageMethod
//
/////////////////////////////////////////
crJXJExtraAttackDemageMethod::crJXJExtraAttackDemageMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1){}
crJXJExtraAttackDemageMethod::crJXJExtraAttackDemageMethod(const crJXJExtraAttackDemageMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),m_overlapCount(1)
{
}
void crJXJExtraAttackDemageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraAttackDemageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraAttackDemageMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraAttackDamage,param);
		short* extra = (short *)param;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}
///////////////////////////////////////////
////
////crJXJFriendCollideExtraMethod
////
///////////////////////////////////////////
//crJXJFriendCollideExtraMethod::crJXJFriendCollideExtraMethod():
//	m_this(NULL),
//	m_item(NULL){}
//crJXJFriendCollideExtraMethod::crJXJFriendCollideExtraMethod(const crJXJFriendCollideExtraMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_item(NULL)
//{
//}
//void crJXJFriendCollideExtraMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_item = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_item = (crInstanceItem *)(LOINT64(param64));
//		}
//		break;
//	}
//}
//void crJXJFriendCollideExtraMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJFriendCollideExtraMethod::operator()(crHandle &handle)
//{
//	//void *param;
//	//crData *thisData = m_this->getDataClass();
//	//thisData->getParam(WCHDATA_ItemState,param);
//	//unsigned char itemstate = *(unsigned char *)param;
//	//if(itemstate == IS_Stop)
//	//{
//	if(m_item.valid())
//	{
//		char isEnemy = 0;
//		m_this->doEvent(WCH_EnemyCheck,MAKEINT64(m_item.get(),&isEnemy));
//		if(isEnemy == 1)
//		{
//			void *param;
//			crData* data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->getParam(WCHDATA_ExtraGuise,param);
//			unsigned int* extra = (unsigned int *)param;
//			*extra |= GS_NoneBlock;
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//			//short extid = Ext_Block;
//			//crHandle *handle = data->getHandle(MAKEINT64(WCH_ExtraHandle,extid));
//			//if(handle)
//			//{
//			//	//data->excHandle(MAKEINT64(WCH_LockData,1));
//			//	data->getParam(WCHDATA_ExtraData,param);
//			//	crData *extraData = (crData *)param;
//			//	if(extraData)
//			//	{
//			//		extraData->excHandle(MAKEINT64(WCH_LockData,1));
//			//		extraData->getParam(WCHDATA_ExtraIDMap,param);
//			//		ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
//			//		if(extraData && extraIDMap->find(extid) == extraIDMap->end())
//			//		{
//			//			crHandle *cloneHandle = handle->clone();
//			//			extraData->insertHandle(MAKEINT64(WCH_DoExtra,extid),cloneHandle);
//			//			(*extraIDMap)[extid] = 0;
//			//		}
//			//		extraData->excHandle(MAKEINT64(WCH_LockData,0));
//			//	}
//			//	//data->excHandle(MAKEINT64(WCH_LockData,0));
//			//}
//		}
//	}
//	//}
//}

/////////////////////////////////////////
//
//crJXJExtraHitRatioPercentMethod
//
/////////////////////////////////////////
crJXJExtraHitRatioPercentMethod::crJXJExtraHitRatioPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraHitRatioPercentMethod::crJXJExtraHitRatioPercentMethod(const crJXJExtraHitRatioPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraHitRatioPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraHitRatioPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraHitRatioPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraHitratioPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount < 1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraHaloMethod
//
/////////////////////////////////////////
crJXJExtraHaloMethod::crJXJExtraHaloMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_range(0.0f),
	m_haloExtraID(0),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_haloInterval(5.0f),
	m_dices(100){}
crJXJExtraHaloMethod::crJXJExtraHaloMethod(const crJXJExtraHaloMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_range(handle.m_range),
	m_haloExtraID(handle.m_haloExtraID),
	m_haloInterval(handle.m_haloInterval),
	m_dices(handle.m_dices),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
}
void crJXJExtraHaloMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraHaloMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_range = atof(str.c_str());
		break;
	case 2:
		m_haloExtraID = (short)(atoi(str.c_str()));
		break;
	case 3:
		m_haloInterval = atof(str.c_str());
		break;
	case 4:
		m_dices = atoi(str.c_str());
		break;
	}
}

void crJXJExtraHaloMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = m_haloInterval;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		if(m_dtrec>=m_haloInterval)
		{//光环每隔m_haloIntervals对外作用一次
			m_dtrec -= m_haloInterval;
			ref_ptr<crInstanceItem> fireItem = m_fireItem.valid()?m_fireItem:m_this;
			CRCore::rangei dices(0,100);
			bool valid = dices.get_random()<m_dices;
			if(valid)
				m_this->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,-1),fireItem.get()));

			ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
			if(hitSight.valid() && m_range>0.0f)
			{
				std::vector< ref_ptr<crInstanceItem> > SPItemVec;
				crVector3 hitpos = m_this->getPosition();
				crVector3 itempos;
				ref_ptr<crInstanceItem> item;
				unsigned int guisestate = GS_Normal;
				unsigned char itemstate;
				ref_ptr<crData> itemdata;
				void *param;

				ref_ptr<crSceneServerPlayerData> playerdata;
				hitSight->lockPlayerEyeMap();
				crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
				for (crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
					itr != playerEyeMap.end();
					++itr)
				{
					playerdata = itr->second;
					crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
					for (crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
						ritr != roleMap.end();
						++ritr)
					{
						item = dynamic_cast<crInstanceItem *>(ritr->second.get());
						itemdata = item->getDataClass();
						if (m_this != item.get() && itemdata.valid())
						{
							itemdata->getParam(WCHDATA_ItemState, param);
							itemstate = *(unsigned char *)param;
							if (itemstate == IS_Dead)
							{
								continue;
							}
							guisestate = GS_Normal;
							item->doEvent(MAKEINT64(WCH_GetGuiseState, 0), MAKEINT64(&guisestate, NULL));
							if (guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
								guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack)
							{
								continue;
							}
							itempos = item->getPosition();
							if ((itempos - hitpos).length() < m_range)
							{
								SPItemVec.push_back(item);
							}
						}
					}
				}
				hitSight->unlockPlayerEyeMap();

				hitSight->lockItemEyeMap();
				crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
				for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
					itr != itemEyeMap.end();
					++itr )
				{
					item = itr->second;
					itemdata = item->getDataClass();
					if(m_this != item.get() && itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							continue;
						}
						guisestate = GS_Normal;
						item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
						if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
							guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack )
						{
							continue;
						}
						itempos = item->getPosition();
						if((itempos - hitpos).length() < m_range)
						{
							SPItemVec.push_back(item);
						}
					}
				}
				hitSight->unlockItemEyeMap();

				for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
					itr != SPItemVec.end();
					++itr )
				{
					valid = dices.get_random()<m_dices;
					if(valid)
						(*itr)->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,-1),fireItem.get()));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDHaloMethod
//
/////////////////////////////////////////
crJXJExtraDHaloMethod::crJXJExtraDHaloMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_range(0.0f),
	m_haloExtraID(0),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f),
	m_haloInterval(5.0f),
	m_dices(100){}
crJXJExtraDHaloMethod::crJXJExtraDHaloMethod(const crJXJExtraDHaloMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_range(handle.m_range),
	m_haloExtraID(handle.m_haloExtraID),
	m_haloInterval(handle.m_haloInterval),
	m_dices(handle.m_dices),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
}
void crJXJExtraDHaloMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraDHaloMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_range = atof(str.c_str());
		break;
	case 2:
		m_haloExtraID = (short)(atoi(str.c_str()));
		break;
	case 3:
		m_haloInterval = atof(str.c_str());
		break;
	case 4:
		m_dices = atoi(str.c_str());
		break;
	}
}

void crJXJExtraDHaloMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = m_haloInterval;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		if(m_dtrec>=m_haloInterval)
		{//光环每隔5s对外作用一次
			m_dtrec -= m_haloInterval;
			ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
			if(hitSight.valid() && m_range>0.0f)
			{
				std::vector< ref_ptr<crInstanceItem> > SPItemVec;
				crVector3 hitpos = m_this->getPosition();
				crVector3 itempos;
				ref_ptr<crInstanceItem> item;
				unsigned int guisestate = GS_Normal;
				ref_ptr<crData> itemdata;
				void *param;
				unsigned char itemstate;
				char isEnemy = 0;

				hitSight->lockInSightRolePlayerMap();
				crSightInfo::RolePlayerMap &rolePlayerMap = hitSight->getInSightRolePlayerMap();
				for (crSightInfo::RolePlayerMap::iterator itr = rolePlayerMap.begin();
					itr != rolePlayerMap.end();
					++itr)
				{
					item = dynamic_cast<crInstanceItem*>(itr->second.get());
					itemdata = item->getDataClass();
					if (itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState, param);
						itemstate = *(unsigned char *)param;
						if (itemstate == IS_Dead)
						{
							continue;
						}
					}
					if (m_fireItem.valid())
					{
						isEnemy = 0;
						m_fireItem->doEvent(WCH_EnemyCheck, MAKEINT64(item.get(), &isEnemy));
						if (isEnemy == 1)//队友
							continue;
					}
					guisestate = GS_Normal;
					item->doEvent(MAKEINT64(WCH_GetGuiseState, 0), MAKEINT64(&guisestate, NULL));
					if (guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
						guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack)
					{
						continue;
					}
					itempos = item->getPosition();
					if ((itempos - hitpos).length() < m_range)
					{
						SPItemVec.push_back(item);
					}
				}
				hitSight->unlockInSightRolePlayerMap();

				hitSight->lockInSightItemMap();
				crSightInfo::ItemMap &itemMap = hitSight->getInSightItemMap();
				for( crSightInfo::ItemMap::iterator itr = itemMap.begin();
					itr != itemMap.end();
					++itr )
				{
					item = itr->second;
					itemdata = item->getDataClass();
					if(itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							continue;
						}
					}
					if(m_fireItem.valid())
					{
						isEnemy = 0;
						m_fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(item.get(),&isEnemy));
						if(isEnemy == 1)//队友
							continue;
					}
					guisestate = GS_Normal;
					item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
						guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/|| guisestate & GS_NoAttack )
					{
						continue;
					}
					itempos = item->getPosition();
					if((itempos - hitpos).length() < m_range)
					{
						SPItemVec.push_back(item);
					}
				}
				hitSight->unlockInSightItemMap();

				ref_ptr<crInstanceItem> fireItem = m_fireItem.valid()?m_fireItem:m_this;

				CRCore::rangei dices(0,100);
				bool valid = false;
				for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = SPItemVec.begin();
					itr != SPItemVec.end();
					++itr )
				{
					valid = dices.get_random()<m_dices;
					if(valid)
						(*itr)->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,-1),fireItem.get()));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraShootMethod
//
/////////////////////////////////////////
crJXJExtraShootMethod::crJXJExtraShootMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_range(0.0f),
	m_haloExtraID(0),
	m_shootInterval(5.0f),
	m_shootCount(5),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
crJXJExtraShootMethod::crJXJExtraShootMethod(const crJXJExtraShootMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_range(handle.m_range),
	m_haloExtraID(handle.m_haloExtraID),
	m_shootInterval(handle.m_shootInterval),
	m_shootCount(handle.m_shootCount),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
void crJXJExtraShootMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_ExtraParam:
		{
			short count = *(short*)param;
			if(count>=0)
				m_count = count;
		}
		break;
	}
}

void crJXJExtraShootMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_range = atof(str.c_str());
		break;
	case 2:
		m_haloExtraID = (short)(atoi(str.c_str()));
		break;
	case 3:
		m_shootInterval = atof(str.c_str());
		break;
	case 4:
		m_shootCount = (short)(atoi(str.c_str()));
		m_count = m_shootCount;
		break;
	}
}

void crJXJExtraShootMethod::operator()(crHandle &handle)
{
	if(m_count<=0)
		return;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = m_shootInterval;

		//////设置寄生关系
		if(m_fireItem.valid()/* && m_fireItem != m_this*/)
		{
			void *param;
			ref_ptr<crInstanceItem> parasiticItem = m_fireItem.get();
			ref_ptr<crData> fireData = m_fireItem->getDataClass();
			if(fireData.valid())
			{
				fireData->getParam(WCHDATA_JXJExtraParasiticItem,param);
				if(param)
				{
					parasiticItem = (crInstanceItem *)param;
				}
				crData *thisData = m_this->getDataClass();
				thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
			}
		}
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;

		//////////设置寄生关系
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJExtraParasiticItem_RD,param);
		ref_ptr<crInstanceItem> parasiticItem = (crInstanceItem *)param;
		if(parasiticItem.valid())
		{
			thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
		}

		if(m_dtrec>=m_shootInterval)
		{//光环每隔1s对外作用一次
			m_dtrec -= m_shootInterval;
			ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
			if(hitSight.valid())
			{
				ref_ptr<crInstanceItem> shootItem;
				float mindist = m_range;
				float dist;
				crVector3 hitpos = m_this->getPosition();
				crVector3 itempos;
				ref_ptr<crInstanceItem> item;
				unsigned int guisestate = GS_Normal;
				ref_ptr<crData>itemdata;
				void *param;
				unsigned char itemstate;

				ref_ptr<crSceneServerPlayerData> playerdata;
				hitSight->lockPlayerEyeMap();
				crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
				for (crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
					itr != playerEyeMap.end();
					++itr)
				{
					playerdata = itr->second;
					crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
					for (crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
						ritr != roleMap.end();
						++ritr)
					{
						item = dynamic_cast<crInstanceItem *>(ritr->second.get());
						itemdata = item->getDataClass();
						if (m_this != item.get() && itemdata.valid())
						{
							itemdata->getParam(WCHDATA_ItemState, param);
							itemstate = *(unsigned char *)param;
							if (itemstate == IS_Dead)
							{
								continue;
							}
							guisestate = GS_Normal;
							item->doEvent(MAKEINT64(WCH_GetGuiseState, 0), MAKEINT64(&guisestate, NULL));
							if (guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
								guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack)
							{
								continue;
							}
							itempos = item->getPosition();
							dist = (itempos - hitpos).length();
							if (dist < mindist)
							{
								mindist = dist;
								shootItem = item;
							}
						}
					}
				}
				hitSight->unlockPlayerEyeMap();

				hitSight->lockItemEyeMap();
				crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
				for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
					itr != itemEyeMap.end();
					++itr )
				{
					item = itr->second;
					itemdata = item->getDataClass();
					if(m_this != item.get() && itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							continue;
						}
						guisestate = GS_Normal;
						item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
						if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
							guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/|| guisestate & GS_NoAttack )
						{
							continue;
						}
						itempos = item->getPosition();
						dist = (itempos - hitpos).length();
						if(dist < mindist)
						{
							mindist = dist;
							shootItem = item;
						}
					}
				}
				hitSight->unlockItemEyeMap();

				if(shootItem.valid())
				{
					m_count--;
					shootItem->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,m_count),m_this));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDShootMethod
//
/////////////////////////////////////////
crJXJExtraDShootMethod::crJXJExtraDShootMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_range(0.0f),
	m_haloExtraID(0),
	m_shootInterval(5.0f),
	m_shootCount(5),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
crJXJExtraDShootMethod::crJXJExtraDShootMethod(const crJXJExtraDShootMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_range(handle.m_range),
	m_haloExtraID(handle.m_haloExtraID),
	m_shootInterval(handle.m_shootInterval),
	m_shootCount(handle.m_shootCount),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
void crJXJExtraDShootMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_ExtraParam:
		{
			short count = *(short*)param;
			if(count>=0)
				m_count = count;
		}
		break;
	}
}

void crJXJExtraDShootMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_range = atof(str.c_str());
		break;
	case 2:
		m_haloExtraID = (short)(atoi(str.c_str()));
		break;
	case 3:
		m_shootInterval = atof(str.c_str());
		break;
	case 4:
		m_shootCount = (short)(atoi(str.c_str()));
		m_count = m_shootCount;
		break;
	}
}

void crJXJExtraDShootMethod::operator()(crHandle &handle)
{
	if(m_count<=0)
		return;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = m_shootInterval;

		////////设置寄生关系
		if (m_fireItem.valid()/* && m_fireItem != m_this*/)
		{
			void *param;
			ref_ptr<crInstanceItem> parasiticItem = m_fireItem.get();
			ref_ptr<crData> fireData = m_fireItem->getDataClass();
			if(fireData.valid())
			{
				fireData->getParam(WCHDATA_JXJExtraParasiticItem,param);
				if(param)
				{
					parasiticItem = (crInstanceItem *)param;
				}
				crData *thisData = m_this->getDataClass();
				thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
			}
		}
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;

		////////设置寄生关系
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJExtraParasiticItem_RD,param);
		ref_ptr<crInstanceItem> parasiticItem = (crInstanceItem *)param;
		if(parasiticItem.valid())
		{
			thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
		}

		if(m_dtrec>=m_shootInterval)
		{//光环每隔5s对外作用一次
			m_dtrec -= m_shootInterval;
			ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
			if(hitSight.valid())
			{
				ref_ptr<crInstanceItem> shootItem;
				float mindist = m_range;
				float dist;
				crVector3 hitpos = m_this->getPosition();
				crVector3 itempos;
				ref_ptr<crInstanceItem> item;
				unsigned int guisestate = GS_Normal;
				ref_ptr<crData> itemdata;
				void *param;
				unsigned char itemstate;
				char isEnemy = 0;

				hitSight->lockInSightRolePlayerMap();
				crSightInfo::RolePlayerMap &rolePlayerMap = hitSight->getInSightRolePlayerMap();
				for (crSightInfo::RolePlayerMap::iterator itr = rolePlayerMap.begin();
					itr != rolePlayerMap.end();
					++itr)
				{
					item = dynamic_cast<crInstanceItem*>(itr->second.get());
					itemdata = item->getDataClass();
					if (itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState, param);
						itemstate = *(unsigned char *)param;
						if (itemstate == IS_Dead)
						{
							continue;
						}
					}
					if (m_fireItem.valid())
					{
						isEnemy = 0;
						m_fireItem->doEvent(WCH_EnemyCheck, MAKEINT64(item.get(), &isEnemy));
						if (isEnemy == 1)//队友
							continue;
					}
					guisestate = GS_Normal;
					item->doEvent(MAKEINT64(WCH_GetGuiseState, 0), MAKEINT64(&guisestate, NULL));
					if (guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
						guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack)
					{
						continue;
					}
					itempos = item->getPosition();
					dist = (itempos - hitpos).length();
					if (dist < mindist)
					{
						mindist = dist;
						shootItem = item;
					}
				}
				hitSight->unlockInSightRolePlayerMap();

				hitSight->lockInSightItemMap();
				crSightInfo::ItemMap &itemMap = hitSight->getInSightItemMap();
				for( crSightInfo::ItemMap::iterator itr = itemMap.begin();
					itr != itemMap.end();
					++itr )
				{
					item = itr->second;
					itemdata = item->getDataClass();
					if(itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							continue;
						}
					}
					if(m_fireItem.valid())
					{
						isEnemy = 0;
						m_fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(item.get(),&isEnemy));
						if(isEnemy == 1)//队友
							continue;
					}
					guisestate = GS_Normal;
					item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
						guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/|| guisestate & GS_NoAttack )
					{
						continue;
					}
					itempos = item->getPosition();
					dist = (itempos - hitpos).length();
					if(dist < mindist)
					{
						mindist = dist;
						shootItem = item;
					}
				}
				hitSight->unlockInSightItemMap();

				if(shootItem.valid())
				{
					m_count--;
					shootItem->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,m_count),m_this));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraChainMethod
//
/////////////////////////////////////////
crJXJExtraChainMethod::crJXJExtraChainMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_range(0.0f),
	m_haloExtraID(0),
	m_shootInterval(5.0f),
	m_shootCount(5),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
crJXJExtraChainMethod::crJXJExtraChainMethod(const crJXJExtraChainMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_range(handle.m_range),
	m_haloExtraID(handle.m_haloExtraID),
	m_shootInterval(handle.m_shootInterval),
	m_shootCount(handle.m_shootCount),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
void crJXJExtraChainMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_ExtraParam:
		{
			short count = *(short*)param;
			if(count>=0)
				m_count = count;
		}
		break;
	}
}

void crJXJExtraChainMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_range = atof(str.c_str());
		break;
	case 2:
		m_haloExtraID = (short)(atoi(str.c_str()));
		break;
	case 3:
		m_shootInterval = atof(str.c_str());
		break;
	case 4:
		m_shootCount = (short)(atoi(str.c_str()));
		m_count = m_shootCount;
		break;
	}
}

void crJXJExtraChainMethod::operator()(crHandle &handle)
{
	if(m_count<=0)
		return;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = m_shootInterval;

		////////设置寄生关系
		if (m_fireItem.valid()/* && m_fireItem != m_this*/)
		{
			void *param;
			ref_ptr<crInstanceItem> parasiticItem = m_fireItem.get();
			ref_ptr<crData> fireData = m_fireItem->getDataClass();
			if(fireData.valid())
			{
				fireData->getParam(WCHDATA_JXJExtraParasiticItem,param);
				if(param)
				{
					parasiticItem = (crInstanceItem *)param;
				}
				crData *thisData = m_this->getDataClass();
				thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
			}
		}
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;

		//////////设置寄生关系
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJExtraParasiticItem_RD,param);
		ref_ptr<crInstanceItem> parasiticItem = (crInstanceItem *)param;
		if(parasiticItem.valid())
		{
			thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
		}

		if(m_dtrec>=m_shootInterval)
		{//光环每隔1s对外作用一次
			m_dtrec -= m_shootInterval;
			ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
			if(hitSight.valid())
			{
				ref_ptr<crInstanceItem> shootItem;
				float mindist = m_range;
				float dist;
				crVector3 hitpos = m_this->getPosition();
				crVector3 itempos;
				ref_ptr<crInstanceItem> item;
				unsigned int guisestate = GS_Normal;
				ref_ptr<crData> itemdata;
				crData *extraData;
				crHandle *existHandle;
				void *param;
				unsigned char itemstate;

				ref_ptr<crSceneServerPlayerData> playerdata;
				hitSight->lockPlayerEyeMap();
				crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
				for (crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
					itr != playerEyeMap.end();
					++itr)
				{
					playerdata = itr->second;
					crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
					for (crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
						ritr != roleMap.end();
						++ritr)
					{
						item = dynamic_cast<crInstanceItem *>(ritr->second.get());
						itemdata = item->getDataClass();
						if (m_this != item.get() && itemdata.valid())
						{
							itemdata->getParam(WCHDATA_ItemState, param);
							itemstate = *(unsigned char *)param;
							if (itemstate == IS_Dead)
							{
								continue;
							}
							guisestate = GS_Normal;
							item->doEvent(MAKEINT64(WCH_GetGuiseState, 0), MAKEINT64(&guisestate, NULL));
							if (guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
								guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack)
							{
								continue;
							}
							itemdata->getParam(WCHDATA_ExtraData, param);
							extraData = (crData *)param;
							if (!extraData)
								continue;
							existHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra, m_haloExtraID));
							if (existHandle)
								continue;
							itempos = item->getPosition();
							dist = (itempos - hitpos).length();
							if (dist < mindist)
							{
								mindist = dist;
								shootItem = item;
							}
						}
					}
				}
				hitSight->unlockPlayerEyeMap();

				hitSight->lockItemEyeMap();
				crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
				for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
					itr != itemEyeMap.end();
					++itr )
				{
					item = itr->second;
					itemdata = item->getDataClass();
					if(m_this != item.get() && itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							continue;
						}

						guisestate = GS_Normal;
						item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
						if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
							guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/|| guisestate & GS_NoAttack )
						{
							continue;
						}
						itemdata->getParam(WCHDATA_ExtraData,param);
						extraData = (crData *)param;
						if(!extraData)
							continue;
						existHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,m_haloExtraID));
						if(existHandle)
							continue;
						itempos = item->getPosition();
						dist = (itempos - hitpos).length();
						if(dist < mindist)
						{
							mindist = dist;
							shootItem = item;
						}
					}
				}
				hitSight->unlockItemEyeMap();

				if(shootItem.valid())
				{
					m_count--;
					shootItem->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,m_count),m_this));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDChainMethod
//
/////////////////////////////////////////
crJXJExtraDChainMethod::crJXJExtraDChainMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_range(0.0f),
	m_haloExtraID(0),
	m_shootInterval(5.0f),
	m_shootCount(5),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
crJXJExtraDChainMethod::crJXJExtraDChainMethod(const crJXJExtraDChainMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_range(handle.m_range),
	m_haloExtraID(handle.m_haloExtraID),
	m_shootInterval(handle.m_shootInterval),
	m_shootCount(handle.m_shootCount),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
	m_count = m_shootCount;
}
void crJXJExtraDChainMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_ExtraParam:
		{
			short count = *(short*)param;
			if(count>=0)
				m_count = count;
		}
		break;
	}
}

void crJXJExtraDChainMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_range = atof(str.c_str());
		break;
	case 2:
		m_haloExtraID = (short)(atoi(str.c_str()));
		break;
	case 3:
		m_shootInterval = atof(str.c_str());
		break;
	case 4:
		m_shootCount = (short)(atoi(str.c_str()));
		m_count = m_shootCount;
		break;
	}
}

void crJXJExtraDChainMethod::operator()(crHandle &handle)
{
	if(m_count<=0)
		return;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = m_shootInterval;

		////////设置寄生关系
		if (m_fireItem.valid()/* && m_fireItem != m_this*/)
		{
			void *param;
			ref_ptr<crInstanceItem> parasiticItem = m_fireItem.get();
			ref_ptr<crData> fireData = m_fireItem->getDataClass();
			if(fireData.valid())
			{
				fireData->getParam(WCHDATA_JXJExtraParasiticItem,param);
				if(param)
				{
					parasiticItem = (crInstanceItem *)param;
				}
				crData *thisData = m_this->getDataClass();
				thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
			}
		}
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;

		////////设置寄生关系
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJExtraParasiticItem_RD,param);
		ref_ptr<crInstanceItem> parasiticItem = (crInstanceItem *)param;
		if(parasiticItem.valid())
		{
			thisData->inputParam(WCHDATA_JXJExtraParasiticItem,parasiticItem.get());
		}

		if(m_dtrec>=m_shootInterval)
		{//光环每隔5s对外作用一次
			m_dtrec -= m_shootInterval;
			ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
			if(hitSight.valid())
			{
				ref_ptr<crInstanceItem> shootItem;
				float mindist = m_range;
				float dist;
				crVector3 hitpos = m_this->getPosition();
				crVector3 itempos;
				ref_ptr<crInstanceItem> item;
				unsigned int guisestate = GS_Normal;
				ref_ptr<crData> itemdata;
				crData *extraData;
				crHandle *existHandle;
				void *param;
				unsigned char itemstate;
				char isEnemy = 0;

				hitSight->lockInSightRolePlayerMap();
				crSightInfo::RolePlayerMap &rolePlayerMap = hitSight->getInSightRolePlayerMap();
				for (crSightInfo::RolePlayerMap::iterator itr = rolePlayerMap.begin();
					itr != rolePlayerMap.end();
					++itr)
				{
					item = dynamic_cast<crInstanceItem*>(itr->second.get());
					itemdata = item->getDataClass();
					if (itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState, param);
						itemstate = *(unsigned char *)param;
						if (itemstate == IS_Dead)
						{
							continue;
						}
						if (m_fireItem.valid())
						{
							isEnemy = 0;
							m_fireItem->doEvent(WCH_EnemyCheck, MAKEINT64(item.get(), &isEnemy));
							if (isEnemy == 1)//队友
								continue;
						}
						guisestate = GS_Normal;
						item->doEvent(MAKEINT64(WCH_GetGuiseState, 0), MAKEINT64(&guisestate, NULL));
						if (guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
							guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/ || guisestate & GS_NoAttack)
						{
							continue;
						}
						itemdata->getParam(WCHDATA_ExtraData, param);
						extraData = (crData *)param;
						if (!extraData)
							continue;
						existHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra, m_haloExtraID));
						if (existHandle)
							continue;
						itempos = item->getPosition();
						dist = (itempos - hitpos).length();
						if (dist < mindist)
						{
							mindist = dist;
							shootItem = item;
						}
					}
				}
				hitSight->unlockInSightRolePlayerMap();

				hitSight->lockInSightItemMap();
				crSightInfo::ItemMap &itemMap = hitSight->getInSightItemMap();
				for( crSightInfo::ItemMap::iterator itr = itemMap.begin();
					itr != itemMap.end();
					++itr )
				{
					item = itr->second;
					itemdata = item->getDataClass();
					if(itemdata.valid())
					{
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							continue;
						}
						if(m_fireItem.valid())
						{
							isEnemy = 0;
							m_fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(item.get(),&isEnemy));
							if(isEnemy == 1)//队友
								continue;
						}
						guisestate = GS_Normal;
						item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
						if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
							guisestate & GS_Stagnate || guisestate & GS_immunoSkill/* || guisestate & GS_Nihility*/|| guisestate & GS_NoAttack )
						{
							continue;
						}
						itemdata->getParam(WCHDATA_ExtraData,param);
						extraData = (crData *)param;
						if(!extraData)
							continue;
						existHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,m_haloExtraID));
						if(existHandle)
							continue;
						itempos = item->getPosition();
						dist = (itempos - hitpos).length();
						if(dist < mindist)
						{
							mindist = dist;
							shootItem = item;
						}
					}
				}
				hitSight->unlockInSightItemMap();

				if(shootItem.valid())
				{
					m_count--;
					shootItem->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_haloExtraID,m_count),m_this));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJEquipExtraMethod
//
/////////////////////////////////////////
crJXJEquipExtraMethod::crJXJEquipExtraMethod():
	m_this(NULL){}
crJXJEquipExtraMethod::crJXJEquipExtraMethod(const crJXJEquipExtraMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJEquipExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJEquipExtraMethod::addParam(int i, const std::string& str)
{
}
void crJXJEquipExtraMethod::operator()(crHandle &handle)
{
	//crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	//crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	//crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	//CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	void *param;
	crData *userData = m_this->getDataClass();
	userData->getParam(WCHDATA_ExtraData,param);
	crData *extraData = (crData *)param;
	if(/*scene && */extraData)
	{
		//unsigned char usertype = m_this->getItemtype();
		//int userid = m_this->getID();
		//int userroleid = m_this->getRoleID();
		//ref_ptr<crSceneServerPlayerData> playerData;
		//if(usertype == crInstanceItem::Role)
		//	playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(userid));
		//ref_ptr<crStreamBuf> stream = new crStreamBuf;
		//stream->createBuf(4);

		crHandle *handle;
		crHandle *cloneHandle;
		_crInt32 equipExtraID;
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		userData->getParam(WCHDATA_EquipOnMap,param);
		EquipOnMap equipOnMap = *(EquipOnMap *)param;
		userData->excHandle(MAKEINT64(WCH_LockData,0));
		crItemChild *itemChild;
		crInstanceItem *equip;
		crData *bulletData;
		short extraid,extrapri;
		bool can = true;
		ExtraIDMap *extraIDMap;
		//crPlayerEventPacket packet;
		//crItemEventPacket itempacket;

		for( EquipOnMap::iterator itr = equipOnMap.begin();
			itr != equipOnMap.end();
			++itr )
		{
			itemChild = m_this->findChildItem(itr->second);
			if(itemChild && itemChild->isLoaded())
			{
				equip = itemChild->getInstanceItem();
				///WCH_EquipExtra
				bulletData = equip->getDataClass();
				if(bulletData)
				{
					if(crGlobalHandle::isClient())
						handle = bulletData->getHandle(MAKEINT64(WCH_EquipExtra,WCH_Client));
					else
						handle = bulletData->getHandle(MAKEINT64(WCH_EquipExtra,WCH_Server));
					if(handle)
					{
						bulletData->getParam(WCHDATA_EquipExtraID,param);
						equipExtraID = *((_crInt32*)param);

						can = true;
						extraid = LOINT32(equipExtraID);
						extrapri = HIINT32(equipExtraID);
						extraData->excHandle(MAKEINT64(WCH_LockData,1));
						extraData->getParam(WCHDATA_ExtraIDMap,param);
						extraIDMap = (ExtraIDMap *)param;
						ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
						if(exitr != extraIDMap->end())
						{
							if(extrapri<HIINT16(exitr->second))
							{
								can = false;
							}
						}
						if(can)
						{
							cloneHandle = handle->clone();
							if(crGlobalHandle::isClient())
							{
								crVector3 dir = m_this->getDir();
								cloneHandle->inputParam(WCHDATA_AttachDir,&dir);
								cloneHandle->inputParam(WCHDATA_FireItem,m_this);
								crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
								if(existhandle)
								{
									existhandle->releaseObjects(NULL);
								}
							}
							extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
							(*extraIDMap)[extraid] = MAKEINT16(0,extrapri);
						}
						extraData->excHandle(MAKEINT64(WCH_LockData,0));
						////if(can)
						////{
						////	stream->seekBegin();
						////	stream->_writeInt(equip->getInstanceItemID());
						////	if(usertype == crInstanceItem::Role)
						////	{
						////		crPlayerEventPacket::buildRequestPacket(packet,userid,userid,userroleid,WCH_RecvEquipExtra,stream.get());
						////		if(playerData.valid())
						////		{
						////			sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						////			scene->sendPacketToItemNeighbor(m_this,packet);
						////		}
						////	}
						////	else
						////	{
						////		crItemEventPacket::buildRequestPacket(itempacket,0,m_this,WCH_RecvEquipExtra,stream.get());
						////		scene->sendPacketToItemNeighbor(m_this,packet);
						////	}
						////}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJReliveExtraMethod
//
/////////////////////////////////////////
crJXJReliveExtraMethod::crJXJReliveExtraMethod():
	m_this(NULL){}
crJXJReliveExtraMethod::crJXJReliveExtraMethod(const crJXJReliveExtraMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJReliveExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJReliveExtraMethod::addParam(int i, const std::string& str)
{
}
void crJXJReliveExtraMethod::operator()(crHandle &handle)
{
	if (m_this->getInstanceItemID() > 0)
	{//克隆的出生是不给无敌buf
		m_this->doEvent(WCH_ExtraHandle, MAKEINT64(MAKEINT32(Ext_Relive, -1), NULL));
	}
}
///////////////////////////////////////////
////
////crJXJRecvEquipExtraMethod
////
///////////////////////////////////////////
//crJXJRecvEquipExtraMethod::crJXJRecvEquipExtraMethod(){}
//crJXJRecvEquipExtraMethod::crJXJRecvEquipExtraMethod(const crJXJRecvEquipExtraMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvEquipExtraMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvEquipExtraMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvEquipExtraMethod::operator()(crHandle &handle)
//{
//	if(m_stream.valid())
//	{
//		crData *data = m_this->getDataClass();
//
//		int bulletitemid = m_stream->_readInt();
//		do 
//		{
//			//if(!fireItem) break;
//			crItemChild *itemChild = m_this->findChildItem(bulletitemid);
//			if(!itemChild || !itemChild->isLoaded()) break;
//			crInstanceItem *bulletitem = itemChild->getInstanceItem();
//			if(!bulletitem) break;
//
//			void *param;
//			crData *bulletData = bulletitem->getDataClass();
//			if(!bulletData) break;
//			crHandle *handle = bulletData->getHandle(MAKEINT64(WCH_EquipExtra,WCH_Client));
//			if(!handle) break;
//
//			bulletData->getParam(WCHDATA_EquipExtraID,param);
//			_crInt32 equipExtraID = *((_crInt32*)param);
//
//			crData *hitData = m_this->getDataClass();
//			//hitData->excHandle(MAKEINT64(WCH_LockData,1));
//			hitData->getParam(WCHDATA_ExtraData,param);
//			crData *extraData = (crData *)param;
//			if(extraData)
//			{
//				bool can = true;
//				short extraid = LOINT32(equipExtraID);
//				short extrapri = HIINT32(equipExtraID);
//				extraData->excHandle(MAKEINT64(WCH_LockData,1));
//				extraData->getParam(WCHDATA_ExtraIDMap,param);
//				ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
//				ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
//				if(exitr != extraIDMap->end())
//				{
//					if(extrapri<exitr->second)
//					{
//						can = false;
//					}
//				}
//				if(can)
//				{
//					crHandle *cloneHandle = handle->clone();
//					crVector3 dir = m_this->getDir();
//					cloneHandle->inputParam(WCHDATA_AttachDir,&dir);
//					cloneHandle->inputParam(WCHDATA_FireItem,m_this);
//					crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
//					if(existhandle)
//					{
//						existhandle->releaseObjects(NULL);
//					}
//
//					extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
//					(*extraIDMap)[extraid] = extrapri;
//				}
//				extraData->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//			//hitData->excHandle(MAKEINT64(WCH_LockData,0));
//		} while (0);
//	}
//}
//////////////////////////////////////////////////////////////////////////
//
//crJXJArmyTypeCheckMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJArmyTypeCheckMethod::crJXJArmyTypeCheckMethod():m_this(NULL)
{

}
crJXJArmyTypeCheckMethod::crJXJArmyTypeCheckMethod(const crJXJArmyTypeCheckMethod& handle):
	crMethod(handle),
	m_this(NULL)
{

}
void crJXJArmyTypeCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJArmyTypeCheckMethod::addParam(int i, const std::string& str)
{

}
void crJXJArmyTypeCheckMethod::operator ()(crHandle &handle)
{
	int armyType = -1;
	crData *thisData = m_this->getDataClass();
	void *param;
	thisData->getParam(WCHDATA_JXJTroopType,param);
	armyType = *(unsigned char *)param;
	//int abstractid = m_this->getAbstractItemID();
	//crTableIO::StrVec record;
	//ref_ptr<crTableIO> roleAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);
	//int index = roleAttrTab->getTitleIndex("兵种");
	//if(roleAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record)>=0)
	//{
	//	armyType = atoi(record[index].c_str());
	//}
	//else
	//{
	//	ref_ptr<crTableIO> npcAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
	//	index = npcAttrTab->getTitleIndex("兵种");
	//	if(npcAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record)>=0)
	//	{
	//		armyType = atoi(record[index].c_str());
	//	}
	//}
	handle.outputParam(0,&armyType);
}

//////////////////////////////////////////////////////////////////////////
//
//crJXJHitArmyTypeCheckMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJHitArmyTypeCheckMethod::crJXJHitArmyTypeCheckMethod():m_this(NULL)
{

}
crJXJHitArmyTypeCheckMethod::crJXJHitArmyTypeCheckMethod(const crJXJHitArmyTypeCheckMethod& handle):
	crMethod(handle),
	m_this(NULL)
{

}
void crJXJHitArmyTypeCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJHitArmyTypeCheckMethod::addParam(int i, const std::string& str)
{

}
void crJXJHitArmyTypeCheckMethod::operator ()(crHandle &handle)
{
	if(m_hitParam.valid() && m_hitParam->m_hitItem.valid())
	{
		int armyType = -1;
		crData *thisData = m_hitParam->m_hitItem->getDataClass();
		if(thisData)
		{
			void *param;
			thisData->getParam(WCHDATA_JXJTroopType,param);
			armyType = *(unsigned char *)param;
		}
		//int abstractid = m_hitParam->m_hitItem->getAbstractItemID();
		//crTableIO::StrVec record;
		//ref_ptr<crTableIO> roleAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);
		//int index = roleAttrTab->getTitleIndex("兵种");
		//if(roleAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record)>=0)
		//{
		//	armyType = atoi(record[index].c_str());
		//}
		//else
		//{
		//	ref_ptr<crTableIO> npcAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
		//	index = npcAttrTab->getTitleIndex("兵种");
		//	if(npcAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record)>=0)
		//	{
		//		armyType = atoi(record[index].c_str());
		//	}
		//}
		handle.outputParam(0,&armyType);
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJFireArmyTypeCheckMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJFireArmyTypeCheckMethod::crJXJFireArmyTypeCheckMethod():m_this(NULL)
{

}
crJXJFireArmyTypeCheckMethod::crJXJFireArmyTypeCheckMethod(const crJXJFireArmyTypeCheckMethod& handle):
	crMethod(handle),
	m_this(NULL)
{

}
void crJXJFireArmyTypeCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJFireArmyTypeCheckMethod::addParam(int i, const std::string& str)
{

}
void crJXJFireArmyTypeCheckMethod::operator ()(crHandle &handle)
{
	if(m_hitParam.valid() && m_hitParam->m_fireItem.valid())
	{
		void *param;
		int armyType = -1;
		// 		int abstractid = m_hitParam->m_fireItem->getAbstractItemID();
		// 		crTableIO::StrVec record;
		// 		ref_ptr<crTableIO> roleAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);
		// 		int index = roleAttrTab->getTitleIndex("兵种");
		// 		if(roleAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record)>=0)
		// 		{
		// 			armyType = atoi(record[index].c_str());
		// 		}
		// 		else
		// 		{
		// 			ref_ptr<crTableIO> npcAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcDataAttrTab);
		// 			index = npcAttrTab->getTitleIndex("兵种");
		// 			if(npcAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),record)>=0)
		// 			{
		// 				armyType = atoi(record[index].c_str());
		// 			}
		// 		}
		// 		
		ref_ptr<crData> fireData = m_hitParam->m_fireItem->getDataClass();
		if(fireData.valid())
		{
			fireData->getParam(WCHDATA_JXJTroopType,param);
			armyType = *(unsigned char *)param;
		}
		handle.outputParam(0,&armyType);
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJArmyAbstractIDCheckMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJArmyAbstractIDCheckMethod::crJXJArmyAbstractIDCheckMethod():m_this(NULL)
{

}
crJXJArmyAbstractIDCheckMethod::crJXJArmyAbstractIDCheckMethod(const crJXJArmyAbstractIDCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_idvec(handle.m_idvec)
{

}
void crJXJArmyAbstractIDCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJArmyAbstractIDCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_idvec);
		break;
	}
}
void crJXJArmyAbstractIDCheckMethod::operator ()(crHandle &handle)
{
	bool yes = false;
	int abstractid = m_this->getAbstractItemID();
	for( std::vector<int>::iterator itr = m_idvec.begin();
		itr != m_idvec.end();
		++itr )
	{
		if(abstractid == *itr)
		{
			yes = true;
			break;
		}
	}
	handle.outputParam(0,&yes);
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJHitArmyAbstractIDCheckMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJHitArmyAbstractIDCheckMethod::crJXJHitArmyAbstractIDCheckMethod():
	m_this(NULL)
{

}
crJXJHitArmyAbstractIDCheckMethod::crJXJHitArmyAbstractIDCheckMethod(const crJXJHitArmyAbstractIDCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_idvec(handle.m_idvec)
{

}
void crJXJHitArmyAbstractIDCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJHitArmyAbstractIDCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_idvec);
		break;
	}
}
void crJXJHitArmyAbstractIDCheckMethod::operator ()(crHandle &handle)
{
	bool yes = false;
	if(m_hitParam.valid() && m_hitParam->m_hitItem.valid())
	{
		int abstractid = m_hitParam->m_hitItem->getAbstractItemID();
		for( std::vector<int>::iterator itr = m_idvec.begin();
			itr != m_idvec.end();
			++itr )
		{
			if(abstractid == *itr)
			{
				yes = true;
				break;
			}
		}
	}
	handle.outputParam(0,&yes);
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJFireArmyAbstractIDCheckMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJFireArmyAbstractIDCheckMethod::crJXJFireArmyAbstractIDCheckMethod():
	m_this(NULL)
{

}
crJXJFireArmyAbstractIDCheckMethod::crJXJFireArmyAbstractIDCheckMethod(const crJXJFireArmyAbstractIDCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_idvec(handle.m_idvec)
{

}
void crJXJFireArmyAbstractIDCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJFireArmyAbstractIDCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_idvec);
		break;
	}
}
void crJXJFireArmyAbstractIDCheckMethod::operator ()(crHandle &handle)
{
	bool yes = false;
	if(m_hitParam.valid() && m_hitParam->m_fireItem.valid())
	{
		int abstractid = m_hitParam->m_fireItem->getAbstractItemID();
		for( std::vector<int>::iterator itr = m_idvec.begin();
			itr != m_idvec.end();
			++itr )
		{
			if(abstractid == *itr)
			{
				yes = true;
				break;
			}
		}
	}
	handle.outputParam(0,&yes);
}
/////////////////////////////////////////
//
//crJXJExtraCritPercentMethod
//
/////////////////////////////////////////
crJXJExtraCritPercentMethod::crJXJExtraCritPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraCritPercentMethod::crJXJExtraCritPercentMethod(const crJXJExtraCritPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraCritPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraCritPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraCritPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraCritPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraCritMethod
//
/////////////////////////////////////////
crJXJExtraCritMethod::crJXJExtraCritMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraCritMethod::crJXJExtraCritMethod(const crJXJExtraCritMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraCritMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraCritMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraCritMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraCrit,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}

/////////////////////////////////////////
//
//crJXJExtraBuildingAttackPercentMethod
//
/////////////////////////////////////////
crJXJExtraBuildingAttackPercentMethod::crJXJExtraBuildingAttackPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{}
crJXJExtraBuildingAttackPercentMethod::crJXJExtraBuildingAttackPercentMethod(const crJXJExtraBuildingAttackPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraBuildingAttackPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraBuildingAttackPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraBuildingAttackPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraBuildAttackPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}

/////////////////////////////////////////
//
//crJXJExtraParrayPercentMethod
//
/////////////////////////////////////////
crJXJExtraParrayPercentMethod::crJXJExtraParrayPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraParrayPercentMethod::crJXJExtraParrayPercentMethod(const crJXJExtraParrayPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraParrayPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraParrayPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraParrayPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraParryPercent,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraParrayMethod
//
/////////////////////////////////////////
crJXJExtraParrayMethod::crJXJExtraParrayMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraParrayMethod::crJXJExtraParrayMethod(const crJXJExtraParrayMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraParrayMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraParrayMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraParrayMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraParry,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraAttackDistMethod
//
/////////////////////////////////////////
crJXJExtraAttackDistMethod::crJXJExtraAttackDistMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraAttackDistMethod::crJXJExtraAttackDistMethod(const crJXJExtraAttackDistMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(handle.m_overlapCount)
{
}
void crJXJExtraAttackDistMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraAttackDistMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraAttackDistMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraAttackDist,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		//*extra += m_extraValue;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));
		if(m_duration>0.0f) m_timer -= *m_dt;
	}
}
/////////////////////////////////////////
//
//crJXJCheckTouchMethod
//
/////////////////////////////////////////
crJXJCheckTouchMethod::crJXJCheckTouchMethod():
	m_dist(5.0f){}
crJXJCheckTouchMethod::crJXJCheckTouchMethod(const crJXJCheckTouchMethod& handle):
	crMethod(handle),
	m_dist(handle.m_dist)
{
}
void crJXJCheckTouchMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
		//case 2:
		//	if(param)
		//	{
		//		_crInt64 param64 = *(_crInt64*)param;
		//		m_ea = (crGUIEventAdapter *)(LOINT64(param64));
		//		m_camera = (crMatrixTransform *)(HIINT64(param64));
		//	}
		//	else
		//	{
		//		m_ea = NULL;
		//		m_camera = NULL;
		//	}
		//	break;
	}
}

void crJXJCheckTouchMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_dist = atof(str.c_str());
		break;
	}
}

void crJXJCheckTouchMethod::operator()(crHandle &handle)
{
	int touched = 0;
	void *param;
	crData *itemData = m_this->getDataClass();
	itemData->getParam(WCHDATA_ItemState,param);
	unsigned char itemState = 0;
	if(param)
		itemState = *(unsigned char*)param;
	if(itemState == IS_Dead)
	{
		touched = 1;
	}
	else if(crRunGameHandle::getInstance()->isInGame())
	{
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if(camera.valid())
		{
			crData *cameraData = camera->getAttachedNode()->getDataClass();
			CRCore::ScopedLock<crData> lock(*cameraData);
			cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
			SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
			if(!selectMyRoles->empty())
			{
				crVector3 itempos = m_this->getPosition();
				crVector3 mypos;
				for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
					itr != selectMyRoles->end();
					++itr )
				{
					mypos = (*itr)->getPosition();
					if((mypos - itempos).length()<m_dist)
					{
						touched = 2;
						break;
					}
				}
			}
		}
	}
	handle.outputParam(0,&touched);
}
/////////////////////////////////////////
//
//crJXJTouchSceneItemMethod
//
/////////////////////////////////////////
crJXJTouchSceneItemMethod::crJXJTouchSceneItemMethod(){}
crJXJTouchSceneItemMethod::crJXJTouchSceneItemMethod(const crJXJTouchSceneItemMethod& handle):
	crMethod(handle)
{
}
void crJXJTouchSceneItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJTouchSceneItemMethod::addParam(int i, const std::string& str)
{
}

void crJXJTouchSceneItemMethod::operator()(crHandle &handle)
{
	void *param;
	crData *itemData = m_this->getDataClass();
	if(itemData)
	{
		itemData->excHandle(MAKEINT64(WCH_LockData,1));
		itemData->getParam(WCHDATA_ItemState,param);
		unsigned char *itemState = (unsigned char *)param;
		if(*itemState!=IS_Dead)
		{
			crPlayerGameData *myplayer = crMyPlayerData::getInstance()->getPlayerGameData();
			if(myplayer)
			{
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(myplayer->getPlayerID());//
					crPlayerServerEventPacket packet;
					crPlayerServerEventPacket::buildRequestPacket(packet,WCH_RecvTouch,m_this,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			*itemState = IS_Dead;
		}
		itemData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvTouchMethod
//
/////////////////////////////////////////
crJXJClientRecvTouchMethod::crJXJClientRecvTouchMethod(){}
crJXJClientRecvTouchMethod::crJXJClientRecvTouchMethod(const crJXJClientRecvTouchMethod& handle):
	crMethod(handle)
{
}
void crJXJClientRecvTouchMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJClientRecvTouchMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientRecvTouchMethod::operator()(crHandle &handle)
{
	void *param;
	crData *itemData = m_this->getDataClass();
	if(itemData)
	{
		itemData->excHandle(MAKEINT64(WCH_LockData,1));
		itemData->getParam(WCHDATA_ItemState,param);
		unsigned char *itemState = (unsigned char *)param;
		*itemState = IS_Dead;
		itemData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSceneItemDropMethod
//
/////////////////////////////////////////
crJXJSceneItemDropMethod::crJXJSceneItemDropMethod():
	m_abstractdrop(false){}
crJXJSceneItemDropMethod::crJXJSceneItemDropMethod(const crJXJSceneItemDropMethod& handle):
	crMethod(handle),
	m_abstractdrop(false)
{
}
void crJXJSceneItemDropMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJSceneItemDropMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_abstractdrop = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJSceneItemDropMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		void *param;
		crData *itemData = m_this->getDataClass();
		if(itemData) 
		{
			itemData->excHandle(MAKEINT64(WCH_LockData,1));
			itemData->getParam(WCHDATA_ItemState,param);
			unsigned char *itemState = (unsigned char *)param;
			if(*itemState==IS_Dead)
			{
				itemData->excHandle(MAKEINT64(WCH_LockData,0));
				return;
			}
			*itemState = IS_Dead;
			itemData->excHandle(MAKEINT64(WCH_LockData,0));
		}
		int playerid = m_stream->_readInt();
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
		if(playerData.valid() && scene)
		{
			//场景掉落
			ref_ptr<crTableIO> dropTab;
			int id;
			if(m_abstractdrop)
			{
				id = m_this->getAbstractItemID();
				dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDrop2Tab);
			}
			else
			{
				id = m_this->getInstanceItemID();
				if(id<=0)
				{
					id = m_this->getAbstractItemID();
					dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDrop2Tab);
				}
				else
				{
					dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDropTab);
				}
			}
			if(dropTab.valid())
			{
				crTableIO::DataVec recordVec;
				dropTab->queryRecords(0,crArgumentParser::appItoa(id),recordVec);
				if(!recordVec.empty())
				{
					//参考crJXJServerOpenTreasureChestMethod
					int dropcountid = dropTab->getTitleIndex("掉落种数");
					int droptypeid = dropTab->getTitleIndex("掉落类型");
					int dropidindex = dropTab->getTitleIndex("dropid");
					int oddsid = dropTab->getTitleIndex("掉落几率");
					int countid = dropTab->getTitleIndex("数量");
					int dropcount = atoi(recordVec[0][dropcountid].c_str());
					//crData *userData = playerData->getPlayerGameData()->getDataClass();
					//userData->excHandle(MAKEINT64(WCH_LockData,1));
					//int packetRemainSize = 0;
					int odds = 0;
					//bool isdroped;
					unsigned char droptype;
					int count;
					crVector2i countrange;
					CRCore::rangei counrnd;
					//RewardItemVec rewarditemvec;
					//ref_ptr<crBagItemData> itemdata;
					std::vector<std::pair<int,int> > DropedResVec;//resid,count
					std::vector<std::pair<unsigned short,int> > DropedEquipVec;//equipid,count
					std::vector<crVector3i> DropedItemVec;//itemid,equipmagic,count
					//crRole *mainRole = playerData->getPlayerGameData()->getMainRole();
					int recordCount = recordVec.size();
					std::vector< std::pair<int,int> >DroprndVec;
					int i,j,k;
					int dropodds;
					for (i = 0; i < recordCount; i++)
					{
						dropodds = atoi(recordVec[i][oddsid].c_str());
						odds += dropodds;
						DroprndVec.push_back(std::make_pair(odds,dropodds));
					}
					crVector2i vec2;
					rangei rndi(0,odds);
					int r;
					for(i = 0; i<dropcount;i++)
					{
						r = rndi.get_random();
						for(j = 0; j<recordCount; j++)
						{
							if(r<=DroprndVec[j].first)
							{//该物品掉出
								DroprndVec[j].first = -1;
								odds -= DroprndVec[j].second;
								rndi.set(0,odds);
								for (k = j+1; k < recordCount; k++)
								{
									DroprndVec[k].first -= DroprndVec[j].second;
								}
								droptype = atoi(recordVec[j][droptypeid].c_str());

								crArgumentParser::appAtoVec(recordVec[j][countid],countrange);
								counrnd.set(countrange[0],countrange[1]);
								count = counrnd.get_random();
								if(count>0)
								{
									droptype = atoi(recordVec[j][droptypeid].c_str());
									switch (droptype)
									{
									case T_Food:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJFood,count));
										break;
									case T_Wood:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJWood,count));
										break;
									case T_Iron:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJIron,count));
										break;
									case T_Horse:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJHorse,count));
										break;
									case T_Copper:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJCoppercash,count));
										break;
									case T_Exp:
										DropedResVec.push_back(std::make_pair(WCHDATA_Experience,count));
										break;
									case T_Achievement:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJAchievement,count));
										break;
									case T_Giftgold:
										DropedResVec.push_back(std::make_pair(WCHDATA_JXJGiftGold,count));
										break;
									case T_TroopsEquip:
										DropedEquipVec.push_back(std::make_pair(atoi(recordVec[j][dropidindex].c_str()),count));
										break;
									case T_Item:
										{
											crArgumentParser::appAtoVec(recordVec[j][dropidindex],vec2);
											DropedItemVec.push_back(crVector3i(vec2[0],vec2[1],count));
										}
										break;
									}
								}
								break;
							}
						}
					}
					//写入包发给服务器 客户端
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					//ref_ptr<crStreamBuf> gameServer_stream = new crStreamBuf;
					//写掉落信息
					int ressize = DropedResVec.size();
					int equipsize = DropedEquipVec.size();
					int itemsize = DropedItemVec.size();
					stream->createBuf(7+ressize*8+itemsize*9+equipsize*6);
					//gameServer_stream->createBuf(7+(ressize+itemsize)*8+equipsize*6);
					stream->_writeInt(playerid);
					stream->_writeUChar(ressize);
					//gameServer_stream->_writeUChar(ressize);
					for( std::vector<std::pair<int,int> >::iterator itr = DropedResVec.begin();
						itr != DropedResVec.end();
						++itr )
					{
						stream->_writeInt(itr->first);
						stream->_writeInt(itr->second);
						//gameServer_stream->_writeInt(itr->first);
						//gameServer_stream->_writeInt(itr->second);
					}
					stream->_writeUChar(equipsize);
					//gameServer_stream->_writeUChar(equipsize);
					for( std::vector<std::pair<unsigned short,int> >::iterator itr = DropedEquipVec.begin();
						itr != DropedEquipVec.end();
						++itr )
					{
						stream->_writeUShort(itr->first);
						stream->_writeInt(itr->second);
						//gameServer_stream->_writeUShort(itr->first);
						//gameServer_stream->_writeInt(itr->second);
					}
					stream->_writeUChar(itemsize);
					//gameServer_stream->_writeUChar(itemsize);
					for( std::vector<crVector3i>::iterator itr = DropedItemVec.begin();
						itr != DropedItemVec.end();
						++itr )
					{
						stream->_writeInt((*itr)[0]);
						stream->_writeInt((*itr)[1]);//equipmagic
						stream->_writeUChar((*itr)[2]);
						//gameServer_stream->_writeInt((*itr)[0]);
						//gameServer_stream->_writeUShort((*itr)[1]);equipmagic
						//gameServer_stream->_writeUChar((*itr)[2]);
					}

					//服务器
					crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
					crJXJDropedItemPacket gameServerPacket;
					crJXJDropedItemPacket::buildRequestPacket(gameServerPacket,stream.get());
					netConductor->getNetManager()->sendPacket("all",gameServerPacket);
					//客户端
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_ClientRecvTouch,NULL);
					scene->sendPacketToItemNeighbor(m_this,packet);
					//sceneServerConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvSceneItemDropMethod
//
/////////////////////////////////////////
crJXJClientRecvSceneItemDropMethod::crJXJClientRecvSceneItemDropMethod(){}
crJXJClientRecvSceneItemDropMethod::crJXJClientRecvSceneItemDropMethod(const crJXJClientRecvSceneItemDropMethod& handle):
	crMethod(handle)
{
}
void crJXJClientRecvSceneItemDropMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvSceneItemDropMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientRecvSceneItemDropMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{//效果及显示

	}
}
/////////////////////////////////////////////////////////////////////////
//
//crJXJRecvSceneItemDropMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJRecvSceneItemDropMethod::crJXJRecvSceneItemDropMethod(){}
crJXJRecvSceneItemDropMethod::crJXJRecvSceneItemDropMethod(const crJXJRecvSceneItemDropMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSceneItemDropMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSceneItemDropMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSceneItemDropMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{//处理数据
		int playerid = m_stream->_readInt();
		unsigned char ressize = m_stream->_readUChar();
		ref_ptr<crPlayerRewardData> reward_info = new crPlayerRewardData;
		reward_info->setPlayerID(playerid);
		reward_info->setType(GP_RewardDropItems);
		RewardEquipsVec reward_equip;
		for(int i = 0;i<ressize;i++)
		{
			int type_id =  m_stream->_readInt();
			int count = m_stream->_readInt();
			switch (type_id) 
			{
			case WCHDATA_JXJFood:
				reward_info->setFood(count);
				break;
			case WCHDATA_JXJWood:
				reward_info->setWood(count);
				break;
			case WCHDATA_JXJIron:
				reward_info->setIron(count);
				break;
			case WCHDATA_JXJHorse:
				reward_info->setHorse(count);
				break;
			case WCHDATA_JXJCoppercash:
				reward_info->setCoopercash(count);
				break;
			case WCHDATA_Experience:
				reward_info->setExperience(count);
				break;
			case WCHDATA_JXJAchievement:
				reward_info->setAchievement(count);
				break;
			case WCHDATA_JXJGiftGold:
				reward_info->setGiftgold(count);
				break;
			}
		}

		unsigned char equipsize = m_stream->_readUChar();
		for(int i = 0;i<equipsize;i++)
		{
			unsigned short equipid = m_stream->_readUShort();
			int equip_count = m_stream->_readInt();
			reward_info->getEquipsVec().push_back(std::make_pair(equipid,equip_count));
		}

		unsigned char itemsize = m_stream->_readUChar();
		ref_ptr<crBagItemData> itemdata;
		int itemid;
		_crInt32 equipmagic;
		unsigned char item_count;
		for(int i = 0;i<itemsize;i++)
		{
			itemid = m_stream->_readInt();
			equipmagic = m_stream->_readInt();
			item_count = m_stream->_readUChar();
			if(itemid>0 && item_count>0)
			{
				itemdata = new crBagItemData;
				itemdata->setItemID(itemid);
				itemdata->setEquipMagic(equipmagic);
				itemdata->setItemCount(item_count);
				reward_info->getRewardItemsVec().push_back(itemdata);
			}
		}

		//服务器处理信息
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData;
		crData *pgData;
		playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));	
		if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
		{
			pgData = playerData->getPlayerGameData()->getDataClass();
			pgData->excHandle(MAKEINT64(WCH_LockData,1));
			reward_info->setType(GP_RewardDropItems);
			playerData->getPlayerGameData()->doEvent(WCH_JXJRecvPlayerRewardInfo,MAKEINT64(reward_info.get(),NULL));
			pgData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJIsNpcChengchiMethod
//
/////////////////////////////////////////
crJXJIsNpcChengchiMethod::crJXJIsNpcChengchiMethod(){}
crJXJIsNpcChengchiMethod::crJXJIsNpcChengchiMethod(const crJXJIsNpcChengchiMethod& handle):
	crMethod(handle)
{
}
void crJXJIsNpcChengchiMethod::addParam(int i, const std::string& str)
{
}
void crJXJIsNpcChengchiMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJIsNpcChengchiMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJBattleID,param);
	int battleid = *(int *)param;
	unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
	//unsigned char startShiliID = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str()));
	bool npcchengchi = defenceShili<c_startShiliID;
	handle.outputParam(0,&npcchengchi);
}
/////////////////////////////////////////
//
//crJXJLoadNpcEquipsFromTabMethod
//
/////////////////////////////////////////
crJXJLoadNpcEquipsFromTabMethod::crJXJLoadNpcEquipsFromTabMethod(){}
crJXJLoadNpcEquipsFromTabMethod::crJXJLoadNpcEquipsFromTabMethod(const crJXJLoadNpcEquipsFromTabMethod& handle):
	crMethod(handle)
{
}
void crJXJLoadNpcEquipsFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJLoadNpcEquipsFromTabMethod::addParam(int i, const std::string& str)
{
}

void crJXJLoadNpcEquipsFromTabMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO> npcEquipsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcEquipsTab);
	if(npcEquipsTab.valid())
	{
		crTableIO::StrVec record;
		int id = m_this->getInstanceItemID();//m_this->getAbstractItemID();
		if(npcEquipsTab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
		{
			int columncount = npcEquipsTab->getColumnCount();
			int equipid;
			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_EquipOnMap,param);
			EquipOnMap *equipOnMap = (EquipOnMap *)param;
			for( int i = 2; i<columncount; i++ )
			{
				if(!record[i].empty())
				{
					equipid = atoi(record[i].c_str());
					if(equipid>0)
						(*equipOnMap).insert(std::make_pair(equipid,0));
				}
				else
				{
					break;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJGuiseStateRenderMethod
//
/////////////////////////////////////////
crJXJGuiseStateRenderMethod::crJXJGuiseStateRenderMethod():
	m_lastTrans(0),
	m_interval(3.0f),
	m_alpha(0.5f),
	m_speed(2.0f),
	m_specFlg(0){}
crJXJGuiseStateRenderMethod::crJXJGuiseStateRenderMethod(const crJXJGuiseStateRenderMethod& handle):
	crMethod(handle),
	m_lastTrans(0),
	m_interval(handle.m_interval),
	m_alpha(handle.m_alpha),
	m_speed(handle.m_speed),
	m_specFlg(handle.m_specFlg)
{
}
void crJXJGuiseStateRenderMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == NULL)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJGuiseStateRenderMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	case 1:
		m_alpha = atof(str.c_str());
		break;
	case 2:
		m_speed = atof(str.c_str());
		break;
	case 3:
		m_specFlg = atoi(str.c_str());
		break;
	}
}
void crJXJGuiseStateRenderMethod::autoTrans(CRCore::crNode *relNode)
{
	int autotrans = 1;
	crAutoTransCallback *callback;
	CRCore::crCollectNodeBYClassNameVisitor searchVisitor;
	searchVisitor.insertClassNameId("crObject");
	relNode->accept(searchVisitor);
	NodeArray &objectArray = searchVisitor.getResult();
	for( NodeArray::iterator itr = objectArray.begin();
		itr != objectArray.end();
		++itr )
	{
		autotrans = 1;
		if(crArgumentParser::readKeyValue((*itr)->getDescriptions(),"AutoTrans",autotrans) && !autotrans)
			continue;
		callback = dynamic_cast<crAutoTransCallback *>((*itr)->getCullCallback("AutoTrans"));
		if(!callback)
		{
			callback = dynamic_cast<crAutoTransCallback *>(crEventCallbackManager::getInstance()->getEventCallback("AutoTrans"));
			(*itr)->addCullCallback(callback);
		}
		if(callback)
		{
			callback->setAutoTrans(m_interval,m_alpha);
			callback->setSpeed(m_speed);
		}
		(dynamic_cast<crObject *>(itr->get()))->setDrawOutLine(0);
	}
}
void crJXJGuiseStateRenderMethod::operator()(crHandle &handle)
{
	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
	unsigned int guisestate = GS_Normal;
	m_this->doEvent(WCH_GetGuiseState,MAKEINT64(&guisestate,NULL));
	crNode *relNode = m_this->getRelNode();
	if(me && relNode)
	{
		crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
		//bool isShareSight = room && room->getShareSight();
		unsigned char isEnemy = 0;
		me->doEvent(WCH_EnemyCheck,MAKEINT64(m_this,&isEnemy));
		//if(guisestate & GS_Sheep)
		//{
		//}
		//if(guisestate & GS_OnHorse)
		//{
		//}
		//if(guisestate & GS_Metamorphose)
		//{
		//}
		//if(guisestate & GS_Stagnate)
		//{
		//}
		if(m_specFlg == SF_Shijiemache)
		{
			crViewMatterObject *bot = dynamic_cast<crViewMatterObject *>(relNode);
			crMultiSwitch *bodySwitch = dynamic_cast<crMultiSwitch *>(bot->getBody());
			if(guisestate & GS_NoAttack)
			{
				if(bodySwitch) bodySwitch->setActiveSwitchSet(1);
			}
			else
			{
				if(bodySwitch) bodySwitch->setActiveSwitchSet(0);
			}
		}
		if(guisestate & GS_Nihility || (guisestate & GS_Hide && !(guisestate & GS_UnHide)))
		{
			if(guisestate & GS_Nihility)
			{
				autoTrans(relNode);
				m_lastTrans = 1;
			}
			else
			{
				//if(isShareSight)
				//{
					if(isEnemy==1)
					{//队友,半透明
						autoTrans(relNode);
						m_lastTrans = 1;
					}
					else
					{
						relNode->setVisiable(false);
						m_lastTrans = 2;
					}
				//}
				//else
				//{
				//	relNode->setVisiable(false);
				//	m_lastTrans = 2;
				//}
			}
		}
		else if(m_lastTrans>0)
		{//从隐身状态恢复
			if(m_lastTrans == 1)
			{
				CRCore::crCollectNodeBYClassNameVisitor searchVisitor;
				searchVisitor.insertClassNameId("crObject");
				relNode->accept(searchVisitor);
				NodeArray &objectArray = searchVisitor.getResult();
				for( NodeArray::iterator itr = objectArray.begin();
					itr != objectArray.end();
					++itr )
				{
					(dynamic_cast<crObject *>(itr->get()))->setDrawOutLine(1);
				}
			}
			else if(m_lastTrans==2)
			{
				relNode->setVisiable(true);
			}
			m_lastTrans = 0;
			//if(isShareSight)
			//{
			//	if(isEnemy==1)
			//	{
			//		CRCore::crCollectNodeBYClassNameVisitor searchVisitor;
			//		searchVisitor.insertClassNameId("crObject");
			//		relNode->accept(searchVisitor);
			//		NodeArray &objectArray = searchVisitor.getResult();
			//		for( NodeArray::iterator itr = objectArray.begin();
			//			itr != objectArray.end();
			//			++itr )
			//		{
			//			(dynamic_cast<crObject *>(itr->get()))->setDrawOutLine(true);
			//		}
			//	}
			//	else
			//	{
			//		relNode->setVisiable(true);
			//	}
			//}
			//else
			//{
			//	relNode->setVisiable(true);
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSelectSkillMethod
//
/////////////////////////////////////////
crJXJSelectSkillMethod::crJXJSelectSkillMethod():
	m_this(NULL){}
crJXJSelectSkillMethod::crJXJSelectSkillMethod(const crJXJSelectSkillMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJSelectSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
		//case 2:
		//	m_enemycount = *(int*)param;
		//	break;
	}
}
void crJXJSelectSkillMethod::addParam(int i, const std::string& str)
{
}
void crJXJSelectSkillMethod::operator()(crHandle &handle)
{
	void *param;
	ref_ptr<crTableIO> npcSkillSelectTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_NpcSkillSelectTab);
	crData *data = m_this->getDataClass();
	float itemRthpPercent = 1.0f;
	m_this->doEvent(MAKEINT64(WCH_JXJGetRTHPPercent,NULL),MAKEINT64(&itemRthpPercent,NULL));

	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_InPatrolEnemyMap,param);
	InPatrolEnemyMap *inPatrolEnemyMap = (InPatrolEnemyMap *)param;
	int enemycount = inPatrolEnemyMap->size();
	data->getParam(WCHDATA_EquipOnMap,param);
	EquipOnMap *equipOnMap = (EquipOnMap *)param;

	crTableIO::StrVec temprecord;
	crTableIO::DataVec records;
	npcSkillSelectTab->queryRecords(0,crArgumentParser::appItoa(m_this->getInstanceItemID()),records);
	//判断血量条件
	if(!records.empty())
	{
		int hpindex = npcSkillSelectTab->getTitleIndex("血量比");
		int reccount = records.size();
		float hpPercent;
		for(int i =0;i<reccount;i++)
		{
			hpPercent = atof(records[i][hpindex].c_str())*0.01f;
			if(itemRthpPercent>=hpPercent)
			{
				temprecord = records[i];
				break;
			}
		}
		if(!temprecord.empty())
		{
			int columncount = npcSkillSelectTab->getColumnCount();
			int weightindex = npcSkillSelectTab->getTitleIndex("普通攻击");
			int attackWeight = atoi(temprecord[weightindex].c_str());
			int maxweight = attackWeight;
			crVector4i info;
			NpcSelectSkillInfo tempInfo;
			std::vector<NpcSelectSkillInfo> skillInfoVec;
			crItemChild *itemChild;
			crInstanceItem *item;
			for( int i = weightindex+1; i<columncount; i++ )
			{
				if(!temprecord[i].empty())
				{
					crArgumentParser::appAtoVec(temprecord[i],info);
					if(enemycount>info[3])
					{
						itemChild = m_this->findChildItemByAbstractID(info[0]);
						if(itemChild && itemChild->isLoaded())
						{
							item = itemChild->getInstanceItem();
							if(item)
							{
								UseItemParam useItemParam;
								useItemParam.m_user = m_this;
								useItemParam.m_target = NULL;
								unsigned short useResult = UR_None;
								item->doEvent(WCH_UseItemCheck,MAKEINT64(&useItemParam,&useResult));
								if(useResult == UR_Succeed)
								{
									maxweight += info[1];
									tempInfo.itemId = item->getInstanceItemID();
									tempInfo.weights = maxweight;
									tempInfo.markId = info[2];
									tempInfo.aroundCount = info[3];
									skillInfoVec.push_back(tempInfo);
								}
							}
						}
					}
				}
				else
				{
					break;
				}
			}
			rangei rndi(0,maxweight);
			int r = rndi.get_random();
			if(r<=attackWeight)
			{
				data->inputParam(WCHDATA_AboutToUseItemID,NULL);//随到普通攻击
			}
			else
			{
				int skillcount = skillInfoVec.size();
				ref_ptr<crInstanceItem> targetItem;
				for(int i = 0; i<skillcount; i++)
				{
					if(r<=skillInfoVec[i].weights)
					{
						switch (skillInfoVec[i].markId)
						{
						case 0://自己脚下
							break;
						case 1://(仇恨最高) 距离最近
							targetItem = inPatrolEnemyMap->begin()->second;
							break;
						case 2://(随机仇恨) 随机距离
							{
								int er = rangei(0,enemycount).get_random();
								for( InPatrolEnemyMap::iterator itr = inPatrolEnemyMap->begin();
									itr != inPatrolEnemyMap->end();
									++itr,--er )
								{
									if(er==0)
									{
										targetItem = itr->second;
										break;
									}
								}
							}
							break;
						case 3://(仇恨最低) 距离最远
							targetItem = inPatrolEnemyMap->rbegin()->second;
							break;
						case 4://血量低于20%
							targetItem = inPatrolEnemyMap->begin()->second;
							for( InPatrolEnemyMap::iterator itr = inPatrolEnemyMap->begin();
								itr != inPatrolEnemyMap->end();
								++itr )
							{
								itemRthpPercent = 1.0f;
								itr->second->doEvent(MAKEINT64(WCH_JXJGetRTHPPercent,NULL),MAKEINT64(&itemRthpPercent,NULL));
								if(itemRthpPercent<=0.2f)
								{
									targetItem = itr->second;
									break;
								}
							}
							break;
						case 5://对自身
							targetItem = m_this;
							break;
						}
						if(targetItem.valid())
						{
							unsigned char targettype = targetItem->getItemtype()==crInstanceItem::Role?Target_Role:Target_Npc;
							data->inputParam(WCHDATA_TargetType,&targettype);
							int targetid = targetItem->getID();
							int targetroleid = targetItem->getRoleID();
							data->inputParam(WCHDATA_TargetID,&targetid);
							data->inputParam(WCHDATA_TargetRoleID,&targetroleid);
						}
						else
						{
							unsigned char targettype = Target_Coord;
							crVector3 pos = m_this->getPosition()+m_this->getDir() * 0.1f;
							data->inputParam(WCHDATA_TargetPos,&pos);
						}
						data->inputParam(WCHDATA_AboutToUseItemID,&(skillInfoVec[i].itemId));
						unsigned char itemstate = IS_UseItem;
						data->inputParam(WCHDATA_ItemState,&itemstate);
						break;
					}
				}
			}
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
///////////////////////////////////////////
////
////crJXJNpcRevertUpdateMethod
////
///////////////////////////////////////////
//crJXJNpcRevertUpdateMethod::crJXJNpcRevertUpdateMethod():
//	m_dt(0.0f){}
//crJXJNpcRevertUpdateMethod::crJXJNpcRevertUpdateMethod(const crJXJNpcRevertUpdateMethod& handle):
//	crMethod(handle),
//	m_dt(0.0f)
//{
//}
//void crJXJNpcRevertUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crInstanceItem*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((float*)(LOINT64(param64)));
//		}
//		else
//		{
//			m_dt = 0.0f;
//		}
//		break;
//	}
//}
//
//void crJXJNpcRevertUpdateMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJNpcRevertUpdateMethod::operator()(crHandle &handle)
//{
//	if(m_dt>0.0f)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->getParam(WCHDATA_RTHP,param);
//		float* rthp = (float*)param;
//		if(!rthp || *rthp<=0) return;
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//
//		float maxhp = 0;
//		float revert = 0;
//		m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
//
//		if(*rthp<maxhp)
//		{
//			m_this->doEvent(MAKEINT64(WCH_GetHPRevert,NULL),MAKEINT64(&revert,NULL));
//			*rthp += revert * m_dt;
//			if(*rthp>maxhp) *rthp = maxhp;
//		}
//
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJNpcRevertMethod
//
/////////////////////////////////////////
crJXJNpcRevertMethod::crJXJNpcRevertMethod():
	m_revertPercent(0.1f){}
crJXJNpcRevertMethod::crJXJNpcRevertMethod(const crJXJNpcRevertMethod& handle):
	crMethod(handle),
	m_revertPercent(handle.m_revertPercent)
{
}
void crJXJNpcRevertMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJNpcRevertMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_revertPercent = atof(str.c_str());
		break;
	}
}

void crJXJNpcRevertMethod::operator()(crHandle &handle)
{
	if(m_revertPercent>0.0f)
	{
		float hp = 0.0f;
		m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&hp,NULL));
		crData *thisData = m_this->getDataClass();
		void *param;
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_RTHP,param);
		float *rthp = (float*)param;
		if(!rthp)
		{
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			return;
		}
		thisData->getParam(WCHDATA_JXJArmyCount,param);
		/*unsigned short*/int armyCount = *(/*unsigned short*/int *)param;
		float armsmaxhp = armyCount * hp;
		if(*rthp>=armsmaxhp)
		{
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
			return;
		}
		//thisData->getParam(WCHDATA_JXJRTArmyCount,param);
		///*unsigned short*/int *rtArmyCount = (/*unsigned short*/int *)param;
		//*rthp += hp * m_revertPercent;
		//if(*rthp>=armsmaxhp)
		//{
		//	*rthp = armsmaxhp;
		//	*rtArmyCount = armyCount;
		//}
		//else
		//{
		//	*rtArmyCount = ceil(*rthp / hp);
		//}
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		float revertHP = hp * m_revertPercent;
		m_this->doEvent(WCH_CureHP,MAKEINT64(&revertHP,NULL));
		////将信息传给m_this以及其附近玩家
		//unsigned char hittype = m_this->getItemtype();
		//int hitid = m_this->getID();

		//crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		//crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		//crNetManager *netManager = sceneServerConductor->getNetManager();
		//crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		//CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		//if(scene)
		//{
		//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
		//	stream->createBuf(6);
		//	stream->_writeFloat(*rthp);
		//	stream->_writeInt(*rtArmyCount);
		//	if(hittype == crInstanceItem::Role)
		//	{
		//		crPlayerEventPacket packet;
		//		crPlayerEventPacket::buildRequestPacket(packet,hitid,hitid,m_this->getRoleID(),WCH_JXJRecvRevert,stream.get());
		//		ref_ptr<crSceneServerPlayerData> hitPlayerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(hitid));
		//		if (hitPlayerData.valid())
		//		{
		//			netManager->sendPacket(hitPlayerData->getPlayerConnectServerAddress(),packet);
		//			scene->sendPacketToItemNeighbor(m_this,packet);
		//		}
		//	}
		//	else
		//	{
		//		crItemEventPacket packet;
		//		crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_JXJRecvRevert,stream.get());
		//		scene->sendPacketToItemNeighbor(m_this,packet);
		//	}
		//}	
	}
}
/////////////////////////////////////////
//
//crJXJRecvRevertMethod
//
/////////////////////////////////////////
crJXJRecvRevertMethod::crJXJRecvRevertMethod(){}
crJXJRecvRevertMethod::crJXJRecvRevertMethod(const crJXJRecvRevertMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRevertMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRevertMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvRevertMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		crData *data = m_this->getDataClass();
		float rthp = m_stream->_readFloat();
		/*unsigned short*/int armcount = m_stream->_readInt();
		data->inputParam(WCHDATA_RTHP,&rthp);
		data->inputParam(WCHDATA_JXJRTArmyCount,&armcount);
	}
}
/////////////////////////////////////////
//
//crJXJItemHPRemainPercentMethod
//
/////////////////////////////////////////
crJXJItemHPRemainPercentMethod::crJXJItemHPRemainPercentMethod():
	m_percent(0.0f){}
crJXJItemHPRemainPercentMethod::crJXJItemHPRemainPercentMethod(const crJXJItemHPRemainPercentMethod& handle):
	crMethod(handle),
	m_percent(0.0f)
{
}
void crJXJItemHPRemainPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJItemHPRemainPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_percent = atof(str.c_str());
		break;
	}
}

void crJXJItemHPRemainPercentMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_RTHP,param);
	float rthp = *(float*)param;

	float maxhp = 0.0f;
	//data->excHandle(MAKEINT64(WCH_LockData,1));//防止阻塞
	m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
	//data->excHandle(MAKEINT64(WCH_LockData,0));
	data->getParam(WCHDATA_JXJArmyCount,param);
	/*unsigned short */int armyCount = *(/*unsigned short*/int *)param;
	maxhp *= armyCount;
	float percent = rthp/maxhp;
	bool bln = percent<m_percent;
	handle.outputParam(0,&bln);
}

/////////////////////////////////////////
//
//crJXJItemExecuteActionMethod
//
/////////////////////////////////////////
crJXJItemExecuteActionMethod::crJXJItemExecuteActionMethod():
	m_action(true){}
crJXJItemExecuteActionMethod::crJXJItemExecuteActionMethod(const crJXJItemExecuteActionMethod& handle):
	crMethod(handle),
	m_anim(handle.m_anim),
	m_action(handle.m_action)
{
}
void crJXJItemExecuteActionMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJItemExecuteActionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_anim = str;
		break;
	case 1:
		m_action = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJItemExecuteActionMethod::operator()(crHandle &handle)
{
	crNode *node = m_this->getRelNode();
	//find CreBodyNode
	CRCore::crSearchNodeBYClassNameVisitor searchByClassNameVisitor;
	searchByClassNameVisitor.setTraversalMode(crNodeVisitor::TRAVERSE_ALL_CHILDREN);
	searchByClassNameVisitor.insertClassNameId("CreBodyNode");
	node->accept(searchByClassNameVisitor);
	CreBodyNode *bodyNode = dynamic_cast<CreBodyNode *>(searchByClassNameVisitor.getResult());
	if(bodyNode)
	{
		ActionRequest* action = bodyNode->getBody()->getActionPrototype( m_anim );
		if (action) 
		{
			bodyNode->setAnimPlaySpeed(1.0f);
			action->setPrioritized(m_action);
			bodyNode->getBody()->executeAction(action, m_action);
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetHitTypeMethod
//
/////////////////////////////////////////
crJXJGetHitTypeMethod::crJXJGetHitTypeMethod(){}
crJXJGetHitTypeMethod::crJXJGetHitTypeMethod(const crJXJGetHitTypeMethod& handle):
	crMethod(handle)
{
}
void crJXJGetHitTypeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJGetHitTypeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetHitTypeMethod::operator()(crHandle &handle)
{
	int hittype = 0;
	if(m_hitParam->m_hitItem.valid() && m_hitParam->m_fireItem.valid())
	{
		if( m_hitParam->m_hitItem->getItemtype() == m_hitParam->m_fireItem->getItemtype() && 
			m_hitParam->m_hitItem->getID() == m_hitParam->m_fireItem->getID() )
			hittype = 2;
		else
		{
			char isEnemy = 0;
			m_hitParam->m_fireItem->doEvent(WCH_EnemyCheck,MAKEINT64(m_hitParam->m_hitItem.get(),&isEnemy));
			if(isEnemy == 1)
				hittype = 1;
		}
	}
	handle.outputParam(0,&hittype);
}
/////////////////////////////////////////
//
//crJXJTargetTypeMethod
//
/////////////////////////////////////////
crJXJTargetTypeMethod::crJXJTargetTypeMethod(){}
crJXJTargetTypeMethod::crJXJTargetTypeMethod(const crJXJTargetTypeMethod& handle):
	crMethod(handle)
{
}
void crJXJTargetTypeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}
void crJXJTargetTypeMethod::addParam(int i, const std::string& str)
{
}
void crJXJTargetTypeMethod::operator()(crHandle &handle)
{
	int hittype = 0;
	if(m_this && m_fireItem.valid())
	{
		if( m_this->getItemtype() == m_fireItem->getItemtype() && 
			m_this->getID() == m_fireItem->getID() )
			hittype = 2;
		else
		{
			char isEnemy = 0;
			m_this->doEvent(WCH_EnemyCheck,MAKEINT64(m_fireItem.get(),&isEnemy));
			if(isEnemy == 1)
				hittype = 1;
		}
	}
	handle.outputParam(0,&hittype);
}
/////////////////////////////////////////
//
//crJXJServerNoticeMethod
//
/////////////////////////////////////////
crJXJServerNoticeMethod::crJXJServerNoticeMethod():
	m_textid(0),
	m_output(NULL){}
crJXJServerNoticeMethod::crJXJServerNoticeMethod(const crJXJServerNoticeMethod& handle):
	crMethod(handle),
	m_textid(handle.m_textid),
	m_output(NULL)
{
}
void crJXJServerNoticeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case WCHDATA_NoticeTextID:
		m_textid = param?*(int *)param:0;
		break;
		//case WCHDATA_NoticeMode:
		//	m_mode = param?*(int *)param:0;
		//	break;
	case WCHDATA_NoticeString:
		m_noticeString = param?*(std::string *)param:std::string("");
		break;
	case WCHDATA_NoticeParam1:
		m_strparam1 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeParam2:
		m_strparam2 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeParam3:
		m_strparam3 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeParam4:
		m_strparam4 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_JXJNoticeParam5:
		m_strparam5 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_JXJNoticeParam6:
		m_strparam6 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeOutPut:
		m_output = (std::string *)(param);
		break;
	}
}
void crJXJServerNoticeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textid = atoi(str.c_str());
		break;
	}
}
void crJXJServerNoticeMethod::parseText(std::string &text)
{
	if(m_strparam1.empty())
		return;
	int i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam1+text.substr(i+2,text.length());
		m_strparam1.clear();
	}
	if(m_strparam2.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam2+text.substr(i+2,text.length());
		m_strparam2.clear();
	}
	if(m_strparam3.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam3+text.substr(i+2,text.length());
		m_strparam3.clear();
	}
	if(m_strparam4.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam4+text.substr(i+2,text.length());
		m_strparam4.clear();
	}
	if(m_strparam5.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam5+text.substr(i+2,text.length());
		m_strparam5.clear();
	}
	if(m_strparam6.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam6+text.substr(i+2,text.length());
		m_strparam6.clear();
	}
}
void crJXJServerNoticeMethod::operator()(crHandle &handle)
{
	std::string noticeStr;
	if(m_textid>0)
	{
		ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		std::string str;
		if(textTab->queryOneRecord(0,crArgumentParser::appItoa(m_textid),record)>=0)
		{
			noticeStr = record[1];
			parseText(noticeStr);
		}
	}
	else
	{
		noticeStr = m_noticeString;
	}
	if(m_output)
	{
		*m_output = noticeStr;
		m_output = NULL;
	}
}
/////////////////////////////////////////
//
//crJXJNoticeMethod
//
/////////////////////////////////////////
crJXJNoticeMethod::crJXJNoticeMethod():
	m_textid(0),
	m_mode(0),
	m_output(NULL){}
crJXJNoticeMethod::crJXJNoticeMethod(const crJXJNoticeMethod& handle):
	crMethod(handle),
	m_textid(handle.m_textid),
	m_mode(handle.m_mode),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent),
	m_output(NULL)
{
}
void crJXJNoticeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case WCHDATA_NoticeTextID:
		m_textid = param?*(int *)param:0;
		break;
	case WCHDATA_NoticeMode:
		m_mode = param?*(int *)param:0;
		break;
	case WCHDATA_NoticeString:
		m_noticeString = param?*(std::string *)param:std::string("");
		break;
	case WCHDATA_NoticeParam1:
		m_strparam1 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeParam2:
		m_strparam2 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeParam3:
		m_strparam3 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeParam4:
		m_strparam4 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_JXJNoticeParam5:
		m_strparam5 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_JXJNoticeParam6:
		m_strparam6 = param?*(std::string *)(param):std::string("");
		break;
	case WCHDATA_NoticeOutPut:
		m_output = (std::string *)(param);
		break;
	}
}
void crJXJNoticeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textid = atoi(str.c_str());
		break;
	case 1:
		m_mode = atoi(str.c_str());
		break;
	case 2:
		m_tipcanvas = str;
		break;
	case 3:
		m_tipcontent = str;
		break;
	}
}
void crJXJNoticeMethod::parseText(std::string &text)
{
	if(m_strparam1.empty())
		return;
	int i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam1+text.substr(i+2,text.length());
		m_strparam1.clear();
	}
	if(m_strparam2.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam2+text.substr(i+2,text.length());
		m_strparam2.clear();
	}
	if(m_strparam3.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam3+text.substr(i+2,text.length());
		m_strparam3.clear();
	}
	if(m_strparam4.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam4+text.substr(i+2,text.length());
		m_strparam4.clear();
	}
	if(m_strparam5.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam5+text.substr(i+2,text.length());
		m_strparam5.clear();
	}
	if(m_strparam6.empty())
		return;
	i = text.find("%s");
	if(i == std::string::npos)
		i = text.find("%d");
	if(i != std::string::npos)
	{
		text = text.substr(0,i)+m_strparam6+text.substr(i+2,text.length());
		m_strparam6.clear();
	}
}
void crJXJNoticeMethod::operator()(crHandle &handle)
{
	std::string noticeStr;
	if(m_textid>0)
	{
		ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		std::string str;
		if(textTab->queryOneRecord(0,crArgumentParser::appItoa(m_textid),record)>=0)
		{
			noticeStr = record[1];
			parseText(noticeStr);
		}
	}
	else
	{
		noticeStr = m_noticeString;
		parseText(noticeStr);
	}
	if(m_output)
	{
		*m_output = noticeStr;
		m_output = NULL;
	}
	if(m_mode == 0)
	{
		ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas("UI_Prompt_Notice");
		if (tipsCanvas.valid())
		{
			tipsCanvas->setCanFocus(false);
			float time = 3.0f;
			crData *canvasdata = tipsCanvas->getDataClass();
			if(canvasdata)canvasdata->inputParam(WCHDATA_JXJVisiableTime,&time);
			ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget("UI_Prompt"));
			if(input.valid())input->setString(noticeStr);
			crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
		}
		//else
		//{
		//	CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
		//	if(noticeText)
		//	{
		//		noticeText->setText(CRIOManager::convertUTF8toUTF16(str).c_str());
		//		noticeText->setVisiable(true);
		//		//CRCore::notify(CRCore::NOTICE)<<"JXJNotice:"<<m_textid<<" "<<str<<std::endl;
		//	}
		//}
	}
	else if(m_mode == 1)
	{
		ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
		if (tipcanvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
			if (tipcontent.valid())
			{
				tipcontent->setString(noticeStr);
			}
			//crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
			crFilterRenderManager::getInstance()->doModal(tipcanvas.get());
		}
	}
	else if(m_mode == 3)
	{
		MessageBox(crStartHandler::getInstance()->getWindowHandle(),noticeStr.c_str(),"将星诀",MB_OK);
	}
}
/////////////////////////////////////////
//
//crJXJGlobalNoticeMethod
//
/////////////////////////////////////////
crJXJGlobalNoticeMethod::crJXJGlobalNoticeMethod():
	m_textid(0),
	m_str(NULL){}
crJXJGlobalNoticeMethod::crJXJGlobalNoticeMethod(const crJXJGlobalNoticeMethod& handle):
	crMethod(handle),
	m_textid(handle.m_textid),
	m_canvas(handle.m_canvas),
	m_widget(handle.m_widget),
	m_str(NULL)
{
}
void crJXJGlobalNoticeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_textid = LOINT64(param64);
			m_str = (std::string *)(HIINT64(param64));
		}
		else
		{
			m_textid = 0;
			m_str = NULL;
		}
		break;
	}
}
void crJXJGlobalNoticeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_widget = str;
		break;
	}
}
void crJXJGlobalNoticeMethod::operator()(crHandle &handle)
{
	if(m_textid>0||m_str)
	{
		std::string str;
		if(m_str)
		{
			str = *m_str;
		}
		else
		{
			ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
			crTableIO::StrVec record;
			if(textTab->queryOneRecord(0,crArgumentParser::appItoa(m_textid),record)>=0)
			{
				str = record[1];
			}
		}
		ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (tipsCanvas.valid())
		{
			tipsCanvas->setCanFocus(false);
			float time = 3.0f;
			crData *canvasdata = tipsCanvas->getDataClass();
			if(canvasdata)canvasdata->inputParam(WCHDATA_JXJVisiableTime,&time);
			ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_widget));
			if(input.valid())input->setString(str);
			crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
		}
		//else
		//{
		//	CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
		//	if(noticeText)
		//	{
		//		noticeText->setText(CRIOManager::convertUTF8toUTF16(str).c_str());
		//		noticeText->setVisiable(true);
		//		//CRCore::notify(CRCore::NOTICE)<<"JXJNotice:"<<m_textid<<" "<<str<<std::endl;
		//	}
		//}
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJQueryGiftsPackDisposeMethod
//
/////////////////////////////////////////
crJXJQueryGiftsPackDisposeMethod::crJXJQueryGiftsPackDisposeMethod():
	m_this(NULL),
	m_taskcount(10){}
crJXJQueryGiftsPackDisposeMethod::crJXJQueryGiftsPackDisposeMethod(const crJXJQueryGiftsPackDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_taskcount(handle.m_taskcount)
{
}
void crJXJQueryGiftsPackDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJQueryGiftsPackDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskcount = atoi(str.c_str());
		break;
	}
}

void crJXJQueryGiftsPackDisposeMethod::operator()(crHandle &handle)
{
	m_taskVec.resize(0);
	m_taskVec.reserve(m_taskcount);
	void *param;
	crData *serverdata = m_this->getDataClass();
	CRCore::ref_ptr<crQueryGiftsPack> giftsPacket;
	serverdata->excHandle(MAKEINT64(WCH_LockData,1));
	serverdata->getParam(WCHDATA_JXJQueryGiftsPackDeque,param);
	QueryGiftsPackDeque *disposeDeq = (QueryGiftsPackDeque *)param;
	int i = 0;
	while(!disposeDeq->empty() && i<m_taskcount)
	{
		giftsPacket = disposeDeq->front();
		disposeDeq->pop_front();
		m_taskVec.push_back(giftsPacket);
		i++;
	}
	serverdata->excHandle(MAKEINT64(WCH_LockData,0));

	//const CRCore::Timer& timer = *CRCore::Timer::instance();
	//CRCore::Timer_t start_tick = timer.tick();
	//float elapsedTime = 0.0f;
	if(!m_taskVec.empty())
	{
		ref_ptr<crGameServerPlayerData> playerData;
		crDBSavePacket dbpacket;
		void *param;
		ref_ptr<crPlayerRewardData> rewardData;
		ref_ptr<crBagItemData> rewarditem;
		ref_ptr<crStreamBuf> query_result;
		ref_ptr<crGiftsPackQueryData> giftpacketRecord;
		crData *pdata;
		int cardcount,itemcount;
		ref_ptr<crUpdateGiftsPack> updateGiftPack;
		ref_ptr<crUpdateMail> updateMailTitlePack;
		crPlayerDataEventPacket eventpacket;
		query_result = new crStreamBuf;
		char _case = 0;
		crDataBase *global_db = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
		for( std::vector<CRCore::ref_ptr<crQueryGiftsPack> >::iterator itr = m_taskVec.begin();
			itr != m_taskVec.end();
			++itr )
		{
			giftsPacket = *itr;
			playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(giftsPacket->getPlayerID()));
			if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
			{
				_case = 0;
				//if(0)
				//{//20140128 邮件奖励数据字节超出。抽将卡应该先检查将卡背包数量，不走邮件奖励，
				//playerid = 1081的玩家有一堆将卡邮件,领取就会宕服务器
				ref_ptr<crDataBase> db_session = global_db->beginSession();
				ref_ptr<crGiftsPackQueryData> packetDataQuery = new crGiftsPackQueryData;
				packetDataQuery->buildQuerySql(giftsPacket->getKey());
				db_session->executeQuery(packetDataQuery.get());			
				crDataBase::QueryResultVec giftpacket_reuslt_vec = db_session->getQueryResult();
				db_session->releaseQuery();
				global_db->endSession(db_session.get());
				if(!giftpacket_reuslt_vec.empty())
				{
					giftpacketRecord = dynamic_cast<crGiftsPackQueryData *>(giftpacket_reuslt_vec[0].get());
					if(giftpacketRecord.valid())
					{
						if(giftpacketRecord->getDistill())
							_case = 2;
						else if(giftpacketRecord->getPack())
						{
							//发放奖励
							rewardData  = new crPlayerRewardData;
							rewardData->setGiftDataStream(giftpacketRecord->getPack());
							pdata = playerData->getPlayerGameData()->getDataClass();
							pdata->excHandle(MAKEINT64(WCH_LockData,1));
							pdata->getParam(WCHDATA_JXJItemBagVec,param);
							JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
							pdata->getParam(WCHDATA_JXJJiangkaBagVec,param);
							JXJItemBagVec *cardbagvec = (JXJItemBagVec *)param;

							JXJItemBagVec::iterator itr_item = itembagvec->begin();
							JXJItemBagVec::iterator itr_card = cardbagvec->begin();

							int packetRemainSize = 0;
							int cardpacketRemainSize = 0;

							while (itr_item!=itembagvec->end())
							{
								if(!itr_item->get())
								{
									packetRemainSize++;
								}
								itr_item++;
							}

							while (itr_card!=cardbagvec->end())
							{
								if(!itr_card->get())
								{
									cardpacketRemainSize++;
								}
								itr_card++;
							}
							//背包充足直接放入背包
							rewardData->parseRewardItemCount(cardcount,itemcount);
							if(packetRemainSize >= itemcount && cardpacketRemainSize >= cardcount)
							{
								db_session = global_db->beginSession();
								updateGiftPack = new crUpdateGiftsPack;
								updateGiftPack->buildUpdateSql(giftpacketRecord->getID());
								if(db_session->executeUpdate(updateGiftPack.get()))
								{
									//crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,updateGiftPack.get());
									//dbConductor->getNetManager()->sendPacket("all",dbpacket);
									//更新邮件标题
									if(giftsPacket->getMailID()>0)
									{
										updateMailTitlePack = new crUpdateMail;
										updateMailTitlePack->buildUpdateSql(giftsPacket->getMailID(),Mail_BeenGetted);//邮件物品已领取
										db_session->executeUpdate(updateMailTitlePack.get());
										//crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,updateMailTitlePack.get());
										//dbConductor->getNetManager()->sendPacket("all",dbpacket);
									}
									global_db->endSession(db_session.get());
									_case = 1;
									rewardData->setType(GP_MailReward);
									playerData->getPlayerGameData()->doEvent(WCH_JXJRecvPlayerRewardInfo,MAKEINT64(rewardData.get(),NULL));
								}
								else
								{
									global_db->endSession(db_session.get());
									_case = -3;//领取失败
								}
							}
							else if(packetRemainSize < itemcount)
							{//物品背包已满
								_case=-1;
							}
							else// if(cardpacketRemainSize < cardcount)
							{//将卡背包已满
								_case = -3;
							}
							//else
							//{
							//	_case = -3;
							//}
							pdata->excHandle(MAKEINT64(WCH_LockData,0));
							//邮件领取后，服务器触发一次立即存档
							callback->savePlayerData(playerData.get());
						}
					}
				}
				//}
				query_result->createBuf(1);
				query_result->_writeChar(_case);
				crPlayerDataEventPacket::buildReplyPacket(eventpacket,giftsPacket->getPlayerID(),WCH_JXJRecvMailReward,query_result.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),eventpacket);
			}
			//elapsedTime += timer.delta_s(start_tick,timer.tick());
		}
	}
	//serverdata->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvChangechiChangeMethod
//
/////////////////////////////////////////
crJXJRecvChangechiChangeMethod::crJXJRecvChangechiChangeMethod():
	m_netType(GameClient_Game){}
crJXJRecvChangechiChangeMethod::crJXJRecvChangechiChangeMethod(const crJXJRecvChangechiChangeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvChangechiChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvChangechiChangeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvChangechiChangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			unsigned short chengchiid = m_stream->_readUShort(); 
			//unsigned char shiliid = m_stream->_readUChar(); 
			//unsigned short chengfang = m_stream->_readUShort(); 
			crData *data = m_this->getDataClass();
			if(data && chengchiid>0)
			{
				void *param;
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJChengChiMap,param);
				ChengchiMap *chengchiMap = (ChengchiMap *)param;
				(*chengchiMap)[chengchiid]->setStream(m_stream.get());
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCameraSelectUpdateMethod
//
/////////////////////////////////////////
crJXJCameraSelectUpdateMethod::crJXJCameraSelectUpdateMethod()
{
}

crJXJCameraSelectUpdateMethod::crJXJCameraSelectUpdateMethod(const crJXJCameraSelectUpdateMethod& handle):
	crMethod(handle)
{
}

void crJXJCameraSelectUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCameraSelectUpdateMethod::addParam(int i, const std::string& str)
{
}

void crJXJCameraSelectUpdateMethod::operator()(crHandle &handle)
{
	void * param;
	crData *cameraData = m_this->getDataClass();
	CRCore::ScopedLock<crData> lock(*cameraData);
	cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
	SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
	crRole *myRole;
	unsigned int guisestate = GS_Normal;
	crNode *fxNode;
	crDecalUpdateCallback *callback;
	for( SelectMyRoleVec::iterator itr = selectMyRoles->begin();
		itr != selectMyRoles->end();)
	{
		myRole = itr->get();
		guisestate = GS_Normal;
		myRole->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate & GS_StaticUnVisiable || guisestate & GS_UnVisiable || guisestate & GS_Stagnate/* || guisestate & GS_NoAttack*/ || guisestate & GS_Taunt || guisestate & GS_Confusion || guisestate & GS_Scare)
		{//不可被自己选中
			fxNode = myRole->findSceneFxNode("$SelectDecal");
			if(fxNode)
			{
				callback = dynamic_cast<crDecalUpdateCallback *>(fxNode->getUpdateCallback("DecalUpdate"));
				if(callback)
				{
					callback->setVisiable(false);
				}
			}
			itr = selectMyRoles->erase(itr);
		}
		else
		{
			++itr;
		}
	}
}
/////////////////////////////////////////
//
//crJXJIsCameraFollowMethod
//
/////////////////////////////////////////
crJXJIsCameraFollowMethod::crJXJIsCameraFollowMethod()
{
}

crJXJIsCameraFollowMethod::crJXJIsCameraFollowMethod(const crJXJIsCameraFollowMethod& handle):
	crMethod(handle)
{
}

void crJXJIsCameraFollowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJIsCameraFollowMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_strCanvas = str;
		break;
	case 1:
		m_strCheckBox = str;
		break;
	default:
		break;
	}
}

void crJXJIsCameraFollowMethod::operator()(crHandle &handle)
{
	//void * param;
	//crData *cameraData = m_this->getDataClass();
	//cameraData->getParam(WCHDATA_JXJCameraFollow,param);
	bool cameraFollow = false;
	if(crFrameStamp::getInstance()->getFrameNumber()>10)
	{
		ref_ptr<crCanvasNode> canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_strCanvas);
		if(canvasNode.valid())
		{
			ref_ptr<crCheckBoxWidgetNode> checkBox = dynamic_cast<crCheckBoxWidgetNode *>(canvasNode->getWidget(m_strCheckBox));
			if(checkBox.valid())
			{
				cameraFollow = checkBox->getSelect();
			}
		}
	}
	handle.outputParam(0,&cameraFollow);
}
/////////////////////////////////////////
//
//crJXJSetXumuFubenIDMethod
//
/////////////////////////////////////////
crJXJSetXumuFubenIDMethod::crJXJSetXumuFubenIDMethod()
{
}
crJXJSetXumuFubenIDMethod::crJXJSetXumuFubenIDMethod(const crJXJSetXumuFubenIDMethod& handle):
	crMethod(handle)
{
}
void crJXJSetXumuFubenIDMethod::inputParam(int i, void *param)
{
}
void crJXJSetXumuFubenIDMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetXumuFubenIDMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crData *data = myPlayer->getDataClass();
		unsigned char type = FT_Fuben;
		data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
		unsigned short fubenid = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuFubenID,0).c_str());
		data->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);
	}
}
/////////////////////////////////////////
//
//crJXJCreateXumuMethod
//
/////////////////////////////////////////
crJXJCreateXumuMethod::crJXJCreateXumuMethod()
{
}
crJXJCreateXumuMethod::crJXJCreateXumuMethod(const crJXJCreateXumuMethod& handle):
	crMethod(handle)
{
	//for (int i = 0; i<3; i++)
	//{
	//	m_formationInfo[i] = handle.m_formationInfo[i];
	//}
}
void crJXJCreateXumuMethod::inputParam(int i, void *param)
{
}
void crJXJCreateXumuMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	crArgumentParser::appAtoVec(str,m_formationInfo[0]);
	//	break;
	//case 1:
	//	crArgumentParser::appAtoVec(str,m_formationInfo[1]);
	//	break;
	//case 2:
	//	crArgumentParser::appAtoVec(str,m_formationInfo[2]);
	//	break;
	//}
}
void crJXJCreateXumuMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crVector4i troops[3];
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops1),troops[0]);
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops2),troops[1]);
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops3),troops[2]);
		crData *data = myPlayer->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec* formationInfoVec = (FormationInfoVec *)param;;
		formationInfoVec->reserve(3);
		CRCore::ref_ptr<crFormationInfo> formationInfo;
		for (int i = 0; i<3; i++)
		{
			formationInfo = new crFormationInfo;
			formationInfo->setAbstractID(troops[i][0]);
			formationInfo->setCount(troops[i][1]);
			formationInfo->setEquips(crVector2i(troops[i][2],troops[i][3]));
			formationInfoVec->push_back(formationInfo);
		}

		int formationCount = formationInfoVec->size();
		crMyPlayerData::getInstance()->clearSelectedGameRoles();
		CRNetApp::GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
		if(gameRoleMap.size()>0)
		{
			crRole *role;
			int i = 0;
			for( CRNetApp::GameRoleMap::iterator itr = gameRoleMap.begin();
				itr != gameRoleMap.end();
				++itr)
			{
				if(myPlayer->getMainRoleID()==itr->first)
					continue;
				if(i<formationCount)
				{
					(*formationInfoVec)[i]->setRoleID(0);
					if((*formationInfoVec)[i]->getCount()>0)
					{
						role = dynamic_cast<crRole *>(itr->second->clone());
						if(crMyPlayerData::getInstance()->addSelectedGameRole(role))
						{
							role->setAbstractItemID((*formationInfoVec)[i]->getAbstractID());
							(*formationInfoVec)[i]->setRoleID(role->getRoleID());
						}
					}
					++i;
				}
				else
				{
					break;
				}
			}
		}
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4*formationCount+1);
		stream->_writeChar((char)formationCount);
		for (int i = 0; i<formationCount; i++)
		{
			//stream->_writeVec4i(troops[i]);
			stream->_writeInt((*formationInfoVec)[i]->getRoleID());
		}
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCreateXumu,stream.get());
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvCreateXumuMethod
//
/////////////////////////////////////////
crJXJRecvCreateXumuMethod::crJXJRecvCreateXumuMethod():
	m_netType(GameClient_Game){}
crJXJRecvCreateXumuMethod::crJXJRecvCreateXumuMethod(const crJXJRecvCreateXumuMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCreateXumuMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCreateXumuMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCreateXumuMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			unsigned short xumuid = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuFubenID,0).c_str());
			thisData->getParam(WCHDATA_JXJFubenProgressMap,param);
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
			FubenProgressMap::iterator itr = fubenProgressMap->find(xumuid);
			if(itr == fubenProgressMap->end())
			{
				unsigned char type = FT_Fuben;
				thisData->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
				unsigned short fubenid = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuFubenID,0).c_str());
				thisData->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);

				crVector4i troops[3];
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops1),troops[0]);
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops2),troops[1]);
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops3),troops[2]);

				char count = m_stream->_readChar();
				thisData->getParam(WCHDATA_JXJFormationInfoVec,param);
				FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
				formationInfoVec->resize(count);
				//crVector4i info;
				for(int i = 0; i<count; i++)
				{
					(*formationInfoVec)[i] = new crFormationInfo;
					//info = m_stream->_readVec4i();
					(*formationInfoVec)[i]->setAbstractID(troops[i][0]);
					(*formationInfoVec)[i]->setCount(troops[i][1]);
					(*formationInfoVec)[i]->setEquips(crVector2i(troops[i][2],troops[i][3]));
					(*formationInfoVec)[i]->setRoleID(m_stream->_readInt());
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));

			GameLogData gamelog(Log_CreateXumu,"创建序幕");
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_this->getPlayerID(),&gamelog));
		}
	}
}
/////////////////////////////////////////
//
//crJXJItemDeadChangeCampMethod
//
/////////////////////////////////////////
crJXJItemDeadChangeCampMethod::crJXJItemDeadChangeCampMethod():
	m_this(NULL),
	m_fireItem(NULL){}
crJXJItemDeadChangeCampMethod::crJXJItemDeadChangeCampMethod(const crJXJItemDeadChangeCampMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_fireItem(NULL)
{
}
void crJXJItemDeadChangeCampMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_fireItem = (crInstanceItem *)(LOINT64(param64));
		}
		else
		{
			m_fireItem = NULL;
		}
		break;
	}
}

void crJXJItemDeadChangeCampMethod::addParam(int i, const std::string& str)
{
}

void crJXJItemDeadChangeCampMethod::operator()(crHandle &handle)
{
	if(m_fireItem.valid() && m_fireItem->getDataClass())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		//CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		//if(scene)
		//{
		//	scene->itemDead(m_this);

		void *param;
		crRoom *room = netCallback->findRoom(m_this->getRoomID());
		if(room && room->getGameRunning())
		{
			//m_this->setSightInfo(NULL);
			crData *data = m_fireItem->getDataClass();
			data->getParam(WCHDATA_Camp,param);
			unsigned char camp = *(unsigned char *)param;
			crData *thisData = m_this->getDataClass();
			thisData->inputParam(WCHDATA_Camp, &camp);
			//unsigned char itemstate = IS_Relive;
			//thisData->inputParam(WCHDATA_ItemState, &itemstate);
			//thisData->excHandle(MAKEINT64(WCH_LockData,1));
			//thisData->getParam(WCHDATA_PatrolPointVec,param);
			//PatrolPointVec* patrolPointVec = (PatrolPointVec*)param;
			//if(patrolPointVec && !patrolPointVec->empty())
			//{
			//	char idx;
			//	thisData->getParam(WCHDATA_PatrolLoopMode,param);
			//	unsigned char loopmode = *(unsigned char *)param;
			//	if(loopmode == PL_NoLoop)
			//	{
			//		idx = 0;
			//	}
			//	else
			//	{
			//		int count = patrolPointVec->size();
			//		idx = rangei(0,count).get_random();
			//		thisData->inputParam(WCHDATA_PatrolIndex,&idx);
			//	}
			//	crVector2 coord = (*patrolPointVec)[idx];
			//	float coordz = scene->getPosZ(m_this->getLayerID(),coord[0],coord[1], m_this->getZoffset() * crGlobalHandle::gData()->gUnitScale());
			//	m_this->setPosxy(coord[0] / crGlobalHandle::gData()->gUnitScale(),coord[1] / crGlobalHandle::gData()->gUnitScale());
			//	m_this->setPosz(coordz / crGlobalHandle::gData()->gUnitScale());
			//}
			////thisData->excHandle(MAKEINT64(WCH_InitData,m_this));
			//thisData->excHandle(MAKEINT64(WCH_LockData,0));
			//scene->itemRelive(m_this);
			//crSightInfo *attackSightInfo = room->getOrCreateSightInfo(camp);
			//m_this->setSightInfo(attackSightInfo);
			//attackSightInfo->addEyeItem(m_this);
		}
		//}
	}
}
/////////////////////////////////////////
//
//crJXJBingzhengFubenProgressMethod
//
/////////////////////////////////////////
crJXJBingzhengFubenProgressMethod::crJXJBingzhengFubenProgressMethod():
	m_this(NULL),
	m_fubenprogress(0){}
crJXJBingzhengFubenProgressMethod::crJXJBingzhengFubenProgressMethod(const crJXJBingzhengFubenProgressMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_fubenprogress(handle.m_fubenprogress)
{
}
void crJXJBingzhengFubenProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJBingzhengFubenProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_fubenprogress = atoi(str.c_str());
		break;
	}
}

void crJXJBingzhengFubenProgressMethod::operator()(crHandle &handle)
{
	if(m_fubenprogress>0)
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crRoom *room = netCallback->findRoom(m_this->getRoomID());
		if(room && room->getGameRunning())
		{
			crData *roomdata = room->getDataClass();
			roomdata->inputParam(WCHDATA_RoomProgress,&m_fubenprogress);
			//void *param;
			//crData *data = m_this->getDataClass();
			//data->getParam(WCHDATA_Camp,param);
			//unsigned char camp = *(unsigned char *)param;
			//
			//crData *roomdata = room->getDataClass();
			//roomdata->getParam(WCHDATA_JXJBattleID,param);
			//int battleid = *(int *)param;
			////unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
			//unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
			//if(camp == attackShili)
			//{
			//	roomdata->inputParam(WCHDATA_RoomProgress,&m_fubenprogress);
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckBingzhengCampMethod
//
/////////////////////////////////////////
crJXJCheckBingzhengCampMethod::crJXJCheckBingzhengCampMethod():
	m_this(NULL){}
crJXJCheckBingzhengCampMethod::crJXJCheckBingzhengCampMethod(const crJXJCheckBingzhengCampMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJCheckBingzhengCampMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJCheckBingzhengCampMethod::addParam(int i, const std::string& str)
{
}

void crJXJCheckBingzhengCampMethod::operator()(crHandle &handle)
{
	bool isattack = false;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	crRoom *room = netCallback->findRoom(m_this->getRoomID());
	if(room && room->getGameRunning())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Camp,param);
		unsigned char camp = *(unsigned char *)param;

		crData *roomdata = room->getDataClass();
		roomdata->getParam(WCHDATA_JXJBattleID,param);
		int battleid = *(int *)param;
		//unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
		unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
		if(camp == attackShili)
		{
			isattack = true;
		}
	}
	handle.outputParam(0,&isattack);
}
/////////////////////////////////////////
//
//crJXJSwitchFubenProgressTimerMethod
//
/////////////////////////////////////////
crJXJSwitchFubenProgressTimerMethod::crJXJSwitchFubenProgressTimerMethod():
	m_dt(NULL),
	m_interval(0.0f),
	m_timer(0.0f),
	m_curindex(0){}
crJXJSwitchFubenProgressTimerMethod::crJXJSwitchFubenProgressTimerMethod(const crJXJSwitchFubenProgressTimerMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_interval(handle.m_interval),
	m_timer(handle.m_timer),
	m_fubenProgressVec(handle.m_fubenProgressVec),
	m_curindex(handle.m_curindex)
{
}
void crJXJSwitchFubenProgressTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float *)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crJXJSwitchFubenProgressTimerMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	case 1:
		CRCore::crArgumentParser::appAtoVec(str,m_fubenProgressVec);
		break;
	}
}
void crJXJSwitchFubenProgressTimerMethod::operator()(crHandle &handle) 
{
	m_timer -= *m_dt;
	if(m_timer <= 0.0f)
	{
		if(m_curindex<m_fubenProgressVec.size())
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			crRoom *room = netCallback->findRoom(m_this->getRoomID());
			if(room && room->getGameRunning())
			{
				short progress = m_fubenProgressVec[m_curindex];
				crData *roomdata = room->getDataClass();
				roomdata->inputParam(WCHDATA_RoomProgress,&progress);
				m_curindex++;
			}
		}
		m_timer = m_interval;
	}

}
/////////////////////////////////////////
//
//crJXJClientCheckItemsDeadMethod
//
/////////////////////////////////////////
crJXJClientCheckItemsDeadMethod::crJXJClientCheckItemsDeadMethod():
	m_trueExecCount(1)
{}
crJXJClientCheckItemsDeadMethod::crJXJClientCheckItemsDeadMethod(const crJXJClientCheckItemsDeadMethod& handle):
	crMethod(handle),
	m_itemidVec(handle.m_itemidVec),
	m_trueExecCount(handle.m_trueExecCount)
{
}
void crJXJClientCheckItemsDeadMethod::inputParam(int i, void *param)
{
}
void crJXJClientCheckItemsDeadMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		CRCore::crArgumentParser::appAtoVec(str,m_itemidVec);
		break;
	case 1:
		m_trueExecCount = (char)(atoi(str.c_str()));
		break;
	}
}
void crJXJClientCheckItemsDeadMethod::operator()(crHandle &handle) 
{
	bool alldead = false;
	crMyPlayerData::ItemNpcPair itemNpcPair;
	unsigned char itemstate;
	void *param;
	crData *data;
	for( std::vector<int>::iterator itr = m_itemidVec.begin();
		itr != m_itemidVec.end();
		++itr )
	{
		if(crMyPlayerData::getInstance()->findInRangeNpc(*itr,itemNpcPair))
		{
			data = itemNpcPair.first->getDataClass();
			if(data)
			{
				data->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
				{
					if (m_trueExecCount )
					{
						alldead = true;
						if(m_trueExecCount > 0)
							m_trueExecCount--;
						break;
					}
				}
			}
		}
	}
	handle.outputParam(0,&alldead);
}
/////////////////////////////////////////
//
//crJXJBingzhengBirthPointMethod
//
/////////////////////////////////////////
crJXJBingzhengBirthPointMethod::crJXJBingzhengBirthPointMethod():
	m_this(NULL){}
crJXJBingzhengBirthPointMethod::crJXJBingzhengBirthPointMethod(const crJXJBingzhengBirthPointMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJBingzhengBirthPointMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJBingzhengBirthPointMethod::addParam(int i, const std::string& str)
{
}
void crJXJBingzhengBirthPointMethod::operator()(crHandle &handle)
{
	if(m_this->getID()>0)
	{
		void *param;
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crNetManager *netManager = sceneServerConductor->getNetManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		crRoom *room = netCallback->findRoom(m_this->getRoomID());
		if(room)
		{
			crData *roomData = room->getDataClass();
			if(roomData)
			{
				crData *thisData = m_this->getDataClass();
				thisData->getParam(WCHDATA_Camp,param);
				unsigned char thiscamp = *(unsigned char *)param;
				crVector3i pos;
				pos[0] = m_this->getPosx();
				pos[1] = m_this->getPosy();
				pos[2] = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCampBirthRange, 0).c_str());

				//roomData->getParam(WCHDATA_JXJBattleID,param);
				//int battleid = *(int *)param;
				//unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
				//unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
				roomData->excHandle(MAKEINT64(WCH_LockData,1));
				roomData->getParam(WCHDATA_JXJCampBirthPointMap,param);
				JXJCampBirthpointMap *campMap = (JXJCampBirthpointMap *)param;
				(*campMap)[thiscamp].insert(std::make_pair(pos,m_this->getIName2()));
				//switch (thiscamp)
				//{
				//case 1:
				//	(*campMap)[defenceShili].insert(pos);
				//	thisData->inputParam(WCHDATA_Camp,&defenceShili);
				//	break;
				//case 2:
				//	(*campMap)[attackShili].insert(pos);
				//	thisData->inputParam(WCHDATA_Camp,&attackShili);
				//	break;
				//default:
				//	(*campMap)[thiscamp].insert(pos);
				//	break;
				//}
				roomData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBingzhenReliveProtectMethod
//
/////////////////////////////////////////
crJXJBingzhenReliveProtectMethod::crJXJBingzhenReliveProtectMethod():
	m_this(NULL){}
crJXJBingzhenReliveProtectMethod::crJXJBingzhenReliveProtectMethod(const crJXJBingzhenReliveProtectMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJBingzhenReliveProtectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJBingzhenReliveProtectMethod::addParam(int i, const std::string& str)
{
}
void crJXJBingzhenReliveProtectMethod::operator()(crHandle &handle)
{
	//m_this->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(JXJExt_Bingzhen,-1),NULL));
}
/////////////////////////////////////////
//
//crJXJGuiseSyncMethod
//
/////////////////////////////////////////
crJXJGuiseSyncMethod::crJXJGuiseSyncMethod():
	m_this(NULL),
	m_dt(0.0f),
	m_interval(2.0f),
	m_time(0.0f),
	m_lastGuise(GS_Normal)
{}
crJXJGuiseSyncMethod::crJXJGuiseSyncMethod(const crJXJGuiseSyncMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(0.0f),
	m_interval(handle.m_interval),
	m_time(0.0f),
	m_lastGuise(GS_Normal)
{
}
void crJXJGuiseSyncMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((float*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0.0f;
		}
		break;
	}
}
void crJXJGuiseSyncMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	}
}
void crJXJGuiseSyncMethod::operator()(crHandle &handle)
{
	m_time += m_dt;
	if(m_time>m_interval)
	{
		unsigned int guisestate = GS_Normal;
		m_this->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
		if(guisestate != m_lastGuise)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crNetManager *netManager = sceneServerConductor->getNetManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
			if(scene)
			{
				m_time = 0.0f;
				m_lastGuise = guisestate;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeUInt(guisestate);
				//将信息传给m_this以及其附近玩家
				unsigned char type = m_this->getItemtype();
				int id = m_this->getID();
				if(type == crInstanceItem::Role)
				{
					crPlayerEventPacket packet;
					crPlayerEventPacket::buildRequestPacket(packet,id,m_this,WCH_JXJRecvGuiseSync,stream.get());
					ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(id));
					if (playerData.valid())
					{
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
				else
				{
					crItemEventPacket packet;
					crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_JXJRecvGuiseSync,stream.get());
					scene->sendPacketToItemNeighbor(m_this,packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGuiseSyncMethod
//
/////////////////////////////////////////
crJXJRecvGuiseSyncMethod::crJXJRecvGuiseSyncMethod(){}
crJXJRecvGuiseSyncMethod::crJXJRecvGuiseSyncMethod(const crJXJRecvGuiseSyncMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvGuiseSyncMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvGuiseSyncMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvGuiseSyncMethod::operator()(crHandle &handle)
{
	if(m_stream.valid() && crRunGameHandle::getInstance()->getRunningCode() == crRunGameHandle::NetGame)
	{
		unsigned int guisestate = m_stream->_readUInt();
		crData *data = m_this->getDataClass();
		//data->inputParam(WCHDATA_GuiseState,&guisestate);
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_GuiseState,param);
		unsigned int *_guisestate = (unsigned int *)param;
		if(*_guisestate & GS_UnVisiable && !(guisestate & GS_UnVisiable))
		{
			float dt = 0.1f;
			m_this->doEvent(WCH_ChangeActState,MAKEINT64(ACT_Idle,&dt));
		}
		*_guisestate = guisestate;
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvTouchShuijingMethod
//
/////////////////////////////////////////
crJXJRecvTouchShuijingMethod::crJXJRecvTouchShuijingMethod():
	m_range(10),
	m_indexType(0)
{}
crJXJRecvTouchShuijingMethod::crJXJRecvTouchShuijingMethod(const crJXJRecvTouchShuijingMethod& handle):
	crMethod(handle),
	m_range(handle.m_range),
	m_indexType(handle.m_indexType)
{
}
void crJXJRecvTouchShuijingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTouchShuijingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_range = atoi(str.c_str());
		break;
	case 1:
		m_indexType = atoi(str.c_str());
		break;
	}
}

void crJXJRecvTouchShuijingMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		void *param;
		crData *itemData = m_this->getDataClass();
		if(itemData) 
		{
			itemData->excHandle(MAKEINT64(WCH_LockData,1));
			itemData->getParam(WCHDATA_ItemState,param);
			unsigned char *itemState = (unsigned char *)param;
			if(*itemState==IS_Dead)
			{
				itemData->excHandle(MAKEINT64(WCH_LockData,0));
				return;
			}
			*itemState = IS_Dead;
			itemData->excHandle(MAKEINT64(WCH_LockData,0));
		}
		int playerid = m_stream->_readInt();
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());

		ref_ptr<crSceneServerPlayerData> playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
		if(playerData.valid() && playerData->getSightInfo())
		{
			ref_ptr<crSightInfo> hitSight = playerData->getSightInfo();
			std::vector< ref_ptr<crInstanceItem> > ItemVec;
			crVector3 shuijinpos = m_this->getPosition();
			crVector3 itempos;
			ref_ptr<crInstanceItem> item;
			unsigned int guisestate = GS_Normal;
			unsigned char itemstate;
			crData *itemdata;
			hitSight->lockItemEyeMap();
			crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
			for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
				itr != itemEyeMap.end();
				++itr )
			{
				item = itr->second;
				itemdata = item->getDataClass();
				itemdata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
					continue;
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable
					||guisestate & GS_Stagnate || guisestate & GS_immunoSkill )
				{
					continue;
				}
				itempos = item->getPosition();
				if((itempos - shuijinpos).length() < m_range)
				{
					ItemVec.push_back(item);
				}
			}
			hitSight->unlockItemEyeMap();

			ref_ptr<crSceneServerPlayerData> playerdata;
			hitSight->lockPlayerEyeMap();
			crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
			for( crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
				itr != playerEyeMap.end();
				++itr )
			{
				playerdata = itr->second;
				crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
				for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
					ritr != roleMap.end();
					++ritr )
				{
					item = dynamic_cast<crInstanceItem *>(ritr->second.get());
					itemdata = item->getDataClass();
					itemdata->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate == IS_Dead)
						continue;
					guisestate = GS_Normal;
					item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
						guisestate & GS_Stagnate || guisestate & GS_immunoSkill )
					{
						continue;
					}
					itempos = item->getPosition();
					if((itempos - shuijinpos).length() < m_range)
					{
						ItemVec.push_back(item);
					}
				}
			}
			hitSight->unlockPlayerEyeMap();
			float cure=10000000.0f;
			for( std::vector< ref_ptr<crInstanceItem> >::iterator itr = ItemVec.begin();
				itr != ItemVec.end();
				++itr )
			{
				if (m_indexType == 1)
				{//1表示加满士气
					(*itr)->doEvent(WCH_JXJCureRTMp, MAKEINT64(&cure, NULL));
				}
				else
				{//0表示治疗血量
					(*itr)->doEvent(WCH_CureHP,MAKEINT64(&cure,NULL));
				}
			}
		}
		//客户端
		if(scene)
		{
			crItemEventPacket packet;
			crItemEventPacket::buildRequestPacket(packet,0,m_this,WCH_ClientRecvTouch,NULL);
			scene->sendPacketToItemNeighbor(m_this,packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJFrameLowDetectMethod
//
/////////////////////////////////////////
bool crJXJFrameLowDetectMethod::s_detectEnable = true;
crJXJFrameLowDetectMethod::crJXJFrameLowDetectMethod():
	m_interval(3.0f),
	m_minframe(15),
	m_time(0.0f){}
crJXJFrameLowDetectMethod::crJXJFrameLowDetectMethod(const crJXJFrameLowDetectMethod& handle):
	crMethod(handle),
	m_interval(handle.m_interval),
	m_minframe(handle.m_minframe),
	m_time(0.0f),
	m_strMsgCanvas(handle.m_strMsgCanvas),
	m_strMsg(handle.m_strMsg)
{
}
void crJXJFrameLowDetectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJFrameLowDetectMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	case 1:
		m_minframe = atoi(str.c_str());
		break;
	case 2:
		m_strMsgCanvas = str;
		break;
	case 3:
		m_strMsg = str;
		break;
	}
}
void crJXJFrameLowDetectMethod::setDetectEnable(bool enable)
{
	s_detectEnable = enable;
}
void crJXJFrameLowDetectMethod::operator()(crHandle &handle)
{
	if(!s_detectEnable)
		return;
	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strMsgCanvas);
	crDisplaySettings *ds = crDisplaySettings::instance();
	float fps = ds->getFpsControl();
	if(fps != 0.0f)
		fps = 1000.0f/fps;
	if( msgCanvas.valid() && !msgCanvas->getVisiable() && !crFilterRenderManager::getInstance()->getModalCanvas() &&
		!crKeyboardMouseHandle::getInstance()->isLocked() &&
		crFrameStamp::getInstance()->getFrameNumber()>50 && 
		fps > m_minframe &&
		crFrameStamp::getInstance()->getFPS()<m_minframe)
	{
		if( ds->getShadowDetail()==0 && ds->getEnableAlphaShadow()==false /*&& ds->getHDR()==0 && ds->getNumMultiSamples()==0*/ && ds->getMaxAnisotropy()<=8 )
			return;

		m_time += crFrameStamp::getInstance()->getFrameInterval();
		if(m_time>m_interval)
		{
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			int texid = 1076;
			noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
			int mode = 2;
			noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
			std::string output;
			noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
			crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);

			ItemMap itemMap;
			rcfg::ConfigScript cfg_script(&itemMap);
			cfg_script.Add("Hypertext");
			cfg_script.Push("Hypertext");
			cfg_script.Add("Content");
			cfg_script.Push("Content");
			cfg_script.Add("Text",output);
			cfg_script.Pop();
			cfg_script.Pop();
			ref_ptr<crHypertextWidgetNode>  msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_strMsg));
			if(msg.valid())
				msg->setHypertext(cfg_script);
			crData *dlgData = msgCanvas->getDataClass();
			int commandtype = CDP_Base;
			dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
			dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
			crFilterRenderManager::getInstance()->showCanvas(msgCanvas.get(),true);
		}
	}
	else
	{
		m_time = 0.0f;
	}
}
/////////////////////////////////////////
//
//crJXJFrameLowSettingMethod
//
/////////////////////////////////////////
crJXJFrameLowSettingMethod::crJXJFrameLowSettingMethod(){}
crJXJFrameLowSettingMethod::crJXJFrameLowSettingMethod(const crJXJFrameLowSettingMethod& handle):
	crMethod(handle)
{
}
void crJXJFrameLowSettingMethod::inputParam(int i, void *param)
{
}

void crJXJFrameLowSettingMethod::addParam(int i, const std::string& str)
{
}

void crJXJFrameLowSettingMethod::operator()(crHandle &handle)
{
	crDisplaySettings *ds = crDisplaySettings::instance();
	ds->setShadowDetail(0);
	ds->setEnableAlphaShadow(false);
	//ds->setHDR(0);
	//ds->setNumMultiSamples(0);
	ds->setMaxAnisotropy(8);
	rcfg::ConfigScript cfg_script;
	std::string filename = "script/init.cfg";
	if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,filename,true))
	{
		//CRCore::notify(CRCore::FATAL)<<"JXJ::crJXJUpdateInitCfgMethod(): file open error "<<filename<<std::endl;
		return;
	}
	if(cfg_script.Push("DisplaySetting"))
	{
		if(!cfg_script.Modify("MaxAnisotropy", 8))
		{
			cfg_script.Add("MaxAnisotropy",8);
		}
		if(!cfg_script.Modify("ShadowDetail", 0))
		{
			cfg_script.Add("ShadowDetail",0);
		}
		if(!cfg_script.Modify("EnableAlphaShadow", 0))
		{
			cfg_script.Add("EnableAlphaShadow",0);
		}
		if(!cfg_script.Modify("HDR", 0))
		{
			cfg_script.Add("HDR",0);
		}
		if(!cfg_script.Modify("numMultiSamples", 0))
		{
			cfg_script.Add("numMultiSamples",0);
		}
	}
	cfg_script.Write("script/init.cfg");
	cfg_script.Close();

	CRIOManager::crWriteCookFile scopedWrite("script/init.cfg");
}
/////////////////////////////////////////
//
//crJXJFrameDetectEnableMethod
//
/////////////////////////////////////////
crJXJFrameDetectEnableMethod::crJXJFrameDetectEnableMethod():
	m_enable(true){}
crJXJFrameDetectEnableMethod::crJXJFrameDetectEnableMethod(const crJXJFrameDetectEnableMethod& handle):
	crMethod(handle),
	m_enable(handle.m_enable)
{
}
void crJXJFrameDetectEnableMethod::inputParam(int i, void *param)
{
}

void crJXJFrameDetectEnableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_enable = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJFrameDetectEnableMethod::operator()(crHandle &handle)
{
	crJXJFrameLowDetectMethod::setDetectEnable(m_enable);
}
/////////////////////////////////////////
//
//crJXJRecvPositionSyncMethod
//
/////////////////////////////////////////
crJXJRecvPositionSyncMethod::crJXJRecvPositionSyncMethod():
	m_netType(GameClient_Game),
	m_counter(0){}
crJXJRecvPositionSyncMethod::crJXJRecvPositionSyncMethod(const crJXJRecvPositionSyncMethod& handle):
	crMethod(handle),
	m_counter(0)
{
}
void crJXJRecvPositionSyncMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPositionSyncMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvPositionSyncMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		//crData *data = m_this->getDataClass();
		//void *param;
		//data->getParam(WCHDATA_ItemState,param);
		//unsigned char itemstate = *(unsigned char*)param;
		//if(itemstate!=IS_Dead && itemstate != IS_Relive)
		//{
		crVector2 pos = m_stream->_readVec2();
		float scale = crGlobalHandle::gData()->gUnitScale();
		crVector2 curPos(m_this->getPosx(),m_this->getPosy());
		curPos *= scale;
		if(curPos != pos)
		{
			m_this->addSyncPos(pos);
			if(!crGlobalHandle::isClient() && m_this->getItemtype() == crInstanceItem::Role)
			{
				crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
				crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
				crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
				CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
				if(scene)
				{
					crSceneLayer *sceneLayer = scene->getSceneLayer(m_this->getLayerID());
					if(sceneLayer)
					{
						CRCore::crVector2s coord = sceneLayer->getCoord(pos[0],pos[1]);
						if(sceneLayer->walkability(coord[0],coord[1]))
						{
							if(m_counter>0)
								m_counter--;
						}
						else
						{//非法位置,记录，并将客户端踢下线
							m_counter++;
							if(m_counter>c_maxIllegalPosCount)
							{
								ref_ptr<crSceneServerPlayerData> player = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(m_this->getID()));
								if(player.valid())
								{
									//crKickoffPlayerPacket kpacket;
									//crKickoffPlayerPacket::buildReplyPacket(kpacket,m_this->getID());
									//sceneServerConductor->getNetManager()->sendPacket(player->getPlayerConnectServerAddress(),kpacket);
									///游戏日志
									std::string logdata = "出现在非法位置超过50次";
									GameLogData gamelog(Log_PositionSync,logdata);
									crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_this->getID(),&gamelog));
									m_counter = 0;
								}
							}
						}
					}
				}
			}
		}
		//}
	}
}
/////////////////////////////////////////
//
//crJXJSprintMethod
//
/////////////////////////////////////////
crJXJSprintMethod::crJXJSprintMethod():
	m_dist(20.0f),
	m_target(NULL){}
crJXJSprintMethod::crJXJSprintMethod(const crJXJSprintMethod& handle):
	crMethod(handle),
	m_dist(handle.m_dist),
	m_target(NULL)
{
}
void crJXJSprintMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWeaponMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gunpoint = *(const crVector3 *)(LOINT64(param64));
			m_target = (crVector3 *)(HIINT64(param64));
		}
		break;
	}
}

void crJXJSprintMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_dist = atof(str.c_str());
		break;
	}
}

void crJXJSprintMethod::operator()(crHandle &handle)
{
	ref_ptr<crViewMatterObject> body = m_this->getFireBody();
	if(body.valid())
	{
		crData *data = body->getDataClass();
		void *param;
		data->getParam(WCHDATA_Item,param);
		if(param)
		{
			ref_ptr<crInstanceItem> item = ((crInstanceItem*)param);
			if(item.valid())
			{//
				crVector3 itempos = item->getPosition();
				crVector3 dir = *m_target - itempos;
				dir[2] = 0.0f;
				dir.normalize();
				crSceneLayer *scenelayer = crMyPlayerData::getInstance()->getSceneLayer();
				crVector2s coord;
				float dist = 1.0f;
				crVector3 newpos = itempos;
				crVector3 testpos;
				bool poschanged = false;
				while (dist<=m_dist)
				{
					testpos = itempos + dir * dist;
					coord = scenelayer->getCoord(crVector2(testpos[0],testpos[1]));
					//判断新位置是否可站立
					if(scenelayer->walkability(coord[0],coord[1]))
					{
						newpos = testpos;
						poschanged = true;
					}
					else
					{
						break;
					}
					dist += 1.0f;
				}
				if(dist>m_dist)
				{
					testpos = itempos + dir * m_dist;
					coord = scenelayer->getCoord(crVector2(testpos[0],testpos[1]));
					//判断新位置是否可站立
					if(scenelayer->walkability(coord[0],coord[1]))
					{
						newpos = testpos;
						poschanged = true;
					}
				}
				if(poschanged)
				{
					itempos = newpos;
					float scale = crGlobalHandle::gData()->gUnitScale();
					float zoffset = item->getZoffset() * scale;
					float z = crMyPlayerData::getInstance()->getPosZ(itempos[0],itempos[1], zoffset);
					itempos[2] = z;
					itempos /= scale;
					item->setPosxy(itempos[0],itempos[1]);
					item->setPosz(itempos[2]);
					item->doEvent(WCH_ItemCoordToNode,MAKEINT64(body.get(),crMatterObject::MD_FullMatrix));
				}
				*m_target = item->getPosition()+item->getDir() * 0.5f;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSprintTargetMethod
//
/////////////////////////////////////////
crJXJSprintTargetMethod::crJXJSprintTargetMethod():
	m_target(NULL),
	m_maxdist(20.0f),
	m_ignoreMap(false){}
crJXJSprintTargetMethod::crJXJSprintTargetMethod(const crJXJSprintTargetMethod& handle):
	crMethod(handle),
	m_target(NULL),
	m_maxdist(handle.m_maxdist),
	m_ignoreMap(handle.m_ignoreMap)
{
}
void crJXJSprintTargetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWeaponMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gunpoint = *(const crVector3 *)(LOINT64(param64));
			m_target = (crVector3 *)(HIINT64(param64));
		}
		break;
	}
}

void crJXJSprintTargetMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_maxdist = atof(str.c_str());
		break;
	case 1:
		m_ignoreMap = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJSprintTargetMethod::operator()(crHandle &handle)
{
	ref_ptr<crViewMatterObject> body = m_this->getFireBody();
	if(body.valid())
	{
		crData *data = body->getDataClass();
		void *param;
		data->getParam(WCHDATA_Item,param);
		if(param)
		{
			ref_ptr<crInstanceItem> item = ((crInstanceItem*)param);
			if(item.valid())
			{//
				crVector3 itempos = item->getPosition();
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_TargetType,param);
				unsigned char targettype = *(unsigned char *)param;
				crVector3 targetPos = *m_target;
				ref_ptr<crInstanceItem> targetItem;
				if(targettype & Target_Instance || targettype & Target_StaticNpc/* || targettype & Target_StaticItem*/)
				{
					ref_ptr<crMatrixTransform> targetNode;
					item->clientGetTarget(targetItem,targetNode);
					if(targetItem.valid())
					{
						targetPos = targetItem->getPosition();
					}
				}
				else
				{
					itemData->getParam(WCHDATA_TargetPos,param);
					targetPos = *(crVector3 *)param;
				}

				crVector3 dir = targetPos - itempos;
				dir[2] = 0.0f;
				float _dist = dir.length();
				if (m_maxdist > 0.0f)
					_dist = CRCore::minimum(_dist, m_maxdist);
				dir.normalize();
				crSceneLayer *scenelayer = crMyPlayerData::getInstance()->getSceneLayer();
				crVector2s coord;
				float dist = m_ignoreMap?_dist:1.0f;
				crVector3 newpos = itempos;
				crVector3 testpos;
				bool poschanged = false;
				while (!m_ignoreMap && dist<=_dist)
				{
					testpos = itempos + dir * dist;
					coord = scenelayer->getCoord(crVector2(testpos[0],testpos[1]));
					//判断新位置是否可站立
					if(scenelayer->walkability(coord[0],coord[1]))
					{
						newpos = testpos;
						poschanged = true;
					}
					else
					{
						break;
					}
					dist += 1.0f;
				}
				if(dist>=_dist)
				{
					testpos = itempos + dir * _dist;
					coord = scenelayer->getCoord(crVector2(testpos[0],testpos[1]));
					//判断新位置是否可站立
					if(scenelayer->walkability(coord[0],coord[1]))
					{
						newpos = testpos;
						poschanged = true;
					}
				}
				if(poschanged)
				{
					itempos = newpos;
					float scale = crGlobalHandle::gData()->gUnitScale();
					float zoffset = item->getZoffset() * scale;
					float z = crMyPlayerData::getInstance()->getPosZ(itempos[0],itempos[1], zoffset);
					itempos[2] = z;
					itempos /= scale;
					item->setPosxy(itempos[0],itempos[1]);
					item->setPosz(itempos[2]);
					item->doEvent(WCH_ItemCoordToNode,MAKEINT64(body.get(),crMatterObject::MD_FullMatrix));
				}
				*m_target = item->getPosition()+item->getDir() * 0.5f;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJTransportationMethod
//
/////////////////////////////////////////
crJXJTransportationMethod::crJXJTransportationMethod():
	m_target(NULL){}
crJXJTransportationMethod::crJXJTransportationMethod(const crJXJTransportationMethod& handle):
	crMethod(handle),
	m_target(NULL)
{
}
void crJXJTransportationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWeaponMatterObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gunpoint = *(const crVector3 *)(LOINT64(param64));
			m_target = (crVector3 *)(HIINT64(param64));
		}
		break;
	}
}

void crJXJTransportationMethod::addParam(int i, const std::string& str)
{
}

void crJXJTransportationMethod::operator()(crHandle &handle)
{
	ref_ptr<crViewMatterObject> body = m_this->getFireBody();
	if(body.valid())
	{
		crData *data = body->getDataClass();
		void *param;
		data->getParam(WCHDATA_Item,param);
		if(param)
		{
			ref_ptr<crInstanceItem> item = ((crInstanceItem*)param);
			if(item.valid())
			{////最近据点
				crData *itemData = item->getDataClass();
				itemData->getParam(WCHDATA_Camp,param);
				unsigned char myShili = *(unsigned char *)param;

				float scale = crGlobalHandle::gData()->gUnitScale();
				crVector2f myPos(item->getPosx(),item->getPosy());
				myPos *= scale;
				crSceneLayer *sceneLayer = crMyPlayerData::getInstance()->getSceneLayer();
				const crSceneLayer::BirthPointArray& pointVec = sceneLayer->getBirthPointArray();
				ref_ptr<crRoom>room = crMyPlayerData::getInstance()->getSelectedRoom();
				crData *roomData = room->getDataClass();
				roomData->getParam(WCHDATA_JXJBattleID,param);
				_crInt32 battleid = *(_crInt32 *)param;
				unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
				unsigned short chengchiid = HIINT32(battleid);
				ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				int chusindex = chengchiTab->getTitleIndex("出生点数");
				if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
				{
					crVector2i bpointvec;
					crArgumentParser::appAtoVec(record[chusindex],bpointvec);
					std::set<crVector3f> BirthPointSet;

					if(!pointVec.empty())
					{
						if(myShili == attackShili)
						{//攻击方
							for( int i = 0; i<bpointvec[0]; i++)
							{
								BirthPointSet.insert(pointVec[i]);
							}
						}
						else
						{
							for( int i = bpointvec[0]; i<bpointvec[0]+bpointvec[1]; i++)
							{
								BirthPointSet.insert(pointVec[i]);
							}
						}
					}
					roomData->excHandle(MAKEINT64(WCH_LockData,1));
					roomData->getParam(WCHDATA_JXJCampBirthPointMap,param);
					JXJCampBirthpointMap *campMap = (JXJCampBirthpointMap *)param;
					JXJCampBirthpoint& birthpointSet = (*campMap)[myShili];
					for( JXJCampBirthpoint::iterator bitr = birthpointSet.begin();
						bitr != birthpointSet.end();
						++bitr )
					{
						BirthPointSet.insert(bitr->first);
					}
					roomData->excHandle(MAKEINT64(WCH_LockData,0)); 
					std::set<crVector3f>::iterator bpitr = BirthPointSet.begin();
					float mindist = (crVector2f((*bpitr)[0],(*bpitr)[1])*scale - myPos).length();
					float dist;
					crVector3f nearBirthPoint = *bpitr;
					for( ++bpitr;
						bpitr != BirthPointSet.end();
						++bpitr )
					{
						dist = (crVector2f((*bpitr)[0], (*bpitr)[1])*scale - myPos).length();
						if(dist<mindist)
						{
							mindist = dist;
							nearBirthPoint = *bpitr;
						}
					}
					crVector3f birthPoint;
					//rangei range(-nearBirthPoint[2],nearBirthPoint[2]);
					birthPoint[0] = nearBirthPoint[0]*scale;// + range.get_random();
					birthPoint[1] = nearBirthPoint[1]*scale;// + range.get_random();
				
					crVector3 pos;
					CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
					if(!scene->findWalkablePos(item.get(),crVector2(birthPoint[0],birthPoint[1]),c_walkableSearchRange,pos))
						CRCore::notify(CRCore::ALWAYS)<<"crJXJTransportationMethod findWalkablePos失败 "<<birthPoint<<std::endl;
					else
					{
						pos/=scale;
						item->setPosxy(pos[0],pos[1]);
						item->setPosz(pos[2]);
						item->doEvent(WCH_ItemCoordToNode,MAKEINT64(body.get(),crMatterObject::MD_FullMatrix));
						*m_target = item->getPosition()+item->getDir() * 0.5f;

						if(crMyPlayerData::getInstance()->ifItemIsMe(item.get()))
						{//相机聚焦
							ref_ptr<crCamera> cam = crCameraManager::getInstance()->getMainCamera();
							if(cam.valid() && cam->getAttachedNode())
							{
								crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(cam->getAttachedNode());
								crVector3 rolePos = item->getPosition();
								cameraNode->doEvent(WCH_CameraFocus,MAKEINT64(&rolePos,NULL));
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSunSimulateLogic
//
/////////////////////////////////////////
crJXJSunSimulateLogic::crJXJSunSimulateLogic():
	m_bIsDayTime(true),
	m_fTimeScale(40.0f),
	m_lastsecond(0),
	m_lasttick(0L),
	m_sundownid(4),
	m_disiable(false)
{
}
crJXJSunSimulateLogic::crJXJSunSimulateLogic(const crJXJSunSimulateLogic& handle):
	crLogic(handle),
	m_sunTab(handle.m_sunTab),
	m_fTimeScale(handle.m_fTimeScale),
	m_sundownid(handle.m_sundownid),
	m_bIsDayTime(true),
	m_lastsecond(0),
	m_lasttick(0L),
	m_disiable(false)
{
	if(handle.m_dayNightHandle.valid())
		m_dayNightHandle = handle.m_dayNightHandle->clone();
	if(handle.m_timeChangeHandle.valid())
		m_timeChangeHandle = handle.m_timeChangeHandle->clone();
}
void crJXJSunSimulateLogic::inputParam(int i, void *param)
{
}
void crJXJSunSimulateLogic::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sunTab = crTableIO::openFile(crGlobalHandle::getInstance()->getTableDir()+str);
		break;
	case 1:
		m_fTimeScale = atof(str.c_str());
		break;
	case 2:
		m_sundownid = atoi(str.c_str());
		break;
	case 3:
		m_disiable = atoi(str.c_str());
		break;
	}
}
void crJXJSunSimulateLogic::inputHandle(int i, void *param)
{
	switch (i)
	{
	case 0:
		m_dayNightHandle = (CRCore::crHandle *)param;
		break;
	case 1:
		m_timeChangeHandle = (CRCore::crHandle *)param;
		break;
	}
}

void crJXJSunSimulateLogic::outputParam(int i, void *param)
{
}
void crJXJSunSimulateLogic::operator()(crHandle &handle)
{
	bool daynightchange = false;
	bool bIsDayTime = false;
	crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(bindview&&bindview->isInited())
	{
		//float dt = m_updateVisitor->getFrameStamp()->getFrameInterval();
		CRCore::Timer_t currenttick = CRCore::Timer::instance()->tick();
		if(m_lasttick == 0L)
		{
			//m_interval += dt;
			//m_interval -= (int)m_interval;
			//if(m_interval<0.0f)
			//	m_interval = 0.0f;
			//else if(m_interval>1.0f)
			//{
			//	char gbuf[256];
			//	sprintf(gbuf,"JXJSunSimulate %f\n\0",m_interval);
			//	gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
			//}
			m_lasttick = currenttick;
			//m_lasttimer = t1;
			time_t t1 = time(0);
			struct tm *pnow;  
			pnow=localtime(&t1);
			m_lastsecond = pnow->tm_hour*3600+pnow->tm_min*60+pnow->tm_sec;
			daynightchange = true;
		}
		float tickdt = CRCore::Timer::instance()->delta_s(m_lasttick,currenttick);
		//char gbuf[256];
		//sprintf(gbuf,"JXJSunSimulate %f\n\0",tickdt);	
		//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
		float last = m_lastsecond;
		last += tickdt;
		last *= m_fTimeScale;
		int unrelsec = (int)last%86400;
		if(!crDisplaySettings::instance()->getEnableAlphaShadow() || m_disiable)
		{
			unrelsec = 9*3600+30*60;
		}
		crVector3 vec3;
		int rowcount = m_sunTab->getRowCount();
		int i = 0;
		for( ;i<rowcount; i++ )
		{
			crArgumentParser::appAtoVec((*m_sunTab)(i,0),vec3);
			if(unrelsec<vec3[0]*3600+vec3[1]*60+vec3[2])
			{
				break;
			}
		}
		int ifrom,ito;
		if(i == rowcount)
		{
			ifrom = rowcount-1;
			ito = 0;
		}
		else
		{
			ifrom = i==0?rowcount-1:i-1;
			ito = i;
		}
		int colid = 1;
		int timeid = atoi((*m_sunTab)(ifrom,colid++).c_str());
		crTableIO::StrVec record1,record2;//日出时间点0,日落时间点4
		m_sunTab->queryOneRecord(1,crArgumentParser::appItoa(0),record1);
		m_sunTab->queryOneRecord(1,crArgumentParser::appItoa(m_sundownid),record2);
		crVector3 vec3_0,vec3_4;
		crArgumentParser::appAtoVec(record1[0],vec3_0);
		crArgumentParser::appAtoVec(record2[0],vec3_4);
		int sunstartsec = vec3_0[0]*3600+vec3_0[1]*60+vec3_0[2];
		int sunendsec = vec3_4[0]*3600+vec3_4[1]*60+vec3_4[2];
		int sunseccount = sunendsec - sunstartsec;
		crVector3 lightpos;
		int sec;
		if(timeid>=0 && timeid<m_sundownid)
		{//太阳周期
			sec = unrelsec - sunstartsec;
			lightpos[0] = cos(CRCore::PI * (float)sec / (float)sunseccount) * 1000.0f;
			lightpos[2] = sin(CRCore::PI * (float)sec / (float)sunseccount) * 1000.0f;
			if(timeid!=0&&timeid!=m_sundownid-1)
			{
				bIsDayTime = true;
			}
		}
		else
		{//月亮周期
			int moonseccount = 86400-sunseccount;
			sec = unrelsec;
			if(sec<sunendsec)
			{
				sec += 86400 - sunendsec;
			}
			else
			{
				sec -= sunendsec;
			}
			lightpos[0] = cos(CRCore::PI * (float)sec / (float)moonseccount) * 1000.0f;
			lightpos[2] = sin(CRCore::PI * (float)sec / (float)moonseccount) * 1000.0f;
		}
		lightpos[1] = atoi((*m_sunTab)(ifrom,colid++).c_str());
		crVector3 vec3_2;
		crVector4 vec4, vec4_2;
		crVector3 ambient,diffuse,specular;
		float flt1;
		crLightSource *sun = crLightSourceManager::getInstance()->getSunLightSource();
		crLightSource::LightParamStruct *lp = sun->getLightParamStruct();
		sun->setEffectPosition(lightpos);
		///从from插值到to
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,0),vec3);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,0),vec3_2);
		sec = unrelsec - (vec3[0]*3600+vec3[1]*60+vec3[2]);
		if(sec < 0)
		{
			sec += 86400;
		}
		crVector3 tmpvec3 = vec3_2-vec3;
		int seccount = tmpvec3[0]*3600+tmpvec3[1]*60+tmpvec3[2];
		if(seccount<0)
		{
			seccount += 86400;
		}
		float fRate = (float)sec/(float)seccount;
		//if(fRate>1.0f)
		//{
		//	fRate = 1.0f;
		//}
		//colid=3
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec3);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec3_2);
		colid++;
		ambient = CRCore::lerp(vec3, vec3_2, fRate);
		ambient /= 255.0f;
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec3);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec3_2);
		colid++;
		diffuse = CRCore::lerp(vec3, vec3_2, fRate);
		diffuse /= 255.0f;
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec3);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec3_2);
		colid++;
		specular = CRCore::lerp(vec3, vec3_2, fRate);
		specular /= 255.0f;
		flt1 = CRCore::lerp(atof((*m_sunTab)(ifrom,colid).c_str()), atof((*m_sunTab)(ito,colid).c_str()), fRate);
		colid++;
		lp->m_lsParam.set(ambient[0],ambient[1],ambient[2],ambient[3],
			diffuse[0],diffuse[1],diffuse[2],diffuse[3],
			specular[0],specular[1],specular[2],specular[3],
			flt1,0.0f,0.0f,0.0f);

		//环境色
		crVector4 vec4Tmp, vec4Tmp2;
		crVector3 vec3Tmp;
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec4);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec4_2);
		colid++;
		vec4Tmp = CRCore::lerp(vec4, vec4_2, fRate);
		float brightness = vec4Tmp[3] + crDisplaySettings::instance()->getBrightness();
		vec4Tmp /= 255.0f;
		vec4Tmp[3] = 1.0f;
		ref_ptr<crSceneView> sceneView = bindview->getDefaultSceneHandler()->getSceneView();
		crStateSet *globalss = sceneView->getGlobalStateSet();
		crLightModel *lightModel = dynamic_cast<crLightModel *>(globalss->getAttribute(crStateAttribute::LIGHTMODEL));
		lightModel->setAmbientIntensity(vec4Tmp + crVector4(brightness,brightness,brightness,0.0f));

		///雾颜色 雾参数
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec3);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec3_2);
		colid++;
		vec3Tmp = CRCore::lerp(vec3, vec3_2, fRate);
		vec3Tmp /= 255.0f;
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec4);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec4_2);
		colid++;
		vec4Tmp2 = CRCore::lerp(vec4, vec4_2, fRate);
		crUniform *uniform;
		if(crBrain::getInstance()->getFog()==1)
		{
			uniform = globalss->getUniform("fog_color");
			uniform->set(vec3Tmp);

			uniform = globalss->getUniform("fog_params");
			uniform->set(vec4Tmp2);
		}
		///上天光 下天光
		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec4);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec4_2);
		colid++;
		vec4Tmp = CRCore::lerp(vec4, vec4_2, fRate);
		flt1 = vec4Tmp[3];
		vec3.set(vec4Tmp[0],vec4Tmp[1],vec4Tmp[2]);
		vec3 /= 255.0f;
		vec3 *= flt1;
		uniform = globalss->getUniform("UpperSkyColor");
		uniform->set(vec3);

		crArgumentParser::appAtoVec((*m_sunTab)(ifrom,colid),vec4);
		crArgumentParser::appAtoVec((*m_sunTab)(ito,colid),vec4_2);
		colid++;
		vec4Tmp = CRCore::lerp(vec4, vec4_2, fRate);
		flt1 = vec4Tmp[3];
		vec3.set(vec4Tmp[0],vec4Tmp[1],vec4Tmp[2]);
		vec3 /= 255.0f;
		vec3 *= flt1;
		uniform = globalss->getUniform("LowerSkyColor");
		uniform->set(vec3);
		if(m_timeChangeHandle.valid())
		{
			m_timeChangeHandle->inputParam(2,&unrelsec);
			(*m_timeChangeHandle)(*this);
		}
	}
	if(m_bIsDayTime != bIsDayTime)
	{
		m_bIsDayTime = bIsDayTime;
		daynightchange = true;
	}
	if(daynightchange)
	{
		if(m_dayNightHandle.valid())
		{
			m_dayNightHandle->inputParam(2,&m_bIsDayTime);
			(*m_dayNightHandle)(*this);
		}
	}

	//handle.outputParam(0,&m_bIsDayTime);
}

/////////////////////////////////////////
//
//crJXJSetNightLightMethod
//
/////////////////////////////////////////
crJXJSetNightLightMethod::crJXJSetNightLightMethod():
	m_bIsDayTime(false)
{
}
crJXJSetNightLightMethod::crJXJSetNightLightMethod(const crJXJSetNightLightMethod& handle):
	crMethod(handle),
	m_bIsDayTime(handle.m_bIsDayTime),
	m_nodename(handle.m_nodename)
{
}
void crJXJSetNightLightMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			m_bIsDayTime = *(bool *)(param);
		}
		break;
	}
}
void crJXJSetNightLightMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nodename = str;
		break;
	}
}
void crJXJSetNightLightMethod::operator()(crHandle &handle)
{
	//显示火把
	//std::string disablelsStr = "Manorlight01|Manorlight02|Manorlight03|Manorlight04|Manorlight05|Manorlight06|Manorlight12|Manorlight15|Manorlight19|Manorlight21|Manorlight23|Manorlight26|Manorlight27|Manorlight28";
	crLightSourceManager::LSVec& lsVec = crLightSourceManager::getInstance()->getLSVec();
	for( crLightSourceManager::LSVec::iterator itr = lsVec.begin();
		itr != lsVec.end();
		++itr )
	{
		if(!(*itr)->getLightIsSunLight())
		{
			if(!crDisplaySettings::instance()->getEnableAlphaShadow())
				(*itr)->setEnable(false);
			else
				(*itr)->setEnable(!m_bIsDayTime);
		}
	}
	if(!m_nodename.empty())
	{
		crCollectNodeBYNameVisitor collector(MATRIXTRANSFORM);
		collector.insertNodeNameId(m_nodename);
		crGroup *root = crSceneManager::getInstance()->getStaticRoot();
		if(root)
		{
			root->accept(collector);
			NodeArray &nodeArray = collector.getResult();
			for( NodeArray::iterator itr = nodeArray.begin();
				itr != nodeArray.end();
				++itr )
			{
				(*itr)->setVisiable(!m_bIsDayTime);
			}
		}
	}
	//显示建筑灯光
	if(crRunGameHandle::getInstance()->isInManor())
	{
		CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
		if (scene)
		{
			ref_ptr<crMultiSwitch>lightsw;
			crInstanceItem *item;
			crNode *constructtionNode;
			//CRCore::crMultiSwitch *constructtionNode;
			CRNetApp::crScene::SceneItemMap &sceneItemMap = scene->getSceneItemMap();
			crCollectNodeBYNameVisitor collector;
			//collector.reset();
			collector.setSearchNodeType(MULTISWITCH);
			collector.insertNodeNameId("LV1");
			collector.insertNodeNameId("LV2");
			collector.insertNodeNameId("LV3");
			collector.insertNodeNameId("LV4");
			collector.insertNodeNameId("LV5");
			for( CRNetApp::crScene::SceneItemMap::iterator itr = sceneItemMap.begin();
				itr != sceneItemMap.end();
				++itr )
			{
				item = itr->second.get();
				constructtionNode = item->getRelNode();
				if(!constructtionNode)
				{
					//CRCore::notify(CRCore::ALWAYS)<<"crJXJSetConstructtionLevelMethod "<<aname<<" 的模型文件不正确"<<std::endl;
					continue;
				}
				constructtionNode->accept(collector);
			}
			NodeArray &nodeArray = collector.getResult();
			for( NodeArray::iterator itr = nodeArray.begin();
				itr != nodeArray.end();
				++itr )
			{
				lightsw = dynamic_cast<crMultiSwitch *>(itr->get());
				lightsw->setActiveSwitchSet(!m_bIsDayTime);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSceneSetVisiableMethod
//
/////////////////////////////////////////
crJXJSceneSetVisiableMethod::crJXJSceneSetVisiableMethod():
	m_visiable(true)
{
}
crJXJSceneSetVisiableMethod::crJXJSceneSetVisiableMethod(const crJXJSceneSetVisiableMethod& handle):
	crMethod(handle),
	m_visiable(handle.m_visiable)
{
}
void crJXJSceneSetVisiableMethod::inputParam(int i, void *param)
{
}
void crJXJSceneSetVisiableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_visiable = (bool)(atoi(str.c_str()));
		break;
	}
}
void crJXJSceneSetVisiableMethod::operator()(crHandle &handle)
{
	crGroup *root = crSceneManager::getInstance()->getStaticRoot();
	if(root)
	{
		root->setVisiable(m_visiable);
	}
}
/////////////////////////////////////////
//
//crJXJBulletFireCaseMethod
//
/////////////////////////////////////////
crJXJBulletFireCaseMethod::crJXJBulletFireCaseMethod(){}
crJXJBulletFireCaseMethod::crJXJBulletFireCaseMethod(const crJXJBulletFireCaseMethod& handle):
	crMethod(handle),
	m_fxidMap(handle.m_fxidMap)
{
}
void crJXJBulletFireCaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crBulletMatterObject*)param;
		break;
	}
}
void crJXJBulletFireCaseMethod::addParam(int i, const std::string& str)
{
	std::vector<int> vec;
	crArgumentParser::appAtoVec(str, vec);
	for (int i = 1; i < vec.size(); i++)
	{
		m_fxidMap.insert(std::make_pair(vec[i], vec[0]));
	}
}
void crJXJBulletFireCaseMethod::operator()(crHandle &handle)
{
	int _case = 0;
	ref_ptr<crViewMatterObject> fire = m_this->getFireWeapon()->getFireBody();
	crData *data = fire->getDataClass();
	if(data)
	{
		void *param;
		data->getParam(WCHDATA_Item,param);
		if(param)
		{
			ref_ptr<crInstanceItem> item = ((crInstanceItem*)param);
			if(item.valid())
			{
				unsigned int guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if(guisestate & GS_ExtraAttack)
				{
					std::map<int,int>::iterator itr = m_fxidMap.begin();

					while (itr!=m_fxidMap.end())
					{
						if(item->findChildItemByAbstractID(itr->first)!=NULL)
						{
							_case = itr->second;
							break;
						}
						itr++;
					}
					//_case = 1;//GS_ExtraAttack
				}
			}
		}
	}
	handle.outputParam(0,&_case);
}
/////////////////////////////////////////
//
//crJXJUseItemCheckMethod
//
/////////////////////////////////////////
crJXJUseItemCheckMethod::crJXJUseItemCheckMethod():m_useItemParam(NULL){}
crJXJUseItemCheckMethod::crJXJUseItemCheckMethod(const crJXJUseItemCheckMethod& handle):
	crMethod(handle),
	m_useItemParam(NULL)
{
}
void crJXJUseItemCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam*)(LOINT64(param64));
			m_useResult = (unsigned short *)(HIINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	}
}

void crJXJUseItemCheckMethod::addParam(int i, const std::string& str)
{
}

void crJXJUseItemCheckMethod::operator()(crHandle &handle)
{
	if(crGlobalHandle::isClient() && !m_this->getNode())
		return;
	if(m_useItemParam && m_useResult && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		do
		{
			void *param;
			crInstanceItem *targetItem = m_useItemParam->m_target.get();
			if(targetItem && targetItem->getDataClass())
			{
				crData *targetData = targetItem->getDataClass();
				targetData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *((unsigned char*)param);
				if (itemstate == IS_Dead || itemstate == IS_Relive)
				{//IS_Dead
					*m_useResult = UR_TargetDead;
					break;
				}
				//targetData->getParam(WCHDATA_RTHP,param);
				//float* rthp = (float *)param;
				//if(rthp && *rthp <= 0)
				//{//IS_Dead
				//	*m_useResult = UR_TargetDead;
				//	break;
				//}
			}

			crData *thisData = m_this->getDataClass();
			CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			thisData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char*)param;
			if(datatype == DT_Attack)
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			else
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,1),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod cdtime "<<cdtime<<std::endl;
			thisData->getParam(WCHDATA_LastUseTime,param);
			_crInt64 lastUseTime = *(_crInt64 *)param;
			if(lastUseTime != 0)
			{
				float dt = CRCore::Timer::instance()->delta_s( lastUseTime, t1 );
				if(dt<cdtime)
				{
					*m_useResult = UR_InCD;
					break;
				}
			}
			crData *userData = m_useItemParam->m_user->getDataClass();
			//userData->getParam(WCHDATA_CurUseItemProtectTime,param);
			//float curUseItemProtectTime = *(float*)param;
			//if(curUseItemProtectTime>0.0f)
			//{
			//	*m_useResult = UR_UseItemProtect;
			//	break;
			//}

			userData->excHandle(MAKEINT64(WCH_LockData,1));

			float *rtmp = NULL;
			userData->getParam(WCHDATA_RTMP,param);
			rtmp = (float*)param;

			thisData->getParam(WCHDATA_JXJUseMpValLimit,param);
			unsigned short useMPLimit = *(unsigned short*)param;
			if(useMPLimit > 0)
			{
				if(*rtmp<useMPLimit)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			float needMP = 0.0f;
			m_useItemParam->m_user->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,m_this));
			//m_this->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,NULL));
			//thisData->getParam(WCHDATA_NeedMP,param);
			//unsigned short needMP = *(unsigned short*)param;
			if(needMP>0.0f)
			{
				if(*rtmp<needMP)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			thisData->getParam(WCHDATA_NeedHP,param);
			unsigned short needHP = *(unsigned short*)param;
			float *rthp = NULL;
			if(needHP>0)
			{
				userData->getParam(WCHDATA_RTHP,param);
				rthp = (float*)param;
				if(*rthp<=needHP)
				{
					*m_useResult = UR_HPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			//UR_TargetInvalid check
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			*m_useResult = UR_Succeed;

		}while(0);

		m_useItemParam = NULL;
		m_useResult = NULL;
	}
}
/////////////////////////////////////////
//
//crJXJUseItemMethod
//
/////////////////////////////////////////
crJXJUseItemMethod::crJXJUseItemMethod():m_useItemParam(NULL){}
crJXJUseItemMethod::crJXJUseItemMethod(const crJXJUseItemMethod& handle):
	crMethod(handle),
	m_useItemParam(NULL)
{
}
void crJXJUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam*)(LOINT64(param64));
			m_useResult = (unsigned short *)(HIINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	}
}

void crJXJUseItemMethod::addParam(int i, const std::string& str)
{
}

void crJXJUseItemMethod::operator()(crHandle &handle)
{
	if(m_this->getNode() && m_useItemParam && m_useResult && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		do
		{
			void *param;
			crInstanceItem *targetItem = m_useItemParam->m_target.get();
			if(targetItem && targetItem->getDataClass())
			{
				crData *targetData = targetItem->getDataClass();
				targetData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *((unsigned char*)param);
				if(itemstate == IS_Dead)
				{//IS_Dead
					*m_useResult = UR_TargetDead;
					break;
				}
				//targetData->getParam(WCHDATA_RTHP,param);
				//float* rthp = (float *)param;
				//if(rthp && *rthp <= 0)
				//{//IS_Dead
				//	*m_useResult = UR_TargetDead;
				//	break;
				//}
			}

			crData *thisData = m_this->getDataClass();
			CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			thisData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char*)param;
			if(datatype == DT_Attack)
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			else
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,1),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod cdtime "<<cdtime<<std::endl;
			thisData->getParam(WCHDATA_LastUseTime,param);
			_crInt64 lastUseTime = *(_crInt64 *)param;
			if(lastUseTime != 0)
			{
				float dt = CRCore::Timer::instance()->delta_s( lastUseTime, t1 );
				if(dt<=cdtime)
				{
					*m_useResult = UR_InCD;
					break;
				}
			}
			crData *userData = m_useItemParam->m_user->getDataClass();
			//userData->getParam(WCHDATA_CurUseItemProtectTime,param);
			//float curUseItemProtectTime = *(float*)param;
			//if(curUseItemProtectTime>0.0f)
			//{
			//	*m_useResult = UR_UseItemProtect;
			//	break;
			//}

			userData->excHandle(MAKEINT64(WCH_LockData,1));

			float *rtmp = NULL;
			userData->getParam(WCHDATA_RTMP,param);
			rtmp = (float*)param;

			thisData->getParam(WCHDATA_JXJUseMpValLimit,param);
			unsigned short useMPLimit = *(unsigned short*)param;
			if(useMPLimit > 0)
			{
				if(*rtmp<useMPLimit)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			float needMP = 0.0f;
			m_useItemParam->m_user->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,m_this));
			//m_this->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,NULL));
			//thisData->getParam(WCHDATA_NeedMP,param);
			//unsigned short needMP = *(unsigned short*)param;
			if(needMP>0.0f)
			{
				if(*rtmp<needMP)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			thisData->getParam(WCHDATA_NeedHP,param);
			unsigned short needHP = *(unsigned short*)param;
			float *rthp = NULL;
			if(needHP>0)
			{
				userData->getParam(WCHDATA_RTHP,param);
				rthp = (float*)param;
				if(*rthp<=needHP)
				{
					*m_useResult = UR_HPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}
			//UR_TargetInvalid check
			//if(rtmp)
			//{
			//	*rtmp -= needMP;
			//}
			//if(rthp)
			//{
			//	*rthp -= needHP;
			//}
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			*m_useResult = UR_Succeed;
			lastUseTime = t1;
			thisData->inputParam(WCHDATA_LastUseTime,&lastUseTime);
			/////UserExtra
			//crHandle *handle = thisData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Client));
			//if(handle)
			//{
			//	thisData->getParam(WCHDATA_UserExtraID,param);
			//	_crInt32 userExtraID = *((_crInt32*)param);

			//	//userData->excHandle(MAKEINT64(WCH_LockData,1));
			//	userData->getParam(WCHDATA_ExtraData,param);
			//	crData *extraData = (crData *)param;
			//	if(extraData)
			//	{
			//		bool can = true;
			//		short extraid = LOINT32(userExtraID);
			//		short extrapri = HIINT32(userExtraID);
			//		extraData->excHandle(MAKEINT64(WCH_LockData,1));
			//		extraData->getParam(WCHDATA_ExtraIDMap,param);
			//		ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
			//		ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
			//		if(exitr != extraIDMap->end())
			//		{
			//			if(extrapri<exitr->second)
			//			{
			//				can = false;
			//			}
			//		}
			//		if(can)
			//		{
			//			crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
			//			if(dynamic_cast<crNodeDrive *>(existhandle))
			//			{
			//				(dynamic_cast<crNodeDrive *>(existhandle))->releaseObjects(NULL);
			//			}
			//			crHandle *cloneHandle = handle->clone();
			//			extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
			//			(*extraIDMap)[extraid] = extrapri;
			//		}
			//		extraData->excHandle(MAKEINT64(WCH_LockData,0));
			//	}
			//	//userData->excHandle(MAKEINT64(WCH_LockData,0));
			//}
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod"<<std::endl;
			//fire
			crNode *userNode = m_useItemParam->m_user->getRelNode();

			//ItemUsePair *itemUsePair = new ItemUsePair;
			thisData->getParam(WCHDATA_ChantTime,param);//吟唱时间
			float chanttime = *(float *)param;
			ref_ptr<ItemUseParam> itemUseParam = new ItemUseParam;
			itemUseParam->m_itemid = m_this->getID();
			itemUseParam->m_chanttime = chanttime;
			itemUseParam->m_dirOffset = m_useItemParam->m_dirOffset;
			//itemUsePair->first = dynamic_cast<crGroup *>(m_this->getNode());
			itemUseParam->m_weapon = dynamic_cast<crGroup *>(m_this->getNode());
			if(targetItem)
			{
				crNode *targetNode = targetItem->getRelNode();
				if(targetNode)
				{
					//itemUsePair->second.first = targetNode;
					itemUseParam->m_targetNode = targetNode;
					if(dynamic_cast<crMatterObject *>(targetNode))
					{
						//itemUsePair->second.second = (dynamic_cast<crMatrixTransform *>(targetNode))->getTrans();
						itemUseParam->m_targetPos = (dynamic_cast<crMatterObject *>(targetNode))->getPhysicsCenter();
					}
					else
					{
						//itemUsePair->second.second = targetNode->getBound().center();
						itemUseParam->m_targetPos = targetNode->getBound().center();
					}
				}
				else
				{
					itemUseParam->m_targetNode = NULL;
					itemUseParam->m_targetPos = targetItem->getPosition();
					if(userNode) itemUseParam->m_targetPos[2] += userNode->getBoundBox().zLength()*0.5f;
				}
			}
			else
			{
				//itemUsePair->second.first = NULL;
				itemUseParam->m_targetNode = NULL;
				userData->getParam(WCHDATA_ItemState,param);
				unsigned char itemstate = *(unsigned char *)param;
				if(itemstate == IS_MoveToPos || itemstate == IS_MoveToUseSkill/* || itemstate == IS_AttackToPos*/)
				{
					userData->getParam(WCHDATA_MoveToPos,param);
				}
				else
				{
					userData->getParam(WCHDATA_TargetPos,param);
				}
				//itemUsePair->second.second = *((crVector3*)param);
				itemUseParam->m_targetPos = *((crVector3*)param);
			}
			//if(!userNode->getVisiable()||!userNode->getEnableIntersect())
			//{
			//             userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,5));
			//}
			//userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
			//if(userNode)
			//    userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_ItemUse,itemUseParam/*itemUsePair*/));

			thisData->getParam(WCHDATA_UseItemProtectTime,param);//吟唱时间
			float itemProtectTime = *(float *)param;
			//userData->inputParam(WCHDATA_CurUseItemProtectTime,&itemProtectTime);
			thisData->getParam(WCHDATA_DataType,param);
			datatype = *(unsigned char *)param;
			if(datatype == DT_Attack)
			{//普通攻击，做暴击判断
				//命中率判定
				//m_useItemParam->m_user->doEvent(WCH_HitratioTest);
				//userData->getParam(WCHDATA_IsMiss,param);
				//bool isMiss = *(bool *)param;
				//if(!isMiss)
				//	m_useItemParam->m_user->doEvent(WCH_CritTest);
				userData->inputParam(WCHDATA_AttackUseParam,itemUseParam.get());
				m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&cdtime,m_this));
				//char gbuf[256];
				//sprintf(gbuf,"UseItem Weapon:%d,targetNode:%d\n\0",itemUseParam->m_weapon->getChild(0),itemUseParam->m_targetNode.get());
				//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
			}
			else
			{
				userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
				m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&itemProtectTime,m_this));

				//crVector3 pos = itemUseParam->m_targetPos;
				//crVector3 dir = pos-m_useItemParam->m_user->getPosition();
				//dir.normalize();
				m_this->doEvent(WCH_PlayUseItemFx,MAKEINT64(m_useItemParam->m_user.get(),NULL));//吟唱特效
			}

			if(datatype == DT_AttackThing)
			{//道具数量减1
				char removeItem = -1;
				m_useItemParam->m_user->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem)); 
			}
			//CRCore::notify(CRCore::ALWAYS)<<"crUseItemMethod "<<std::endl;
		}while(0);

		m_useItemParam = NULL;
		m_useResult = NULL;
	}
}
/////////////////////////////////////////
//
//crJXJServerUseItemMethod
//
/////////////////////////////////////////
crJXJServerUseItemMethod::crJXJServerUseItemMethod():m_useItemParam(NULL){}
crJXJServerUseItemMethod::crJXJServerUseItemMethod(const crJXJServerUseItemMethod& handle):
	crMethod(handle),
	m_useItemParam(NULL)
{
}
void crJXJServerUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam *)(LOINT64(param64));
			m_useResult = (unsigned short *)(HIINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
			m_useResult = NULL;
		}
		break;
	}
}

void crJXJServerUseItemMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerUseItemMethod::operator()(crHandle &handle)
{
	if(m_useItemParam && m_useResult && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		do
		{
			void *param;
			//服务器不做目标死亡判定
			//crInstanceItem *targetItem = m_useItemParam->m_target.get();
			//if(targetItem && targetItem->getDataClass())
			//{
			//	crData *targetData = targetItem->getDataClass();
			//	targetData->getParam(WCHDATA_ItemState,param);
			//	unsigned char itemstate = *((unsigned char*)param);
			//	if(itemstate == IS_Dead)
			//	{//IS_Dead
			//		*m_useResult = UR_TargetDead;
			//		break;
			//	}
			//	//targetData->getParam(WCHDATA_RTHP,param);
			//	//float* rthp = (float *)param;
			//	//if(rthp && *rthp <= 0)
			//	//{//IS_Dead
			//	//	*m_useResult = UR_TargetDead;
			//	//	break;
			//	//}
			//}

			crData *thisData = m_this->getDataClass();
			CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			thisData->getParam(WCHDATA_DataType,param);
			unsigned char datatype = *(unsigned char*)param;
			if(datatype == DT_Attack)
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			else
				m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,1),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			//CRCore::notify(CRCore::ALWAYS)<<"crServerUseItemMethod cdtime "<<cdtime<<std::endl;
			thisData->getParam(WCHDATA_LastUseTime,param);
			_crInt64 lastUseTime = *(_crInt64 *)param;
			if(lastUseTime != 0)
			{
				float dt = CRCore::Timer::instance()->delta_s( lastUseTime, t1 );
				if(dt<cdtime)
				{
					*m_useResult = UR_InCD;
					break;
				}
			}
			crData *userData = m_useItemParam->m_user->getDataClass();
			//userData->getParam(WCHDATA_CurUseItemProtectTime,param);
			//float curUseItemProtectTime = *(float*)param;
			//if(curUseItemProtectTime>0.0f)
			//{
			//	*m_useResult = UR_UseItemProtect;
			//	break;
			//}

			userData->excHandle(MAKEINT64(WCH_LockData,1));
			float *rtmp = NULL;
			userData->getParam(WCHDATA_RTMP,param);
			rtmp = (float*)param;

			thisData->getParam(WCHDATA_JXJUseMpValLimit,param);
			unsigned short useMPLimit = *(unsigned short*)param;
			if(useMPLimit > 0)
			{
				if(*rtmp<useMPLimit)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			float needMP = 0.0f;
			m_useItemParam->m_user->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,m_this));
			//thisData->getParam(WCHDATA_NeedMP,param);
			//unsigned short needMP = *(unsigned short*)param;
			if(needMP>0.0f)
			{
				if(*rtmp<needMP)
				{
					*m_useResult = UR_MPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			thisData->getParam(WCHDATA_NeedHP,param);
			unsigned short needHP = *(unsigned short*)param;
			float *rthp = NULL;
			if(needHP>0)
			{
				userData->getParam(WCHDATA_RTHP,param);
				rthp = (float*)param;
				if(*rthp<=needHP)
				{
					*m_useResult = UR_HPLack;
					userData->excHandle(MAKEINT64(WCH_LockData,0));
					break;
				}
			}

			//UR_TargetInvalid check

			//if(rtmp)
			//{
			//	*rtmp -= needMP;
			//}
			//if(rthp)
			//{
			//	*rthp -= needHP;
			//}
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			if(needHP>0)
			{
				DamagePair dp(needHP,std::make_pair(SkillDM,0));//ExtraDM
				m_useItemParam->m_user->doEvent(WCH_AddDamage,MAKEINT64(&dp,NULL));
			}
			if (needMP>0)
			{
				float needMPf = needMP;
				m_useItemParam->m_user->doEvent(WCH_JXJReduceRTMp,MAKEINT64(&needMPf,NULL));
			}

			*m_useResult = UR_Succeed;
			lastUseTime = t1;
			thisData->inputParam(WCHDATA_LastUseTime,&lastUseTime);

			//thisData->getParam(WCHDATA_UseItemProtectTime,param);
			//float itemProtectTime = *(float *)param;
			//userData->inputParam(WCHDATA_CurUseItemProtectTime,&itemProtectTime);
			//CRCore::notify(CRCore::ALWAYS)<<"crServerUseItemMethod"<<std::endl;
			//thisData->getParam(WCHDATA_DataType,param);
			//datatype = *(unsigned char*) param;
			//if(datatype == DT_AttackThing)
			//{//道具数量减1
			//	char removeItem = -1;
			//	m_useItemParam->m_user->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem));
			//}
			//else if(datatype == DT_Attack)
			//{//普通攻击，做暴击判断
			//	m_useItemParam->m_user->doEvent(WCH_HitratioTest);
			//	userData->getParam(WCHDATA_IsMiss,param);
			//	bool isMiss = *(bool *)param;
			//	if(!isMiss)
			//	{
			//		m_useItemParam->m_user->doEvent(WCH_CritTest);
			//		//目标做格挡躲避等判断
			//		if(targetItem && targetItem->getDataClass())
			//		{
			//			crData *targetData = targetItem->getDataClass();
			//			targetItem->doEvent(WCH_DodgeTest);
			//			targetData->getParam(WCHDATA_IsDodge,param);
			//			bool isDodge = *(bool *)param;
			//			if(!isDodge)
			//				targetItem->doEvent(WCH_ParryTest);
			//		}
			//	}
			//}
			//server要记录本次攻击
			crData *bulletitemData = m_this->getDataClass();
			if(bulletitemData)
			{
				CRCore::ref_ptr<HitParam> hitParam;
				bulletitemData->getParam(WCHDATA_DataType,param);
				unsigned char datatype = *(unsigned char*) param;
				if(datatype == DT_Skill)
				{
					hitParam = new HitParam;
					hitParam->m_hitItem = m_useItemParam->m_target;
					hitParam->m_rate = 1.0f;
					hitParam->m_fireItem = m_useItemParam->m_user;
					m_useItemParam->m_user->doEvent(WCH_UseSkillExtraTest,MAKEINT64(hitParam.get(),NULL));
				}
				if(datatype == DT_Attack && m_useItemParam->m_user->getItemtype() != crInstanceItem::Role)/* && !dynamic_cast<crRole *>(m_useItemParam->m_target.get()))*/
				{//NPC攻击NPC，或者攻击角色,立即命中
					//CRCore::notify(CRCore::ALWAYS)<<"crNodeCollideWithItemMethod "<<m_this->getID()<<std::endl;
					if(!hitParam.valid())
					{
						hitParam = new HitParam;
						hitParam->m_hitItem = m_useItemParam->m_target;
						hitParam->m_rate = 1.0f;
						hitParam->m_fireItem = m_useItemParam->m_user;
					}
					m_this->doEvent(WCH_NodeCollideWithItem,MAKEINT64(hitParam.get(),NULL));

					//if(datatype == DT_Attack)
					//{//普通攻击，做暴击判断
					m_useItemParam->m_user->doEvent(WCH_MissCritTest);
					if(m_useItemParam->m_target.valid())
						m_useItemParam->m_target->doEvent(WCH_DodgeParryTest);
					//else
					//{
					//	CRCore::notify(CRCore::ALWAYS)<<"NPC攻击方式配置错误：NPCAbstract: "<<m_useItemParam->m_user->getAbstractItemID()<<" AttackID:"<<m_this->getAbstractItemID()<<std::endl;
					//}
					//}
				}
				else
				{
					thisData->getParam(WCHDATA_Duration,param);
					float duration = *(float *)param;
					ref_ptr<crUseItemRecord> userItemRecord = new crUseItemRecord;
					userItemRecord->setItem(m_this);
					userItemRecord->setUser(m_useItemParam->m_user.get());
					thisData->getParam(WCHDATA_DamageCount,param);
					unsigned char damagecount = *(unsigned char *)param;
					if(damagecount==1)
						userItemRecord->setTarget(m_useItemParam->m_target.get());//需要判断该技能是群攻还是单体攻击，如果是群攻则m_target＝NULL
					userItemRecord->setDamageCount(damagecount);
					userItemRecord->setDuration(duration);
					crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_UseItemRecordMap,param);
					UseItemRecordMap *useItemRecordMap = (UseItemRecordMap *)param;
					useItemRecordMap->insert(std::make_pair(userItemRecord->getUser(),userItemRecord.get()));
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}while(0);
		m_useItemParam = NULL;
		m_useResult = NULL;
	}
}
/////////////////////////////////////////
//
//crJXJNetUseItemMethod
//
/////////////////////////////////////////
crJXJNetUseItemMethod::crJXJNetUseItemMethod():m_usercdid(0){}
crJXJNetUseItemMethod::crJXJNetUseItemMethod(const crJXJNetUseItemMethod& handle):
	crMethod(handle),
	m_usercdid(handle.m_usercdid)
{
}
void crJXJNetUseItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_useItemParam = (UseItemParam *)(LOINT64(param64));
		}
		else
		{
			m_useItemParam = NULL;
		}
		break;
	}
}

void crJXJNetUseItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_usercdid = (unsigned char)(atoi(str.c_str()));
		break;
	}
}

void crJXJNetUseItemMethod::operator()(crHandle &handle)
{
	if(m_this->getNode() && m_useItemParam && m_useItemParam->m_user.valid() && m_useItemParam->m_user->getDataClass())
	{
		///UserExtra
		void *param;
		crData *thisData = m_this->getDataClass();
		crData* userData = m_useItemParam->m_user->getDataClass();

		float needMP = 0.0f;
		m_useItemParam->m_user->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,m_this));
		//m_this->doEvent(WCH_JXJGetSkillNeedRTMP,MAKEINT64(&needMP,NULL));
		//thisData->getParam(WCHDATA_NeedMP,param);
		//unsigned short needMP = *(unsigned short*)param;
		float *rtmp = NULL;
		userData->excHandle(MAKEINT64(WCH_LockData,1));
		if(needMP>0)
		{
			userData->getParam(WCHDATA_RTMP,param);
			rtmp = (float*)param;
		}
		thisData->getParam(WCHDATA_NeedHP,param);
		unsigned short needHP = *(unsigned short*)param;
		float *rthp = NULL;
		if(needHP>0)
		{
			userData->getParam(WCHDATA_RTHP,param);
			rthp = (float*)param;
		}
		if(rtmp)
		{
			*rtmp -= needMP;
		}
		if(rthp)
		{
			*rthp -= needHP;
		}
		userData->excHandle(MAKEINT64(WCH_LockData,0));

		//crHandle *handle = thisData->getHandle(MAKEINT64(WCH_UserExtra,WCH_Client));
		//if(handle)
		//{
		//	thisData->getParam(WCHDATA_UserExtraID,param);
		//	_crInt32 userExtraID = *((_crInt32*)param);

		//	//userData->excHandle(MAKEINT64(WCH_LockData,1));
		//	userData->getParam(WCHDATA_ExtraData,param);
		//	crData *extraData = (crData *)param;
		//	if(extraData)
		//	{
		//		bool can = true;
		//		short extraid = LOINT32(userExtraID);
		//		short extrapri = HIINT32(userExtraID);
		//		extraData->excHandle(MAKEINT64(WCH_LockData,1));
		//		extraData->getParam(WCHDATA_ExtraIDMap,param);
		//		ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
		//		ExtraIDMap::iterator exitr = extraIDMap->find(extraid);
		//		if(exitr != extraIDMap->end())
		//		{
		//			if(extrapri<exitr->second)
		//			{
		//				can = false;
		//			}
		//		}
		//		if(can)
		//		{
		//			crHandle *existhandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extraid));
		//			if(dynamic_cast<crNodeDrive *>(existhandle))
		//			{
		//				(dynamic_cast<crNodeDrive *>(existhandle))->releaseObjects(NULL);
		//			}
		//			crHandle *cloneHandle = handle->clone();
		//			extraData->insertHandle(MAKEINT64(WCH_DoExtra,extraid),cloneHandle);
		//			(*extraIDMap)[extraid] = extrapri;
		//		}
		//		extraData->excHandle(MAKEINT64(WCH_LockData,0));
		//	}
		//	//userData->excHandle(MAKEINT64(WCH_LockData,0));
		//}
		//CRCore::notify(CRCore::ALWAYS)<<"crNetUseItemMethod"<<std::endl;
		//fire
		crNode *userNode = m_useItemParam->m_user->getRelNode();
		//ItemUsePair *itemUsePair = new ItemUsePair;
		ref_ptr<ItemUseParam> itemUseParam = new ItemUseParam;
		itemUseParam->m_itemid = m_this->getID();
		itemUseParam->m_dirOffset = m_useItemParam->m_dirOffset;
		//itemUsePair->first = dynamic_cast<crGroup *>(m_this->getNode());
		itemUseParam->m_weapon = dynamic_cast<crGroup *>(m_this->getNode());
		crInstanceItem *targetItem = m_useItemParam->m_target.get();
		if(targetItem)
		{
			crNode *targetNode = targetItem->getRelNode();
			if(targetNode)
			{
				//itemUsePair->second.first = targetNode;
				itemUseParam->m_targetNode = targetNode;
				if(dynamic_cast<crMatterObject *>(targetNode))
				{
					//itemUsePair->second.second = (dynamic_cast<crMatrixTransform *>(targetNode))->getTrans();
					itemUseParam->m_targetPos = (dynamic_cast<crMatterObject *>(targetNode))->getPhysicsCenter();
				}
				else
				{
					//itemUsePair->second.second = targetNode->getBound().center();
					itemUseParam->m_targetPos = targetNode->getBound().center();
				}
			}
			else
			{
				itemUseParam->m_targetNode = NULL;
				itemUseParam->m_targetPos = targetItem->getPosition();
				if(userNode) itemUseParam->m_targetPos[2] += userNode->getBoundBox().zLength()*0.5f;
			}
		}
		else
		{
			//itemUsePair->second.first = NULL;
			itemUseParam->m_targetNode = NULL;
			userData->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char *)param;
			if(itemstate == IS_MoveToPos || itemstate == IS_MoveToUseSkill/* || itemstate == IS_AttackToPos*/)
			{
				userData->getParam(WCHDATA_MoveToPos,param);
			}
			else
			{
				userData->getParam(WCHDATA_TargetPos,param);
			}
			itemUseParam->m_targetPos = *((crVector3*)param);
		}
		//if(!userNode->getVisiable()||!userNode->getEnableIntersect())
		//{
		//	userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_NodeInRange,5));
		//}
		//userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
		//if(userNode)
		//    userNode->doEvent(MAKEINT64(WCH_MSGCONTAINER,WCH_UPDATEVISITOR),MAKEINT64(WCH_ItemUse,itemUseParam/*itemUsePair*/));

		//thisData->getParam(WCHDATA_CDTime,param);
		//float cdtime = *(float *)param;
		//float usercd = 0;
		//m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,m_usercdid),MAKEINT64(&usercd,NULL));
		//cdtime += usercd;
		thisData->getParam(WCHDATA_DataType,param);
		unsigned char datatype = *(unsigned char*)param;
		if(datatype == DT_Attack)
		{
			userData->inputParam(WCHDATA_AttackUseParam,itemUseParam.get());
			thisData->getParam(WCHDATA_CDTime,param);
			float cdtime = *(float *)param;
			float cdreduce = 0.0f;
			m_useItemParam->m_user->doEvent(MAKEINT64(WCH_GetSkillCD,0),MAKEINT64(&cdreduce,NULL));
			if(cdreduce<=-1.0f)
				cdreduce = -0.99f; 
			cdtime = cdtime/(1.0f+cdreduce);
			m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&cdtime,m_this));
		}
		else
		{
			userData->inputParam(WCHDATA_ItemUseParam,itemUseParam.get());
			thisData->getParam(WCHDATA_UseItemProtectTime,param);
			float itemProtectTime = *(float *)param;
			m_useItemParam->m_user->doEvent(WCH_WEAPON_FIRE,MAKEINT64(&itemProtectTime,m_this));

			//crVector3 pos = itemUseParam->m_targetPos;
			//crVector3 dir = pos-m_useItemParam->m_user->getPosition();
			//dir.normalize();
			m_this->doEvent(WCH_PlayUseItemFx,MAKEINT64(m_useItemParam->m_user.get(),NULL));//吟唱特效
		}
		//thisData->getParam(WCHDATA_DataType,param);
		//unsigned char datatype = *(unsigned char*) param;
		//if(datatype == DT_AttackThing)
		//{//道具数量减1
		//	char removeItem = -1;
		//	m_userAndTargetItem->first->doEvent(WCH_RemoveItemFromBackPack,MAKEINT64(m_this,&removeItem));
		//}
		//发动攻击视野
		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
		if(me)
		{
			char isEnemy = 0;
			me->doEvent(WCH_EnemyCheck,MAKEINT64(m_useItemParam->m_user.get(),&isEnemy));
			if(isEnemy!=1)
			{
				bool visable = true;
				//if(m_useItemParam->m_target.valid())
				//{
				//	if(m_useItemParam->m_target == m_useItemParam->m_user)
				//	{
				//		visable = false;
				//	}
				//	else
				//	{
				//		isEnemy = 0;
				//		me->doEvent(WCH_EnemyCheck,MAKEINT64(m_useItemParam->m_target.get(),&isEnemy));
				//		if(isEnemy!=1)
				//		{
				//			visable = false;
				//		}
				//	}
				//}
				crMyPlayerData::getInstance()->insertItemVisiable(m_useItemParam->m_user.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraShiftingMethod
//
/////////////////////////////////////////
crJXJExtraShiftingMethod::crJXJExtraShiftingMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_flg(0),
	m_act(0),
	m_maxdist(0.0f),
	m_ignoreMap(false),
	m_start(false),
	m_timer(0.0f){}
crJXJExtraShiftingMethod::crJXJExtraShiftingMethod(const crJXJExtraShiftingMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_flg(handle.m_flg),
	m_act(handle.m_act),
	m_maxdist(handle.m_maxdist),
	m_ignoreMap(handle.m_ignoreMap),
	m_start(false),
	m_timer(0.0f)
{
}
void crJXJExtraShiftingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraShiftingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = atof(str.c_str());
		break;
	case 2:
		m_flg = (char)(atoi(str.c_str()));
		break;
	case 3:
		m_act = atoi(str.c_str());
		break;
	case 4:
		m_maxdist = atof(str.c_str());
		break;
	case 5:
		m_ignoreMap = atof(str.c_str());
		break;
	}
}

void crJXJExtraShiftingMethod::operator()(crHandle &handle)
{
	if(m_this->isMainAI() && m_fireItem.valid())
	{
		if(!m_start)
		{
			m_start = true;
			m_timer = m_duration;
			if(m_flg == 2)
			{
				rangef r(0.0f,2.0f*PI);
				float _r = r.get_random();
				m_dir.set(cos(_r),sin(_r),0.0f);
				m_this->setTargetDir(m_dir);
			}
			else if(m_flg == 3)
			{
				crVector3 mypos = m_this->getPosition();
				ref_ptr<crData> data = m_fireItem->getDataClass();
				if(data.valid())
				{
					void *param;
					data->getParam(WCHDATA_TargetPos,param);
					m_firepos = *(crVector3 *)param;
					m_dir = m_firepos - mypos;
					m_dir[2] = 0.0f;
					m_maxdist = m_dir.length();
					m_dir.normalize();
				}
			}
			else
			{
				crVector3 mypos = m_this->getPosition();
				m_firepos = m_fireItem->getPosition();
				if(m_flg == 1)
					m_dir = m_firepos - mypos;
				else
					m_dir = mypos-m_firepos;
				m_dir[2] = 0.0f;
				m_dir.normalize();
			}
		}
		if(m_timer>=0.0f)
		{
			float dt = *m_dt;
			if(m_duration>0.0f) m_timer -= dt;
			if(m_timer<0.0f)
				dt += m_timer;
			crVector3 itempos = m_this->getPosition();
			crSceneLayer *scenelayer = m_this->getSceneLayer();
			if(scenelayer)
			{
				float _dist = dt * m_extraValue;
				if (m_flg == 3)
				{
					_dist = CRCore::minimum(_dist, m_maxdist);
					m_maxdist -= _dist;
					if (m_maxdist == 0.0f)
						m_timer = 0.0f;
				}
				crVector2s coord;
				float dist = m_ignoreMap ? _dist : 1.0f;
				crVector3 newpos = itempos;
				crVector3 testpos;
				bool poschanged = false;
				while (!m_ignoreMap && dist<=_dist)
				{
					testpos = itempos + m_dir * dist;
					coord = scenelayer->getCoord(crVector2(testpos[0],testpos[1]));
					//判断新位置是否可站立
					if(scenelayer->walkability(coord[0],coord[1]))
					{
						newpos = testpos;
						poschanged = true;
					}
					else
					{
						break;
					}
					dist += 1.0f;
				}
				if(dist>=_dist)
				{
					testpos = itempos + m_dir * _dist;
					coord = scenelayer->getCoord(crVector2(testpos[0],testpos[1]));
					//判断新位置是否可站立
					if(scenelayer->walkability(coord[0],coord[1]))
					{
						newpos = testpos;
						poschanged = true;
					}
				}
				if(poschanged)
				{
					itempos = newpos;
					float scale = crGlobalHandle::gData()->gUnitScale();
					float z = m_this->getPosZ(itempos[0],itempos[1]);
					itempos[2] = z;
					itempos /= scale;
					m_this->setPosxy(itempos[0],itempos[1]);
					m_this->setPosz(itempos[2]);
					if(crGlobalHandle::isClient())
					{
						m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(m_this->getRelNode(),crMatterObject::MD_FullMatrix));
						if(m_act!=0)
						{
							float duration = 0.5f;
							m_this->doEvent(WCH_ChangeActState,MAKEINT64(m_act,&duration));
						}
					}
					if(m_flg == 1)
					{//1:向内
						m_dir = m_firepos - itempos;
						m_dir[2] = 0.0f;
						if(m_dir.length()<0.5f)
						{
							m_timer = 0.0f;
						}
						m_dir.normalize();
					}
					else if(m_flg == 0 && m_maxdist>0.0f)
					{//1:向外,最大距离限制
						if((m_firepos - itempos).length()>m_maxdist)
						{
							m_timer = 0.0f;
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraLiftMethod
//
/////////////////////////////////////////
crJXJExtraLiftMethod::crJXJExtraLiftMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_maxdist(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_movedDist(0.0f){}
crJXJExtraLiftMethod::crJXJExtraLiftMethod(const crJXJExtraLiftMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_maxdist(handle.m_maxdist),
	m_start(false),
	m_timer(0.0f),
	m_movedDist(0.0f)
{
}
void crJXJExtraLiftMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJExtraLiftMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = atof(str.c_str());
		break;
	case 2:
		m_maxdist = atof(str.c_str());
		break;
	}
}

void crJXJExtraLiftMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_movedDist = 0.0f;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;

		float z = m_this->getPosz();
		float _dist = *m_dt * m_extraValue;
		m_movedDist+=fabs(_dist);
		z+=_dist;
		if(m_maxdist>0.0f && m_movedDist>m_maxdist)
		{
			m_timer = 0.0f;
		}
		m_this->setPosz(z);
		m_this->doEvent(WCH_ItemCoordToNode,MAKEINT64(m_this->getRelNode(),crMatterObject::MD_FullMatrix));
	}
}
/////////////////////////////////////////
//
//crJXJExtraDelayControlMethod
//
/////////////////////////////////////////
crJXJExtraDelayControlMethod::crJXJExtraDelayControlMethod():
	m_dt(NULL),
	m_timer(0.0f),
	m_delay(0.0f){}
crJXJExtraDelayControlMethod::crJXJExtraDelayControlMethod(const crJXJExtraDelayControlMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_timer(0.0f),
	m_delay(handle.m_delay)
{
}
void crJXJExtraDelayControlMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJExtraDelayControlMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_delay = atof(str.c_str());
		break;
	}
}

void crJXJExtraDelayControlMethod::operator()(crHandle &handle)
{
	bool taskCanceled = true;
	m_timer += *m_dt;
	if(m_timer>m_delay)
	{
		taskCanceled = false;
	}
	handle.outputParam(0,&taskCanceled);
}
/////////////////////////////////////////
//
//crJXJNpcDeadDropItemMethod
//
/////////////////////////////////////////
crJXJNpcDeadDropItemMethod::crJXJNpcDeadDropItemMethod():
	m_interval(300.0f){}
crJXJNpcDeadDropItemMethod::crJXJNpcDeadDropItemMethod(const crJXJNpcDeadDropItemMethod& handle):
	crMethod(handle),
	m_interval(300.0f)
{
}
void crJXJNpcDeadDropItemMethod::addParam(int i, const std::string& str)
{
}
void crJXJNpcDeadDropItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_killerItem = (crInstanceItem*)(LOINT64(param64));
		}
		else
		{
			m_killerItem = NULL;
		}
		break;
	}
}
void crJXJNpcDeadDropItemMethod::operator()(crHandle &handle)
{
	if(m_killerItem.valid())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		crRoom *room = netCallback->findRoom(m_this->getRoomID());
		ref_ptr<crTableIO> dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJNpcItemDropTab);
		crTableIO::DataVec recordVec;
		dropTab->queryRecords(0,crArgumentParser::appItoa(m_this->getInstanceItemID()),recordVec);
		if(!recordVec.empty())
		{
			//参考crJXJServerOpenTreasureChestMethod
			int dropcountid = dropTab->getTitleIndex("掉落种数");
			int dropaid = dropTab->getTitleIndex("abstractid");
			int droptypeid = dropTab->getTitleIndex("itemtype");
			int oddsid = dropTab->getTitleIndex("掉落几率");
			int countid = dropTab->getTitleIndex("数量");
			int dropcount = atoi(recordVec[0][dropcountid].c_str());
			int odds = 0;
			int count;
			crVector2i countrange;
			CRCore::rangei counrnd;
			std::vector< crVector3i > DropedItemVec;//abstractid,itemtype,count
			int recordCount = recordVec.size();
			std::vector< std::pair<int,int> >DroprndVec;
			int i,j,k;
			int dropodds;
			for (i = 0; i < recordCount; i++)
			{
				dropodds = atoi(recordVec[i][oddsid].c_str());
				odds += dropodds;
				DroprndVec.push_back(std::make_pair(odds,dropodds));
			}
			crVector3i vec3;
			rangei rndi(0,odds);
			int r;
			for(i = 0; i<dropcount;i++)
			{
				r = rndi.get_random();
				for(j = 0; j<recordCount; j++)
				{
					if(r<=DroprndVec[j].first)
					{//该物品掉出
						//DroprndVec[j].first = -1;
						odds -= DroprndVec[j].second;
						rndi.set(0,odds);
						for (k = j+1; k < recordCount; k++)
						{
							DroprndVec[k].first -= DroprndVec[j].second;
						}						
						crArgumentParser::appAtoVec(recordVec[j][countid],countrange);
						counrnd.set(countrange[0],countrange[1]);
						count = counrnd.get_random();
						if(count>0)
						{
							vec3[0] = atoi(recordVec[j][dropaid].c_str());
							vec3[1] = atoi(recordVec[j][droptypeid].c_str());
							vec3[2] = count;
							DropedItemVec.push_back(vec3);
						}
						break;
					}
				}
			}
			ref_ptr<crInstanceItem> item;
			float scale = crGlobalHandle::gData()->gUnitScale();
			void *param;
			//crVector2 coordpos(m_this->getPosx()*scale,m_this->getPosy()*scale);
			crVector3 pos;
			ref_ptr<crAbstractItem> aitem;
			crData *fireData = m_killerItem->getDataClass();
			fireData->getParam(WCHDATA_Camp,param);
			unsigned char camp = *(unsigned char*)param;
			crData *itemdata;
			int abstractid = 0;
			unsigned char itemtype;
			/*unsigned short*/int itemcount;
			crJXJQueryAbstractItemPacket packet;
			float zoffset;
			int layerid = m_this->getLayerID();
			crNetConductor *gameServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
			int dropsize = DropedItemVec.size();
			int range = dropsize>10?2000:500;
			short sightRange;
			for( std::vector< crVector3i >::iterator itr = DropedItemVec.begin();
				itr != DropedItemVec.end();
				++itr )
			{
				abstractid = (*itr)[0];
				itemtype = (*itr)[1];
				itemcount = (*itr)[2];
				if (abstractid>0 && itemcount>0)
				{
					item = new crInstanceItem;
					item->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
					item->setDropItemTimer(m_interval);
					item->setItemtype(itemtype);
					//item->setAbstractItemID(droppedItem);
					item->setSceneID(m_this->getSceneID());
					item->setRoomID(m_this->getRoomID());
					item->setLayerID(layerid);

					pos[0] = m_this->getPosx();
					pos[1] = m_this->getPosy();
					pos[0] += rangei(-range,range).get_random();
					pos[1] += rangei(-range,range).get_random();
					pos[0] *= scale;
					pos[1] *= scale;
					zoffset = item->getZoffset() * scale;
					pos[2] = scene->getPosZ(layerid,pos[0],pos[1],zoffset);
					pos/=scale;
					item->setPosxy(pos[0],pos[1]);
					item->setPosz(pos[2]);

					//if(!scene->findWalkablePos(item.get(),coordpos,c_walkableSearchRange,pos))
					//{
					//	CRCore::notify(CRCore::ALWAYS)<<"crJXJNpcDeadDropItemMethod findWalkablePos失败 "<<coordpos<<std::endl;
					//}
					//pos/=scale;
					//item->setPosxy(pos[0],pos[1]);
					//item->setPosz(pos[2]);

					aitem = crGlobalHandle::getInstance()->findAbstractItem(abstractid);
					if(aitem.valid())
					{
						item->setAbstractItem(aitem.get());
						item->loadItemData(0);
						itemdata = item->getDataClass();
						if(itemdata)
						{
							item->setDataClass(itemdata);
							itemdata->inputParam(WCHDATA_Camp,&camp);
							itemdata->inputParam(WCHDATA_JXJArmyCount,&itemcount);
							itemdata->excHandle(MAKEINT64(WCH_InitData,item.get()));
							itemdata->getParam(WCHDATA_SightRange, param);
							sightRange = *((short*)param);
							if (sightRange>0 && (room->getShareSight() || itemtype == crInstanceItem::Npc || itemtype == crInstanceItem::Role))
								item->setSightInfo(room->getOrCreateSightInfo(camp,true));

							scene->insertSceneItem(item.get());
							scene->itemRelive(item.get());
						}
					}
					else
					{
						crJXJQueryAbstractItemPacket::buildRequestPacket(packet,abstractid,item.get(),camp,itemcount,m_interval);
						gameServerConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvAbstractItemMethod
//SceneServer
/////////////////////////////////////////
crJXJRecvAbstractItemMethod::crJXJRecvAbstractItemMethod(){}
crJXJRecvAbstractItemMethod::crJXJRecvAbstractItemMethod(const crJXJRecvAbstractItemMethod& handle):
	crMethod(handle),
	m_recvDataStream(handle.m_recvDataStream)
{
}
void crJXJRecvAbstractItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}

void crJXJRecvAbstractItemMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvAbstractItemMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		CRCore::crStreamBuf *stream = m_recvDataStream->getStream();
		if(stream)
		{
			crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
			crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
			crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
			ref_ptr<crInstanceItem> item;
			int itemid = stream->_readInt();
			int sceneid = stream->_readInt();
			int roomid = stream->_readInt();
			int layerid = stream->_readInt();
			int posx = stream->_readInt();
			int posy = stream->_readInt();
			unsigned char itemtype = stream->_readUChar();
			unsigned char camp = stream->_readUChar();
			/*unsigned short*/int itemcount = stream->_readInt();
			float interval = stream->_readFloat();
			crVector3 dir = stream->_readVec3();
			_crInt64 ownerid = stream->_readInt64();
			short bufid = stream->_readShort();
			unsigned char npctype = stream->_readUChar();
			CRNetApp::crScene *scene = netCallback->findScene(sceneid);
			crRoom *room = netCallback->findRoom(roomid);
			if(scene && room)
			{
				item = new crInstanceItem;
				ref_ptr<crAbstractItem> aitem; 
				readAbstractItem(aitem,stream/*,true*/);
				if(aitem.valid())
				{
					crGlobalHandle::getInstance()->insertAbstractItem(aitem.get());
					item->setAbstractItem(aitem.get());
					item->setInstanceItemID(itemid);
					item->setSceneID(sceneid);
					item->setRoomID(roomid);
					item->setLayerID(layerid);
					item->setItemtype(itemtype);
					item->setPosxy(posx,posy);
					item->loadItemData(0);
					item->setDropItemTimer(interval);
					item->setDir(dir);
					item->setOwnerID(ownerid);
					crData *itemdata = item->getDataClass();
					if(itemdata)
					{
						itemdata->inputParam(WCHDATA_Camp,&camp);
						itemdata->inputParam(WCHDATA_JXJNpcItemType,&npctype);
						itemdata->inputParam(WCHDATA_JXJArmyCount,&itemcount);
						itemdata->excHandle(MAKEINT64(WCH_InitData,item.get()));
						void *param;
						itemdata->getParam(WCHDATA_SightRange, param);
						short sightRange = *((short*)param);
						if (sightRange > 0 && (room->getShareSight() || itemtype == crInstanceItem::Npc || itemtype == crInstanceItem::Role))
							item->setSightInfo(room->getOrCreateSightInfo(camp,true));

						scene->insertSceneItem(item.get());
						scene->itemRelive(item.get());
						if(bufid>0)
						{
							item->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(bufid,-1),NULL));
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRoomCheckHpPercentDownMethod
//
/////////////////////////////////////////
crJXJRoomCheckHpPercentDownMethod::crJXJRoomCheckHpPercentDownMethod():
	m_instanceid(0),
	m_percent(0.5f){}
crJXJRoomCheckHpPercentDownMethod::crJXJRoomCheckHpPercentDownMethod(const crJXJRoomCheckHpPercentDownMethod& handle):
	crMethod(handle),
	m_instanceid(handle.m_instanceid),
	m_percent(handle.m_percent)
{
}
void crJXJRoomCheckHpPercentDownMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_instanceid = atoi(str.c_str());
		break;
	case 1:
		m_percent = atof(str.c_str());
		break;
	}
}
void crJXJRoomCheckHpPercentDownMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRoomCheckHpPercentDownMethod::operator()(crHandle &handle)
{
	bool condition = true;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		void *param;
		crData *itemData;
		ref_ptr<crInstanceItem> item;
		item = scene->findRoomItem(m_this->getRoomID(),m_instanceid);
		if(item.valid())
		{	
			float maxhp = 0.0f;
			item->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
			itemData = item->getDataClass();
			if(itemData && maxhp>0.0f)
			{
				itemData->getParam(WCHDATA_JXJArmyCount,param);
				float armyCount = *(/*unsigned short*/int *)param;
				maxhp *= armyCount;
				itemData->getParam(WCHDATA_RTHP,param);
				float rthp = *(float*)param;
				float percent = rthp/maxhp;
				condition = percent<m_percent;
			}
		}
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJCheckHpPercentDownMethod
//
/////////////////////////////////////////
crJXJCheckHpPercentDownMethod::crJXJCheckHpPercentDownMethod():
	m_percent(0.5f){}
crJXJCheckHpPercentDownMethod::crJXJCheckHpPercentDownMethod(const crJXJCheckHpPercentDownMethod& handle):
	crMethod(handle),
	m_percent(handle.m_percent)
{
}
void crJXJCheckHpPercentDownMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_percent = atof(str.c_str());
		break;
	}
}
void crJXJCheckHpPercentDownMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem *)param;
		break;
	}
}
void crJXJCheckHpPercentDownMethod::operator()(crHandle &handle)
{
	bool condition = true;

	float maxhp = 0.0f;
	m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
	if(maxhp>0.0f)
	{
		void *param;
		crData *itemData = m_this->getDataClass();
		itemData->getParam(WCHDATA_JXJArmyCount,param);
		float armyCount = *(/*unsigned short*/int *)param;
		maxhp *= armyCount;
		itemData->getParam(WCHDATA_RTHP,param);
		float rthp = *(float*)param;
		float percent = rthp/maxhp;
		condition = percent<m_percent;
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJRemoveItemFormSceneMethod
//
/////////////////////////////////////////
crJXJRemoveItemFormSceneMethod::crJXJRemoveItemFormSceneMethod():
	m_instanceid(0){}
crJXJRemoveItemFormSceneMethod::crJXJRemoveItemFormSceneMethod(const crJXJRemoveItemFormSceneMethod& handle):
	crMethod(handle),
	m_instanceid(handle.m_instanceid)
{
}
void crJXJRemoveItemFormSceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_instanceid = atoi(str.c_str());
		break;
	}
}
void crJXJRemoveItemFormSceneMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRemoveItemFormSceneMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crInstanceItem> item;
		item = scene->findRoomItem(m_this->getRoomID(),m_instanceid);
		if(item.valid())
		{
			int id = item->getInstanceItemID();
			if(id<0)
			{
				scene->wantToRemoveItem(item.get());
				crGlobalHandle::recycleItemID(id);
			}
			else
			{
				unsigned char itemstate = IS_Dead;
				unsigned int guiseState;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				crItemEventPacket packet;
				void *param;
				crData *itemData = item->getDataClass();
				if(itemData)
				{
					itemData->inputParam(WCHDATA_ItemState, &itemstate);
					itemData->getParam(WCHDATA_GuiseState,param);
					guiseState = *(unsigned int *)param;
					if(guiseState & GS_Static)
						guiseState = GS_StaticUnVisiable;
					else
						guiseState = GS_UnVisiable;
					itemData->inputParam(WCHDATA_GuiseState, &guiseState);
					//stream->seekBegin();
					//stream->_writeUInt(guiseState);
					//crItemEventPacket::buildRequestPacket(packet,0,item.get(),WCH_RecvGuiseState,stream.get());
					//scene->sendPacketToItemNeighbor(item.get(),packet);
				}
				scene->itemDead(item.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckMyHpPercentDownMethod
//
/////////////////////////////////////////
crJXJCheckMyHpPercentDownMethod::crJXJCheckMyHpPercentDownMethod():
	m_percent(0.5f){}
crJXJCheckMyHpPercentDownMethod::crJXJCheckMyHpPercentDownMethod(const crJXJCheckMyHpPercentDownMethod& handle):
	crMethod(handle),
	m_percent(handle.m_percent)
{
}
void crJXJCheckMyHpPercentDownMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_percent = atof(str.c_str());
		break;
	}
}
void crJXJCheckMyHpPercentDownMethod::inputParam(int i, void *param)
{
}
void crJXJCheckMyHpPercentDownMethod::operator()(crHandle &handle)
{
	bool condition = false;
	crMyPlayerData::getInstance()->lockMyRoleNpcMap();
	crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
	crRole *player;
	float maxhp = 0.0f;
	void *param;
	crData *itemData;
	float armyCount,rthp,percent;
	for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
		itr != myRoles.end();
		++itr )
	{
		player = itr->second.first.get();
		player->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
		if(maxhp>0.0f)
		{
			itemData = player->getDataClass();
			itemData->getParam(WCHDATA_JXJArmyCount,param);
			armyCount = *(/*unsigned short*/int *)param;
			maxhp *= armyCount;
			itemData->getParam(WCHDATA_RTHP,param);
			rthp = *(float*)param;
			percent = rthp/maxhp;
			condition = percent<m_percent;
			if(condition)
				break;
		}
	}
	crMyPlayerData::getInstance()->unlockMyRoleNpcMap();

	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJRoomCurePlayerHPMethod
//
/////////////////////////////////////////
crJXJRoomCurePlayerHPMethod::crJXJRoomCurePlayerHPMethod():
	m_curehp(10000000.0f){}
crJXJRoomCurePlayerHPMethod::crJXJRoomCurePlayerHPMethod(const crJXJRoomCurePlayerHPMethod& handle):
	crMethod(handle),
	m_curehp(handle.m_curehp)
{
}
void crJXJRoomCurePlayerHPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_curehp = atof(str.c_str());
		break;
	}
}
void crJXJRoomCurePlayerHPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRoomCurePlayerHPMethod::operator()(crHandle &handle)
{
	if(m_this->getGameRunning())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			std::vector< ref_ptr<crRole> > RoleVec;
			ref_ptr<crRole> role;
			crData *roledata;
			void *param;
			unsigned char itemstate;
			unsigned int guisestate = GS_Normal;
			scene->lockRoomRoleMap();
			CRNetApp::crScene::RoomRoleMap &roomRoleMap = scene->getRoomRoleMap();
			CRNetApp::crScene::SceneRoleMap &sceneRoleMap = roomRoleMap[m_this->getRoomID()];
			for( CRNetApp::crScene::SceneRoleMap::iterator sritr = sceneRoleMap.begin();
				sritr != sceneRoleMap.end();
				++sritr )
			{
				role = sritr->second.get();
				roledata = role->getDataClass();
				roledata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
					continue;
				guisestate = GS_Normal;
				role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable
					/*|| guisestate & GS_Stagnate || guisestate & GS_immunoSkill*/ )
				{
					continue;
				}
				RoleVec.push_back(role);
			}
			scene->unlockRoomRoleMap();

			for( std::vector< ref_ptr<crRole> >::iterator itr = RoleVec.begin();
				itr != RoleVec.end();
				++itr )
			{
				if(m_curehp>0)
				{
					(*itr)->doEvent(WCH_CureHP,MAKEINT64(&m_curehp,NULL));
				}
				else
				{
					DamagePair dp(-m_curehp,std::make_pair(PhysicsDM,0));
					(*itr)->doEvent(WCH_AddDamage,MAKEINT64(&dp,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRoomCurePlayerMPMethod
//
/////////////////////////////////////////
crJXJRoomCurePlayerMPMethod::crJXJRoomCurePlayerMPMethod():
	m_curemp(10000000.0f){}
crJXJRoomCurePlayerMPMethod::crJXJRoomCurePlayerMPMethod(const crJXJRoomCurePlayerMPMethod& handle):
	crMethod(handle),
	m_curemp(handle.m_curemp)
{
}
void crJXJRoomCurePlayerMPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_curemp = atof(str.c_str());
		break;
	}
}
void crJXJRoomCurePlayerMPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRoomCurePlayerMPMethod::operator()(crHandle &handle)
{
	if(m_this->getGameRunning())
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			std::vector< ref_ptr<crRole> > RoleVec;
			ref_ptr<crRole> role;
			crData *roledata;
			void *param;
			unsigned char itemstate;
			unsigned int guisestate = GS_Normal;
			scene->lockRoomRoleMap();
			CRNetApp::crScene::RoomRoleMap &roomRoleMap = scene->getRoomRoleMap();
			CRNetApp::crScene::SceneRoleMap &sceneRoleMap = roomRoleMap[m_this->getRoomID()];
			for( CRNetApp::crScene::SceneRoleMap::iterator sritr = sceneRoleMap.begin();
				sritr != sceneRoleMap.end();
				++sritr )
			{
				role = sritr->second.get();
				roledata = role->getDataClass();
				roledata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
					continue;
				guisestate = GS_Normal;
				role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable
					/*|| guisestate & GS_Stagnate || guisestate & GS_immunoSkill*/ )
				{
					continue;
				}
				RoleVec.push_back(role);
			}
			scene->unlockRoomRoleMap();

			for( std::vector< ref_ptr<crRole> >::iterator itr = RoleVec.begin();
				itr != RoleVec.end();
				++itr )
			{
				if(m_curemp>0)
					(*itr)->doEvent(WCH_JXJCureRTMp,MAKEINT64(&m_curemp,NULL));
				else
				{
					float value = -m_curemp;
					(*itr)->doEvent(WCH_JXJReduceRTMp,MAKEINT64(&value,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAddPlayerCureMPMethod
//
/////////////////////////////////////////
crJXJAddPlayerCureMPMethod::crJXJAddPlayerCureMPMethod():
	m_curemp(10000000.0f){}
crJXJAddPlayerCureMPMethod::crJXJAddPlayerCureMPMethod(const crJXJAddPlayerCureMPMethod& handle):
	crMethod(handle),
	m_curemp(handle.m_curemp)
{
}
void crJXJAddPlayerCureMPMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_curemp = atof(str.c_str());
		break;
	}
}
void crJXJAddPlayerCureMPMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crSceneServerPlayerData *)(LOINT64(param64));
		}
		else
		{
			m_player = NULL;
		}
		break;
	}
}
void crJXJAddPlayerCureMPMethod::operator()(crHandle &handle)
{
	if(m_player.valid())
	{
		crRole *role;
		crSceneServerPlayerData::RoleMap &roleMap = m_player->getRoleMap();
		for( crSceneServerPlayerData::RoleMap::iterator itr = roleMap.begin();
			itr != roleMap.end();
			++itr )
		{
			role = itr->second.get();
			if(role)
			{
				if(m_curemp>0.0f)
					role->doEvent(WCH_JXJCureRTMp,MAKEINT64(&m_curemp,NULL));
				else
				{
					float value = -m_curemp;
					role->doEvent(WCH_JXJReduceRTMp,MAKEINT64(&value,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerGainExtraMethod
//
/////////////////////////////////////////
crJXJPlayerGainExtraMethod::crJXJPlayerGainExtraMethod():
	m_extraid(0){}
crJXJPlayerGainExtraMethod::crJXJPlayerGainExtraMethod(const crJXJPlayerGainExtraMethod& handle):
	crMethod(handle),
	m_extraid(handle.m_extraid)
{
}
void crJXJPlayerGainExtraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_extraid = atoi(str.c_str());
		break;
	}
}
void crJXJPlayerGainExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJPlayerGainExtraMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		std::vector< ref_ptr<crRole> > RoleVec;
		ref_ptr<crRole> role;
		crData *roledata;
		void *param;
		unsigned char itemstate;
		unsigned int guisestate = GS_Normal;
		scene->lockRoomRoleMap();
		CRNetApp::crScene::RoomRoleMap &roomRoleMap = scene->getRoomRoleMap();
		CRNetApp::crScene::SceneRoleMap &sceneRoleMap = roomRoleMap[m_this->getRoomID()];
		for( CRNetApp::crScene::SceneRoleMap::iterator sritr = sceneRoleMap.begin();
			sritr != sceneRoleMap.end();
			++sritr )
		{
			role = sritr->second.get();
			roledata = role->getDataClass();
			roledata->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate == IS_Dead)
				continue;
			guisestate = GS_Normal;
			role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
				guisestate & GS_Stagnate || guisestate & GS_immunoSkill )
			{
				continue;
			}
			RoleVec.push_back(role);
		}
		scene->unlockRoomRoleMap();

		for( std::vector< ref_ptr<crRole> >::iterator itr = RoleVec.begin();
			itr != RoleVec.end();
			++itr )
		{
			(*itr)->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_extraid,-1),NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerRemoveExtraMethod
//
/////////////////////////////////////////
crJXJPlayerRemoveExtraMethod::crJXJPlayerRemoveExtraMethod():
	m_extraid(0){}
crJXJPlayerRemoveExtraMethod::crJXJPlayerRemoveExtraMethod(const crJXJPlayerRemoveExtraMethod& handle):
	crMethod(handle),
	m_extraid(handle.m_extraid)
{
}
void crJXJPlayerRemoveExtraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_extraid = atoi(str.c_str());
		break;
	}
}
void crJXJPlayerRemoveExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJPlayerRemoveExtraMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crNetManager *netManager = sceneServerConductor->getNetManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		std::vector< ref_ptr<crRole> > RoleVec;
		ref_ptr<crRole> role;
		ref_ptr<crData>roledata;
		void *param;
		unsigned char itemstate;
		unsigned int guisestate = GS_Normal;
		scene->lockRoomRoleMap();
		CRNetApp::crScene::RoomRoleMap &roomRoleMap = scene->getRoomRoleMap();
		CRNetApp::crScene::SceneRoleMap &sceneRoleMap = roomRoleMap[m_this->getRoomID()];
		for( CRNetApp::crScene::SceneRoleMap::iterator sritr = sceneRoleMap.begin();
			sritr != sceneRoleMap.end();
			++sritr )
		{
			role = sritr->second.get();
			roledata = role->getDataClass();
			roledata->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate == IS_Dead)
				continue;
			guisestate = GS_Normal;
			role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable ||
				guisestate & GS_Stagnate || guisestate & GS_immunoSkill )
			{
				continue;
			}
			RoleVec.push_back(role);
		}
		scene->unlockRoomRoleMap();

		crData *extraData;
		ExtraIDMap *extraIDMap;
		crPlayerEventPacket packet;
		ref_ptr<crSceneServerPlayerData> playerData;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(2);
		stream->_writeShort(m_extraid);
		int playerid;
		for( std::vector< ref_ptr<crRole> >::iterator itr = RoleVec.begin();
			itr != RoleVec.end();
			++itr )
		{
			roledata = (*itr)->getDataClass();
			roledata->getParam(WCHDATA_ExtraData,param);
			if(param)
			{
				extraData = (crData *)param;
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				extraIDMap = (ExtraIDMap *)param;
				if(extraIDMap->find(m_extraid)!=extraIDMap->end())
				{
					extraData->removeHandle(MAKEINT64(WCH_DoExtra,m_extraid));
					extraIDMap->erase(m_extraid);
					playerid = (*itr)->getID();
					crPlayerEventPacket::buildRequestPacket(packet,playerid,(*itr).get(),WCH_JXJRecvRemoveExtra,stream.get());
					playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
					if (playerData.valid())
					{
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
					scene->sendPacketToItemNeighbor(itr->get(),packet);
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvRemoveExtraMethod
//
/////////////////////////////////////////
crJXJRecvRemoveExtraMethod::crJXJRecvRemoveExtraMethod(){}
crJXJRecvRemoveExtraMethod::crJXJRecvRemoveExtraMethod(const crJXJRecvRemoveExtraMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRemoveExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRemoveExtraMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvRemoveExtraMethod::operator()(crHandle &handle)
{
	if(m_stream.valid() && crRunGameHandle::getInstance()->getRunningCode() == crRunGameHandle::NetGame)
	{
		short extrabufid = m_stream->_readShort();
		void *param;
		ref_ptr<crData> data = m_this->getDataClass();
		if(data.valid())
		{
			data->getParam(WCHDATA_ExtraData,param);
			if(param)
			{
				crData *extraData = (crData *)param;
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				ExtraIDMap *extraIDMap = (ExtraIDMap *)param;
				if(extraIDMap->find(extrabufid)!=extraIDMap->end())
				{
					crHandle *handle = extraData->getHandle(MAKEINT64(WCH_DoExtra,extrabufid));
					if(handle)
					{
						handle->releaseObjects(NULL);
					}
					extraData->removeHandle(MAKEINT64(WCH_DoExtra,extrabufid));
					extraIDMap->erase(extrabufid);
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckRoleDamageHpPercentMethod
//
/////////////////////////////////////////
crJXJCheckRoleDamageHpPercentMethod::crJXJCheckRoleDamageHpPercentMethod():
	m_percent(0.5f){}
crJXJCheckRoleDamageHpPercentMethod::crJXJCheckRoleDamageHpPercentMethod(const crJXJCheckRoleDamageHpPercentMethod& handle):
	crMethod(handle),
	m_percent(handle.m_percent)
{
}
void crJXJCheckRoleDamageHpPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_percent = atof(str.c_str());
		break;
	}
}
void crJXJCheckRoleDamageHpPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_role = (crRole *)(LOINT64(param64));
		}
		else
		{
			m_role = NULL;
		}
		break;
	}
}
void crJXJCheckRoleDamageHpPercentMethod::operator()(crHandle &handle)
{
	bool condition = true;
	if(m_role.valid())
	{
		float maxhp = 0.0f;
		m_role->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
		if(maxhp>0.0f)
		{
			void *param;
			crData *itemData = m_role->getDataClass();
			itemData->getParam(WCHDATA_JXJArmyCount,param);
			float armyCount = *(/*unsigned short*/int *)param;
			maxhp *= armyCount;
			itemData->getParam(WCHDATA_RTHP,param);
			float rthp = *(float*)param;
			float percent = rthp/maxhp;
			condition = percent<m_percent;
		}
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJRoomTriggerCountMethod
//
/////////////////////////////////////////
crJXJRoomTriggerCountMethod::crJXJRoomTriggerCountMethod():
	m_maxcount(-1),
	m_count(0),
m_resetInterval(0){}
crJXJRoomTriggerCountMethod::crJXJRoomTriggerCountMethod(const crJXJRoomTriggerCountMethod& handle):
	crMethod(handle),
	m_maxcount(handle.m_maxcount),
	m_resetInterval(handle.m_resetInterval),
	m_count(0)
{
}
void crJXJRoomTriggerCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_maxcount = atoi(str.c_str());
		break;
	case 1:
		m_resetInterval = atoi(str.c_str());
		break;
	}
}
void crJXJRoomTriggerCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRoomTriggerCountMethod::operator()(crHandle &handle)
{
	bool condition = false;
	if (m_maxcount < 0)
	{
		condition = true;
	}
	else
	{
		time_t t = time(0);
		if (m_resetInterval > 0)
		{
			if (t - m_lasttimer > m_resetInterval)
			{
				m_count = 0;
			}
		}
		if (m_count < m_maxcount)
		{
			m_count++;
			condition = true;
			m_lasttimer = t;
		}
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJRoomTriggerCountCaseMethod
//
/////////////////////////////////////////
crJXJRoomTriggerCountCaseMethod::crJXJRoomTriggerCountCaseMethod():
	m_count(0){}
crJXJRoomTriggerCountCaseMethod::crJXJRoomTriggerCountCaseMethod(const crJXJRoomTriggerCountCaseMethod& handle):
	crMethod(handle),
	m_count(0)
{
}
void crJXJRoomTriggerCountCaseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_count = atoi(str.c_str());
		break;
	}
}
void crJXJRoomTriggerCountCaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRoomTriggerCountCaseMethod::operator()(crHandle &handle)
{
	int _case = m_count;
	m_count++;
	handle.outputParam(0,&_case);
}
/////////////////////////////////////////
//
//crJXJIfInVolumeNodeIsNpcMethod
//
/////////////////////////////////////////
crJXJIfInVolumeNodeIsNpcMethod::crJXJIfInVolumeNodeIsNpcMethod():
	m_inVolumeNode(NULL)
{
}

crJXJIfInVolumeNodeIsNpcMethod::crJXJIfInVolumeNodeIsNpcMethod(const crJXJIfInVolumeNodeIsNpcMethod& handle):
	crMethod(handle),
	m_inVolumeNode(NULL)
{
}

void crJXJIfInVolumeNodeIsNpcMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_inVolumeNode = (crNode *)(LOINT64(param64));
		}
		else
		{
			m_inVolumeNode = 0;
		}
		break;
	}
}

void crJXJIfInVolumeNodeIsNpcMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_npcVec);
		//m_npcid = atoi(str.c_str());
		break;
	}
}

void crJXJIfInVolumeNodeIsNpcMethod::operator()(crHandle &handle)
{
	bool bln = false;
	if(m_inVolumeNode)
	{
		crData *data = m_inVolumeNode->getDataClass();
		if(data)
		{
			void *param;
			data->getParam(WCHDATA_Item,param);
			if(param)
			{
				ref_ptr<crInstanceItem> item = (crInstanceItem *)param;
				for (NpcIDVec::iterator nvItr = m_npcVec.begin();
					nvItr != m_npcVec.end(); ++ nvItr)
				{
					if (item->getInstanceItemID() == *nvItr)
					{
						bln = true;
						break;
					}
				}
			}
		}
	}
	handle.outputParam(0,&bln);
}
/////////////////////////////////////////
//
//crJXJSetNpcGuiseStateFromTabMethod
//
/////////////////////////////////////////
crJXJSetNpcGuiseStateFromTabMethod::crJXJSetNpcGuiseStateFromTabMethod():
	m_id(0),
	m_open(false),
	m_state(0) {}
//m_garrison(true){}
crJXJSetNpcGuiseStateFromTabMethod::crJXJSetNpcGuiseStateFromTabMethod(const crJXJSetNpcGuiseStateFromTabMethod& handle):
	crMethod(handle),
	m_id(handle.m_id),
	m_open(handle.m_open),
	m_state(handle.m_state)
	//m_garrison(handle.m_garrison)
{
}
void crJXJSetNpcGuiseStateFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	case 1:
		m_open = (bool)(atoi(str.c_str()));
		break;
	case 2:
		m_state = 1 << atoi(str.c_str());
		break;
	}
}
void crJXJSetNpcGuiseStateFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJSetNpcGuiseStateFromTabMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		crInstanceItem *item;
		crData *itemData;
		unsigned char itemstate;
		unsigned int guisestate = GS_Normal;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_id);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_id;
			++itr )
		{
			item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
			if(item && item->getItemtype() == crInstanceItem::Npc && item->getDataClass())
			{
				itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
					ItemList.push_back(item);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock
		unsigned int *gs;
		for( std::list< ref_ptr<crInstanceItem> >::iterator itr = ItemList.begin();
			itr != ItemList.end();
			++itr )
		{
			itemData = (*itr)->getDataClass();
			itemData->getParam(WCHDATA_GuiseState,param);
			gs = (unsigned int *)param;
			if(m_open)
				*gs |= m_state;
			else
				*gs &= ~m_state;
		}
	}
}
/////////////////////////////////////////
//
//crJXJRemoveItemsFormSceneMethod
//
/////////////////////////////////////////
crJXJRemoveItemsFormSceneMethod::crJXJRemoveItemsFormSceneMethod():
	m_tableid(0){}
crJXJRemoveItemsFormSceneMethod::crJXJRemoveItemsFormSceneMethod(const crJXJRemoveItemsFormSceneMethod& handle):
	crMethod(handle),
	m_tableid(handle.m_tableid)
{
}
void crJXJRemoveItemsFormSceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	}
}
void crJXJRemoveItemsFormSceneMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJRemoveItemsFormSceneMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		crInstanceItem *item;
		crData *itemData;
		unsigned char itemstate;
		unsigned int guisestate = GS_Normal;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_tableid);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_tableid;
			++itr )
		{
			item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
			if(item && item->getDataClass())
			{
				ItemList.push_back(item);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock
		int id = 0;
		itemstate = IS_Dead;
		unsigned int guiseState;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		crItemEventPacket packet;
		for( std::list< ref_ptr<crInstanceItem> >::iterator itr = ItemList.begin();
			itr != ItemList.end();
			++itr )
		{
			item = itr->get();
			id = item->getInstanceItemID();
			if(id<0)
			{
				scene->wantToRemoveItem(item);
				crGlobalHandle::recycleItemID(id);
			}
			else
			{
				itemData = item->getDataClass();
				if(itemData)
				{
					itemData->inputParam(WCHDATA_ItemState, &itemstate);
					itemData->getParam(WCHDATA_GuiseState,param);
					guiseState = *(unsigned int *)param;
					if(guiseState & GS_Static)
						guiseState = GS_StaticUnVisiable;
					else
						guiseState = GS_UnVisiable;
					itemData->inputParam(WCHDATA_GuiseState, &guiseState);
					//stream->seekBegin();
					//stream->_writeUInt(guiseState);
					//crItemEventPacket::buildRequestPacket(packet,0,item,WCH_RecvGuiseState,stream.get());
					//scene->sendPacketToItemNeighbor(item,packet);
				}
				scene->itemDead(item);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckFireItemFromTabMethod
//
/////////////////////////////////////////
crJXJCheckFireItemFromTabMethod::crJXJCheckFireItemFromTabMethod():
	m_tableid(0){}
crJXJCheckFireItemFromTabMethod::crJXJCheckFireItemFromTabMethod(const crJXJCheckFireItemFromTabMethod& handle):
	crMethod(handle),
	m_tableid(handle.m_tableid)
{
}
void crJXJCheckFireItemFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	}
}
void crJXJCheckFireItemFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_fireItem = NULL;
		}
		break;
	}
}
void crJXJCheckFireItemFromTabMethod::operator()(crHandle &handle)
{
	bool found = false;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		unsigned int guisestate = GS_Normal;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_tableid);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_tableid;
			++itr )
		{
			if(m_fireItem->getInstanceItemID() == itr->second->getInstanceID())
			{
				found = true;
				break;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	handle.outputParam(0,&found);
}
/////////////////////////////////////////
//
//crJXJCheckHitItemFromTabMethod
//
/////////////////////////////////////////
crJXJCheckHitItemFromTabMethod::crJXJCheckHitItemFromTabMethod():
	m_tableid(0){}
crJXJCheckHitItemFromTabMethod::crJXJCheckHitItemFromTabMethod(const crJXJCheckHitItemFromTabMethod& handle):
	crMethod(handle),
	m_tableid(handle.m_tableid)
{
}
void crJXJCheckHitItemFromTabMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	}
}
void crJXJCheckHitItemFromTabMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitItem = (crInstanceItem*)(LOINT64(param64));
		}
		else
		{
			m_hitItem = NULL;
		}
		break;
	}
}
void crJXJCheckHitItemFromTabMethod::operator()(crHandle &handle)
{
	bool found = false;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		unsigned int guisestate = GS_Normal;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_tableid);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_tableid;
			++itr )
		{
			if(m_hitItem->getInstanceItemID() == itr->second->getInstanceID())
			{
				found = true;
				break;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	handle.outputParam(0,&found);
}
/////////////////////////////////////////
//
//crJXJCheckFireItemIDMethod
//
/////////////////////////////////////////
crJXJCheckFireItemIDMethod::crJXJCheckFireItemIDMethod():
	m_itemid(0){}
crJXJCheckFireItemIDMethod::crJXJCheckFireItemIDMethod(const crJXJCheckFireItemIDMethod& handle):
	crMethod(handle),
	m_itemid(handle.m_itemid)
{
}
void crJXJCheckFireItemIDMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	}
}
void crJXJCheckFireItemIDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_fireItem = (crInstanceItem*)(HIINT64(param64));
		}
		else
		{
			m_fireItem = NULL;
		}
		break;
	}
}
void crJXJCheckFireItemIDMethod::operator()(crHandle &handle)
{
	bool found = m_fireItem->getInstanceItemID() == m_itemid;
	handle.outputParam(0,&found);
}
/////////////////////////////////////////
//
//crJXJCheckHitItemIDMethod
//
/////////////////////////////////////////
crJXJCheckHitItemIDMethod::crJXJCheckHitItemIDMethod():
	m_itemid(0){}
crJXJCheckHitItemIDMethod::crJXJCheckHitItemIDMethod(const crJXJCheckHitItemIDMethod& handle):
	crMethod(handle),
	m_itemid(handle.m_itemid)
{
}
void crJXJCheckHitItemIDMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	}
}
void crJXJCheckHitItemIDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitItem = (crInstanceItem*)(LOINT64(param64));
		}
		else
		{
			m_hitItem = NULL;
		}
		break;
	}
}
void crJXJCheckHitItemIDMethod::operator()(crHandle &handle)
{
	bool found = m_hitItem->getInstanceItemID() == m_itemid;
	handle.outputParam(0,&found);
}
/**************************************************************************

METHOD: crJXJChangeItemPatrolPointVecFormSceneMethod

**************************************************************************/
JXJ::crJXJChangeItemPatrolPointVecFormSceneMethod::crJXJChangeItemPatrolPointVecFormSceneMethod():
	m_tableid(-1){}

JXJ::crJXJChangeItemPatrolPointVecFormSceneMethod
	::crJXJChangeItemPatrolPointVecFormSceneMethod( const crJXJChangeItemPatrolPointVecFormSceneMethod & handle ):
crMethod(handle),
	m_tableid(handle.m_tableid)
{

}

void JXJ::crJXJChangeItemPatrolPointVecFormSceneMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void JXJ::crJXJChangeItemPatrolPointVecFormSceneMethod::addParam( int i, const std::string& str )
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	case 1:
		{
			crArgumentParser::appAtoVec(str,m_pointVec);
			size_t vecSzie = m_pointVec.size();
			float scale = crGlobalHandle::gData()->gUnitScale();
			for (size_t i = 0; i < vecSzie; ++i)
			{
				m_pointVec[i] *= scale;
			}
		}
		break;
	}
}

void JXJ::crJXJChangeItemPatrolPointVecFormSceneMethod::operator()( crHandle &handle )
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		crInstanceItem* item;
		crData *itemData;
		unsigned char itemstate;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_tableid);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_tableid;
			++itr )
		{
			item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
			if(item && item->getDataClass())
			{
				itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
					ItemList.push_back(item);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock
		int id = 0;
		int startIdx = 0;
		size_t pointNum = m_pointVec.size() >> 1;
		PatrolPointVec *patrolPointVec = NULL; 
		crVector2 vec2;
		for( std::list< ref_ptr<crInstanceItem> >::iterator itr = ItemList.begin();
			itr != ItemList.end();
			++itr )
		{
			item = itr->get();
			id = item->getInstanceItemID();
			if (id)
			{
				itemData = item->getDataClass();
				if(itemData)
				{
					itemData->excHandle(MAKEINT64(WCH_LockData,1));
					itemData->getParam(WCHDATA_PatrolPointVec,param);
					patrolPointVec = (PatrolPointVec *)param;
					if(patrolPointVec && pointNum)
					{
						patrolPointVec->clear();
						for (size_t i = 0; i < pointNum; ++ i)
						{
							vec2[0] = m_pointVec[(i << 1)] ;
							vec2[1] = m_pointVec[(i << 1) + 1] ;
							patrolPointVec->push_back(vec2);
						}

						itemData->inputParam(WCHDATA_PatrolIndex,&startIdx);
					}
					itemData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}


/**************************************************************************

METHOD: crJXJSceneNpcGainExtraMethod

**************************************************************************/
crJXJNpcGainExtraFromTableMethod::crJXJNpcGainExtraFromTableMethod():
	m_this(NULL),
	m_tableid(0),
	m_extraid(0)
{

}
crJXJNpcGainExtraFromTableMethod::crJXJNpcGainExtraFromTableMethod( const crJXJNpcGainExtraFromTableMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_tableid(handle.m_tableid),
	m_extraid(handle.m_extraid)
{

}

void crJXJNpcGainExtraFromTableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	case 1:
		m_extraid = atoi(str.c_str());
		break;
	}
}
void crJXJNpcGainExtraFromTableMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJNpcGainExtraFromTableMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		crInstanceItem *item;
		crData *itemData;
		unsigned char itemstate;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_tableid);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_tableid;
			++itr )
		{
			item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
			if(item && item->getDataClass())
			{
				itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
					ItemList.push_back(item);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock


		for( std::list< ref_ptr<crInstanceItem> >::iterator itr = ItemList.begin();
			itr != ItemList.end();
			++itr )
		{
			(*itr)->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_extraid,-1),NULL));
		}
	}
}

/**************************************************************************

METHOD: crJXJNpcRemoveExtraFromTableMethod

**************************************************************************/
crJXJNpcRemoveExtraFromTableMethod::crJXJNpcRemoveExtraFromTableMethod():
	m_this(NULL),
	m_tableid(0),
	m_extraid(0)
{

}

crJXJNpcRemoveExtraFromTableMethod::crJXJNpcRemoveExtraFromTableMethod( const crJXJNpcRemoveExtraFromTableMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_tableid(handle.m_tableid),
	m_extraid(handle.m_extraid)
{

}

void crJXJNpcRemoveExtraFromTableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tableid = atoi(str.c_str());
		break;
	case 1:
		m_extraid = atoi(str.c_str());
		break;
	}
}
void crJXJNpcRemoveExtraFromTableMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJNpcRemoveExtraFromTableMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crNetManager *netManager = sceneServerConductor->getNetManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		crInstanceItem *item;
		crData *itemData;
		unsigned char itemstate;
		void *param;
		crData *data = m_this->getDataClass();
		std::list< ref_ptr<crInstanceItem> >ItemList;
		scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
		data->excHandle(MAKEINT64(WCH_LockData,1));

		data->getParam(WCHDATA_JXJReliveItemMap,param);
		ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;
		ReliveItemMap::iterator itr = reliveItemMap->find(m_tableid);
		for( ;
			itr != reliveItemMap->end() && itr->first == m_tableid;
			++itr )
		{
			item = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
			if(item && item->getDataClass())
			{
				itemData = item->getDataClass();
				itemData->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
					ItemList.push_back(item);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock

		ref_ptr<crData>itemdata;
		crData *extraData;
		ExtraIDMap *extraIDMap;
		crItemEventPacket packet;
		ref_ptr<crSceneServerPlayerData> playerData;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(2);
		stream->_writeShort(m_extraid);
		for( std::list< ref_ptr<crInstanceItem> >::iterator itr = ItemList.begin();
			itr != ItemList.end();
			++itr )
		{
			itemdata = (*itr)->getDataClass();
			itemdata->getParam(WCHDATA_ExtraData,param);
			if(param)
			{
				extraData = (crData *)param;
				extraData->excHandle(MAKEINT64(WCH_LockData,1));
				extraData->getParam(WCHDATA_ExtraIDMap,param);
				extraIDMap = (ExtraIDMap *)param;
				if(extraIDMap->find(m_extraid)!=extraIDMap->end())
				{
					extraData->removeHandle(MAKEINT64(WCH_DoExtra,m_extraid));
					extraIDMap->erase(m_extraid);
					crItemEventPacket::buildRequestPacket(packet,0,itr->get(),WCH_JXJRecvRemoveExtra,stream.get());
					scene->sendPacketToItemNeighbor(itr->get(),packet);
				}
				extraData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}

/**************************************************************************

METHOD: 

**************************************************************************/

JXJ::crJXJNpcLockPlayerMethod::crJXJNpcLockPlayerMethod():
	m_this(NULL)
{

}

JXJ::crJXJNpcLockPlayerMethod::crJXJNpcLockPlayerMethod( const crJXJNpcLockPlayerMethod & handle ):
	crMethod(handle),
	m_this(NULL)
{

}

void JXJ::crJXJNpcLockPlayerMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void JXJ::crJXJNpcLockPlayerMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_tableID = atoi(str.c_str());
		break;
	default:
		break;
	}

}

void JXJ::crJXJNpcLockPlayerMethod::operator()( crHandle &handle )
{
	if (m_this)
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			ref_ptr<crInstanceItem > npcItem = NULL;
			void *param;
			crData *data = m_this->getDataClass();
			typedef std::list< ref_ptr<crInstanceItem> >ItemList;
			ItemList itemList;

			ref_ptr<crRole> role = NULL;
			unsigned char itemstate = IS_Dead;
			crData *roledata;
			scene->lockRoomRoleMap();
			CRNetApp::crScene::RoomRoleMap &roomRoleMap = scene->getRoomRoleMap();
			CRNetApp::crScene::SceneRoleMap &sceneRoleMap = roomRoleMap[m_this->getRoomID()];
			for( CRNetApp::crScene::SceneRoleMap::iterator sritr = sceneRoleMap.begin();
				sritr != sceneRoleMap.end();
				++sritr )
			{
				role = sritr->second.get();
				roledata = role->getDataClass();
				roledata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
					break;
				role = NULL;
			}
			scene->unlockRoomRoleMap();
			if(!role.valid())
				return;
			scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJReliveItemMap,param);
			ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;

			crData *itemData;
			ReliveItemMap::iterator itr = reliveItemMap->find(m_tableID);
			for( ;
				itr != reliveItemMap->end() && itr->first == m_tableID;
				++itr )
			{
				npcItem = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
				if(npcItem.valid() && npcItem->getDataClass() )
				{
					itemData = npcItem->getDataClass();
					itemData->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate != IS_Dead)
						itemList.push_back(npcItem);
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock

			crData *npcData;
			unsigned char targettype = crInstanceItem::Role;
			int targetid,targetroleid;
			crVector3 targetPos;
			unsigned int gs;
			for (ItemList::iterator ilItr = itemList.begin();
				ilItr != itemList.end(); ++ ilItr)
			{
				npcItem = *ilItr;
				if( npcItem.valid()
					&& npcItem->isMainAI()
					&& npcItem->getDataClass() )
				{
					npcData = npcItem->getDataClass();
					npcData->inputParam(WCHDATA_TargetType,&targettype);
					npcData->inputParam(WCHDATA_TargetNode,role->getRelNode());
					targetid = role->getID();
					targetroleid = role->getRoleID();
					npcData->inputParam(WCHDATA_TargetID,&targetid);
					npcData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
					targetPos = role->getPosition();
					npcData->inputParam(WCHDATA_TargetPos,&targetPos);

					// 锁定后设成嘲讽状态
					npcData->getParam(WCHDATA_GuiseState,param);
					gs = *(unsigned int *)param;
					gs |= GS_Taunt; 
					npcData->inputParam(WCHDATA_GuiseState,&gs);
				}
			}
		}
	}
}

/**************************************************************************

METHOD: crJXJSetNpcStealthMethod

**************************************************************************/
JXJ::crJXJSetNpcStealthMethod::crJXJSetNpcStealthMethod():
	m_this(NULL),
	m_stealth(0),
	m_tableID(0)
{

}

JXJ::crJXJSetNpcStealthMethod::crJXJSetNpcStealthMethod( const crJXJSetNpcStealthMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_stealth(handle.m_stealth),
	m_tableID(handle.m_tableID)
{

}

void JXJ::crJXJSetNpcStealthMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}

}

void JXJ::crJXJSetNpcStealthMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_tableID = atoi(str.c_str());
		break;
	case 1:
		m_stealth = atof(str.c_str())/crGlobalHandle::gData()->gUnitScale();
		break;
	default:
		break;
	}

}

void JXJ::crJXJSetNpcStealthMethod::operator()( crHandle &handle )
{
	if (m_this)
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			ref_ptr<crInstanceItem > npcItem = NULL;
			crData *itemData;
			unsigned char itemstate;
			void *param;
			crData *data = m_this->getDataClass();
			typedef std::list< ref_ptr<crInstanceItem> >ItemList;
			ItemList itemList;

			scene->lockRoomItemMap();//m_roomItemMutex->roomdatalock
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJReliveItemMap,param);
			ReliveItemMap *reliveItemMap = (ReliveItemMap *)param;

			ReliveItemMap::iterator itr = reliveItemMap->find(m_tableID);
			for( ;
				itr != reliveItemMap->end() && itr->first == m_tableID;
				++itr )
			{
				npcItem = scene->findRoomItem(m_this->getRoomID(),itr->second->getInstanceID());
				if(npcItem.valid() && npcItem->getDataClass() )
				{
					itemData = npcItem->getDataClass();
					itemData->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate != IS_Dead)
						itemList.push_back(npcItem);
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			scene->unlockRoomItemMap();//m_roomItemMutex->roomdatalock

			for (ItemList::iterator ilItr = itemList.begin();
				ilItr != itemList.end(); ++ ilItr)
			{
				npcItem = *ilItr;
				if(npcItem.valid() && npcItem->isMainAI()
					&& npcItem->getDataClass())
				{
					crData * thisData = npcItem->getDataClass();
					thisData->inputParam(WCHDATA_Stealth,&m_stealth);
				}
			}
		}
	}
}

/**************************************************************************

METHOD: crJXJSetPlayerSightRangeMethod

**************************************************************************/
JXJ::crJXJSetPlayerSightRangeMethod::crJXJSetPlayerSightRangeMethod():
	m_this(NULL),
	m_sight(0)
{

}

JXJ::crJXJSetPlayerSightRangeMethod::crJXJSetPlayerSightRangeMethod( const crJXJSetPlayerSightRangeMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_sight(handle.m_sight)
{

}

void JXJ::crJXJSetPlayerSightRangeMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void JXJ::crJXJSetPlayerSightRangeMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_sight = atof(str.c_str())/crGlobalHandle::gData()->gUnitScale();
		break;
	default:
		break;
	}
}

void JXJ::crJXJSetPlayerSightRangeMethod::operator()( crHandle &handle )
{
	if (m_this)
	{
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
		if(scene)
		{
			ref_ptr<crInstanceItem > npcItem = NULL;
			void *param;
			crData *data = m_this->getDataClass();
			typedef std::list< ref_ptr<crInstanceItem> >ItemList;
			ItemList itemList;

			ref_ptr<crRole> role = NULL;
			unsigned char itemstate = IS_Dead;
			scene->lockRoomRoleMap();
			CRNetApp::crScene::RoomRoleMap &roomRoleMap = scene->getRoomRoleMap();
			CRNetApp::crScene::SceneRoleMap &sceneRoleMap = roomRoleMap[m_this->getRoomID()];
			for( CRNetApp::crScene::SceneRoleMap::iterator sritr = sceneRoleMap.begin();
				sritr != sceneRoleMap.end();
				++sritr )
			{
				role = sritr->second.get();
				crData *roledata = role->getDataClass();
				roledata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate != IS_Dead)
					break;
				roledata->inputParam(WCHDATA_SightRange,&m_sight);
			}
			scene->unlockRoomRoleMap();

		}
	}
}
/**************************************************************************

METHOD: crJXJAddEyePointMethod

**************************************************************************/

crJXJAddEyePointMethod::crJXJAddEyePointMethod():
	m_this(NULL),
	m_camp(1)
{

}

crJXJAddEyePointMethod::crJXJAddEyePointMethod( const crJXJAddEyePointMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_camp(handle.m_camp),
	m_eyepointVec(handle.m_eyepointVec)
{
}

void crJXJAddEyePointMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void crJXJAddEyePointMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_camp = atoi(str.c_str());
		break;
	default:
		{
			crVector2f vec2;
			crArgumentParser::appAtoVec(str,vec2);
			crVector2i eye(vec2[0]/crGlobalHandle::gData()->gUnitScale(),vec2[1]/crGlobalHandle::gData()->gUnitScale());
			m_eyepointVec.push_back(eye);
		}
		break;
	}

}

void crJXJAddEyePointMethod::operator()( crHandle &handle )
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJBattleID,param);
	int battleid = *(int *)param;
	crSightInfo *sightinfo = NULL;
	switch (m_camp)
	{
	case 1://守方
		{
			unsigned char defenceShili = (unsigned char)(HIINT16(LOINT32(battleid)));
			sightinfo = m_this->getOrCreateSightInfo(defenceShili);
		}
		break;
	case 2://攻方
		{
			unsigned char attackShili = (unsigned char)(LOINT16(LOINT32(battleid)));
			sightinfo = m_this->getOrCreateSightInfo(attackShili);
		}
		break;
	}
	if(sightinfo)
	{
		for( std::vector<CRCore::crVector2i>::iterator itr = m_eyepointVec.begin();
			itr != m_eyepointVec.end();
			++itr )
		{
			sightinfo->insertEyePoint(*itr);
		}
	}
}
/////////////////////////////////////////
//
//crJXJAddScenarioTimerMethod
//
/////////////////////////////////////////
crJXJAddScenarioTimerMethod::crJXJAddScenarioTimerMethod():
	m_msg(0),
	m_interval(5.0f),
	m_id(0),
	m_times(1)
{
}

crJXJAddScenarioTimerMethod::crJXJAddScenarioTimerMethod( const crJXJAddScenarioTimerMethod & handle ):
	crMethod(handle),
	m_msg(handle.m_msg),
	m_interval(handle.m_interval),
	m_id(handle.m_id),
	m_times(handle.m_times)
{
}

void crJXJAddScenarioTimerMethod::inputParam( int i, void *param )
{
}

void crJXJAddScenarioTimerMethod::addParam( int i, const std::string& str )
{
	switch(i) 
	{
	case 0:
		m_msg = atoi(str.c_str());
		break;
	case 1:
		m_interval = atof(str.c_str());
		break;
	case 2:
		m_id = atoi(str.c_str());
		break;
	case 3:
		m_times = atoi(str.c_str());
		break;
	}
}

void crJXJAddScenarioTimerMethod::operator()( crHandle &handle )
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && room)
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(16);
		stream->_writeInt(m_msg);
		stream->_writeFloat(m_interval);
		stream->_writeInt(m_id);
		stream->_writeInt(m_times);
		crRoomEventPacket packet;
		crRoomEventPacket::buildRequestPacket(packet,WCH_JXJRecvAddScenarioTimer,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRemoveScenarioTimerMethod
//
/////////////////////////////////////////
crJXJRemoveScenarioTimerMethod::crJXJRemoveScenarioTimerMethod():
	m_id(0)
{
}

crJXJRemoveScenarioTimerMethod::crJXJRemoveScenarioTimerMethod( const crJXJRemoveScenarioTimerMethod & handle ):
	crMethod(handle),
	m_id(handle.m_id)
{
}

void crJXJRemoveScenarioTimerMethod::inputParam( int i, void *param )
{
}

void crJXJRemoveScenarioTimerMethod::addParam( int i, const std::string& str )
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	}
}

void crJXJRemoveScenarioTimerMethod::operator()( crHandle &handle )
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && room)
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(m_id);
		crRoomEventPacket packet;
		crRoomEventPacket::buildRequestPacket(packet,WCH_JXJRecvRemoveScenarioTimer,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJServerAddScenarioTimerMethod
//
/////////////////////////////////////////
crJXJServerAddScenarioTimerMethod::crJXJServerAddScenarioTimerMethod():
	m_msg(0),
	m_interval(5.0f),
	m_id(0),
	m_times(1){}
crJXJServerAddScenarioTimerMethod::crJXJServerAddScenarioTimerMethod(const crJXJServerAddScenarioTimerMethod& handle):
	crMethod(handle),
	m_msg(handle.m_msg),
	m_interval(handle.m_interval),
	m_id(handle.m_id),
	m_times(handle.m_times)
{
}
void crJXJServerAddScenarioTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerAddScenarioTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msg = atoi(str.c_str());
		break;
	case 1:
		m_interval = atof(str.c_str());
		break;
	case 2:
		m_id = atoi(str.c_str());
		break;
	case 3:
		m_times = atoi(str.c_str());
		break;
	}
}

void crJXJServerAddScenarioTimerMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioTimerMap,param);
	ScenarioTimerMap *timermap = (ScenarioTimerMap *)param;
	//timermap->insert(std::make_pair(m_id,crJXJScenarioTimer(m_msg,m_interval,m_times)));
	(*timermap)[m_id] = new crJXJScenarioTimer(m_msg,m_interval,m_times);
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJServerEnableScenarioTimerMethod
//
/////////////////////////////////////////
crJXJServerEnableScenarioTimerMethod::crJXJServerEnableScenarioTimerMethod():
	m_id(0),
	m_times(1){}
crJXJServerEnableScenarioTimerMethod::crJXJServerEnableScenarioTimerMethod(const crJXJServerEnableScenarioTimerMethod& handle):
	crMethod(handle),
	m_id(handle.m_id),
	m_times(handle.m_times)
{
}
void crJXJServerEnableScenarioTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerEnableScenarioTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	case 1:
		m_times = atoi(str.c_str());
		break;
	}
}

void crJXJServerEnableScenarioTimerMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioTimerMap,param);
	ScenarioTimerMap *timermap = (ScenarioTimerMap *)param;
	ScenarioTimerMap::iterator itr = timermap->find(m_id);
	if (itr != timermap->end())
	{
		itr->second->m_times = m_times;
		if (m_times == -2)
			itr->second->m_timer = 0.0f;
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJServerRemoveScenarioTimerMethod
//
/////////////////////////////////////////
crJXJServerRemoveScenarioTimerMethod::crJXJServerRemoveScenarioTimerMethod():
	m_id(0){}
crJXJServerRemoveScenarioTimerMethod::crJXJServerRemoveScenarioTimerMethod(const crJXJServerRemoveScenarioTimerMethod& handle):
	crMethod(handle),
	m_id(handle.m_id)
{
}
void crJXJServerRemoveScenarioTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerRemoveScenarioTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	}
}

void crJXJServerRemoveScenarioTimerMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioTimerMap,param);
	ScenarioTimerMap *timermap = (ScenarioTimerMap *)param;
	timermap->erase(m_id);
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvAddScenarioTimerMethod
//
/////////////////////////////////////////
crJXJRecvAddScenarioTimerMethod::crJXJRecvAddScenarioTimerMethod(){}
crJXJRecvAddScenarioTimerMethod::crJXJRecvAddScenarioTimerMethod(const crJXJRecvAddScenarioTimerMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvAddScenarioTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvAddScenarioTimerMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvAddScenarioTimerMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		int msg = m_stream->_readInt();
		float interval = m_stream->_readFloat();
		int id = m_stream->_readInt();
		int times = m_stream->_readInt();
		crData *data = m_this->getDataClass();
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJScenarioTimerMap,param);
		ScenarioTimerMap *timermap = (ScenarioTimerMap *)param;
		//timermap->insert(std::make_pair(id,crJXJScenarioTimer(msg,interval,times)));
		(*timermap)[id] = new crJXJScenarioTimer(msg,interval,times);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvRemoveScenarioTimerMethod
//
/////////////////////////////////////////
crJXJRecvRemoveScenarioTimerMethod::crJXJRecvRemoveScenarioTimerMethod(){}
crJXJRecvRemoveScenarioTimerMethod::crJXJRecvRemoveScenarioTimerMethod(const crJXJRecvRemoveScenarioTimerMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRemoveScenarioTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRemoveScenarioTimerMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvRemoveScenarioTimerMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		int id = m_stream->_readInt();
		crData *data = m_this->getDataClass();
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJScenarioTimerMap,param);
		ScenarioTimerMap *timermap = (ScenarioTimerMap *)param;
		timermap->erase(id);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/**************************************************************************

METHOD: crJXJScenarioTimerMethod

**************************************************************************/

crJXJScenarioTimerMethod::crJXJScenarioTimerMethod():
	m_this(NULL),
	m_dt(NULL)
{

}

crJXJScenarioTimerMethod::crJXJScenarioTimerMethod( const crJXJScenarioTimerMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL)
{
}

void crJXJScenarioTimerMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJScenarioTimerMethod::addParam( int i, const std::string& str )
{
}

void crJXJScenarioTimerMethod::operator()( crHandle &handle )
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioTimerMap,param);
	ScenarioTimerMap *timermap = (ScenarioTimerMap *)param;
	for( ScenarioTimerMap::iterator itr = timermap->begin();
		itr != timermap->end(); )
	{
		if(itr->second->m_times==0 || itr->second->m_times==-2)
		{//停止计时
			++itr;
			continue;
		}
		itr->second->m_timer -= *m_dt;
		if(itr->second->m_timer<0.0f)
		{
			itr->second->m_timer = itr->second->m_interval;
			if(itr->second->m_times>0)
				itr->second->m_times--;
			m_this->doEvent(MAKEINT64(WCH_JXJScenarioTimerEvent,itr->second->m_msg));
			if(itr->second->m_times == 0)
			{//移除计时
				itr = timermap->erase(itr);
				continue;
			}
		}
		++itr;
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJPauseRoomMethod
//
/////////////////////////////////////////
crJXJPauseRoomMethod::crJXJPauseRoomMethod():
	m_pausetime(0.0f){}
crJXJPauseRoomMethod::crJXJPauseRoomMethod(const crJXJPauseRoomMethod& handle):
	crMethod(handle),
	m_pausetime(handle.m_pausetime)
{
}
void crJXJPauseRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJPauseRoomMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_pausetime = atof(str.c_str());
		break;
	}
}

void crJXJPauseRoomMethod::operator()(crHandle &handle)
{
	m_this->pauseRoom(m_pausetime);
}
/////////////////////////////////////////
//
//crJXJClientPauseRoomMethod
//
/////////////////////////////////////////
crJXJClientPauseRoomMethod::crJXJClientPauseRoomMethod():
	m_pausetime(0){}
crJXJClientPauseRoomMethod::crJXJClientPauseRoomMethod(const crJXJClientPauseRoomMethod& handle):
	crMethod(handle),
	m_pausetime(handle.m_pausetime)
{
}
void crJXJClientPauseRoomMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_pausetime = atoi(str.c_str());
		break;
	}
}
void crJXJClientPauseRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}
void crJXJClientPauseRoomMethod::operator()(crHandle &handle)
{
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && room && room->getGameRunning())
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(2);
		stream->_writeShort(m_pausetime);
		crRoomEventPacket packet;
		crRoomEventPacket::buildRequestPacket(packet,WCH_JXJServerRecvPauseRoom,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvPauseRoomMethod
//
/////////////////////////////////////////
crJXJRecvPauseRoomMethod::crJXJRecvPauseRoomMethod(){}
crJXJRecvPauseRoomMethod::crJXJRecvPauseRoomMethod(const crJXJRecvPauseRoomMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvPauseRoomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPauseRoomMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvPauseRoomMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		short time = m_stream->_readShort();
		m_this->pauseRoom(time);
	}
}
/////////////////////////////////////////
//
//crJXJRoomDoEventMethod
//
/////////////////////////////////////////
crJXJRoomDoEventMethod::crJXJRoomDoEventMethod():
	m_msg(0),
	m_param(NULL){}
crJXJRoomDoEventMethod::crJXJRoomDoEventMethod(const crJXJRoomDoEventMethod& handle):
	crMethod(handle),
	m_msg(handle.m_msg)
{
}
void crJXJRoomDoEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	case 2:
		if(param)
		{
			m_param = *(_crInt64*)param;
		}
		else
		{
			m_param = NULL;
		}
		break;
	}
}

void crJXJRoomDoEventMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msg = atoi(str.c_str());
		break;
	}
}

void crJXJRoomDoEventMethod::operator()(crHandle &handle)
{
	m_this->doEvent(MAKEINT64(WCH_JXJRoomDoEvent,m_msg),m_param);
}
/////////////////////////////////////////
//
//crJXJExtraDamageMaxHPPercentMethod
//
/////////////////////////////////////////
crJXJExtraDamageMaxHPPercentMethod::crJXJExtraDamageMaxHPPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f){}
crJXJExtraDamageMaxHPPercentMethod::crJXJExtraDamageMaxHPPercentMethod(const crJXJExtraDamageMaxHPPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
}
void crJXJExtraDamageMaxHPPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraDamageMaxHPPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraDamageMaxHPPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *itemData = m_this->getDataClass();
		float maxhp = 0.0f;
		m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
		itemData->getParam(WCHDATA_JXJArmyCount,param);
		/*unsigned short*/int armyCount = *(/*unsigned short*/int *)param;
		maxhp *= (float)armyCount;
		float extraValue = maxhp * (float)m_extraValue * 0.01f;

		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		float damage = 0.0f;
		if(m_timer<0.0f)
		{
			m_dtrec += m_timer;
			damage = extraValue * m_dtrec;
			m_dtrec = 0.0f;
			//m_start = false;
			//m_timer = 0.0f;

		}
		else if(m_dtrec>=1.0f)
		{
			damage = extraValue;
			m_dtrec -= 1.0f;
		}
		if(damage!=0.0f)
		{
			DamagePair dp(damage,std::make_pair(SkillDM,0));//ExtraDM
			m_this->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_fireItem.get()));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraDamageRTHPPercentMethod
//
/////////////////////////////////////////
crJXJExtraDamageRTHPPercentMethod::crJXJExtraDamageRTHPPercentMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f){}
crJXJExtraDamageRTHPPercentMethod::crJXJExtraDamageRTHPPercentMethod(const crJXJExtraDamageRTHPPercentMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
}
void crJXJExtraDamageRTHPPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraDamageRTHPPercentMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraDamageRTHPPercentMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *itemData = m_this->getDataClass();
		itemData->getParam(WCHDATA_RTHP,param);
		float rthp = *(float*)param;
		float extraValue = rthp * (float)m_extraValue * 0.01f;

		if(m_duration>0.0f) m_timer -= *m_dt;
		m_dtrec += *m_dt;
		float damage = 0.0f;
		if(m_timer<0.0f)
		{
			m_dtrec += m_timer;
			damage = extraValue * m_dtrec;
			m_dtrec = 0.0f;
			//m_start = false;
			//m_timer = 0.0f;

		}
		else if(m_dtrec>=1.0f)
		{
			damage = extraValue;
			m_dtrec -= 1.0f;
		}
		if(damage!=0.0f)
		{
			DamagePair dp(damage,std::make_pair(SkillDM,0));//ExtraDM
			m_this->doEvent(WCH_AddDamage,MAKEINT64(&dp,m_fireItem.get()));
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerSetScenarioVariableMethod
//
/////////////////////////////////////////
crJXJServerSetScenarioVariableMethod::crJXJServerSetScenarioVariableMethod():
	m_value(0.0f),
	m_sync(0)
{}
crJXJServerSetScenarioVariableMethod::crJXJServerSetScenarioVariableMethod(const crJXJServerSetScenarioVariableMethod& handle):
	crMethod(handle),
	m_nameid(handle.m_nameid),
	m_value(handle.m_value),
	m_sync(handle.m_sync)
{
}
void crJXJServerSetScenarioVariableMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerSetScenarioVariableMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameid = str;
		break;
	case 1:
		m_value = atof(str.c_str());
		break;
	case 2:
		m_sync = 0;
		break;
	default:
		break;
	}
}

void crJXJServerSetScenarioVariableMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	if (data)
	{
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJScenarioVariableMap,param);
		ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
		(*variableMap)[m_nameid] = m_value;
		data->excHandle(MAKEINT64(WCH_LockData,0));
		if(m_sync)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4 + m_nameid.size());
			stream->_writeString(m_nameid);
			stream->_writeFloat(m_value);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet, 0, WCH_JXJSyncScenarioVariable, stream.get());
			m_this->sendPacketToAll(packet);				
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerScenarioVariableOperatorMethod
//
/////////////////////////////////////////
crJXJServerScenarioVariableOperatorMethod::crJXJServerScenarioVariableOperatorMethod():
	m_value(0),
	m_op(0),
	m_sync(0)
{}
crJXJServerScenarioVariableOperatorMethod::crJXJServerScenarioVariableOperatorMethod(const crJXJServerScenarioVariableOperatorMethod& handle):
	crMethod(handle),
	m_nameid(handle.m_nameid),
	m_op(handle.m_op),
	m_value(handle.m_value),
	m_sync(handle.m_sync)
{
}
void crJXJServerScenarioVariableOperatorMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerScenarioVariableOperatorMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameid = str;
		break;
	case 1:
		m_op = atoi(str.c_str());
		break;
	case 2:
		m_value = atof(str.c_str());
		break;
	case 3:
		m_sync = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJServerScenarioVariableOperatorMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	if (data)
	{
		float v = m_value;
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJScenarioVariableMap,param);
		ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
		ScenarioVariableMap::iterator itr = variableMap->find(m_nameid);
		if(itr == variableMap->end())
			(*variableMap)[m_nameid] = m_value;
		else
		{
			switch (m_op)
			{
			case 0:
				itr->second = m_value;
				break;
			case 1:
				itr->second += m_value;
				break;
			case 2:
				itr->second *= m_value;
				break;
			}
			v = itr->second;
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		if(m_sync)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4 + m_nameid.size());
			stream->_writeString(m_nameid);
			stream->_writeFloat(v);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet, 0, WCH_JXJSyncScenarioVariable, stream.get());
			m_this->sendPacketToAll(packet);				
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerScenarioVariableCheckMethod
//
/////////////////////////////////////////
crJXJServerScenarioVariableCheckMethod::crJXJServerScenarioVariableCheckMethod():
	m_value(0),
	m_op(0){}
crJXJServerScenarioVariableCheckMethod::crJXJServerScenarioVariableCheckMethod(const crJXJServerScenarioVariableCheckMethod& handle):
	crMethod(handle),
	m_nameid(handle.m_nameid),
	m_op(handle.m_op),
	m_value(handle.m_value)
{
}
void crJXJServerScenarioVariableCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerScenarioVariableCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameid = str;
		break;
	case 1:
		m_op = atoi(str.c_str());
		break;
	case 2:
		m_value = atof(str.c_str());
		break;
	}
}

void crJXJServerScenarioVariableCheckMethod::operator()(crHandle &handle)
{
	bool success = false;
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioVariableMap,param);
	ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
	ScenarioVariableMap::iterator itr = variableMap->find(m_nameid);
	switch (m_op)
	{
	case 0:
		if(itr != variableMap->end())
			success = true;
		break;
	case 1:
		if(itr!=variableMap->end() && itr->second == m_value)
			success = true;
		break;
	case 2:
		if(itr!=variableMap->end() && itr->second > m_value)
			success = true;
		break;
	case 3:
		if(itr!=variableMap->end() && itr->second >= m_value)
			success = true;
		break;
	case 4:
		if(itr!=variableMap->end() && itr->second < m_value)
			success = true;
		break;
	case 5:
		if(itr!=variableMap->end() && itr->second <= m_value)
			success = true;
		break;
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crJXJServerScenarioVariableCaseMethod
//
/////////////////////////////////////////
crJXJServerScenarioVariableCaseMethod::crJXJServerScenarioVariableCaseMethod(){}
crJXJServerScenarioVariableCaseMethod::crJXJServerScenarioVariableCaseMethod(const crJXJServerScenarioVariableCaseMethod& handle):
	crMethod(handle),
	m_nameid(handle.m_nameid)
{
}
void crJXJServerScenarioVariableCaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerScenarioVariableCaseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameid = str;
		break;
	}
}

void crJXJServerScenarioVariableCaseMethod::operator()(crHandle &handle)
{
	int _case = 0;
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioVariableMap,param);
	ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
	ScenarioVariableMap::iterator itr = variableMap->find(m_nameid);
	if(itr != variableMap->end())
		_case = itr->second;
	data->excHandle(MAKEINT64(WCH_LockData,0));
	handle.outputParam(0,&_case);
}
/////////////////////////////////////////
//
//crJXJServerScenarioVariableSaveMethod
//
/////////////////////////////////////////
crJXJServerScenarioVariableSaveMethod::crJXJServerScenarioVariableSaveMethod(){}
crJXJServerScenarioVariableSaveMethod::crJXJServerScenarioVariableSaveMethod(const crJXJServerScenarioVariableSaveMethod& handle):
	crMethod(handle),
	m_nameidVec(handle.m_nameidVec),
	m_filepath(handle.m_filepath)
{
}
void crJXJServerScenarioVariableSaveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerScenarioVariableSaveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_nameidVec);
		break;
	case 1:
		m_filepath = str;
		break;
	}
}

void crJXJServerScenarioVariableSaveMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	ref_ptr<CREncapsulation::crTableIO> vartab = new CREncapsulation::crTableIO;
	CREncapsulation::crTableIO::StrVec title;
	title.push_back("name");
	title.push_back("value");
	vartab->setTitleVec(title);
	CREncapsulation::crTableIO::StrVec record;
	record.resize(2);
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJScenarioVariableMap,param);
	ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
	ScenarioVariableMap::iterator sitr;
	for( std::vector<std::string>::iterator itr = m_nameidVec.begin();
		itr != m_nameidVec.end();
		++itr )
	{
		sitr = variableMap->find(*itr);
		if(sitr != variableMap->end())
		{
			record[0] = sitr->first;
			record[1] = crArgumentParser::appFtoa(sitr->second);
			vartab->addData(record);
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
	std::string name = m_this->getName();
	CRNet::crNetConductor * sceneServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(SceneServer);
	CRNet::crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	CRNetApp::crSceneServerCallback *netCallback = dynamic_cast<CRNetApp::crSceneServerCallback *>(netDataManager->getNetCallback());
	std::string relFileName = m_filepath + netCallback->getServerName() + "/"+ name+".tab";
	vartab->saveToFileNoCook(relFileName);
}
/////////////////////////////////////////
//
//crJXJServerScenarioVariableLoadMethod
//
/////////////////////////////////////////
crJXJServerScenarioVariableLoadMethod::crJXJServerScenarioVariableLoadMethod():
	m_sync(false)
{}
crJXJServerScenarioVariableLoadMethod::crJXJServerScenarioVariableLoadMethod(const crJXJServerScenarioVariableLoadMethod& handle):
	crMethod(handle),
	m_nameidVec(handle.m_nameidVec),
	m_filepath(handle.m_filepath),
	m_sync(handle.m_sync)
{
}
void crJXJServerScenarioVariableLoadMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJServerScenarioVariableLoadMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_nameidVec);
		break;
	case 1:
		m_filepath = str;
		break;
	case 2:
		m_sync = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJServerScenarioVariableLoadMethod::operator()(crHandle &handle)
{
	std::string name = m_this->getName();
	CRNet::crNetConductor * sceneServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(SceneServer);
	CRNet::crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	CRNetApp::crSceneServerCallback *netCallback = dynamic_cast<CRNetApp::crSceneServerCallback *>(netDataManager->getNetCallback());
	std::string relFileName = m_filepath + netCallback->getServerName() + "/"+ name+".tab";
	ref_ptr<CREncapsulation::crTableIO> vartab = CREncapsulation::crTableIO::openFile(relFileName.c_str());
	if(vartab.valid())
	{
		crData *data = m_this->getDataClass();
		void *param;
		CREncapsulation::crTableIO::StrVec record;
		record.resize(2);
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJScenarioVariableMap,param);
		ScenarioVariableMap *variableMap = (ScenarioVariableMap *)param;
		for( std::vector<std::string>::iterator itr = m_nameidVec.begin();
			itr != m_nameidVec.end();
			++itr )
		{
			if(vartab->queryOneRecord(0,*itr,record)>=0)
			{
				(*variableMap)[record[0]] = atof(record[1].c_str());
				if(m_sync)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4 + record[0].size());
					stream->_writeString(record[0]);
					stream->_writeFloat(atof(record[1].c_str()));
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet, 0, WCH_JXJSyncScenarioVariable, stream.get());
					m_this->sendPacketToAll(packet);				
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJExtraCritPowerMethod
//
/////////////////////////////////////////
crJXJExtraCritPowerMethod::crJXJExtraCritPowerMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraCritPowerMethod::crJXJExtraCritPowerMethod(const crJXJExtraCritPowerMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraCritPowerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraCritPowerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = (short)(atoi(str.c_str()));
		break;
	}
}

void crJXJExtraCritPowerMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraCritPower,param);
		short* extra = (short *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;
		*extra += m_extraValue * m_overlapCount;
		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJExtraSputteringMethod
//
/////////////////////////////////////////
crJXJExtraSputteringMethod::crJXJExtraSputteringMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1){}
crJXJExtraSputteringMethod::crJXJExtraSputteringMethod(const crJXJExtraSputteringMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_overlapCount(1)
{
}
void crJXJExtraSputteringMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	case WCHDATA_JXJOverlapParam:
		{
			short overlap = *(short*)param;
			if(overlap>m_overlapCount && m_start)
			{
				m_timer = m_duration;
			}
			m_overlapCount = overlap>0 ? overlap : 1;
		}
		break;
	}
}

void crJXJExtraSputteringMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_extraValue);
		break;
	}
}

void crJXJExtraSputteringMethod::operator()(crHandle &handle)
{
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
	}
	if(m_timer>=0.0f)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKEINT64(WCH_LockData,1));
		thisData->getParam(WCHDATA_ExtraSputtering,param);
		_crInt32* extra = (_crInt32 *)param;
		//if(m_overlapCount<1) m_overlapCount = 1;

		_crInt16 extraarea = LOINT32(*extra);
		_crInt16 extrapercent = HIINT32(*extra);
		extrapercent += m_extraValue[1] * m_overlapCount;
		*extra = MAKEINT32(m_extraValue[0],m_extraValue[1]);

		thisData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_duration>0.0f) m_timer -= *m_dt;
		//if(m_timer<0.0f)
		//{
		//	m_start = false;
		//	m_timer = 0.0f;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJBattleDeadAddArmyMethod
//
/////////////////////////////////////////
crJXJBattleDeadAddArmyMethod::crJXJBattleDeadAddArmyMethod(){}
crJXJBattleDeadAddArmyMethod::crJXJBattleDeadAddArmyMethod(const crJXJBattleDeadAddArmyMethod& handle):
	crMethod(handle)
{
}
void crJXJBattleDeadAddArmyMethod::inputParam(int i, void *param)
{
}

void crJXJBattleDeadAddArmyMethod::addParam(int i, const std::string& str)
{
}

void crJXJBattleDeadAddArmyMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInBattle())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crJXJCampAddArmyInfoPacket packet;
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
//////////////////////////////////////////////////////////////////////////
//crJXJBattleDeadAddArmyPromptMethod
//////////////////////////////////////////////////////////////////////////
crJXJBattleDeadAddArmyPromptMethod::crJXJBattleDeadAddArmyPromptMethod()
{}
crJXJBattleDeadAddArmyPromptMethod::crJXJBattleDeadAddArmyPromptMethod(const crJXJBattleDeadAddArmyPromptMethod& handle):
	m_noticeCanvas(handle.m_noticeCanvas),
	m_inputMoney(handle.m_inputMoney),
	m_inputWood(handle.m_inputWood),
	m_inputIron(handle.m_inputIron),
	m_inputHorse(handle.m_inputHorse),
	m_inputFood(handle.m_inputFood),
	m_okbtn(handle.m_okbtn),
	m_strCanvas(handle.m_strCanvas),
	m_strText(handle.m_strText)
{

}
void crJXJBattleDeadAddArmyPromptMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode *)param;
		break;
	}
}
void crJXJBattleDeadAddArmyPromptMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_inputMoney = str;
		break;
	case 2:
		m_inputWood = str;
		break;
	case 3:
		m_inputIron = str;
		break;
	case 4:
		m_inputHorse = str;
		break;
	case 5:
		m_inputFood = str;
		break;
	case 6:
		m_inputRecruitTime = str;
		break;
	case 7:
		m_inputRecruitTime_2 = str;
		break;
	case 8:
		m_okbtn = str;
		break;
	case 9:
		m_strCanvas = str;
		break;
	case 10:
		m_strText = str;
		break;
	}
}
void crJXJBattleDeadAddArmyPromptMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInBattle())
	{
		void *param;
		crMyPlayerData *me = crMyPlayerData::getInstance();
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		crData *myPlayerData = myPlayer->getDataClass();
		myPlayerData->excHandle(MAKEINT64(WCH_LockData,1));
		crRole *role;
		TroopsMap recruitTroops;
		/*unsigned short*/int rtCount = 0;
		crData *roledata;
		BattleAddArmyInfoVec addArmyInfoVec;
		for(int i = 0;i<3;i++)
		{
			role = me->getLoadedRoleByIndex(i);
			if(!role)
				continue;
			roledata = role->getDataClass();
			int abstractid = role->getAbstractItemID();
			int roleid = role->getRoleID();
			if(roledata)
			{
				roledata->getParam(WCHDATA_JXJArmyCount,param);
				/*unsigned short*/int count = *(/*unsigned short*/int *)param;
				roledata->getParam(WCHDATA_JXJRTArmyCount,param);
				rtCount = *(/*unsigned short*/int *)param;
				if(rtCount>=count) continue;

				if (rtCount == 0)
				{
					addArmyInfoVec.push_back(std::make_pair(abstractid, std::make_pair(roleid, rtCount)));
					if(recruitTroops.find(abstractid)!=recruitTroops.end())
					{
						recruitTroops[abstractid]+=count;
					}
					else
					{
						recruitTroops[abstractid]=count;
					}
					if(addArmyInfoVec.empty())
					{
						battleDeadAddArmyFaild(-1);
					}
				}
			}			
		}
		//if(addArmyInfoVec.empty())  // 应该当rtCount == 0时才判定。否则会出现直接选择复活据点补兵时，补兵完成，却弹出兵力不足的窗口，然后只能退出战场
		//{
		//	battleDeadAddArmyFaild(-1);
		//}
		if (addArmyInfoVec.empty())  // 补兵窗口弹出后，也能直接选择复活据点补兵，此时点补兵按钮只会关闭窗口，不会重复补兵
		{
			if(m_this->getParentCanvas())
			{
				crFilterRenderManager::getInstance()->closeCanvas(m_this->getParentCanvas());
			}
		}
		myPlayerData->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troops = (TroopsMap *)param;
		TroopsMap::iterator itr_troops;
		TroopsMap recruitTroops_copy = recruitTroops;
		for( TroopsMap::iterator itr = recruitTroops.begin();
			itr != recruitTroops.end();
			)
		{
			itr_troops = troops->find(itr->first);
			if (itr_troops != troops->end())
			{
				if(itr_troops->second>=itr->second)
				{
					//itr_troops->second-=itr->second;
					itr = recruitTroops.erase(itr);
					continue;
				}
				else
				{
					itr->second-=itr_troops->second;
					//itr_troops->second = 0;
				}
			}
			++itr;
		}
		myPlayerData->excHandle(MAKEINT64(WCH_LockData,0));
		BattleRecruitCheckResult recruitCheck;
		myPlayer->doEvent(WCH_JXJBattleRecruitCheck,MAKEINT64(&recruitTroops,&recruitCheck));
		if(recruitCheck.m_code==1)
		{//不需要扣资源，直接补兵
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				crJXJCampAddArmyInfoPacket packet;
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			if(m_this->getParentCanvas())
			{
				crFilterRenderManager::getInstance()->closeCanvas(m_this->getParentCanvas());
			}
		}
		else if(recruitCheck.m_code>=0)
		{
			ref_ptr<crCanvasNode>  msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			ref_ptr<crStaticTextWidgetNode> inputMoneyText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputMoney));
			ref_ptr<crStaticTextWidgetNode> inputWoodText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputWood));
			ref_ptr<crStaticTextWidgetNode> inputIronText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputIron));
			ref_ptr<crStaticTextWidgetNode> inputHorseText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputHorse));
			ref_ptr<crStaticTextWidgetNode> inputFoodText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputFood));
			ref_ptr<crHypertextWidgetNode> inputRecruitTime = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_inputRecruitTime));
			ref_ptr<crHypertextWidgetNode> inputRecruitTime_2 = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_inputRecruitTime_2));
			ref_ptr<crButtonWidgetNode>  okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_okbtn));
			//int hinttype = JXJGoldCostType_BattleInspire;
			//crData *braindata = crBrain::getInstance()->getDataClass();
			//braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);

			//crData * data = me->getPlayerGameData()->getDataClass();
			//data->getParam(WCHDATA_JXJGoldCostHintInt,param);
			//unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_BattleInspire;
			//if (ifhint)
			//{
// 				std::vector<float>v_i;
// 				ItemMap itemMap;
// 				rcfg::ConfigScript cfg_script(&itemMap);
// 				cfg_script.Add("Hypertext");
// 				cfg_script.Push("Hypertext");
// 				cfg_script.Add("Content");
// 				cfg_script.Push("Content");
// 				cfg_script.Add("Text","您确认要花费");
// 				cfg_script.Pop();
// 
// 				cfg_script.Add("Content");
// 				cfg_script.Push("Content",2);
// 				v_i.clear();
// 				v_i.push_back(140.0);
// 				v_i.push_back(40.0);
// 				v_i.push_back(40.0);
// 				v_i.push_back(255.0);
// 				cfg_script.Add("Color",v_i);
				char tmpText2[80];
				std::string tmpText[6];
				if(recruitCheck.m_code==0)
				{
					if(recruitCheck.m_copperneed>=0) tmpText[0] = "0";
					if(recruitCheck.m_woodneed>=0)   tmpText[1] = "0";
					if(recruitCheck.m_ironneed>=0)   tmpText[2] = "0";
					if(recruitCheck.m_horseneed>=0)  tmpText[3] = "0";
					if(recruitCheck.m_foodneed>=0)   tmpText[4] = crArgumentParser::appItoa(recruitCheck.m_foodneed);
					if(recruitCheck.m_goldneed>=0)   tmpText[5] = "礼金/元宝：0";
				}
				else if(recruitCheck.m_code==2)
				{
					if(recruitCheck.m_copperneed>=0) tmpText[0] = crArgumentParser::appItoa(recruitCheck.m_copperneed);
					if(recruitCheck.m_woodneed>=0)   tmpText[1] = crArgumentParser::appItoa(recruitCheck.m_woodneed);
					if(recruitCheck.m_ironneed>=0)   tmpText[2] = crArgumentParser::appItoa(recruitCheck.m_ironneed);
					if(recruitCheck.m_horseneed>=0)  tmpText[3] = crArgumentParser::appItoa(recruitCheck.m_horseneed);
					if(recruitCheck.m_foodneed>=0)   tmpText[4] = crArgumentParser::appItoa(recruitCheck.m_foodneed);
					if(recruitCheck.m_goldneed>=0)   tmpText[5] = "礼金/元宝："+crArgumentParser::appItoa(recruitCheck.m_goldneed);
				}
				else if(recruitCheck.m_code == 3)
				{
					if(recruitCheck.m_copperneed>=0) tmpText[0] = crArgumentParser::appItoa(recruitCheck.m_copperneed);
					if(recruitCheck.m_woodneed>=0)   tmpText[1] = crArgumentParser::appItoa(recruitCheck.m_woodneed);
					if(recruitCheck.m_ironneed>=0)   tmpText[2] = crArgumentParser::appItoa(recruitCheck.m_ironneed);
					if(recruitCheck.m_horseneed>=0)  tmpText[3] = crArgumentParser::appItoa(recruitCheck.m_horseneed);
					if(recruitCheck.m_foodneed>=0)   tmpText[4] = crArgumentParser::appItoa(recruitCheck.m_foodneed);
					if(recruitCheck.m_goldneed>=0)   tmpText[5] = "礼金/元宝："+crArgumentParser::appItoa(recruitCheck.m_goldneed);
				}

				if (inputMoneyText.valid() && inputWoodText.valid() && inputIronText.valid() && inputHorseText.valid() &&  inputFoodText.valid())
				{
					inputMoneyText->setString(tmpText[0]);
					inputWoodText->setString(tmpText[1]);
					inputIronText->setString(tmpText[2]);
					inputHorseText->setString(tmpText[3]);
					inputFoodText->setString(tmpText[4]);
				}
				if (inputRecruitTime.valid())
				{
					std::vector<float>v_i;
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");

					cfg_script.Add("Content");
					cfg_script.Push("Content");
					cfg_script.Add("Text","您确认要花费");
					cfg_script.Pop();

					cfg_script.Pop();
					inputRecruitTime->setHypertext(cfg_script);
				}
				if (inputRecruitTime_2.valid())
				{
					std::vector<float>v_i;
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");

					cfg_script.Add("Content");
					cfg_script.Push("Content");
					v_i.clear();
					v_i.push_back(140.0);
					v_i.push_back(40.0);
					v_i.push_back(40.0);
					v_i.push_back(255.0);
					cfg_script.Add("Color",v_i);
					cfg_script.Add("Text",tmpText[5]);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",2);
					memset(tmpText2,0,sizeof(tmpText2));
					sprintf(tmpText2,"来补充兵力吗？\0");
					cfg_script.Add("Text",std::string(tmpText2));
					cfg_script.Pop();


					cfg_script.Pop();
					inputRecruitTime_2->setHypertext(cfg_script);
				}



// 				cfg_script.Add("Text",tmpText);
// 				cfg_script.Pop();
// 
// 				cfg_script.Add("Content");
// 				cfg_script.Push("Content",3);
// 				sprintf(tmpText2,"来补充兵力!\0");
// 				cfg_script.Add("Text",tmpText2);
// 				cfg_script.Pop();
// 				// 				if(m_index==1 && inspireCost>0)
// 				// 				{
// 				// 					cfg_script.Add("Content");
// 				// 					cfg_script.Push("Content",3);
// 				// 					strInfo = string("另花费元宝：")+crArgumentParser::appItoa(inspireCost)+std::string("进行战场鼓舞！\0");
// 				// 					cfg_script.Add("Text",strInfo);
// 				// 					cfg_script.Pop();
// 				// 				}
// 				cfg_script.Pop();
// 				msg->setHypertext(cfg_script);
			//}
/*			ref_ptr<crCanvasNode>  canvas = m_this->getParentCanvas();*/
			//crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
			//crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
// 			crData *dlgData = msgCanvas->getDataClass();
// 			int commandtype = CDP_Widget;
// 			dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
// 			dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
			//if (ifhint)
			//{ //始终弹出战场补兵消耗提示，解除与 战场鼓舞消费提示 的绑定
			if(recruitCheck.m_code!=0)
				crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
			else
				if(okBtn.valid())okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
			//}
			//else
			//{
			//	if(okBtn.valid())okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
			//}
		}
		else
		{
			battleDeadAddArmyFaild(recruitCheck.m_code);
			if(m_this->getParentCanvas())
			{
				crFilterRenderManager::getInstance()->closeCanvas(m_this->getParentCanvas());
			}
		}
	}
}
void crJXJBattleDeadAddArmyPromptMethod::battleDeadAddArmyFaild(int code)
{
	//补兵失败
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_strCanvas);
	ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
	if (canvas.valid() && camera.valid())
	{
		ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_strText));
		if (text.valid())
		{
			int textid = 1087;
			switch (code)
			{
			case -1:
				textid = 1088;//兵力不足，补兵失败！点击确定后退出
				break;
			case -2:
				textid = 1089;//粮草不足，补兵失败！点击确定后退出
				break;
			case -3:
				textid = 1090;//元宝不足
				break;
			case -4:
				textid = 1091;//资源不足
				break;
			case -6:
				textid = 1092;//铜钱不足
				break;
			case -7:
				textid = 1093;//今日可购资源量不足
				break;
			case -8:
				textid = 1094;//资源够买失败
				break;
			}
			ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
			crTableIO::StrVec record;
			std::string str;
			if(textTab->queryOneRecord(0,crArgumentParser::appItoa(textid),record)>=0)
			{
				str = record[1];
			}
			text->setString(str);
		}
		crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		crData *camadata = camera->getAttachedNode()->getDataClass();
		short timer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJExitTimerLimit, 0).c_str());
		camadata->inputParam(WCHDATA_JXJTimer, &timer);
	}
}
//////////////////////////////////////////////////////////////////////////
//crJXJRecvAddArmyFaildMethod
//////////////////////////////////////////////////////////////////////////
crJXJRecvAddArmyFaildMethod::crJXJRecvAddArmyFaildMethod()
{}
crJXJRecvAddArmyFaildMethod::crJXJRecvAddArmyFaildMethod(const crJXJRecvAddArmyFaildMethod& handle):
	m_strCanvas(handle.m_strCanvas),
	m_strText(handle.m_strText)
{

}
void crJXJRecvAddArmyFaildMethod::inputParam(int i, void *param)
{
}
void crJXJRecvAddArmyFaildMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_strCanvas = str;
		break;
	case 1:
		m_strText = str;
		break;
	}
}
void crJXJRecvAddArmyFaildMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInBattle())
	{
		//补兵失败
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_strCanvas);
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if (canvas.valid() && camera.valid())
		{
			ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_strText));
			if (text.valid())
			{
				text->setString(std::string("补兵失败！点击确定后退出"));
				crFilterRenderManager::getInstance()->showCanvas(canvas.get(), true);
				crData *camadata = camera->getAttachedNode()->getDataClass();
				short timer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJExitTimerLimit, 0).c_str());
				camadata->inputParam(WCHDATA_JXJTimer, &timer);
			}
		}
	}
}
//////////////////////////////////////////////////////////////////////////
//crJXJNpcUseSkillMethod
//////////////////////////////////////////////////////////////////////////
crJXJNpcUseSkillMethod::crJXJNpcUseSkillMethod():
	m_this(NULL),
	m_itemid(0),
	m_mark(0),
	m_curemp(100.0f)
{

}
crJXJNpcUseSkillMethod::crJXJNpcUseSkillMethod( const crJXJNpcUseSkillMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_itemid(handle.m_itemid),
	m_abstractIDVec(handle.m_abstractIDVec),
	m_mark(handle.m_mark),
	m_curemp(handle.m_curemp)
{

}

void crJXJNpcUseSkillMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_abstractIDVec);
		break;
	case 2:
		m_mark = atoi(str.c_str());
		break;
	case 3:
		m_curemp = atof(str.c_str());
		break;
	}
}
void crJXJNpcUseSkillMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}
void crJXJNpcUseSkillMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene && !m_abstractIDVec.empty())
	{
		ref_ptr<crInstanceItem>item = scene->findRoomItem(m_this->getRoomID(),m_itemid);
		if(item.valid())
		{
			item->doEvent(WCH_JXJCureRTMp,MAKEINT64(&m_curemp,NULL));
			void *param;
			crData *data = item->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_InPatrolEnemyMap,param);
			InPatrolEnemyMap *inPatrolEnemyMap = (InPatrolEnemyMap *)param;
			int enemycount = inPatrolEnemyMap->size();
			int id = rangei(0,m_abstractIDVec.size()).get_random();
			ref_ptr<crItemChild>itemChild = item->findChildItemByAbstractID(m_abstractIDVec[id]);
			if(enemycount>0 && itemChild.valid() && itemChild->isLoaded())
			{
				ref_ptr<crInstanceItem>skill = itemChild->getInstanceItem();
				if(skill.valid())
				{
					UseItemParam useItemParam;
					useItemParam.m_user = item;
					useItemParam.m_target = NULL;
					unsigned short useResult = UR_None;
					skill->doEvent(WCH_UseItemCheck,MAKEINT64(&useItemParam,&useResult));
					if(useResult == UR_Succeed)
					{
						ref_ptr<crInstanceItem> targetItem;
						switch (m_mark)
						{
						case 0://自己脚下
							break;
						case 1://(仇恨最高) 距离最近
							targetItem = inPatrolEnemyMap->begin()->second;
							break;
						case 2://(随机仇恨) 随机距离
							{
								int er = rangei(0,enemycount).get_random();
								for( InPatrolEnemyMap::iterator itr = inPatrolEnemyMap->begin();
									itr != inPatrolEnemyMap->end();
									++itr,--er )
								{
									if(er==0)
									{
										targetItem = itr->second;
										break;
									}
								}
							}
							break;
						case 3://(仇恨最低) 距离最远
							targetItem = inPatrolEnemyMap->rbegin()->second;
							break;
						case 4://血量低于20%
							{
								float itemRthpPercent;
								targetItem = inPatrolEnemyMap->begin()->second;
								for( InPatrolEnemyMap::iterator itr = inPatrolEnemyMap->begin();
									itr != inPatrolEnemyMap->end();
									++itr )
								{
									itemRthpPercent = 1.0f;
									itr->second->doEvent(MAKEINT64(WCH_JXJGetRTHPPercent,NULL),MAKEINT64(&itemRthpPercent,NULL));
									if(itemRthpPercent<=0.2f)
									{
										targetItem = itr->second;
										break;
									}
								}
							}
							break;
						case 5://对自身
							targetItem = item;
							break;
						}
						if(targetItem.valid())
						{
							unsigned char targettype = targetItem->getItemtype()==crInstanceItem::Role?Target_Role:Target_Npc;
							data->inputParam(WCHDATA_TargetType,&targettype);
							int targetid = targetItem->getID();
							int targetroleid = targetItem->getRoleID();
							data->inputParam(WCHDATA_TargetID,&targetid);
							data->inputParam(WCHDATA_TargetRoleID,&targetroleid);
						}
						else
						{
							unsigned char targettype = Target_Coord;
							crVector3 pos = item->getPosition()+item->getDir() * 0.1f;
							data->inputParam(WCHDATA_TargetPos,&pos);
						}
						int skillid = skill->getInstanceItemID();
						data->inputParam(WCHDATA_AboutToUseItemID,&skillid);
						unsigned char itemstate = IS_UseItem;
						data->inputParam(WCHDATA_ItemState,&itemstate);
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
//////////////////////////////////////////////////////////////////////////
//crJXJSceneCreateMainRoomMethod
//////////////////////////////////////////////////////////////////////////
crJXJSceneCreateMainRoomMethod::crJXJSceneCreateMainRoomMethod()
{

}
crJXJSceneCreateMainRoomMethod::crJXJSceneCreateMainRoomMethod( const crJXJSceneCreateMainRoomMethod & handle ):
	crMethod(handle)
{
}

void crJXJSceneCreateMainRoomMethod::addParam(int i, const std::string& str)
{
}
void crJXJSceneCreateMainRoomMethod::inputParam(int i, void *param)
{
}
void crJXJSceneCreateMainRoomMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer); 
	crNetDataManager *netDataManager = sceneServer->getNetDataManager();
	crSceneServerCallback *callback = dynamic_cast<crSceneServerCallback*>(netDataManager->getNetCallback());
	if(callback)
	{
		ref_ptr<crTableIO> worldfubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJWorldFubenab);
		int sceneidindex = worldfubentab->getTitleIndex("sceneid");
		int nameindex = worldfubentab->getTitleIndex("name");
		int siteindex = worldfubentab->getTitleIndex("视野共享");
		int maxplayerindex = worldfubentab->getTitleIndex("最大人数");
		int count = worldfubentab->getRowCount();
		int sceneid;
		std::string name;
		ref_ptr<CRNetApp::crScene> scene;
		ref_ptr<CRNetApp::crRoom> room;
		ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
		for(int i = 0; i<count; i++)
		{
			sceneid = atoi((*worldfubentab)(i, sceneidindex).c_str());
			scene = callback->findScene(sceneid);
			if(scene.valid())
			{
				name = (*worldfubentab)(i, nameindex);
				streamBuf->createBuf(20+name.length());
				streamBuf->_writeChar(crRoom::Extern);//1
				streamBuf->_writeString(name);//16+4
				streamBuf->_writeInt(-1);//4
				streamBuf->_writeShort(atoi((*worldfubentab)(i, maxplayerindex).c_str()));//2
				streamBuf->_writeBool(false);//1
				streamBuf->seekBegin();
				room = callback->createRoom(sceneid,streamBuf.get());
				if(room.valid())
				{
					room->setShareSight(atoi((*worldfubentab)(i, siteindex).c_str()));
					scene->setMainRoomID(room->getRoomID());
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJTimerEqualMethod
//
/////////////////////////////////////////
crJXJTimerEqualMethod::crJXJTimerEqualMethod():
m_delta(3){}
crJXJTimerEqualMethod::crJXJTimerEqualMethod(const crJXJTimerEqualMethod& handle):
	crMethod(handle),
	m_time(handle.m_time),
	m_delta(handle.m_delta)
{
}
void crJXJTimerEqualMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		{
			crVector3i t;
			crArgumentParser::appTimetoVec(str, t, ':');
			m_time = t[0] * 3600 + t[1] * 60 + t[2];
		}
		break;
	case 1:
		m_delta = atoi(str.c_str());
		break;
	}
}
void crJXJTimerEqualMethod::inputParam(int i, void *param)
{
}
void crJXJTimerEqualMethod::operator()(crHandle &handle)
{
	bool condition = false;
	time_t t = time(0);
	struct tm *pnow;  
	pnow=localtime(&t);
	//crVector3i nowtime(pnow->tm_hour,pnow->tm_min,pnow->tm_sec);
	int nowtime = pnow->tm_hour * 3600 + pnow->tm_min * 60 + pnow->tm_sec;
	if (nowtime >= m_time && nowtime < m_time+m_delta)
	{
		condition = true;
		//char tmp[20];
		//strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t));
		//CRCore::notify(CRCore::ALWAYS) << tmp << "JXJTimerEqual允许延迟:" << m_delta << std::endl;
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJKillNpcShiliGainItemMethod
//
/////////////////////////////////////////
crJXJKillNpcShiliGainItemMethod::crJXJKillNpcShiliGainItemMethod():
	m_this(NULL),
	m_dropitemid(0),
	m_isfirecamp(true){}
crJXJKillNpcShiliGainItemMethod::crJXJKillNpcShiliGainItemMethod(const crJXJKillNpcShiliGainItemMethod& handle):
	crMethod(handle),
	m_dropitemid(handle.m_dropitemid),
	m_isfirecamp(handle.m_isfirecamp)
{
}
void crJXJKillNpcShiliGainItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_deadItem = (crInstanceItem *)(LOINT64(param64));
			m_fireItem = (crInstanceItem *)(HIINT64(param64));
		}
		else
		{
			m_deadItem = NULL;
			m_fireItem = NULL;
		}
		break;
	}
}

void crJXJKillNpcShiliGainItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_dropitemid = atoi(str.c_str());
		break;
	case 1:
		m_isfirecamp = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJKillNpcShiliGainItemMethod::operator()(crHandle &handle)
{
	if(m_deadItem.valid())
	{
		void *param;
		ref_ptr<crData> itemData;
		if(m_isfirecamp)
		{
			if(m_fireItem.valid())
			{
				itemData = m_fireItem->getDataClass();
			}
		}
		else
		{
			itemData = m_deadItem->getDataClass();
		}
		if(itemData.valid())
		{
			itemData->getParam(WCHDATA_Camp,param);
			unsigned char camp = *(unsigned char *)param;
			if(camp>=c_startShiliID)
			{
				//场景掉落
				ref_ptr<crTableIO> dropTab;
				int id = m_dropitemid;
				if(id==0)
				{
					id = m_deadItem->getInstanceItemID();
					if(id<=0)
					{
						id = m_deadItem->getAbstractItemID();
						dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDrop2Tab);
					}
					else
					{
						dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDropTab);
					}
				}
				else
				{
					dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDropTab);
				}
				if(dropTab.valid())
				{
					crTableIO::DataVec recordVec;
					dropTab->queryRecords(0,crArgumentParser::appItoa(id),recordVec);
					if(!recordVec.empty())
					{
						//参考crJXJServerOpenTreasureChestMethod
						int dropcountid = dropTab->getTitleIndex("掉落种数");
						int droptypeid = dropTab->getTitleIndex("掉落类型");
						int dropidindex = dropTab->getTitleIndex("dropid");
						int oddsid = dropTab->getTitleIndex("掉落几率");
						int countid = dropTab->getTitleIndex("数量");
						int dropcount = atoi(recordVec[0][dropcountid].c_str());
						//crData *userData = playerData->getPlayerGameData()->getDataClass();
						//userData->excHandle(MAKEINT64(WCH_LockData,1));
						//int packetRemainSize = 0;
						int odds = 0;
						//bool isdroped;
						unsigned char droptype;
						int count;
						crVector2i countrange;
						CRCore::rangei counrnd;
						//RewardItemVec rewarditemvec;
						//ref_ptr<crBagItemData> itemdata;
						std::vector<std::pair<int,int> > DropedResVec;//resid,count
						std::vector<std::pair<unsigned short,int> > DropedEquipVec;//equipid,count
						std::vector<crVector3i> DropedItemVec;//itemid,equipmagic,count
						//crRole *mainRole = playerData->getPlayerGameData()->getMainRole();
						int recordCount = recordVec.size();
						std::vector< std::pair<int,int> >DroprndVec;
						int i,j,k;
						int dropodds;
						for (i = 0; i < recordCount; i++)
						{
							dropodds = atoi(recordVec[i][oddsid].c_str());
							odds += dropodds;
							DroprndVec.push_back(std::make_pair(odds,dropodds));
						}
						crVector2i vec2;
						rangei rndi(0,odds);
						int r;
						for(i = 0; i<dropcount;i++)
						{
							r = rndi.get_random();
							for(j = 0; j<recordCount; j++)
							{
								if(r<=DroprndVec[j].first)
								{//该物品掉出
									DroprndVec[j].first = -1;
									odds -= DroprndVec[j].second;
									rndi.set(0,odds);
									for (k = j+1; k < recordCount; k++)
									{
										DroprndVec[k].first -= DroprndVec[j].second;
									}
									droptype = atoi(recordVec[j][droptypeid].c_str());

									crArgumentParser::appAtoVec(recordVec[j][countid],countrange);
									counrnd.set(countrange[0],countrange[1]);
									count = counrnd.get_random();
									if(count>0)
									{
										droptype = atoi(recordVec[j][droptypeid].c_str());
										switch (droptype)
										{
										case T_Food:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJFood,count));
											break;
										case T_Wood:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJWood,count));
											break;
										case T_Iron:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJIron,count));
											break;
										case T_Horse:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJHorse,count));
											break;
										case T_Copper:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJCoppercash,count));
											break;
										case T_Exp:
											DropedResVec.push_back(std::make_pair(WCHDATA_Experience,count));
											break;
										case T_Achievement:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJAchievement,count));
											break;
										case T_Giftgold:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJGiftGold,count));
											break;
										case T_TroopsEquip:
											DropedEquipVec.push_back(std::make_pair(atoi(recordVec[j][dropidindex].c_str()),count));
											break;
										case T_Item:
											{
												crArgumentParser::appAtoVec(recordVec[j][dropidindex],vec2);
												DropedItemVec.push_back(crVector3i(vec2[0],vec2[1],count));
											}
											break;
										}
									}
									break;
								}
							}
						}
						//写入包发给服务器 客户端
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						//ref_ptr<crStreamBuf> gameServer_stream = new crStreamBuf;
						//写掉落信息
						int ressize = DropedResVec.size();
						int equipsize = DropedEquipVec.size();
						int itemsize = DropedItemVec.size();
						stream->createBuf(7+ressize*8+itemsize*9+equipsize*6);
						//gameServer_stream->createBuf(7+(ressize+itemsize)*8+equipsize*6);
						stream->_writeInt(0);//playerid
						stream->_writeUChar(ressize);
						//gameServer_stream->_writeUChar(ressize);
						for( std::vector<std::pair<int,int> >::iterator itr = DropedResVec.begin();
							itr != DropedResVec.end();
							++itr )
						{
							stream->_writeInt(itr->first);
							stream->_writeInt(itr->second);
							//gameServer_stream->_writeInt(itr->first);
							//gameServer_stream->_writeInt(itr->second);
						}
						stream->_writeUChar(equipsize);
						//gameServer_stream->_writeUChar(equipsize);
						for( std::vector<std::pair<unsigned short,int> >::iterator itr = DropedEquipVec.begin();
							itr != DropedEquipVec.end();
							++itr )
						{
							stream->_writeUShort(itr->first);
							stream->_writeInt(itr->second);
							//gameServer_stream->_writeUShort(itr->first);
							//gameServer_stream->_writeInt(itr->second);
						}
						stream->_writeUChar(itemsize);
						//gameServer_stream->_writeUChar(itemsize);
						for( std::vector<crVector3i>::iterator itr = DropedItemVec.begin();
							itr != DropedItemVec.end();
							++itr )
						{
							stream->_writeInt((*itr)[0]);
							stream->_writeInt((*itr)[1]);//equipmagic
							stream->_writeUChar((*itr)[2]);
							//gameServer_stream->_writeInt((*itr)[0]);
							//gameServer_stream->_writeUShort((*itr)[1]);equipmagic
							//gameServer_stream->_writeUChar((*itr)[2]);
						}

						//服务器
						crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
						crJXJDropedItemPacket packet;
						crJXJDropedItemPacket::buildRequestPacket(packet,stream.get());

						m_this->lockPlayerList();
						crRoom::PlayerList &playerList = m_this->getPlayerList();
						if(!playerList.empty())
						{
							crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer);
							crNetDataManager *netDataManager = sceneServer->getNetDataManager();
							ref_ptr<crStreamBuf> packetStream = packet.getStreamBuf();
							int bufsize = packetStream->getBufSize();
							int playerid;
							ref_ptr<crSceneServerPlayerData> playerData;
							crRoomPlayer *roomPlayer;
							for( crRoom::PlayerList::iterator itr = playerList.begin();
								itr != playerList.end();
								++itr )
							{
								roomPlayer = itr->get();
								if(roomPlayer->getGroupID() == camp)
								{
									playerid = roomPlayer->getPlayerID();
									playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
									if(playerData.valid()/* && playerData->isClientRunning() && roomPlayer->getReady() && playerData->getRoomID() == m_roomid*/)
									{
										packetStream->seekBegin();
										packetStream->_writeInt(playerid);
										packetStream->setBufSize(bufsize);
										netConductor->getNetManager()->sendPacket("all",packet);//发送到GameServer
									}
								}
							}
						}
						m_this->unlockPlayerList();
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRoomItemDrop2Method
//
/////////////////////////////////////////
crJXJRoomItemDrop2Method::crJXJRoomItemDrop2Method():
	m_this(NULL),
	m_dropitemid(0),
	m_camp(0){}
crJXJRoomItemDrop2Method::crJXJRoomItemDrop2Method(const crJXJRoomItemDrop2Method& handle):
	crMethod(handle),
	m_dropitemid(handle.m_dropitemid),
	m_camp(handle.m_camp)
{
}
void crJXJRoomItemDrop2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void crJXJRoomItemDrop2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_dropitemid = atoi(str.c_str());
		break;
	case 1:
		m_camp = (unsigned char)(atoi(str.c_str()));
		break;
	}
}

void crJXJRoomItemDrop2Method::operator()(crHandle &handle)
{
	if(m_dropitemid>0)
	{
		//场景掉落
		ref_ptr<crTableIO> dropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSceneItemDrop2Tab);;
		if(dropTab.valid())
		{
			crTableIO::DataVec recordVec;
			dropTab->queryRecords(0,crArgumentParser::appItoa(m_dropitemid),recordVec);
			if(!recordVec.empty())
			{
				//参考crJXJServerOpenTreasureChestMethod
				int dropcountid = dropTab->getTitleIndex("掉落种数");
				int droptypeid = dropTab->getTitleIndex("掉落类型");
				int dropidindex = dropTab->getTitleIndex("dropid");
				int oddsid = dropTab->getTitleIndex("掉落几率");
				int countid = dropTab->getTitleIndex("数量");
				int dropcount = atoi(recordVec[0][dropcountid].c_str());
				//crData *userData = playerData->getPlayerGameData()->getDataClass();
				//userData->excHandle(MAKEINT64(WCH_LockData,1));
				//int packetRemainSize = 0;
				int odds = 0;
				//bool isdroped;
				unsigned char droptype;
				int count;
				crVector2i countrange;
				CRCore::rangei counrnd;
				//RewardItemVec rewarditemvec;
				//ref_ptr<crBagItemData> itemdata;
				std::vector<std::pair<int,int> > DropedResVec;//resid,count
				std::vector<std::pair<unsigned short,int> > DropedEquipVec;//equipid,count
				std::vector<crVector3i> DropedItemVec;//itemid,equipmagic,count
				//crRole *mainRole = playerData->getPlayerGameData()->getMainRole();
				int recordCount = recordVec.size();
				std::vector< std::pair<int,int> >DroprndVec;
				int i,j,k;
				int dropodds;
				for (i = 0; i < recordCount; i++)
				{
					dropodds = atoi(recordVec[i][oddsid].c_str());
					odds += dropodds;
					DroprndVec.push_back(std::make_pair(odds,dropodds));
				}
				crVector2i vec2;
				rangei rndi(0,odds);
				int r;
				for(i = 0; i<dropcount;i++)
				{
					r = rndi.get_random();
					for(j = 0; j<recordCount; j++)
					{
						if(r<=DroprndVec[j].first)
						{//该物品掉出
							DroprndVec[j].first = -1;
							odds -= DroprndVec[j].second;
							rndi.set(0,odds);
							for (k = j+1; k < recordCount; k++)
							{
								DroprndVec[k].first -= DroprndVec[j].second;
							}
							droptype = atoi(recordVec[j][droptypeid].c_str());

							crArgumentParser::appAtoVec(recordVec[j][countid],countrange);
							counrnd.set(countrange[0],countrange[1]);
							count = counrnd.get_random();
							if(count>0)
							{
								droptype = atoi(recordVec[j][droptypeid].c_str());
								switch (droptype)
								{
								case T_Food:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJFood,count));
									break;
								case T_Wood:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJWood,count));
									break;
								case T_Iron:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJIron,count));
									break;
								case T_Horse:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJHorse,count));
									break;
								case T_Copper:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJCoppercash,count));
									break;
								case T_Exp:
									DropedResVec.push_back(std::make_pair(WCHDATA_Experience,count));
									break;
								case T_Achievement:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJAchievement,count));
									break;
								case T_Giftgold:
									DropedResVec.push_back(std::make_pair(WCHDATA_JXJGiftGold,count));
									break;
								case T_TroopsEquip:
									DropedEquipVec.push_back(std::make_pair(atoi(recordVec[j][dropidindex].c_str()),count));
									break;
								case T_Item:
									{
										crArgumentParser::appAtoVec(recordVec[j][dropidindex],vec2);
										DropedItemVec.push_back(crVector3i(vec2[0],vec2[1],count));
									}
									break;
								}
							}
							break;
						}
					}
				}
				//写入包发给服务器 客户端
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//ref_ptr<crStreamBuf> gameServer_stream = new crStreamBuf;
				//写掉落信息
				int ressize = DropedResVec.size();
				int equipsize = DropedEquipVec.size();
				int itemsize = DropedItemVec.size();
				stream->createBuf(7+ressize*8+itemsize*9+equipsize*6);
				//gameServer_stream->createBuf(7+(ressize+itemsize)*8+equipsize*6);
				stream->_writeInt(0);//playerid
				stream->_writeUChar(ressize);
				//gameServer_stream->_writeUChar(ressize);
				for( std::vector<std::pair<int,int> >::iterator itr = DropedResVec.begin();
					itr != DropedResVec.end();
					++itr )
				{
					stream->_writeInt(itr->first);
					stream->_writeInt(itr->second);
					//gameServer_stream->_writeInt(itr->first);
					//gameServer_stream->_writeInt(itr->second);
				}
				stream->_writeUChar(equipsize);
				//gameServer_stream->_writeUChar(equipsize);
				for( std::vector<std::pair<unsigned short,int> >::iterator itr = DropedEquipVec.begin();
					itr != DropedEquipVec.end();
					++itr )
				{
					stream->_writeUShort(itr->first);
					stream->_writeInt(itr->second);
					//gameServer_stream->_writeUShort(itr->first);
					//gameServer_stream->_writeInt(itr->second);
				}
				stream->_writeUChar(itemsize);
				//gameServer_stream->_writeUChar(itemsize);
				for( std::vector<crVector3i>::iterator itr = DropedItemVec.begin();
					itr != DropedItemVec.end();
					++itr )
				{
					stream->_writeInt((*itr)[0]);
					stream->_writeInt((*itr)[1]);//equipmagic
					stream->_writeUChar((*itr)[2]);
					//gameServer_stream->_writeInt((*itr)[0]);
					//gameServer_stream->_writeUShort((*itr)[1]);equipmagic
					//gameServer_stream->_writeUChar((*itr)[2]);
				}

				//服务器
				crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
				crJXJDropedItemPacket packet;
				crJXJDropedItemPacket::buildRequestPacket(packet,stream.get());

				m_this->lockPlayerList();
				crRoom::PlayerList &playerList = m_this->getPlayerList();
				if(!playerList.empty())
				{
					crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(SceneServer);
					crNetDataManager *netDataManager = sceneServer->getNetDataManager();
					ref_ptr<crStreamBuf> packetStream = packet.getStreamBuf();
					int bufsize = packetStream->getBufSize();
					int playerid;
					ref_ptr<crSceneServerPlayerData> playerData;
					crRoomPlayer *roomPlayer;
					for( crRoom::PlayerList::iterator itr = playerList.begin();
						itr != playerList.end();
						++itr )
					{
						roomPlayer = itr->get();
						if(m_camp == 0 || roomPlayer->getGroupID() == m_camp)
						{
							playerid = roomPlayer->getPlayerID();
							playerData = dynamic_cast<crSceneServerPlayerData *>(netDataManager->getPlayerData(playerid));
							if(playerData.valid()/* && playerData->isClientRunning() && roomPlayer->getReady() && playerData->getRoomID() == m_roomid*/)
							{
								packetStream->seekBegin();
								packetStream->_writeInt(playerid);
								packetStream->setBufSize(bufsize);
								netConductor->getNetManager()->sendPacket("all",packet);//发送到GameServer
							}
						}
					}
				}
				m_this->unlockPlayerList();
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSendItemposSignalToPlayerMethod
//
/////////////////////////////////////////
crJXJSendItemposSignalToPlayerMethod::crJXJSendItemposSignalToPlayerMethod():
	m_this(NULL),
	m_itemid(0),
	m_camp(0){}
crJXJSendItemposSignalToPlayerMethod::crJXJSendItemposSignalToPlayerMethod(const crJXJSendItemposSignalToPlayerMethod& handle):
	crMethod(handle),
	m_itemid(handle.m_itemid),
	m_camp(handle.m_camp)
{
}
void crJXJSendItemposSignalToPlayerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void crJXJSendItemposSignalToPlayerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	case 1:
		m_camp = (unsigned char)(atoi(str.c_str()));
		break;
	}
}

void crJXJSendItemposSignalToPlayerMethod::operator()(crHandle &handle)
{
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crInstanceItem> item = scene->findRoomItem(m_this->getRoomID(),m_itemid);
		if(item.valid())
		{
			crData *data = item->getDataClass();
			void *param;
			data->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char *)param;
			if(itemstate != IS_Dead)
			{
				ref_ptr<crStreamBuf> posStream = new crStreamBuf;
				posStream->createBuf(13);
				posStream->_writeVec3(item->getPosition());//4*3
				posStream->_writeUChar(Signal_ItemPos);
				ref_ptr<crPlayerDataSceneEventPacket> packet = new crPlayerDataSceneEventPacket;
				crPlayerDataSceneEventPacket::buildReplyPacket(*packet,0,WCH_JXJRecvSignalsPos,posStream.get());
				m_this->sendRoomMessage(packet.get(), m_camp);
				//if(m_camp == 0)
				//{//send
				//	m_this->sendRoomMessage(packet.get(),m_camp);
				//}
				//else
				//{
				//	m_this->sendPacketToGroup(m_camp,packet);
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetGuiseMethod
//
/////////////////////////////////////////
crJXJSetGuiseMethod::crJXJSetGuiseMethod():
	m_guise(0),
	m_setflg(true){}
crJXJSetGuiseMethod::crJXJSetGuiseMethod(const crJXJSetGuiseMethod& handle):
	crMethod(handle),
	m_guise(handle.m_guise),
	m_setflg(handle.m_setflg)
{
}
void crJXJSetGuiseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJSetGuiseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_guise = 1<<(unsigned int)(atoi(str.c_str()));
		break;
	case 1:
		m_setflg = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJSetGuiseMethod::operator()(crHandle &handle)
{
	void *param;
	crData *thisData = m_this->getDataClass();
	thisData->excHandle(MAKEINT64(WCH_LockData,1));
	thisData->getParam(WCHDATA_GuiseState,param);
	unsigned int* guise = (unsigned int *)param;
	if(guise)
	{
		if(m_setflg)
			*guise |= m_guise;
		else
			*guise &= ~m_guise;
	}
	thisData->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJSetItemStateMethod
//
/////////////////////////////////////////
crJXJSetItemStateMethod::crJXJSetItemStateMethod():
	m_state(2),
	m_rthp(0.0f){}
crJXJSetItemStateMethod::crJXJSetItemStateMethod(const crJXJSetItemStateMethod& handle):
	crMethod(handle),
	m_state(handle.m_state),
	m_rthp(handle.m_rthp)
{
}
void crJXJSetItemStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJSetItemStateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_state = atoi(str.c_str());
		break;
	case 1:
		m_rthp = atof(str.c_str());
		break;
	}
}

void crJXJSetItemStateMethod::operator()(crHandle &handle)
{
	crData *thisData = m_this->getDataClass();
	if(m_rthp>0.0f)
		thisData->inputParam(WCHDATA_RTHP,&m_rthp);
	thisData->inputParam(WCHDATA_ItemState,&m_state);
}
/////////////////////////////////////////
//
//crJXJCheckNpcGuiseMethod
//
/////////////////////////////////////////
crJXJCheckNpcGuiseMethod::crJXJCheckNpcGuiseMethod():
	m_this(NULL),
	m_itemid(0),
	m_guise(0){}
crJXJCheckNpcGuiseMethod::crJXJCheckNpcGuiseMethod(const crJXJCheckNpcGuiseMethod& handle):
	crMethod(handle),
	m_itemid(handle.m_itemid),
	m_guise(handle.m_guise)
{
}
void crJXJCheckNpcGuiseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom *)param;
		break;
	}
}

void crJXJCheckNpcGuiseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	case 1:
		m_guise = 1<<(unsigned int)(atoi(str.c_str()));
		break;
	}
}

void crJXJCheckNpcGuiseMethod::operator()(crHandle &handle)
{
	bool condition = false;
	crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
	crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
	crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
	CRNetApp::crScene *scene = netCallback->findScene(m_this->getSceneID());
	if(scene)
	{
		ref_ptr<crInstanceItem> item = scene->findRoomItem(m_this->getRoomID(),m_itemid);
		if(item.valid())
		{
			unsigned int guisestate = GS_Normal;
			item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
			if(guisestate & m_guise)
				condition = true;
		}
	}
	handle.outputParam(0,&condition);
}

/////////////////////////////////////////
//
//crJXJExtraDropItemMethod
//
/////////////////////////////////////////
crJXJExtraDropItemMethod::crJXJExtraDropItemMethod():
m_abstractid(0),
m_itemtype(0),
m_itemcount(0),
m_interval(5.0f),
m_bufid(0),
m_start(false){}
crJXJExtraDropItemMethod::crJXJExtraDropItemMethod(const crJXJExtraDropItemMethod& handle):
	crMethod(handle),
	m_abstractid(handle.m_abstractid),
	m_itemtype(handle.m_itemtype),
	m_itemcount(handle.m_itemcount),
	m_interval(handle.m_interval),
	m_bufid(handle.m_bufid),
	m_start(false)
{
}
void crJXJExtraDropItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	case WCHDATA_JXJItemUseTargetPos:
		m_itemUseTargetPos = *(crVector3*)param;
		break;
	}
}
void crJXJExtraDropItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_abstractid = atoi(str.c_str());
		break;
	case 1:
		m_itemtype = (unsigned char)(atoi(str.c_str()));
		break;
	case 2:
		m_itemcount = (unsigned short)(atoi(str.c_str()));
		break;
	case 3:
		m_interval = atof(str.c_str());
		break;
	case 4:
		m_bufid = atoi(str.c_str());
		break;
	}
}
void crJXJExtraDropItemMethod::operator()(crHandle &handle)
{
	if(!m_start && m_fireItem.valid() && m_fireItem->getDataClass())
	{
		ref_ptr<crData> fireData = m_fireItem->getDataClass();
		m_start = true;
		///UserExtra
		void *param;
		//fireData->getParam(WCHDATA_TargetPos,param);
		//crVector3 targetPosition = *(crVector3 *)param;
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		int sceneid = m_fireItem->getSceneID();
		int roomid = m_fireItem->getRoomID();
		CRNetApp::crScene *scene = netCallback->findScene(sceneid);

		float scale = crGlobalHandle::gData()->gUnitScale();
		ref_ptr<crAbstractItem> aitem;
		fireData->getParam(WCHDATA_Camp,param);
		unsigned char camp = *(unsigned char*)param;
		int layerid = m_fireItem->getLayerID();

		ref_ptr<crInstanceItem> item = new crInstanceItem;
		item->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
		item->setDropItemTimer(m_interval);
		item->setItemtype(m_itemtype);
		item->setSceneID(sceneid);
		item->setRoomID(roomid);
		item->setLayerID(layerid);
		float zoffset = item->getZoffset() * scale;
		float posz = scene->getPosZ(layerid,m_itemUseTargetPos[0],m_itemUseTargetPos[1],zoffset);
		posz/=scale;
		item->setPosxy(m_itemUseTargetPos[0]/scale,m_itemUseTargetPos[1]/scale);
		item->setPosz(posz);
		crVector3 firepos = m_fireItem->getPosition();
		crVector3 dir = m_itemUseTargetPos - firepos;
		dir[2] = 0.0f;
		dir.normalize();
		item->setDir(dir);
		item->setOwnerID(MAKEINT64(m_fireItem->getID(),m_fireItem->getRoleID()));
		aitem = crGlobalHandle::getInstance()->findAbstractItem(m_abstractid);
		unsigned char npcType = NPC_DropItem;
		if(aitem.valid())
		{
			item->setAbstractItem(aitem.get());
			item->loadItemData(0);
			crData *itemdata = item->getDataClass();
			if(itemdata)
			{
				itemdata->inputParam(WCHDATA_Camp,&camp);
				itemdata->inputParam(WCHDATA_JXJNpcItemType,&npcType);
				itemdata->inputParam(WCHDATA_JXJArmyCount,&m_itemcount);
				itemdata->excHandle(MAKEINT64(WCH_InitData,item.get()));
				item->setSightInfo(m_fireItem->getSightInfo());

				scene->insertSceneItem(item.get());
				scene->itemRelive(item.get());
				if(m_bufid>0)
				{
					item->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_bufid,-1),NULL));
				}
			}
		}
		else
		{
			crNetConductor *gameServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
			crJXJQueryAbstractItemPacket packet;
			crJXJQueryAbstractItemPacket::buildRequestPacket(packet,m_abstractid,item.get(),camp,m_itemcount,m_interval,m_bufid,npcType);
			gameServerConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJExtraPhantomMethod
//
/////////////////////////////////////////
crJXJExtraPhantomMethod::crJXJExtraPhantomMethod():
	m_duration(0.0f),
	m_hpScale(0.5f),
	m_damageScale(0.35f),
	m_count(1),
	m_bufid(0),
	m_start(false){}
crJXJExtraPhantomMethod::crJXJExtraPhantomMethod(const crJXJExtraPhantomMethod& handle):
	crMethod(handle),
	m_duration(handle.m_duration),
	m_hpScale(handle.m_hpScale),
	m_damageScale(handle.m_damageScale),
	m_count(handle.m_count),
	m_bufid(handle.m_bufid),
	m_start(false)
{
}
void crJXJExtraPhantomMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case WCHDATA_FireItem:
		m_fireItem = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraPhantomMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_hpScale = atof(str.c_str());
		break;
	case 2:
		m_damageScale = atof(str.c_str());
		break;
	case 3:
		m_count = atoi(str.c_str());
		break;
	case 4:
		m_bufid = atoi(str.c_str());
		break;
	}
}

void crJXJExtraPhantomMethod::operator()(crHandle &handle)
{
	if(!m_start && m_fireItem.valid() && m_fireItem->getDataClass())
	{
		ref_ptr<crData> fireData = m_fireItem->getDataClass();
		m_start = true;
		//clone
		crNetConductor *sceneServerConductor = crNetContainer::getInstance()->getNetConductor(SceneServer);
		crNetDataManager *netDataManager = sceneServerConductor->getNetDataManager();
		crSceneServerCallback *netCallback = dynamic_cast<crSceneServerCallback *>(netDataManager->getNetCallback());
		int sceneid = m_this->getSceneID();
		CRNetApp::crScene *scene = netCallback->findScene(sceneid);

		//crRole *role = dynamic_cast<crRole *>(m_this);
		//if(!role)
		//{
		void *param;
		fireData->getParam(WCHDATA_Camp,param);
		unsigned char camp = *(unsigned char*)param;
		crData *itemData;
		int hp = 0;
		int attack= 0;
		int rtcount = 0;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJRTArmyCount,param);
		if(param)
			rtcount = *(int *)param;
		thisData->getParam(WCHDATA_HP,param);
		if(param)
		{
			hp = *(int *)param;
			if(m_hpScale!=1.0f)
			{
				hp = (int)((float)(hp) * m_hpScale + 0.5f);
			}
		}
		thisData->getParam(WCHDATA_Attack,param);
		if(param)
		{
			attack = *(int *)param;
			if(m_damageScale!=1.0f)
			{
				attack = (int)((float)(attack) * m_damageScale + 0.5f);
			}
		}
		ref_ptr<crInstanceItem> phantom;
		ref_ptr<crRole> rolephantom;
		unsigned char npcType = NPC_Phantom;
		_crInt64 ownerid = MAKEINT64(m_fireItem->getID(),m_fireItem->getRoleID());
		for(int i = 0; i<m_count; i++)
		{
			phantom = dynamic_cast<crInstanceItem *>(m_this->clone());
			phantom->setInstanceItemID(crGlobalHandle::gainTemporaryItemID());
			rolephantom = dynamic_cast<crRole *>(phantom.get());
			if(rolephantom.valid())
			{
				rolephantom->setPlayerID(phantom->getInstanceItemID());
			}
			phantom->setDropItemTimer(m_duration);
			phantom->setOwnerID(ownerid);
			itemData = phantom->getDataClass();
			itemData->inputParam(WCHDATA_Camp,&camp);
			itemData->inputParam(WCHDATA_JXJNpcItemType,&npcType);
			phantom->setSightInfo(m_fireItem->getSightInfo());
			phantom->setIName(m_fireItem->getIName());

			itemData->inputParam(WCHDATA_HP,&hp);
			itemData->inputParam(WCHDATA_Attack,&attack);
			itemData->excHandle(MAKEINT64(WCH_InitData,phantom.get()));
			itemData->inputParam(WCHDATA_JXJRTArmyCount,&rtcount);
			scene->insertSceneItem(phantom.get());
			scene->itemRelive(phantom.get());
			if(m_bufid>0)
			{
				phantom->doEvent(WCH_ExtraHandle,MAKEINT64(MAKEINT32(m_bufid,-1),NULL));
			}
		}
		//}
		//else
		//{//创建一个同名NPC

		//}
	}
}


/////////////////////////////////////////
//
//crJXJIsGainExtraMethod
//
/////////////////////////////////////////
crJXJIsGainExtraMethod::crJXJIsGainExtraMethod():
	m_type(0){}
crJXJIsGainExtraMethod::crJXJIsGainExtraMethod(const crJXJIsGainExtraMethod& handle):
	crMethod(handle),
	m_type(handle.m_type),
	m_idvec(handle.m_idvec)
{
}
void crJXJIsGainExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJIsGainExtraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = atoi(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_idvec);
		break;
	}
}
void crJXJIsGainExtraMethod::operator()(crHandle &handle)
{
	bool yes = false;
	if(m_hitParam.valid())
	{
		ref_ptr<crInstanceItem> item = m_type == 0?m_hitParam->m_fireItem:m_hitParam->m_hitItem;
		if(item.valid() && item->getDataClass())
		{
			void *param;
			crData *itemdata = item->getDataClass();
			itemdata->getParam(WCHDATA_ExtraData,param);
			crData *extraData = (crData *)param;
			if(extraData)
			{
				crHandle *existHandle = NULL;
				for( std::vector<int>::iterator itr = m_idvec.begin();
					itr != m_idvec.end();
					++itr )
				{
					existHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,*itr));
					if(existHandle)
					{
						yes = true;
						break;
					}
				}
			}
		}
	}
	handle.outputParam(0,&yes);
}
/////////////////////////////////////////
//
//crJXJExtraIsGainExtraMethod
//
/////////////////////////////////////////
crJXJExtraIsGainExtraMethod::crJXJExtraIsGainExtraMethod(){}
crJXJExtraIsGainExtraMethod::crJXJExtraIsGainExtraMethod(const crJXJExtraIsGainExtraMethod& handle):
	crMethod(handle),
	m_idvec(handle.m_idvec)
{
}
void crJXJExtraIsGainExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJExtraIsGainExtraMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_idvec);
		break;
	}
}
void crJXJExtraIsGainExtraMethod::operator()(crHandle &handle)
{
	bool yes = false;
	void *param;
	crData *itemdata = m_this->getDataClass();
	itemdata->getParam(WCHDATA_ExtraData,param);
	crData *extraData = (crData *)param;
	if(extraData)
	{
		crHandle *existHandle = NULL;
		for( std::vector<int>::iterator itr = m_idvec.begin();
			itr != m_idvec.end();
			++itr )
		{
			existHandle = extraData->getHandle(MAKEINT64(WCH_DoExtra,*itr));
			if(existHandle)
			{
				yes = true;
				break;
			}
		}
	}
	handle.outputParam(0,&yes);
}
/////////////////////////////////////////
//
//crJXJInCritTestMethod
//
/////////////////////////////////////////
crJXJInCritTestMethod::crJXJInCritTestMethod():
m_type(0){}
crJXJInCritTestMethod::crJXJInCritTestMethod(const crJXJInCritTestMethod& handle):
	crMethod(handle),
	m_type(handle.m_type)
{
}
void crJXJInCritTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_hitParam = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJInCritTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = atoi(str.c_str());
		break;
	}
}
void crJXJInCritTestMethod::operator()(crHandle &handle)
{
	void * param;
	bool cancelTask = true;
	if(m_hitParam.valid())
	{
		ref_ptr<crInstanceItem> item = m_type == 0?m_hitParam->m_fireItem:m_hitParam->m_hitItem;
		if(item.valid() && item->getDataClass())
		{
			crData *itemdata = item->getDataClass();
			itemdata->getParam(WCHDATA_IsCrit,param);
			bool isCrit = *(bool *)param;
			if(isCrit)
			{
				cancelTask = false;
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJInDodgeTestMethod
//
/////////////////////////////////////////
crJXJInDodgeTestMethod::crJXJInDodgeTestMethod():
	m_type(0){}
crJXJInDodgeTestMethod::crJXJInDodgeTestMethod(const crJXJInDodgeTestMethod& handle):
	crMethod(handle),
	m_type(handle.m_type)
{
}
void crJXJInDodgeTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_hitParam = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJInDodgeTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = atoi(str.c_str());
		break;
	}
}
void crJXJInDodgeTestMethod::operator()(crHandle &handle)
{
	void * param;
	bool cancelTask = true;
	if(m_hitParam.valid())
	{
		ref_ptr<crInstanceItem> item = m_type == 0?m_hitParam->m_fireItem:m_hitParam->m_hitItem;
		if(item.valid() && item->getDataClass())
		{
			crData *itemdata = item->getDataClass();
			itemdata->getParam(WCHDATA_IsDodge,param);
			bool isDodge = *(bool *)param;
			if(isDodge)
			{
				cancelTask = false;
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJInParryTestMethod
//
/////////////////////////////////////////
crJXJInParryTestMethod::crJXJInParryTestMethod():
	m_type(0){}
crJXJInParryTestMethod::crJXJInParryTestMethod(const crJXJInParryTestMethod& handle):
	crMethod(handle),
	m_type(handle.m_type)
{
}
void crJXJInParryTestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_hitParam = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_hitParam = (HitParam *)(LOINT64(param64));
		}
		else
		{
			m_hitParam = NULL;
		}
		break;
	}
}
void crJXJInParryTestMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = atoi(str.c_str());
		break;
	}
}
void crJXJInParryTestMethod::operator()(crHandle &handle)
{
	void * param;
	bool cancelTask = true;
	if(m_hitParam.valid())
	{
		ref_ptr<crInstanceItem> item = m_type == 0?m_hitParam->m_fireItem:m_hitParam->m_hitItem;
		if(item.valid() && item->getDataClass())
		{
			crData *itemdata = item->getDataClass();
			itemdata->getParam(WCHDATA_IsParry,param);
			bool isParry = *(bool *)param;
			if(isParry)
			{
				cancelTask = false;
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJIsMyRoleAllDeadMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJIsMyRoleAllDeadMethod::crJXJIsMyRoleAllDeadMethod(){}
crJXJIsMyRoleAllDeadMethod::crJXJIsMyRoleAllDeadMethod(const crJXJIsMyRoleAllDeadMethod& handle):
	crMethod(handle)
{
}
void crJXJIsMyRoleAllDeadMethod::inputParam(int i, void *param)
{
}
void crJXJIsMyRoleAllDeadMethod::addParam(int i, const std::string& str)
{
}
void crJXJIsMyRoleAllDeadMethod::operator ()(crHandle &handle)
{
	bool isalldead = false;
	if(crRunGameHandle::getInstance()->isInGame())
	{
		isalldead = true;
		crMyPlayerData *me = crMyPlayerData::getInstance();
		ref_ptr<crRole> role;
		void *param;
		unsigned char itemstate;
		crData *data;
		for(int i = 0;i<3;i++)
		{
			role = me->getLoadedRoleByIndex(i);
			if(!role)
				continue;
			data = role->getDataClass();
			data->getParam(WCHDATA_ItemState,param);
			itemstate = *(unsigned char *)param;
			if(itemstate != IS_Dead)
			{
				isalldead = false;
				break;
			}
		}
	}
	handle.outputParam(0,&isalldead);
}
/////////////////////////////////////////
//
//crJXJScenarioPlayerCountCheckMethod
//
/////////////////////////////////////////
crJXJScenarioPlayerCountCheckMethod::crJXJScenarioPlayerCountCheckMethod():
	m_value(0),
	m_op(0){}
crJXJScenarioPlayerCountCheckMethod::crJXJScenarioPlayerCountCheckMethod(const crJXJScenarioPlayerCountCheckMethod& handle):
	crMethod(handle),
	m_op(handle.m_op),
	m_value(handle.m_value)
{
}
void crJXJScenarioPlayerCountCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRoom*)param;
		break;
	}
}

void crJXJScenarioPlayerCountCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_op = atoi(str.c_str());
		break;
	case 1:
		m_value = atof(str.c_str());
		break;
	}
}

void crJXJScenarioPlayerCountCheckMethod::operator()(crHandle &handle)
{
	bool success = false;
	int playercount = m_this->getPlayerCount();
	switch (m_op)
	{
	case 1:
		if(playercount == m_value)
			success = true;
		break;
	case 2:
		if(playercount > m_value)
			success = true;
		break;
	case 3:
		if(playercount >= m_value)
			success = true;
		break;
	case 4:
		if(playercount < m_value)
			success = true;
		break;
	case 5:
		if(playercount <= m_value)
			success = true;
		break;
	}
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crJXJExtraCorpseCountMethod
//
/////////////////////////////////////////
crJXJExtraCorpseCountMethod::crJXJExtraCorpseCountMethod():
	m_range(0.0f)
{
}

crJXJExtraCorpseCountMethod::crJXJExtraCorpseCountMethod(const crJXJExtraCorpseCountMethod& handle):
	crMethod(handle),
	m_range(handle.m_range)
{
}

void crJXJExtraCorpseCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraCorpseCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_range = atof(str.c_str());
		break;
	}
}
void crJXJExtraCorpseCountMethod::operator()(crHandle &handle)
{
	short corpseCount = 0;
	crVector3 hitpos = m_this->getPosition();
	crVector3 itempos;
	ref_ptr<crInstanceItem> item;
	unsigned int guisestate = GS_Normal;
	unsigned char itemstate;
	ref_ptr<crData>itemdata;
	void *param;
	if(crGlobalHandle::isClient())
	{
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		crMyPlayerData::getInstance()->lockMyRoleNpcMap();
		crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
		for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
			itr != myRoles.end();
			++itr )
		{
			item = itr->second.first.get();
			itemdata = item->getDataClass();
			if(m_this != item.get() && itemdata.valid())
			{
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
				{
					continue;
				}
				itemdata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
				{
					itempos = item->getPosition();
					if((itempos - hitpos).length() < m_range)
					{
						corpseCount++;
					}
				}
			}
		}
		crMyPlayerData::getInstance()->unlockMyRoleNpcMap();

		crMyPlayerData::getInstance()->lockInRangePlayerMap();
		crMyPlayerData::InRangePlayerMap &playerMap = crMyPlayerData::getInstance()->getInRangePlayerMap();
		for( crMyPlayerData::InRangePlayerMap::iterator itr = playerMap.begin();
			itr != playerMap.end();
			++itr )
		{
			item = itr->second.first.get();
			itemdata = item->getDataClass();
			if(itemdata.valid())
			{
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
				{
					continue;
				}
				itemdata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
				{
					itempos = item->getPosition();
					if((itempos - hitpos).length() < m_range)
					{
						corpseCount++;
					}
				}
			}
		}
		crMyPlayerData::getInstance()->unlockInRangePlayerMap();

		crMyPlayerData::getInstance()->lockInRangeNpcMap();
		crMyPlayerData::InRangeNpcMap &npcMap = crMyPlayerData::getInstance()->getInRangeNpcMap();
		for( crMyPlayerData::InRangeNpcMap::iterator itr = npcMap.begin();
			itr != npcMap.end();
			++itr )
		{
			item = itr->second.first.get();
			itemdata = item->getDataClass();
			if(itemdata.valid())
			{
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
				{
					continue;
				}
				itemdata->getParam(WCHDATA_ItemState,param);
				itemstate = *(unsigned char *)param;
				if(itemstate == IS_Dead)
				{
					itempos = item->getPosition();
					if((itempos - hitpos).length() < m_range)
					{
						corpseCount++;
					}
				}
			}
		}
		crMyPlayerData::getInstance()->unlockInRangeNpcMap();

	}
	else
	{
		ref_ptr<crSightInfo> hitSight = m_this->getSightInfo();
		if(hitSight.valid() && m_range>0.0f)
		{
			hitSight->lockItemEyeMap();
			crSightInfo::ItemEyeMap &itemEyeMap = hitSight->getItemEyeMap();
			for( crSightInfo::ItemEyeMap::iterator itr = itemEyeMap.begin();
				itr != itemEyeMap.end();
				++itr )
			{
				item = itr->second;
				itemdata = item->getDataClass();
				if(m_this != item.get() && itemdata.valid())
				{
					guisestate = GS_Normal;
					item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
					if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
					{
						continue;
					}
					itemdata->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate == IS_Dead)
					{
						itempos = item->getPosition();
						if((itempos - hitpos).length() < m_range)
						{
							corpseCount++;
						}
					}
				}
			}
			hitSight->unlockItemEyeMap();

			ref_ptr<crSceneServerPlayerData> playerdata;
			hitSight->lockPlayerEyeMap();
			crSightInfo::PlayerEyeMap &playerEyeMap = hitSight->getPlayerEyeMap();
			for( crSightInfo::PlayerEyeMap::iterator itr = playerEyeMap.begin();
				itr != playerEyeMap.end();
				++itr )
			{
				playerdata = itr->second;
				crSceneServerPlayerData::RoleMap &roleMap = playerdata->getRoleMap();
				for( crSceneServerPlayerData::RoleMap::iterator ritr = roleMap.begin();
					ritr != roleMap.end();
					++ritr )
				{
					item = dynamic_cast<crInstanceItem *>(ritr->second.get());
					itemdata = item->getDataClass();
					if(m_this != item.get() && itemdata.valid())
					{
						guisestate = GS_Normal;
						item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
						if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
						{
							continue;
						}
						itemdata->getParam(WCHDATA_ItemState,param);
						itemstate = *(unsigned char *)param;
						if(itemstate == IS_Dead)
						{
							itempos = item->getPosition();
							if((itempos - hitpos).length() < m_range)
							{
								corpseCount++;
							}
						}
					}
				}
			}
			hitSight->unlockPlayerEyeMap();

			hitSight->lockInSightItemMap();
			crSightInfo::ItemMap &itemMap = hitSight->getInSightItemMap();
			for( crSightInfo::ItemMap::iterator itr = itemMap.begin();
				itr != itemMap.end();
				++itr )
			{
				item = itr->second;
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
				{
					continue;
				}

				itemdata = item->getDataClass();
				if(itemdata.valid())
				{
					itemdata->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate == IS_Dead)
					{
						itempos = item->getPosition();
						if((itempos - hitpos).length() < m_range)
						{
							corpseCount++;
						}
					}
				}
			}
			hitSight->unlockInSightItemMap();

			hitSight->lockInSightRolePlayerMap();
			crSightInfo::RolePlayerMap &rolePlayerMap = hitSight->getInSightRolePlayerMap();
			for( crSightInfo::RolePlayerMap::iterator itr = rolePlayerMap.begin();
				itr != rolePlayerMap.end();
				++itr )
			{
				item = dynamic_cast<crInstanceItem*>(itr->second.get());
				guisestate = GS_Normal;
				item->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				if( guisestate & GS_Static || guisestate & GS_StaticUnVisiable || guisestate & GS_StaticNoneBlock || guisestate & GS_UnVisiable )
				{
					continue;
				}

				itemdata = item->getDataClass();
				if(itemdata.valid())
				{
					itemdata->getParam(WCHDATA_ItemState,param);
					itemstate = *(unsigned char *)param;
					if(itemstate == IS_Dead)
					{
						itempos = item->getPosition();
						if((itempos - hitpos).length() < m_range)
						{
							corpseCount++;
						}
					}
				}
			}
			hitSight->unlockInSightRolePlayerMap();
		}
	}
	handle.outputParam(1,&corpseCount);
}
/////////////////////////////////////////
//
//crJXJExtraHpPercentCountMethod
//
/////////////////////////////////////////
crJXJExtraHpPercentCountMethod::crJXJExtraHpPercentCountMethod():
	m_percent(0.0f)
{
}

crJXJExtraHpPercentCountMethod::crJXJExtraHpPercentCountMethod(const crJXJExtraHpPercentCountMethod& handle):
	crMethod(handle),
	m_percent(handle.m_percent)
{
}

void crJXJExtraHpPercentCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraHpPercentCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_percent = atof(str.c_str());
		break;
	}
}
void crJXJExtraHpPercentCountMethod::operator()(crHandle &handle)
{
	short overlapCount = 0;
	void *param;
	crData *itemData = m_this->getDataClass();
	float maxhp = 0.0f;
	m_this->doEvent(MAKEINT64(WCH_GetHP,NULL),MAKEINT64(&maxhp,NULL));
	itemData->getParam(WCHDATA_JXJArmyCount,param);
	/*unsigned short*/int armyCount = *(/*unsigned short*/int *)param;
	maxhp *= (float)armyCount;
	itemData->getParam(WCHDATA_RTHP,param);
	float rthp = *(float*)param;
	float damage = maxhp-rthp;
	if(damage>0.0f)
	{
		damage /= maxhp;
		overlapCount = damage / m_percent;
	}
	handle.outputParam(1,&overlapCount);
}
/////////////////////////////////////////
//
//crJXJExtraIsPlayerMethod
//
/////////////////////////////////////////
crJXJExtraIsPlayerMethod::crJXJExtraIsPlayerMethod()
{
}

crJXJExtraIsPlayerMethod::crJXJExtraIsPlayerMethod(const crJXJExtraIsPlayerMethod& handle):
	crMethod(handle)
{
}

void crJXJExtraIsPlayerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraIsPlayerMethod::addParam(int i, const std::string& str)
{
}
void crJXJExtraIsPlayerMethod::operator()(crHandle &handle)
{
	bool isplayer = m_this->getRoleID()>0;
	handle.outputParam(0,&isplayer);
}

/////////////////////////////////////////
//
//crJXJExtraHiddenMethod
//
/////////////////////////////////////////
crJXJExtraHiddenMethod::crJXJExtraHiddenMethod():
	m_dt(NULL),
	m_duration(0.0f),
	m_extraValue(0.0f),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f){}
crJXJExtraHiddenMethod::crJXJExtraHiddenMethod(const crJXJExtraHiddenMethod& handle):
	crMethod(handle),
	m_dt(NULL),
	m_duration(handle.m_duration),
	m_extraValue(handle.m_extraValue),
	m_start(false),
	m_timer(0.0f),
	m_dtrec(0.0f)
{
}
void crJXJExtraHiddenMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float*)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJExtraHiddenMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_duration = atof(str.c_str());
		break;
	case 1:
		m_extraValue = atof(str.c_str());
		break;
	}
}

void crJXJExtraHiddenMethod::operator()(crHandle &handle)
{
	bool ishidden = false;
	if(!m_start)
	{
		m_start = true;
		m_timer = m_duration;
		m_dtrec = 0.0f;
	}
	if(m_timer>=0.0f)
	{
		if(m_duration>0.0f) m_timer -= *m_dt;
		do 
		{
			crData *thisData = m_this->getDataClass();
			void *param;
			thisData->getParam(WCHDATA_ItemState,param);
			unsigned char itemstate = *(unsigned char *)param;
			if(itemstate == IS_UseItem)
			{
				m_dtrec = -1.0f;
				break;
			}
			crVector3 pos = m_this->getPosition();
			if((m_lastposition - pos).length()>1.0f)
			{
				m_lastposition = pos;
				m_dtrec = 0.0f;
				break;
			}
			m_dtrec += *m_dt;
			if(m_dtrec>m_extraValue)
			{//进入潜伏状态
				ishidden = true;
			}
		} while (0);
	}
	handle.outputParam(0,&ishidden);
}
/////////////////////////////////////////
//
//crJXJDebugInfoMethod
//
/////////////////////////////////////////
crJXJDebugInfoMethod::crJXJDebugInfoMethod(){}
crJXJDebugInfoMethod::crJXJDebugInfoMethod(const crJXJDebugInfoMethod& handle):
	crMethod(handle),
	m_str(handle.m_str)
{
}
void crJXJDebugInfoMethod::inputParam(int i, void *param)
{
}

void crJXJDebugInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_str = str;
		break;
	}
}

void crJXJDebugInfoMethod::operator()(crHandle &handle)
{
	time_t t = time(0);
	char tmp[20];
	strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S\0", localtime(&t));
	CRCore::notify(CRCore::ALWAYS) << tmp<<" "<< m_str << std::endl;
}
/////////////////////////////////////////
//
//crJXJExtraDamageCheckMethod
//
/////////////////////////////////////////
crJXJExtraDamageCheckMethod::crJXJExtraDamageCheckMethod() :
m_rthp(0.0f),
m_damageValue(0.0f){}
crJXJExtraDamageCheckMethod::crJXJExtraDamageCheckMethod(const crJXJExtraDamageCheckMethod& handle) :
crMethod(handle),
m_rthp(handle.m_rthp),
m_damageValue(handle.m_damageValue)
{
}
void crJXJExtraDamageCheckMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}

void crJXJExtraDamageCheckMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_damageValue = atof(str.c_str());
		break;
	}
}

void crJXJExtraDamageCheckMethod::operator()(crHandle &handle)
{
	bool rtn = false;
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_RTHP, param);
	float rthp = *(float*)param;
	if (m_rthp == 0.0f)
	{
		m_rthp = rthp;
	}
	else if (m_rthp - rthp > m_damageValue)
	{
		rtn = true;
	}
	handle.outputParam(0, &rtn);
}
/////////////////////////////////////////
//
//crJXJExtraCancelMethod
//
/////////////////////////////////////////
crJXJExtraCancelMethod::crJXJExtraCancelMethod() :
m_output(NULL){}
crJXJExtraCancelMethod::crJXJExtraCancelMethod(const crJXJExtraCancelMethod& handle) :
crMethod(handle),
m_output(NULL)
{
}
void crJXJExtraCancelMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 3:
		m_output = (bool*)param;
		break;
	}
}

void crJXJExtraCancelMethod::operator()(crHandle &handle)
{
	*m_output = true;
}