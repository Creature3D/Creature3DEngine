/**********************************************************************
*
*	文件:	   appMethod.cpp
*
*	描述:	   
*
*	作者:	   吴财华
*					
*
**********************************************************************/
#include <rbody/Creature3D/CreBody.h>
#include <JXJ/appMethod.h>
#include <JXJ/appMethod16.h>
#include <JXJ/appDataParam.h>
#include <JXJ/appMsg.h>
#include <JXJ/appPackets.h>
#include <CRUI/crWidgetExtend.h>
#include <CRNetApp/appNetLogic.h>
#include <CRNetApp/appGlobalHandle.h>
#include <CRProducer/crViewer.h>
#include <CRProducer/crSceneHandler.h>
#include <CRUtil/crAcceptGIVisitor.h>
#include <CRDataBase/crDataBaseManager.h>
#include <CRNetApp/appDBUpdate2.h>
#include <CRNetApp/appDBQuery2.h>
#include <CREncapsulation/crGameDices.h>
#include <CREncapsulation/crStartHandler.h>
#include <CRIOManager/crConvertUTF.h>
#include <CRIOManager/crLoadManager.h>
#include <CRCore/crBlockDetectThread.h>
#include <CREncapsulation/crNodeVisitors.h>
#include <CRDownload/crDownload.h>
#include <CRNetApp/appDataLockManager.h>
#include <sstream>
#include <shellapi.h>
using namespace CRCore;
using namespace CRNetApp;
using namespace CRDataBase;
using namespace CRNet;
using namespace CRProducer;
using namespace CRPhysics;
using namespace CREncapsulation;
using namespace CRUtil;
using namespace CRIOManager;
using namespace rbody;
using namespace JXJ;
using namespace CRUI;
using namespace CRDownload;
void getDesstring(std::string &desstr,std::string &param1,std::string &param2,std::string &output)
{
	crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
	int texid = 0;
	int mode = 2;

	noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
	noticeHandle->inputParam(WCHDATA_NoticeString,&desstr);
	noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
	noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
	noticeHandle->inputParam(WCHDATA_NoticeParam2,&param2);
	noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
	crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
}
/////////////////////////////////////////
//
//crJXJUISelectPlayerIconUpdateMethod
//
/////////////////////////////////////////
crJXJUISelectPlayerIconUpdateMethod::crJXJUISelectPlayerIconUpdateMethod()
{
}
crJXJUISelectPlayerIconUpdateMethod::crJXJUISelectPlayerIconUpdateMethod(const crJXJUISelectPlayerIconUpdateMethod& handle):
	crMethod(handle),
	m_playerIconRadioGroup(handle.m_playerIconRadioGroup),
	m_iconimagebox(handle.m_iconimagebox),
	m_sexradio(handle.m_sexradio)
{
}
void crJXJUISelectPlayerIconUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUISelectPlayerIconUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_playerIconRadioGroup = str;
		break;
	case 1:
		m_iconimagebox = str;
		break;
	case 2:
		m_sexradio = str;
		break;
	}
}
void crJXJUISelectPlayerIconUpdateMethod::operator()(crHandle &handle)
{
	if(crDisplaySettings::instance()->getRunMode()>0)
	{
		crRadioGroupWidgetNode *playerIconRadioGroupWidget = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_playerIconRadioGroup));
		crRadioGroupWidgetNode *sexradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_sexradio));
		crImageBoxWidgetNode *iconImageBox = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_iconimagebox));
		ref_ptr<crTableIO>playerIconTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
		crData *data = crBrain::getInstance()->getDataClass();
		void *param;
		int sexindex = 0;
		if (sexradio)
		{
			sexindex = sexradio->getSelect();
		}
		if(playerIconTab.valid())
		{
			int rowCount = playerIconTab->getRowCount();
			int iconindex = playerIconTab->getTitleIndex("icon大灰");
			int iconindex2 = playerIconTab->getTitleIndex("icon大");
			int payindex = playerIconTab->getTitleIndex("是否付费道具");
			data->getParam(WCHDATA_JXJCurPlayerIconID,param);
			int curPlayerIconID = *(int *)param;

			crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass()-> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int maleIconCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaleIconCount,viplv).c_str());
			bool sex = curPlayerIconID >= maleIconCount;//false表示男性
			if (!sex)//男性
			{
				if (sexindex != 0)
				{
					curPlayerIconID = maleIconCount;
					data->inputParam(WCHDATA_JXJCurPlayerIconID,&curPlayerIconID);
				}
			}
			else //女性
			{
				if (sexindex == 0)
				{
					curPlayerIconID = 0;
					data->inputParam(WCHDATA_JXJCurPlayerIconID,&curPlayerIconID);
				}
			}
			int id = curPlayerIconID;
			std::string iconfile1,iconfile2,iconfile3;
			crRadioGroupWidgetNode::RadioGroup &radioGroup = playerIconRadioGroupWidget->getRadioGroup();
			crMultiSwitch *radioButton0/*,*radioButton1*/;
			crStateSet *ss1/*,*ss2*/;
			crTexture2D *tex2d;
			unsigned int cursel = playerIconRadioGroupWidget->getSelect();

			if ((cursel + curPlayerIconID) >= rowCount)
			{
				cursel = 0;
				playerIconRadioGroupWidget->select(cursel);
			}
			int i = 0;
			int radiocount = radioGroup.size()/* * 0.5f*/;
			//if (iconImageBox)
			//{
			//	iconImageBox->setVisiable(true);
			//	iconfile3 = (*playerIconTab)(cursel + curPlayerIconID,iconindex2);
			//	iconImageBox->setImageName(iconfile3);
			//}
			int iconmaxcount = 0;
			if (!sex)
			{
				iconmaxcount = maleIconCount;
			}
			else
			{
				iconmaxcount = playerIconTab->getRowCount();
			}
			for( ; i<radiocount; i++,id++ )
			{
				if(atoi((*playerIconTab)(id,payindex).c_str()) > 0)
				{
					break;
				}

				radioButton0 = radioGroup[i].second->getButton();
				//radioButton1 = radioGroup[radiocount+i].second->getButton();
				if (id < iconmaxcount)
				{
					iconfile1 = (*playerIconTab)(id,iconindex);
				}
				else
				{
					break;
				}

				//if (id+maleIconCount<playerIconTab->getRowCount())
				//{
				//	iconfile2 = (*playerIconTab)(id+maleIconCount,iconindex);
				//}
				radioButton0->setVisiable(true);
//				radioButton1->setVisiable(true);
				ss1 = dynamic_cast<crObject *>(radioButton0->getChild(0))->getDrawable(0)->getStateSet();
				//ss2 = dynamic_cast<crObject *>(radioButton1->getChild(0))->getDrawable(0)->getStateSet();

				tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
				if(tex2d)
				{
					if(tex2d->getImageNameID().compare(iconfile1)!=0)
						tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				}
				else
				{
					tex2d = new crTexture2D;
					tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
					tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
					tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
					ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				}
				//tex2d = dynamic_cast<crTexture2D *>(ss2->getTextureAttribute(0,crStateAttribute::TEXTURE));
				//if(tex2d)
				//{
				//	if(tex2d->getImageNameID().compare(iconfile2)!=0)
				//		tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile2,tex2d));
				//}
				//else
				//{
				//	tex2d = new crTexture2D;
				//	tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
				//	tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
				//	tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
				//	tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
				//	tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
				//	tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile2,tex2d));
				//	ss2->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				//}

				//if(id+1<maleIconCount) 
				//	id++;
				//else
				//{
				//	if(cursel>i+radiocount)
				//		playerIconRadioGroupWidget->select(i+radiocount);
				//	else if(cursel<halfCount && cursel>i)
				//		playerIconRadioGroupWidget->select(i);
				//	break;
				//}
			}
			//i++;
			for( ;i<radiocount;++i )
			{
				radioButton0 = radioGroup[i].second->getButton();
			//	radioButton1 = radioGroup[radiocount+i].second->getButton();
				radioButton0->setVisiable(false);
			//	radioButton1->setVisiable(false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISelectIconSexChangeMethod
//
/////////////////////////////////////////
crJXJUISelectIconSexChangeMethod::crJXJUISelectIconSexChangeMethod():
	m_sex(0)
{
}
crJXJUISelectIconSexChangeMethod::crJXJUISelectIconSexChangeMethod(const crJXJUISelectIconSexChangeMethod& handle):
	crMethod(handle),
	m_sex(handle.m_sex)
{
}
void crJXJUISelectIconSexChangeMethod::inputParam(int i, void *param)
{
}
void crJXJUISelectIconSexChangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sex = (bool)(atoi(str.c_str()));
		break;
	}
}
void crJXJUISelectIconSexChangeMethod::operator()(crHandle &handle)
{
	//void *param;
	//crData *data = crBrain::getInstance()->getDataClass();
	//data->getParam(WCHDATA_JXJCurPlayerIconID,param);
	//int* curPlayerIconID = (int *)param;
	//int maleIconCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaleIconCount).c_str());
	//bool sex = *curPlayerIconID >= maleIconCount;//false表示男性
	//if(sex != m_sex)
	//{
	//	*curPlayerIconID = m_sex?maleIconCount:0;
	//}
}
/////////////////////////////////////////
//
//crJXJUISelectIconWalkMethod
//
/////////////////////////////////////////
crJXJUISelectIconWalkMethod::crJXJUISelectIconWalkMethod():
	m_step(1)
{
}
crJXJUISelectIconWalkMethod::crJXJUISelectIconWalkMethod(const crJXJUISelectIconWalkMethod& handle):
	crMethod(handle),
	m_step(handle.m_step)
{
}
void crJXJUISelectIconWalkMethod::inputParam(int i, void *param)
{
}
void crJXJUISelectIconWalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	}
}
void crJXJUISelectIconWalkMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = crBrain::getInstance()->getDataClass();
	data->getParam(WCHDATA_JXJCurPlayerIconID,param);
	int* curPlayerIconID = (int *)param;
	crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass()-> getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	int maleIconCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaleIconCount,viplv).c_str());
	ref_ptr<crTableIO>table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
	crTableIO::DataVec records;
	int payindex = table->getTitleIndex("是否付费道具");
	std::string str = "0";
	table->queryRecords(payindex,str,records);
	if(table.valid())
	{
		int rowCount = records.size();
		bool sex = *curPlayerIconID >= maleIconCount;//false表示男性
		//*curPlayerIconID += m_step;
		int tryID = *curPlayerIconID + m_step;
		if(!sex)
		{
			if(tryID<0)
				*curPlayerIconID = 0;
			else if(tryID < maleIconCount)
				*curPlayerIconID = tryID;//maleIconCount-1;
		}
		else
		{
			if(tryID<maleIconCount)
				*curPlayerIconID = maleIconCount;
			else if(tryID < rowCount)
				*curPlayerIconID = tryID;
		}
		//if(tryID<0)
		//	*curPlayerIconID = 0;
		//else if(tryID < maleIconCount)
		//	*curPlayerIconID = tryID;//maleIconCount-1;
	}
}
/////////////////////////////////////////
//
//crJXJUISetPlayerIconMethod
//
/////////////////////////////////////////
crJXJUISetPlayerIconMethod::crJXJUISetPlayerIconMethod()
{
}
crJXJUISetPlayerIconMethod::crJXJUISetPlayerIconMethod(const crJXJUISetPlayerIconMethod& handle):
	crMethod(handle),
	m_playerIconRadioGroup(handle.m_playerIconRadioGroup),
	m_nameWidget(handle.m_nameWidget)
{
}
void crJXJUISetPlayerIconMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISetPlayerIconMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_playerIconRadioGroup = str;
		break;
	case 1:
		m_nameWidget = str;
		break;
	}
}
void crJXJUISetPlayerIconMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	crEditWidgetNode *nameEditWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_nameWidget));
	std::string name = nameEditWidget->getUTF8String();
	if(!name.empty())
	{
		crRadioGroupWidgetNode *playerIconRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_playerIconRadioGroup));
		int iconSelect = playerIconRadioGroup->getSelect();
		int count = playerIconRadioGroup->getRadioGroup().size();
		int halfcount = count * 0.5f;
		//bool selectSex = iconSelect<halfcount;
		
		void *param;
		crData *data = crBrain::getInstance()->getDataClass();
		ref_ptr<crTableIO>table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
		crTableIO::StrVec record;
		if(table.valid())
		{
			crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
			playerData -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int maleIconCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaleIconCount,viplv).c_str());
			//iconSelect+=1;
			//if(!selectSex)
			//	iconSelect += maleIconCount - halfcount;
			data->getParam(WCHDATA_JXJCurPlayerIconID,param);
			int curPlayerIconID = *(int *)param;
			int id = iconSelect + curPlayerIconID + 1;
			unsigned char playersex = 0;
			
			if (table->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
			{
				playersex = (unsigned char)atoi(record[table->getTitleIndex("性别")].c_str());
			}
			unsigned char iconid = id;//(unsigned char)(atoi((*table)(id,0).c_str()));
			//bool selectSex = sexSelect == 1;
			playerData->inputParam(WCHDATA_PlayerIconID,&iconid);
			bool selectSex = true;
			if (playersex)
				selectSex = false;
			playerData->inputParam(WCHDATA_PlayerSex,&selectSex);
			//crMyPlayerData::getInstance()->getPlayerGameData()->setName(name);
		}
	}
	else
	{
		bool cancelTask = true;
		handle.outputParam(0,&cancelTask);
	}
}
/////////////////////////////////////////
//
//crJXJUISelectPowerInitMethod
//
/////////////////////////////////////////
crJXJUISelectPowerInitMethod::crJXJUISelectPowerInitMethod()
{
}
crJXJUISelectPowerInitMethod::crJXJUISelectPowerInitMethod(const crJXJUISelectPowerInitMethod& handle):
	crMethod(handle),
	m_selectPowerCanvas(handle.m_selectPowerCanvas),
	m_powerRaidoGroup(handle.m_powerRaidoGroup)
{
}
void crJXJUISelectPowerInitMethod::inputParam(int i, void *param)
{
}
void crJXJUISelectPowerInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_selectPowerCanvas = str;
		break;
	case 1:
		m_powerRaidoGroup = str;
		break;
	}
}
void crJXJUISelectPowerInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO>table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
	ref_ptr<crCanvasNode> canvas = dynamic_cast<crCanvasNode* >(crFilterRenderManager::getInstance()->findCanvas(m_selectPowerCanvas));
	if(table.valid() && canvas.valid())
	{
		crRadioGroupWidgetNode *powerRaidoGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_powerRaidoGroup));
	
		int rowCount = table->getRowCount();
		std::string iconfile1,iconfile2;
		crRadioGroupWidgetNode::RadioGroup &radioGroup = powerRaidoGroup->getRadioGroup();
		crMultiSwitch *radioButton;
		crStateSet *ss1,*ss2;
		crTexture2D *tex2d;
		crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
		int id = 0;
		for( ;
			itr != radioGroup.end() && id<rowCount;
			++itr,id++ )
		{
			iconfile1 = (*table)(id,2);
			iconfile2 = (*table)(id,3);
			radioButton = itr->second->getButton();
			radioButton->setVisiable(true);
			ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();
			ss2 = dynamic_cast<crObject *>(radioButton->getChild(1))->getDrawable(0)->getStateSet();

			tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
			if(tex2d)
			{
				if(tex2d->getImageNameID().compare(iconfile1)!=0)
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
			}
			else
			{
				tex2d = new crTexture2D;
				tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
				tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
				tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
				tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
			}
			tex2d = dynamic_cast<crTexture2D *>(ss2->getTextureAttribute(0,crStateAttribute::TEXTURE));
			if(tex2d)
			{
				if(tex2d->getImageNameID().compare(iconfile2)!=0)
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile2,tex2d));
			}
			else
			{
				tex2d = new crTexture2D;
				tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
				tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
				tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
				tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile2,tex2d));
				ss2->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICreatePlayerMethod
//
/////////////////////////////////////////
crJXJUICreatePlayerMethod::crJXJUICreatePlayerMethod()
{
}
crJXJUICreatePlayerMethod::crJXJUICreatePlayerMethod(const crJXJUICreatePlayerMethod& handle):
	crMethod(handle),
	m_selectPowerCanvas(handle.m_selectPowerCanvas),
	m_powerRaidoGroup(handle.m_powerRaidoGroup)
{
}
void crJXJUICreatePlayerMethod::inputParam(int i, void *param)
{
}
void crJXJUICreatePlayerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_selectPowerCanvas = str;
		break;
	case 1:
		m_powerRaidoGroup = str;
		break;
	//case 2:
	//	m_startShiliid = atoi(str.c_str());
	//	break;
	}
}
void crJXJUICreatePlayerMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = dynamic_cast<crCanvasNode *>(crFilterRenderManager::getInstance()->findCanvas(m_selectPowerCanvas));
	ref_ptr<crTableIO>shiliTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
	if(shiliTab.valid() && canvas.valid())
	{
		crRadioGroupWidgetNode *powerRaidoGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_powerRaidoGroup));
		crData *data = crBrain::getInstance()->getDataClass();
	
		ref_ptr<crTableIO>homeTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHomeTab);
		int id = powerRaidoGroup->getSelect();
		crTableIO::StrVec record;
		//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
		crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		if (3 == id)
		{
			if (shiliTab->queryOneRecord(0,crArgumentParser::appItoa(rangei(0,3).get_random()+c_startShiliID),record)>=0)
			{
				unsigned char shiliid = (unsigned char)(atoi(record[0].c_str()));
				playerData->inputParam(WCHDATA_JXJShiliID,&shiliid);
				unsigned short chengchiid = 0;
				playerData->inputParam(WCHDATA_JXJChengchiID,&chengchiid);
				unsigned short homeid = 0;
				playerData->inputParam(WCHDATA_JXJHomeID,&homeid);
			}
		}
		else
		{
			if (shiliTab->queryOneRecord(0,crArgumentParser::appItoa(id+c_startShiliID),record)>=0)
			{
				unsigned char shiliid = (unsigned char)(atoi(record[0].c_str()));
				playerData->inputParam(WCHDATA_JXJShiliID,&shiliid);
				unsigned short chengchiid = (unsigned short)(atoi(record[shiliTab->getTitleIndex("默认城池")].c_str()));
				playerData->inputParam(WCHDATA_JXJChengchiID,&chengchiid);

				//homeid 确定
				if(homeTab->queryOneRecord(homeTab->getTitleIndex("chengchiid"),crArgumentParser::appItoa(chengchiid),record)>=0)
				{
					unsigned short homeid = atoi(record[0].c_str());
					playerData->inputParam(WCHDATA_JXJHomeID,&homeid);
					if(homeid>0)
					{//如果有homescene,玩家登陆有直接进入homescene
						crData *runGameData = crRunGameHandle::getInstance()->getDataClass();
						int sceneid = atoi(record[homeTab->getTitleIndex("sceneid")].c_str());
						runGameData->inputParam(WCHDATA_SceneID,&sceneid);
					}
				}
				else
				{
					char gbuf[256];
					sprintf(gbuf,"crJXJUICreatePlayerMethod: homeTab没有该城池记录：%d\n\0",chengchiid);
					gDebugInfo->debugInfo(CRCore::WARN,gbuf);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerLoginMethod
//
/////////////////////////////////////////
crJXJPlayerLoginMethod::crJXJPlayerLoginMethod()
{
}
crJXJPlayerLoginMethod::crJXJPlayerLoginMethod(const crJXJPlayerLoginMethod& handle):
	crMethod(handle)
{
}
void crJXJPlayerLoginMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJPlayerLoginMethod::addParam(int i, const std::string& str)
{
}
void crJXJPlayerLoginMethod::operator()(crHandle &handle)
{
	if(m_this && m_this == crMyPlayerData::getInstance()->getPlayerGameData())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_JXJHomeID,param);
		unsigned short homeid = *(unsigned short *)param;
		if(homeid>0)
		{
			ref_ptr<crTableIO>homeTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHomeTab);
			crTableIO::StrVec record;
			if(homeTab->queryOneRecord(0,crArgumentParser::appItoa(homeid),record)>=0)
			{
				crData *runGameData = crRunGameHandle::getInstance()->getDataClass();
				int sceneid = atoi(record[homeTab->getTitleIndex("sceneid")].c_str());
				runGameData->inputParam(WCHDATA_SceneID,&sceneid);
			}
		}
		//CRCore::notify(CRCore::ALWAYS)<<"crJXJPlayerLoginMethod homeid="<<homeid<<std::endl;
		char gbuf[256];
		sprintf(gbuf,"crJXJPlayerLoginMethod homeid=%d\n\0",homeid);
		gDebugInfo->debugInfo(CRCore::ALWAYS,gbuf);
	}
}
/////////////////////////////////////////
//
//crJXJSetCountryFlagMethod
//
/////////////////////////////////////////
crJXJSetCountryFlagMethod::crJXJSetCountryFlagMethod()
{
}
crJXJSetCountryFlagMethod::crJXJSetCountryFlagMethod(const crJXJSetCountryFlagMethod& handle):
	crMethod(handle),
	m_flagname(handle.m_flagname),
	m_weiflag(handle.m_weiflag),
	m_shuflag(handle.m_shuflag),
	m_wuflag(handle.m_wuflag),
	m_npcflag(handle.m_npcflag)
{
}
void crJXJSetCountryFlagMethod::inputParam(int i, void *param)
{
}
void crJXJSetCountryFlagMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_flagname = str;
		break;
	case 1:
		m_weiflag = str;
		break;
	case 2:
		m_shuflag = str;
		break;
	case 3:
		m_wuflag = str;
		break;
	case 4:
		m_npcflag = str;
		break;
	}
}
void crJXJSetCountryFlagMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		//////////////////////////////
		void *param;
		crGroup *root = crSceneManager::getInstance()->getStaticRoot();
		if(root)
		{
			crCollectNodeBYNameVisitor collector(CRCore::OBJECT);
			collector.insertNodeNameId(m_flagname);
			root->accept(collector);
			NodeArray &nodeArray = collector.getResult();
			if(!nodeArray.empty())
			{
				crObject *obj;
				std::set<crStateSet *>ssset;
				for( NodeArray::iterator itr = nodeArray.begin();
					itr != nodeArray.end();
					++itr )
				{
					obj = dynamic_cast<crObject *>(itr->get());
					//ssset.insert(obj->getDrawable(0)->getStateSet());
					ssset.insert(obj->getOrCreateStateSet());
				}
				crData *data = playerGameData->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;
				//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
				unsigned char activechildindex = shiliid - c_startShiliID;
				std::string iconfile1;
				switch (activechildindex)
				{
				case 0:
					iconfile1 = m_weiflag;
					break;
				case 1:
					iconfile1 = m_shuflag;
					break;
				case 2:
					iconfile1 = m_wuflag;
					break;
				default:
					iconfile1 = m_npcflag;
					break;
				}
				ref_ptr<crTexture2D> tex2d = new crTexture2D;
				for( std::set<crStateSet *>::iterator itr = ssset.begin();
					itr != ssset.end();
					++itr )
				{
					tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
					tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
					tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d.get()));
					(*itr)->setTextureAttributeAndModes(0,tex2d.get(),crStateAttribute::ON|crStateAttribute::OVERRIDE);
				}
			}
		}
		////////////////////////////////////
	}
}
/////////////////////////////////////////
//
//crJXJSetItemFlagMethod
//
/////////////////////////////////////////
crJXJSetItemFlagMethod::crJXJSetItemFlagMethod()
{
}
crJXJSetItemFlagMethod::crJXJSetItemFlagMethod(const crJXJSetItemFlagMethod& handle):
	crMethod(handle),
	m_flagname(handle.m_flagname),
	m_weiflag(handle.m_weiflag),
	m_shuflag(handle.m_shuflag),
	m_wuflag(handle.m_wuflag),
	m_npcflag(handle.m_npcflag)
{
}
void crJXJSetItemFlagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJSetItemFlagMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_flagname = str;
		break;
	case 1:
		m_weiflag = str;
		break;
	case 2:
		m_shuflag = str;
		break;
	case 3:
		m_wuflag = str;
		break;
	case 4:
		m_npcflag = str;
		break;
	}
}
void crJXJSetItemFlagMethod::operator()(crHandle &handle)
{
	//////////////////////////////
	void *param;
	crGroup *root = dynamic_cast<crGroup *>(m_this->getRelNode());
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(root && playerGameData)
	{
		crCollectNodeBYNameVisitor collector(CRCore::OBJECT);
		collector.insertNodeNameId(m_flagname);
		root->accept(collector);
		NodeArray &nodeArray = collector.getResult();
		if(!nodeArray.empty())
		{
			crObject *obj;
			std::set<crStateSet *>ssset;
			for( NodeArray::iterator itr = nodeArray.begin();
				itr != nodeArray.end();
				++itr )
			{
				obj = dynamic_cast<crObject *>(itr->get());
				//ssset.insert(obj->getDrawable(0)->getStateSet());
				ssset.insert(obj->getOrCreateStateSet());
			}
			crData *data = playerGameData->getDataClass();
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *(unsigned char *)param;
			//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
			unsigned char activechildindex = shiliid - c_startShiliID;
			std::string iconfile1;
			switch (activechildindex)
			{
			case 0:
				iconfile1 = m_weiflag;
				break;
			case 1:
				iconfile1 = m_shuflag;
				break;
			case 2:
				iconfile1 = m_wuflag;
				break;
			default:
				iconfile1 = m_npcflag;
				break;
			}
			ref_ptr<crTexture2D> tex2d = new crTexture2D;
			for( std::set<crStateSet *>::iterator itr = ssset.begin();
				itr != ssset.end();
				++itr )
			{
				tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
				tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
				tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
				tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d.get()));
				(*itr)->setTextureAttributeAndModes(0,tex2d.get(),crStateAttribute::ON|crStateAttribute::OVERRIDE);
			}
		}
	}
	////////////////////////////////////
}
/////////////////////////////////////////
//
//crJXJBingzhengCampFlagMethod
//
/////////////////////////////////////////
crJXJBingzhengCampFlagMethod::crJXJBingzhengCampFlagMethod():
	m_this(NULL)
{
}
crJXJBingzhengCampFlagMethod::crJXJBingzhengCampFlagMethod(const crJXJBingzhengCampFlagMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_nodeName(handle.m_nodeName)
{
}
void crJXJBingzhengCampFlagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJBingzhengCampFlagMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_nodeName = str;
		break;
	}
}
void crJXJBingzhengCampFlagMethod::operator()(crHandle &handle)
{
	if(!m_body)
	{
		crNode *relNode = m_this->getRelNode();
		if(!relNode)return;
		CRCore::crSearchNodeBYNameVisitor searchByNameVisitor;
		searchByNameVisitor.setNameId(m_nodeName);
		searchByNameVisitor.setSearchNodeType(MULTISWITCH);
		relNode->accept(searchByNameVisitor);
		m_body = dynamic_cast<crMultiSwitch *>(searchByNameVisitor.getResult());
	}
	if(m_body.valid())
	{
		crData *data = m_this->getDataClass();
		if(data)
		{
			void *param;
			data->getParam(WCHDATA_Camp,param);
			unsigned char shiliid = *(unsigned char *)param;
			unsigned char activechildindex = shiliid - c_startShiliID;
			switch (activechildindex)
			{
			case 0:
				m_body->setActiveSwitchSet(1);
				break;
			case 1:
				m_body->setActiveSwitchSet(2);
				break;
			case 2:
				m_body->setActiveSwitchSet(3);
				break;
			default:
				m_body->setActiveSwitchSet(0);
				break;
			}
		}
	}
// 	if(m_stateset)
// 	{
// 		crTexture2D *tex2d = dynamic_cast<crTexture2D *>(m_stateset->getTextureAttribute(0,crStateAttribute::TEXTURE));
// 		crData *data = m_this->getDataClass();
// 		void *param;
// 		data->getParam(WCHDATA_Camp,param);
// 		unsigned char shiliid = *(unsigned char *)param;
// 		unsigned char activechildindex = shiliid - c_startShiliID;
// 		std::string iconfile1;
// 		switch (activechildindex)
// 		{
// 		case 0:
// 			iconfile1 = m_weiflag;
// 			break;
// 		case 1:
// 			iconfile1 = m_shuflag;
// 			break;
// 		case 2:
// 			iconfile1 = m_wuflag;
// 			break;
// 		default:
// 			iconfile1 = m_npcflag;
// 			break;
// 		}
// 		if(tex2d)
// 		{
// 			if(tex2d->getImageNameID().compare(iconfile1)!=0)
// 				tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
// 		}
// 		else
// 		{
// 			tex2d = new crTexture2D;
// 			tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
// 			tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
// 			tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
// 			tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
// 			tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
// 			tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
// 			m_stateset->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
// 		}
// 	}
}

/////////////////////////////////////////
//
//crJXJBingzhengCanAddArmyMethod
//
/////////////////////////////////////////
crJXJBingzhengCanAddArmyMethod::crJXJBingzhengCanAddArmyMethod() :
m_this(NULL)
{
}
crJXJBingzhengCanAddArmyMethod::crJXJBingzhengCanAddArmyMethod(const crJXJBingzhengCanAddArmyMethod& handle) :
crMethod(handle),
m_this(NULL),
m_nodeName(handle.m_nodeName)
{
}
void crJXJBingzhengCanAddArmyMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if (param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJBingzhengCanAddArmyMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_nodeName = str;
		break;
	}
}
void crJXJBingzhengCanAddArmyMethod::operator()(crHandle &handle)
{
	if(crRunGameHandle::getInstance()->isInBattle())
	{
		if (!m_body)
		{
			crNode *relNode = m_this->getRelNode();
			if (!relNode)return;
			CRCore::crSearchNodeBYNameVisitor searchByNameVisitor;
			searchByNameVisitor.setNameId(m_nodeName);
			searchByNameVisitor.setSearchNodeType(MULTISWITCH);
			relNode->accept(searchByNameVisitor);
			m_body = dynamic_cast<crMultiSwitch *>(searchByNameVisitor.getResult());
		}
		ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
		if (m_body.valid() && camera.valid())
		{
			void *param;
			crData * cameraData = camera->getAttachedNode()->getDataClass();

			if (cameraData)
			{
				cameraData->getParam(WCHDATA_JXJCampAddArmyTimer, param);
				float addArmyTimer = *(float *)param;

				char isEnemy = 0;
				crMyPlayerData::getInstance()->getCurrentRole()->doEvent(WCH_EnemyCheck, MAKEINT64(m_this, &isEnemy));

				if (isEnemy != 1 || addArmyTimer > 0.0f)
				{
					m_body->setActiveSwitchSet(0);
				}
				else
				{
					m_body->setActiveSwitchSet(1);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetConstructtionLevelMethod
//
/////////////////////////////////////////
crJXJSetConstructtionLevelMethod::crJXJSetConstructtionLevelMethod()
{
}
crJXJSetConstructtionLevelMethod::crJXJSetConstructtionLevelMethod(const crJXJSetConstructtionLevelMethod& handle):
	crMethod(handle)
{
}
void crJXJSetConstructtionLevelMethod::inputParam(int i, void *param)
{
}
void crJXJSetConstructtionLevelMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetConstructtionLevelMethod::operator()(crHandle &handle)
{
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(scene)
	{
		void *param;
		crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		playerData->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		float factor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingFactor,viplv).c_str());


		playerData->getParam(WCHDATA_JXJFuyalv,param);
		unsigned char fuyalv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJBingyinglv,param);
		unsigned char bingyinglv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJJiusilv,param);
		unsigned char jiusilv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJGongfanglv,param);
		unsigned char gongfanglv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJShijilv,param);
		unsigned char shijilv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJFukulv,param);
		unsigned char fukulv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJMingjulv,param);
		_crInt64 mingjulv = *(_crInt64 *)param;
		_crInt32 lo32 = LOINT64(mingjulv);
		_crInt32 hi32 = HIINT64(mingjulv);
		_crInt16 lo16 = LOINT32(lo32);
		_crInt16 hi16 = HIINT32(lo32);
		unsigned char mingju[8];
		mingju[0] = (unsigned char)LOINT16(lo16);
		mingju[1] = (unsigned char)HIINT16(lo16);
		mingju[2] = (unsigned char)LOINT16(hi16);
		mingju[3] = (unsigned char)HIINT16(hi16);
		lo16 = LOINT32(hi32);
		hi16 = HIINT32(hi32);
		mingju[4] = (unsigned char)LOINT16(lo16);
		mingju[5] = (unsigned char)HIINT16(lo16);
		mingju[6] = (unsigned char)LOINT16(hi16);
		mingju[7] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJNongtianlv,param);
		_crInt64 nongtianlv = *(_crInt64 *)param;
		lo32 = LOINT64(nongtianlv);
		hi32 = HIINT64(nongtianlv);
		lo16 = LOINT32(lo32);
		hi16 = HIINT32(lo32);
		unsigned char nongtian[8];
		nongtian[0] = (unsigned char)LOINT16(lo16);
		nongtian[1] = (unsigned char)HIINT16(lo16);
		nongtian[2] = (unsigned char)LOINT16(hi16);
		nongtian[3] = (unsigned char)HIINT16(hi16);
		lo16 = LOINT32(hi32);
		hi16 = HIINT32(hi32);
		nongtian[4] = (unsigned char)LOINT16(lo16);
		nongtian[5] = (unsigned char)HIINT16(lo16);
		nongtian[6] = (unsigned char)LOINT16(hi16);
		nongtian[7] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJMuchanglv,param);
		_crInt32 muchanglv = *(_crInt32 *)param;
		lo16 = LOINT32(muchanglv);
		hi16 = HIINT32(muchanglv);
		unsigned char muchang[4];
		muchang[0] = (unsigned char)LOINT16(lo16);
		muchang[1] = (unsigned char)HIINT16(lo16);
		muchang[2] = (unsigned char)LOINT16(hi16);
		muchang[3] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJLingdilv,param);
		_crInt32 lingdilv = *(_crInt32 *)param;
		lo16 = LOINT32(lingdilv);
		hi16 = HIINT32(lingdilv);
		unsigned char lingdi[4];
		lingdi[0] = (unsigned char)LOINT16(lo16);
		lingdi[1] = (unsigned char)HIINT16(lo16);
		lingdi[2] = (unsigned char)LOINT16(hi16);
		lingdi[3] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJKuangshanlv,param);
		_crInt32 kuangshanlv = *(_crInt32 *)param;
		lo16 = LOINT32(kuangshanlv);
		hi16 = HIINT32(kuangshanlv);
		unsigned char kuangshan[4];
		kuangshan[0] = (unsigned char)LOINT16(lo16);
		kuangshan[1] = (unsigned char)HIINT16(lo16);
		kuangshan[2] = (unsigned char)LOINT16(hi16);
		kuangshan[3] = (unsigned char)HIINT16(hi16);


		playerData->getParam(WCHDATA_JXJShuichelv,param);
		unsigned char shuichelv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJRonglulv,param);
		unsigned char ronglulv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJGongshelv,param);
		unsigned char gongshelv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJMochuanlv,param);
		unsigned char mochuanlv = *(unsigned char *)param;

		std::vector<int> minjuvec,nongtianvec,muchangvec,lindivec,kuangshanvec;
		for (int i = 0; i < 8; i++)
		{
			minjuvec.push_back(mingju[i]);
			nongtianvec.push_back(nongtian[i]);
		}
		for (int i = 0; i < 8; i++)
		{
			muchangvec.push_back(muchang[i]);
			lindivec.push_back(lingdi[i]);
			kuangshanvec.push_back(kuangshan[i]);
		}

		crInstanceItem *item;
		CRCore::crMultiSwitch *constructtionNode;
		CRNetApp::crScene::SceneItemMap &sceneItemMap = scene->getSceneItemMap();
		std::vector<crMultiSwitch *> Mingju;
		std::vector<crMultiSwitch *> Nongtian;
		std::vector<crMultiSwitch *> Muchang;
		std::vector<crMultiSwitch *> Lingdi;
		std::vector<crMultiSwitch *> Kuangshan;
		Mingju.reserve(8);
		Nongtian.reserve(8);
		Muchang.reserve(4);
		Lingdi.reserve(4);
		Kuangshan.reserve(4);
		std::string str = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitFuyaFactor,viplv);
		float limit = atof(str.c_str());
		str = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitJiusiFactor,viplv);
		float limitjiusi = atof(str.c_str());
		str = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitTerritoryFactor,viplv);
		float limitresource = atof(str.c_str());
		for( CRNetApp::crScene::SceneItemMap::iterator itr = sceneItemMap.begin();
			 itr != sceneItemMap.end();
			 ++itr )
		{
			item = itr->second.get();
			constructtionNode = dynamic_cast<crMultiSwitch *>(dynamic_cast<crGroup *>(item->getRelNode())->getChild(0));
			const std::string &aname = item->getAbstractItem()->getName();
			if(!constructtionNode)
			{
				//CRCore::notify(CRCore::ALWAYS)<<"crJXJSetConstructtionLevelMethod "<<aname<<" 的模型文件不正确"<<std::endl;
				continue;
			}
			if(aname.compare("Fuya") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,fuyalv,factor,limit,0);
			}
			else if(aname.compare("Bingying") == 0)
			{
				crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;
				//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
				unsigned char activechildindex = shiliid - c_startShiliID;
				constructtionNode->setActiveSwitchSet(activechildindex);
				constructtionNode = dynamic_cast<crMultiSwitch *>(constructtionNode->getFirstActiveChild());
				setFunctionalBuildingModel(constructtionNode,bingyinglv,factor,limit,0);
			}
			else if(aname.compare("Jiusi") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,jiusilv,factor,limitjiusi,1);
			}
			else if(aname.compare("Gongfang") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,gongfanglv,factor,limitjiusi,1);
			}
			else if(aname.compare("Shiji") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,shijilv,factor,limitjiusi,1);
			}
			else if(aname.compare("Fuku") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,fukulv,factor,limit,0);
			}
			else if(aname.compare("Mingju") == 0)
			{
				Mingju.push_back(constructtionNode);
			}
			else if(aname.compare("Nongtian") == 0)
			{
				Nongtian.push_back(constructtionNode);
			}
			else if(aname.compare("Muchang") == 0)
			{
				Muchang.push_back(constructtionNode);
			}
			else if(aname.compare("Lingdi") == 0)
			{
				Lingdi.push_back(constructtionNode);
			}
			else if(aname.compare("Kuangshan") == 0)
			{
				Kuangshan.push_back(constructtionNode);
			}
			else if(aname.compare("shuiche") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,shuichelv - 1,1.0f,5,0);
			}
			else if(aname.compare("ronglu") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,ronglulv - 1,1.0f,5,0);
			}
			else if(aname.compare("gongshe") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,gongshelv - 1,1.0f,5,0);
			}
			else if(aname.compare("mochuan") == 0)
			{
				setFunctionalBuildingModel(constructtionNode,mochuanlv - 1,1.0f,5,0);
			}
		}
		setTerritoryBuildingModel(Mingju,minjuvec,factor,limitresource,2);
		setTerritoryBuildingModel(Nongtian,nongtianvec,factor,limitresource,2);
		setTerritoryBuildingModel(Muchang,muchangvec,factor,limitresource,2);
		setTerritoryBuildingModel(Lingdi,lindivec,factor,limitresource,2);
		setTerritoryBuildingModel(Kuangshan,kuangshanvec,factor,limitresource,2);
	}
}
void crJXJSetConstructtionLevelMethod::setTerritoryBuildingModel(std::vector<CRCore::crMultiSwitch *> modelvec,std::vector<int> buildinglvvec,float factor,float limit,int flag)
{
	int i = 0;
	std::vector<CRCore::crMultiSwitch *>::iterator citr;
	for(citr = modelvec.begin();		//矿山
		citr != modelvec.end() && i<buildinglvvec.size();
		++citr,i++ )
	{
		if (buildinglvvec[i] > 0)
		{
			float buildingfactor = floor(buildinglvvec[i] * factor) + flag;
			if (buildingfactor>limit)
			{
				buildingfactor = limit;
			}
			modelvec[i]->setActiveSwitchSet(buildingfactor);
		}
		else
		{
			break;
		}
	}
	if ( citr != modelvec.end() && i<buildinglvvec.size())
	{
		modelvec[i]->setActiveSwitchSet(1);
		++citr,i++;
	}
	for(;citr != modelvec.end() && i<buildinglvvec.size();++citr,i++ )
	{
		modelvec[i]->setActiveSwitchSet(0);
	}
}
void crJXJSetConstructtionLevelMethod::setFunctionalBuildingModel(CRCore::crMultiSwitch* model,int buildinglv,float factor,float limit,int flag)
{
	if (buildinglv > 0)
	{
		float buildingfactor = floor(buildinglv * factor) + flag;
		if (buildingfactor>limit)
		{
			buildingfactor = limit;
		}
		model->setActiveSwitchSet(buildingfactor);
	}
	else
	{
		model->setActiveSwitchSet(0);
	}
}
/////////////////////////////////////////
//
//crJXJUIUpdateMyInfoMethod
//
/////////////////////////////////////////
crJXJUIUpdateMyInfoMethod::crJXJUIUpdateMyInfoMethod()
{
}
crJXJUIUpdateMyInfoMethod::crJXJUIUpdateMyInfoMethod(const crJXJUIUpdateMyInfoMethod& handle):
	crMethod(handle),
	m_playerFace(handle.m_playerFace),
	m_nickname(handle.m_nickname),
	m_flag(handle.m_flag),
	m_gold(handle.m_gold),
	m_govPosition(handle.m_govPosition),
	m_cashGift(handle.m_cashGift),
	m_money(handle.m_money),
	m_food(handle.m_food),
	m_wood(handle.m_wood),
	m_iron(handle.m_iron),
	m_horse(handle.m_horse),
	m_lv(handle.m_lv),
	m_lijin(handle.m_lijin),
	m_junling(handle.m_junling),
	m_exp(handle.m_exp),
	m_expprogress(handle.m_expprogress),
	m_junlingPro(handle.m_junlingPro),
	m_vipflashsw(handle.m_vipflashsw),
	m_qiyubtn(handle.m_qiyubtn)
{
}
void crJXJUIUpdateMyInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIUpdateMyInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_playerFace = str;
		break;
	case 1:
		m_nickname = str;
		break;
	case 2:
		m_flag = str;
		break;
	case 3:
		m_gold = str;
		break;
	case 4:
		m_govPosition = str;
		break;
	case 5:
		m_cashGift = str;
		break;
	case 6:
		m_money = str;
		break;
	case 7:
		m_food = str;
		break;
	case 8:
		m_wood = str;
		break;
	case 9:
		m_iron = str;
		break;
	case 10:
		m_horse = str;
		break;
	case 11:
		m_lv = str;
		break;
	case 12:
		m_lijin = str;
		break;
	case 13:
		m_junling = str;
		break;
	case 14:
		m_exp = str;
		break;
	case 15:
		m_expprogress = str;
		break;
	case 16:
		m_junlingPro = str;
		break;
	case 17:
		m_vipflashsw = str;
		break;
	case 18:
		m_qiyubtn = str;
		break;
	}
}
void crJXJUIUpdateMyInfoMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData && playerGameData->getMainRole())
	{
		crRole *mainRole = playerGameData->getMainRole();
		crData *mainRoleData = mainRole->getDataClass();
		crButtonWidgetNode *playerFaceWidget = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_playerFace));
		crStaticTextWidgetNode *nicknameWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nickname));
		crStaticTextWidgetNode *goldWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gold));
		crStaticTextWidgetNode *govPositionWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_govPosition));
		crStaticTextWidgetNode *cashGiftWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_cashGift));
		crStaticTextWidgetNode *moneyWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_money));
		crStaticTextWidgetNode *foodWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_food));
		crStaticTextWidgetNode *woodWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_wood));
		crStaticTextWidgetNode *ironWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_iron));
		crStaticTextWidgetNode *horseWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horse));
		crStaticTextWidgetNode *lvWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_lv));
		crStaticTextWidgetNode *lijinWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_lijin));
		crStaticTextWidgetNode *junlingWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_junling));
		crStaticTextWidgetNode *expWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_exp));
		crProgressWidgetNode *expPre = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_expprogress));
		crProgressWidgetNode *junlingPro = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_junlingPro));
		ref_ptr<crMultiSwitch> vipplayersw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_vipflashsw));
		void *param;
		crMultiSwitch *shiliSW;
		crData *data = playerGameData->getDataClass();
		std::string name = crMyPlayerData::getInstance()->getCharacterName();
		if(nicknameWidget) nicknameWidget->setString(name);
		if(expWidget) expWidget->clearString();
		data->getParam(WCHDATA_PlayerIconID,param);
		unsigned char iconid = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJShiliID,param);
		unsigned char shiliid = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJGoldingot,param);
		int goldingot = *(int *)param;
		mainRoleData->getParam(WCHDATA_JXJGovPost,param);
		unsigned char govPost = *(unsigned char *)param;
		//data->getParam(WCHDATA_Cashgift,param);
		//int cash = *(int *)param;

		data->getParam(WCHDATA_JXJFukulv, param);
		unsigned char fukulv = *(unsigned char *)param;
		ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
		crTableIO::StrVec record, recordd, recordc, recordf;
		fukutab->queryOneRecord(0, crArgumentParser::appItoa((int)fukulv), record);
		int foodlimitid = fukutab->getTitleIndex("粮食");
		int woodlimitid = fukutab->getTitleIndex("木材");
		int ironlimitid = fukutab->getTitleIndex("铁矿");
		int horselimitid = fukutab->getTitleIndex("马匹");
		float fukulimitaddpercent = 0.0f;
		playerGameData->doEvent(WCH_JXJGetFukuLimitAdd, MAKEINT64(&fukulimitaddpercent, NULL));
		int foodlimit = atoi(record[foodlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int woodlimit = atoi(record[woodlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int ironlimit = atoi(record[ironlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int horselimit = atoi(record[horselimitid].c_str()) * (1.0f + fukulimitaddpercent);

		data->getParam(WCHDATA_JXJCoppercash,param);
		int coppercash = *(int *)param;

		data->getParam(WCHDATA_JXJFood,param);
	    int food = *(int *)param;
		//foodWidget->setString(crArgumentParser::appItoa(food));
		if (food >= foodlimit){
			foodWidget->setColor(crVector4f(255.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		else{
			foodWidget->setColor(crVector4f(0.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		//foodWidget->setColor(food >= foodlimit ? m_overColor : m_normalColor);
		data->getParam(WCHDATA_JXJWood,param);
		int wood = *(int *)param;
		//woodWidget->setString(crArgumentParser::appItoa(food));
		if (wood >= woodlimit){
			woodWidget->setColor(crVector4f(255.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		else{
			woodWidget->setColor(crVector4f(0.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		//woodWidget->setColor(wood >= woodlimit ? m_overColor : m_normalColor);
		data->getParam(WCHDATA_JXJIron,param);
		int iron = *(int *)param;
		//ironWidget->setString(crArgumentParser::appItoa(iron));
		if (iron >= ironlimit){
			ironWidget->setColor(crVector4f(255.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		else{
			ironWidget->setColor(crVector4f(0.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		//ironWidget->setColor(iron >= ironlimit ? m_overColor : m_normalColor);
		data->getParam(WCHDATA_JXJHorse,param);
		int horse = *(int *)param;
		//horseWidget->setString(crArgumentParser::appItoa(horse));
		if (horse >= horselimit){
			horseWidget->setColor(crVector4f(255.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		else{
			horseWidget->setColor(crVector4f(0.0f, 0.0f, 0.0f, 255.0f) / 255.0f);
		}
		//horseWidget->setColor(horse >= horselimit ? m_overColor : m_normalColor);
		data->getParam(WCHDATA_JXJGiftGold,param);
		int lijin = *(int *)param;//礼金

		mainRoleData->getParam(WCHDATA_Level,param);
		unsigned char level = *(unsigned char *)param;
		mainRoleData->getParam(WCHDATA_Experience,param);
		int curexperience = *(int *)param;//经验
		//int experiencemax = 987654;//升级所需经验
		//int lijin = 8888;//礼金
		//int junling = 10;//当前军令
		//int junlingmax = 20;//军令最大值

		//if(cashGiftWidget) cashGiftWidget->setString(crArgumentParser::appItoa(cash));
		if(goldWidget) ifOverhundredthousand(goldingot, goldWidget);
		if(moneyWidget) ifOverhundredthousand(coppercash, moneyWidget);
		if(foodWidget) ifOverhundredthousand(food, foodWidget);
		if(woodWidget) ifOverhundredthousand(wood, woodWidget);
		if(ironWidget) ifOverhundredthousand(iron, ironWidget);
		if(horseWidget) ifOverhundredthousand(horse, horseWidget);
		if(lvWidget) lvWidget->setString(crArgumentParser::appItoa(level));
		if(lijinWidget) ifOverhundredthousand(lijin, lijinWidget);
		//////////////////////////////////////////////////经验值及经验条的显示 2013.8.28
		int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,0).c_str());
		//crTableIO::StrVec record, recordd, recordc, recordf;
	    ref_ptr<crTableIO>LordlvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordlvTab);
		int lvid = LordlvTab->getTitleIndex("lv");
		int experience = LordlvTab->getTitleIndex("经验");
		mainRoleData->getParam(WCHDATA_Level,param);
		unsigned char *nowlv = (unsigned char *)param;
		if ((*nowlv) < 1)
		{
			(*nowlv) = 1;
		}
		if ((*nowlv) > maxlv)
		{
			(*nowlv) = maxlv;
		}
		//unsigned char curlv = *nowlv-10;
		//unsigned char nextlv = curlv+1;
		unsigned char nextlv = *nowlv+1;
		if(LordlvTab->queryOneRecord(lvid,crArgumentParser::appItoa((int)(*nowlv)),recordd) >= 0)
		{
			//int experienceCount = 0;
			//for (int i = 1;i <= int(*nowlv);++i)
			//{
			//	if(LordlvTab->queryOneRecord(lvid,crArgumentParser::appItoa(i),recordc))
			//		experienceCount += atoi(recordc[1].c_str());
			//}
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			if(LordlvTab->queryOneRecord(lvid,crArgumentParser::appItoa((int)nextlv),record)>=0)
			{
				//if(expWidget)expWidget->setString(crArgumentParser::appItoa(curexperience - experienceCount)+"/"+record[experience]);
				if ((int)(*nowlv) == 1)
				{
					if(expWidget)expWidget->setString(crArgumentParser::appItoa(curexperience) + "/" + crArgumentParser::appItoa(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str())));
				}
				else if(expWidget)expWidget->setString(crArgumentParser::appItoa(curexperience - atoi(recordd[experience].c_str()))+"/"+crArgumentParser::appItoa(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str())));
				//if ((int)nextlv > maxlv)
				//{
				//	expWidget->clearString();
				//}
			}
			if (int(*nowlv) >= maxlv)
			{
				float nowexpPro = 1;
				if(expPre)expPre->setProgress(nowexpPro);
			}
			else
			{
				if (int(*nowlv) == 1)
				{
					float nowexpPro = float(curexperience)/float(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str()));
					if(expPre)expPre->setProgress(nowexpPro);
				}
				else
				{
					float nowexpPro = float(curexperience - atoi(recordd[experience].c_str()))/float(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str()));
					if(expPre)expPre->setProgress(nowexpPro);
				}
			}
			//////////////////////////////////////军令条的显示 2013.8.28
			data->getParam(WCHDATA_JXJJunling,param);
			unsigned short junling = *(unsigned short *)param;
			junling = junling/100;
			int maxjunling = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str());
			if(junlingWidget)junlingWidget->setString(crArgumentParser::appItoa(junling)+"/"+crArgumentParser::appItoa(maxjunling));
			float nowjunlingPro = float(junling)/float(maxjunling);
			if(junlingPro)junlingPro->setProgress(nowjunlingPro);

			/////////////////////////////////////////////
			if(playerFaceWidget)
			{
				ref_ptr<crTableIO>playerIconTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
				if(playerIconTable->queryOneRecord(0,crArgumentParser::appItoa(iconid),record)>=0)
				{
					//playerFaceWidget->setImageName(record[1]);
					crStateSet *state_set = dynamic_cast<crObject *>(( dynamic_cast<crGroup *>(playerFaceWidget->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
					if (state_set)
					{
						crTexture2D *texture_2d = dynamic_cast<crTexture2D *>(state_set->getTextureAttribute(0,crStateAttribute::TEXTURE));
						if (texture_2d)
						{
							texture_2d->setImage(0, texture_2d->getImageDataRequestHandler()->requestImageFile(record[1],texture_2d));
							playerFaceWidget->setVisiable(true);
						}
					}
				}
			}
			//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
			shiliSW = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_flag));
			if(shiliSW)
			{
				shiliSW->setActiveSwitchSet(shiliid-c_startShiliID);
			}
			if(govPositionWidget)
			{
				ref_ptr<crTableIO>govPostTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				govPostTable->queryOneRecord(0,crArgumentParser::appItoa(govPost),record);
				govPositionWidget->setString(record[1]);
			}
		}
		if(vipplayersw.valid())
		{
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char vipLevel = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJPlayerHaveGotViplvReward,param);
			unsigned char havegot = *(unsigned char *)param;
			if(havegot < vipLevel)
			{
				vipplayersw->setActiveSwitchSet(1);
			}
			else
			{
				vipplayersw->setActiveSwitchSet(0);
			}
		}
		ref_ptr<crButtonWidgetNode> qiyuBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_qiyubtn));
		if(qiyuBtn.valid())
		{
			bool qiyu = false;
			mainRoleData->getParam(WCHDATA_JXJQiyuTaskID,param);
			int qiyutaskid = *(int *)param;
			if(qiyutaskid>0)
			{
				ref_ptr<crGameTask>gameTask;
				crData *myMetierData = mainRole->getMetierDataClass();
				myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
				myMetierData->getParam(WCHDATA_GameTaskMap,param);
				GameTaskMap *gameTaskMap = (GameTaskMap *)param;
				GameTaskMap::iterator itr = gameTaskMap->find(qiyutaskid);
				if(itr != gameTaskMap->end())
				{
					gameTask = itr->second;
					if(gameTask->getActivation())
						qiyu = true;
				}
				myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			qiyuBtn->setVisiable(qiyu);
		}
	}
}
void crJXJUIUpdateMyInfoMethod::ifOverhundredthousand(int i, crStaticTextWidgetNode* textnode)
{
	if (i<100000)
	{
		textnode->setString(crArgumentParser::appItoa(i));
	}
	else if (i<100000000)
	{
		i = i/10000;
		std::string str = crArgumentParser::appItoa(i)+"W";
		textnode->setString(str);
	}
	else
	{
		i = i/100000000;
		std::string str = crArgumentParser::appItoa(i)+"E";
		textnode->setString(str);
	}
}
/////////////////////////////////////////
//
//crJXJGameServerUpdateMethod
//
/////////////////////////////////////////
crJXJGameServerUpdateMethod::crJXJGameServerUpdateMethod():
	m_maxInterval(0)
{
}
crJXJGameServerUpdateMethod::crJXJGameServerUpdateMethod(const crJXJGameServerUpdateMethod& handle):
crMethod(handle),
m_maxInterval(0)
{
}
void crJXJGameServerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_player = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crGameServerPlayerData*)(HIINT64(param64));
		}
		else
		{
			m_player = NULL;
		}
		break;
	}
}
void crJXJGameServerUpdateMethod::addParam(int i, const std::string& str)
{
}
void crJXJGameServerUpdateMethod::zeroRefresh(time_t t1, bool bZero, bool initZero)
{
	bool isZhouRefrech = false;
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJCountryRecommendSet, param);
	bool recommendSet =  *(bool *)param;
	data -> getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	crVector2i maxlevycount;
	crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount,viplv).c_str(),maxlevycount);
	unsigned char levycount = maxlevycount[LevyType_Free] + maxlevycount[LevyType_Gold];
	unsigned char giftcount = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOnLineGiftMaxCount,viplv).c_str()));
	unsigned char maxGetCount = (unsigned char)atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLandRewardGetCount,viplv).c_str());
	data->inputParam(WCHDATA_JXJLevyCount, &levycount);
	//unsigned char *levycount = (unsigned char *)param;
	//if (*levycount < nowlevycount)
	//{
	//	*levycount = nowlevycount;
	//}
	char buildcountrytimes = (char)atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJVipBuildCountryTimes,viplv).c_str());
	data->inputParam(WCHDATA_JXJBuildCountryTimes,&buildcountrytimes);
	//在线时长清零
	data->inputParam(WCHDATA_JXJOnlineTimer,NULL);
	//每日死亡数清零
	data->inputParam(WCHDATA_JXJDayPlayerDeadCount,NULL);
	data->inputParam(WCHDATA_JXJDayKillPlayerCount,NULL);
	data->inputParam(WCHDATA_JXJDayKillNPCCount,NULL);
	data->inputParam(WCHDATA_JXJDayKillEachTroops,NULL);
	//重置黄钻每日礼包
	data->getParam(WCHDATA_JXJYELLOWAWARDINFO,param);
	int yellowInfo = *(int*)param &0xffff;
	data->inputParam(WCHDATA_JXJYELLOWAWARDINFO,&yellowInfo);

	//重置每日市集购买次数
	unsigned char count = 1;
	data->inputParam(WCHDATA_JXJBuyResourceCount,&count);
	data->getParam(WCHDATA_JXJShijilv,param);
	unsigned char shijilv = *(unsigned char *)param;
	int freeLevel = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMarketFreeBuyLevel,viplv).c_str());
	if (shijilv >= freeLevel)
	{
		data->inputParam(WCHDATA_JXJFreeBuyInfo,0);
	}
	//重置元宝补兵次数
	data->inputParam(WCHDATA_JXJGoldRecruitCount,0);
	//else if(*levycount > nowlevycount)
	//{
	//	*levycount = nowlevycount;
	//}
	//data->inputParam(WCHDATA_JXJLuckyCardCopperCost,0);
	//data->inputParam(WCHDATA_JXJLuckyCardGoldCost,0);
	//data->inputParam(WCHDATA_JXJKnowLuckyCard,0);
	data->inputParam(WCHDATA_JXJOnlineRewardCount,&giftcount);
	data->inputParam(WCHDATA_JXJOnlineRewardTimer,&t1);
	unsigned char junlingcount = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunlingBuyCount,viplv).c_str()));
	data->inputParam(WCHDATA_JXJBuyJunlingCount,&junlingcount);
	data->inputParam(WCHDATA_MarketBuyResourceCount,0);
	data->inputParam(WCHDATA_JXJBuyJunlingTimer, 0);
	data->inputParam(WCHDATA_JXJLingqufengluFlag, 0);

		//crPlayerDataEventPacket packet;
	//crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvJiusiCostCountRefresh,NULL);
	//gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
	//免费平叛时间
	unsigned char freecount = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxFreeCount,viplv).c_str()));
	data->inputParam(WCHDATA_JXJFreeCounterinsurgencyCount,&freecount);

	//if(m_this->getMainRole() && m_this->getMainRole()->getDataClass())
	{
		//crData *mainRoleData = m_this->getMainRole()->getDataClass();

		//data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
		MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *) param;
		myGroupApplySet->clear();
		//data->excHandle(MAKEINT64(WCH_LockData,0));
	}

	std::deque< unsigned short > fubeniddeq;
	////////////////////////////////////副本重置
	data->getParam(WCHDATA_JXJFubenProgressMap,param);
	FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
	for (FubenProgressMap::iterator itr = fubenProgress->begin();
		itr != fubenProgress->end();
		++itr)
	{
		if(itr->second->getComplete() > 0)
		{
			itr->second->setComplete(1);
			fubeniddeq.push_back(itr->first);
		}
	}
	/// 投票记录周一重置
	time_t t = time(0);
	struct  tm  sTm = *localtime(&t);

	data->getParam(WCHDATA_UpdateTimer,param);
	_crInt64 updateTimer = *(_crInt64 *)param;

	struct tm  preTm = *localtime(&updateTimer);
	if (initZero || (sTm.tm_wday == 1 && sTm.tm_hour >= 5)
		 || (sTm.tm_wday > 1 && sTm.tm_yday - preTm.tm_yday > sTm.tm_wday - 1))
	{//每周零点刷新
		isZhouRefrech = true;
		data->getParam(WCHDATA_JXJSelectLeaderSet,param);
		SelectLeaderIdSet * selectLeaderSet = (SelectLeaderIdSet *)param;
		selectLeaderSet->clear();
		recommendSet = false;
		data->inputParam(WCHDATA_JXJCountryRecommendSet, &recommendSet);
		//data->getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
		//HadWonGroupFuBenSet * hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
		//hadWonGroupFuBenSet->clear();	
		//周活动刷新
		//if (m_this->getMainRole() && m_this->getMainRole()->getDataClass())
		//{
			int huodongID = 0;
			crData *mainroledata = m_this->getMainRole()->getDataClass();
			mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
			mainroledata->getParam(WCHDATA_JXJNewHuodongMap, param);
			NewHuodongMap *huodongMap= (NewHuodongMap *)param;
			NewHuodongMap ::iterator hitr = huodongMap->end();
			crTableIO::DataVec record;	
			ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
			if (huodongTab.valid())
			{
				int refreshidx = huodongTab->getTitleIndex("刷新");
				int circleidx = huodongTab->getTitleIndex("次数");
				huodongTab->queryRecords(refreshidx,"7",record);	
				for (crTableIO::DataVec::iterator ditr = record.begin();ditr!=record.end();++ditr)
				{
					huodongID = atoi((*ditr)[0].c_str());
					hitr = huodongMap->find(huodongID);
					if(hitr != huodongMap->end())
					{
						hitr->second->refresh(atoi((*ditr)[circleidx].c_str()));
					}
				}
			}
			mainroledata->excHandle(MAKEINT64(WCH_LockData,0));
		//}
		//周常任务刷新
				/*shiliData->getParam(WCHDATA_JXJChengxiang,param);
				int chengxiangid = *(int*)param;
				shiliData->getParam(WCHDATA_JXJDasima,param);
				int dasimaid = *(int*)param;
				shiliData->getParam(WCHDATA_JXJDajiangjun,param);
				int dajiangjunid = *(int*)param;
				int playerid = m_this->getPlayerID();*/
			//if(playerid==chengxiangid || playerid==dasimaid || playerid==dajiangjunid)
			//{
		crRole *mainRole = m_this->getMainRole();
		if (mainRole)
		{
			crData *myMetierData = mainRole->getMetierDataClass();
			if (myMetierData)
			{
				myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
				myMetierData->getParam(WCHDATA_GameTaskMap,param);
				GameTaskMap *gameTaskMap = (GameTaskMap *)param;
				if (gameTaskMap)
				{
					ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
					int taskidindex = tasktitletab->getTitleIndex("taskid");
					crTableIO::StrVec record;
					for( GameTaskMap::iterator itr = gameTaskMap->begin();itr != gameTaskMap->end();++itr )
					{
						int renwutype = 0;
						if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(itr->second->getTaskID()),record) >= 0)
						{
							renwutype = atoi(record[0].c_str());
							if(renwutype == 5)
								itr->second->resetTask();
						//itr->second->setActivation(true);
						}
					}
				}
				myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
		//}
		///异国将卡商店刷新
		ref_ptr<crTableIO>foreignCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJForeignCardTab);
		data->getParam(WCHDATA_JXJShiliID, param);
		unsigned char shiliid = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJForeignCard, param);
		crVector3i* foreignCard = (crVector3i *)param;
		int rowcount = foreignCardTab->getRowCount();
		std::vector<int>CardVec;
		int cardid;
		crVector2i saleShili;
		for (int i = 0; i < rowcount; ++i)
		{
			crArgumentParser::appAtoVec((*foreignCardTab)(i, 1), saleShili, '|');
			if (saleShili[0] == shiliid || saleShili[1] == shiliid)
			{
				cardid = atoi((*foreignCardTab)(i, 0).c_str());
				if (cardid != (*foreignCard)[0] && cardid != (*foreignCard)[1] && cardid != (*foreignCard)[2])
				{
					CardVec.push_back(cardid);
				}
			}
		}
		if (!CardVec.empty())
		{
			rangei cardrange(0, CardVec.size());
			int cardrnd[2];
			int cardrndtmp = cardrange.get_random();
			(*foreignCard)[0] = CardVec[cardrndtmp];
			cardrnd[0] = cardrndtmp;
			do
			{
				cardrndtmp = cardrange.get_random();
			} while (cardrndtmp == cardrnd[0]);
			(*foreignCard)[1] = CardVec[cardrndtmp];
			cardrnd[1] = cardrndtmp;
			do
			{
				cardrndtmp = cardrange.get_random();
			} while (cardrndtmp == cardrnd[0] || cardrndtmp == cardrnd[1]);
			(*foreignCard)[2] = CardVec[cardrndtmp];
		}
	}

	//日常任务刷新
	int jifen = 0;
	data->inputParam(WCHDATA_JXJGuoZhanJiFen,&jifen);
	crRole *mainRole = m_this->getMainRole();
	if (mainRole)
	{
		crData *mainroledata = mainRole->getDataClass();
		mainroledata->inputParam(WCHDATA_JXJQiyuTaskID,NULL);
		crData *myMetierData = mainRole->getMetierDataClass();
		if (myMetierData)
		{
			myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
			myMetierData->getParam(WCHDATA_GameTaskMap,param);
			GameTaskMap *gameTaskMap = (GameTaskMap *)param;
			if (gameTaskMap)
			{
				ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
				int taskidindex = tasktitletab->getTitleIndex("taskid");
				crTableIO::StrVec record;
				for( GameTaskMap::iterator itr = gameTaskMap->begin();itr != gameTaskMap->end();++itr )
				{
					int renwutype = 0;
					if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(itr->second->getTaskID()),record) >= 0)
					{
						renwutype = atoi(record[0].c_str());
						if(renwutype == 4 || renwutype == 8)
						{
							itr->second->resetTask();
							//itr->second->setActivation(true);
						}
					}
				}
			}
			myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}

	//征战商店每日购买上限刷新
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJBuyShangXianMap,param);
	std::map<int,unsigned char> *buyshangxianmap = (std::map<int,unsigned char>*)param;
	buyshangxianmap->clear();
	
	//世界战场玩家领取活动奖励次数刷新
	unsigned char gettimes = 0;
	data->inputParam(WCHDATA_JXJAmHuoDongGetTimes,&gettimes);
	data->inputParam(WCHDATA_JXJAmHuoDongGetTimes+1,&gettimes);
	data->inputParam(WCHDATA_JXJAmHuoDongGetTimes+2,&gettimes);

	// 国家福利投资重置
	unsigned char feteTimes = 0;
	data->inputParam(WCHDATA_JXJCountryBenefitFeteTimes	,&feteTimes);
	unsigned char enrichTimes = 0;
	data->inputParam(WCHDATA_JXJCountryBenefitEnrichTimes	,&enrichTimes);
	unsigned char enrichType = 0;
	data->inputParam(WCHDATA_JXJCountryBenefitEnrichType,&enrichType);

	//军团副本奖励 领取次数
	bool hadwontoday = false;
	data->inputParam(WCHDATA_JXJHadWonJunTuanFBT,&hadwontoday);
	//征召次数重置
	unsigned char times = 0;
	data->inputParam(WCHDATA_JXJUsedZhengZhaoTimes,&times);
	//是否已经自动显示节日活动窗口
	bool hadShowFestivalHuodongCanvas = false;
	data->inputParam(WCHDATA_JXJHadShowFestivalHuodongCanvas, &hadShowFestivalHuodongCanvas);
	
	// 军团捐献重置
	unsigned char val = 0;
	data->inputParam(WCHDATA_JXJGroupContributeiType	,&val);
	data->inputParam(WCHDATA_JXJGroupContributeiTimes,&val);
	data->getParam(WCHDATA_JXJSeriesLandDay,param);
	unsigned short * seriesDays = (unsigned short *)param;
	data->getParam(WCHDATA_JXJLandRewardGetCount,param);
	unsigned char * rewardCount = (unsigned char *)param;
	if(bZero)
	{
		//连续登陆时间
		*seriesDays += 1;
		//登陆奖励次数
		if(*seriesDays <= maxGetCount)
			*rewardCount = *seriesDays;
		else
			*rewardCount = maxGetCount;
		if(*rewardCount == 0)
		{
			*rewardCount = 1;
		}
	}
	else
	{
		//重置连续登陆时间
		*seriesDays = 1;
		//重置登陆奖励次数
		*rewardCount = 1;
	}
	//活跃度重置
	//mainrolerefesh();
	if (mainRole)
	{
		int targetcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJHuoYueDuTargetCount).c_str());
		int totalhuoyuedu = 0;
		int curstep = 0;
		int curhuoyuedu = 0;

		crData *mainroledata = m_this->getMainRole()->getDataClass();
		mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
		mainroledata->getParam(WCHDATA_JXJHuoyueduMap, param);
		HuoyueduMap *huoyuedumap = (HuoyueduMap *)param;
		mainroledata->getParam(WCHDATA_JXJHuoyueduRewardSet, param);
		HuoyueduRewardSet *huoyuedurewardset = (HuoyueduRewardSet *)param;
		huoyuedurewardset->clear();
		for (HuoyueduMap::iterator hyditr = huoyuedumap->begin();
			hyditr != huoyuedumap->end();
			++hyditr)
		{
			//if (hyditr->first != HYD_Vip)
			//{
			curstep = hyditr->second->getStep();
			curhuoyuedu = hyditr->second->getPoint();
			totalhuoyuedu += curstep*curhuoyuedu;

			hyditr->second->setStep(0);
			hyditr->second->setComplete(false);
			//}
		}
		mainroledata->excHandle(MAKEINT64(WCH_LockData,0));

		bool check = true;
		data->inputParam(WCHDATA_JXJIsCheckHuoYueDuSign,&check);
		if (totalhuoyuedu < targetcount)
			data->inputParam(WCHDATA_JXJFinishHuoYueDuDayCount,&val);
		
	}

	data->getParam(WCHDATA_JXJFinishHuoYueDuDayCount,param);
	unsigned char continuedayc = *(unsigned char *)param;
	// 登陆天数累加

	data->getParam(WCHDATA_JXJPlayerLoginDays,param);
	unsigned short * loginDays = (unsigned short *)param;
	++ *loginDays;
    m_this->doEvent(WCH_JXJCheck7Day);

	//军团城池特产刷新次数重置
	unsigned char spreftimes = 0;
	data->inputParam(WCHDATA_JXJSpecialtyRefreshTimes,&spreftimes);

	//城池特产刷新
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJGroupCantonSpecialtyVec,param);
	GroupCantonSpecialtyVec *gcspecialtyVec = (GroupCantonSpecialtyVec *)param;
	for( GroupCantonSpecialtyVec::iterator gvitr = gcspecialtyVec->begin();
		gvitr != gcspecialtyVec->end();
		++gvitr )
	{
		*gvitr = NULL;
	}
	//data->excHandle(MAKEINT64(WCH_LockData,0));


	//活动日刷新
	if (m_this->getMainRole() && m_this->getMainRole()->getDataClass())
	{
		int huodongID = 0;
		crData *mainroledata = m_this->getMainRole()->getDataClass();
		mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
		mainroledata->getParam(WCHDATA_JXJNewHuodongMap, param);
		NewHuodongMap *huodongMap= (NewHuodongMap *)param;
		NewHuodongMap ::iterator hitr = huodongMap->end();
		crTableIO::DataVec record;	
		ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
		if (huodongTab.valid())
		{
			int circleidx = huodongTab->getTitleIndex("次数");
			int refreshidx = huodongTab->getTitleIndex("刷新");
			huodongTab->queryRecords(refreshidx,"1",record);	
			for (crTableIO::DataVec::iterator ditr = record.begin();ditr!=record.end();++ditr)
			{
				huodongID = atoi((*ditr)[0].c_str());
				hitr = huodongMap->find(huodongID);
				if(hitr != huodongMap->end())
				{
					hitr->second->refresh(atoi((*ditr)[circleidx].c_str()));
					//弱国奖励激活
					if (huodongID == Activation_WeakShili && hitr->second->isIntimeCheck())
					{
						crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
						data->getParam(WCHDATA_JXJShiliID,param);
						unsigned char shiliid = *(unsigned char *)param;
						gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
						gsBrainData->getParam(WCHDATA_JXJShiliWei + shiliid - c_startShiliID,param);
						crJXJShili *shili = (crJXJShili *)param;
						if (shili && shili->getDataClass())
						{
							crData *shiliData = shili->getDataClass();	
							shiliData->getParam(WCHDATA_JXJCountryStrength,param);
							unsigned char countrystrength = *(unsigned char*)param;
							if(countrystrength == 0)
							{
								hitr->second->setActivation(1,m_this->getPlayerID());
							}
						}
						gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
					}
					else if (huodongID == Activation_Telephone && hitr->second->isActivation()==0 && hitr->second->isIntimeCheck())
					{//查询数据库如果手机号码已经有了，直接完成
						ref_ptr<crJXJTelQueryData> telQuery = new crJXJTelQueryData;
						telQuery->buildQuerySql(m_this->getPlayerID());
						std::string tel;
						crDataBase *accountdb = crDataBaseManager::getInstance()->getAccountDB();
						ref_ptr<crDataBase> accountSession = accountdb->beginSession();
						accountSession->executeQuery(telQuery.get());
						crDataBase::QueryResultVec &telQueryResultVec = accountSession->getQueryResult();
						if(!telQueryResultVec.empty())
						{
							telQuery = dynamic_cast<crJXJTelQueryData *>(telQueryResultVec[0].get());
							tel = telQuery->getTel();
						}
						accountSession->releaseQuery();
						accountdb->endSession(accountSession.get());
						if(tel.empty())
						{
							hitr->second->setActivation(1,m_this->getPlayerID());
						}
						else
						{
							hitr->second->setActivation(2,m_this->getPlayerID());
						}
					}
				}
			}
		}
		mainroledata->excHandle(MAKEINT64(WCH_LockData,0));
	}
	//data->excHandle(MAKEINT64(WCH_LockData,1));
	
	data->getParam(WCHDATA_JXJZhouKaEndTime,param);
	time_t zhoukaendtime = *(_crInt64 *)param;
	time_t curtime = time(0);
	if (curtime >= zhoukaendtime)
	{
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		unsigned char _status = 0;
		data->inputParam(WCHDATA_JXJZhouKaGetStatus,&_status);
		_crInt64 _endtime= 0;
		data->inputParam(WCHDATA_JXJZhouKaEndTime,&_endtime);
		int _zhoukaid = 0;
		data->inputParam(WCHDATA_JXJGainedZhouKaID,&_zhoukaid);
		int _dayidx = -1;
		data->inputParam(WCHDATA_JXJZhouKaGetDayIdx,&_dayidx);
		//data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	else
	{
		int endday = (int)((zhoukaendtime + 28800)/c_24hours);
		int curday = (int)((curtime + 28800)/c_24hours);
		int zhoukadayidx = 7 - (endday - curday);
		if (zhoukadayidx >=0 && zhoukadayidx <7)
		{
			data->inputParam(WCHDATA_JXJZhouKaGetDayIdx,&zhoukadayidx);
		}
	}
	//data->excHandle(MAKEINT64(WCH_LockData,0));
	m_this->doEvent(WCH_JXJRecvUpdateZhouKaStatus,MAKEINT64(NULL,GameServer));

	//// 同步玩家礼金到国民列表
	//crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();

	//data->getParam(WCHDATA_JXJShiliID,param);
	//unsigned char shiliid = *(unsigned char *)param;
	//
	//gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));

	//gsBrainData->getParam(WCHDATA_JXJShiliWei + shiliid - c_startShiliID,param);
	//crJXJShili *shili = (crJXJShili *)param;
	//if (shili && shili->getDataClass())
	//{
	//	crData *shiliData = shili->getDataClass();	
	//	CRCore::ScopedLock<crData> lock(*shiliData);

	//	shiliData->getParam(WCHDATA_JXJPeopleMap,param);
	//	PeopleMap *peopleMap = (PeopleMap *)param;
	//	PeopleMap::iterator itr = peopleMap->find(m_this->getPlayerID());
	//	if (itr != peopleMap->end())
	//	{
	//		data->getParam(WCHDATA_JXJGiftGold,param);
	//		int giftGold = *(int *)param;
	//		if (itr->second->getGiftGold() != giftGold)
	//		{
	//			itr->second->setGiftGold(giftGold);
	//		}
	//	}
	//}

	//gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));

	////////////////////////////////////
	////////////////////////////////////
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(33 + fubeniddeq.size() * 2);
	stream->_writeUChar(levycount);
	stream->_writeUChar(giftcount);
	stream->_writeUChar(junlingcount);
	stream->_writeInt64(t1);
	stream->_writeUChar(fubeniddeq.size());
	for (std::deque< unsigned short >::iterator itr = fubeniddeq.begin();
		itr != fubeniddeq.end();
		++itr)
	{
		stream->_writeUShort((*itr));
	}

	stream->_writeUChar(freecount);
	stream->_writeUShort(*seriesDays);
	stream->_writeUChar(*rewardCount);
	stream->_writeUShort(*loginDays);
	stream->_writeBool(isZhouRefrech);
	stream->_writeBool(recommendSet);
	stream->_writeUChar(continuedayc);
	data->getParam(WCHDATA_JXJForeignCard, param);
	crVector3i foreignCard = *(crVector3i *)param;
	stream->_writeVec3i(foreignCard);

	crPlayerDataEventPacket packet;
	crPlayerDataEventPacket::buildReplyPacket(packet,m_player->getPlayerID(),WCH_JXJRecvZeroRefresh,stream.get());
	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
	netConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(),packet);

	if(viplv>0)
	{
		m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKEINT64(HYD_Vip, viplv));
	}
	if(mainRole) mainRole->doEvent(WCH_JXJServerActiveTask);
}
//void crJXJGameServerUpdateMethod::mainrolerefesh()
//{
//	crData *data = m_this->getDataClass();
//	//unsigned char mainrolerefreshflag = 0;
//	//if (m_this->getMainRole() && m_this->getMainRole()->getDataClass())
//	//{
//		void *param;
//		crData *mainroledata = m_this->getMainRole()->getDataClass();
//		mainroledata->getParam(WCHDATA_JXJHuoyueduMap, param);
//		HuoyueduMap *huoyuedumap = (HuoyueduMap *)param;
//		mainroledata->getParam(WCHDATA_JXJHuoyueduRewardSet, param);
//		HuoyueduRewardSet *huoyuedurewardset = (HuoyueduRewardSet *)param;
//		huoyuedurewardset->clear();
//		for (HuoyueduMap::iterator hyditr = huoyuedumap->begin();
//			hyditr != huoyuedumap->end();
//			++hyditr)
//		{
//			//if (hyditr->first != HYD_Vip)
//			//{
//				hyditr->second->setStep(0);
//				hyditr->second->setComplete(false);
//			//}
//		}
//		crPlayerDataEventPacket packet;
//		crPlayerDataEventPacket::buildReplyPacket(packet, m_player->getPlayerID(), WCH_JXJRecvMainroleZeroRefresh, NULL);
//		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
//		netConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(), packet);
//		//mainrolerefreshflag = 0;
//
//		data -> getParam(WCHDATA_JXJVipLv,param);
//		unsigned char viplv = *(unsigned char *)param;
//		if(viplv>0)
//		{
//			m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKEINT64(HYD_Vip, viplv));
//		}
//	//}
//	//else
//	//{
//	//	mainrolerefreshflag = 1;
//	//}
//	//data->inputParam(WCHDATA_JXJMainRoleRefreshFlag, &mainrolerefreshflag);
//}
time_t getNextUpdateTime(time_t t)
{
	struct tm *pnow = localtime(&t);
	time_t zero = t - pnow->tm_hour*3600 - pnow->tm_min*60 - pnow->tm_sec ; 
	if (pnow->tm_hour<5)
	{
		return zero + 5*3600;
	}

	return zero + (24+5)*3600;
}
void crJXJGameServerUpdateMethod::operator()(crHandle &handle)
{
	if(m_this->getDBValid() && /*m_player->getSceneID() == 0 &&*/ m_this->getMainRole() && m_this->getMainRole()->getDataClass())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_JXJShiliID, param);
		unsigned char shiliid = *(unsigned char *)param;
		if (shiliid < c_startShiliID)
			return;

		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		if(m_maxInterval == 0)
		{
			m_maxInterval = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJResproduceMaxTime,viplv).c_str());
		}

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_UpdateTimer,param);
		_crInt64* updateTimer = (_crInt64 *)param;
		time_t t1 = time(0);
		if(*updateTimer == 0L)
		{
			*updateTimer = t1;
			zeroRefresh(t1,false,true);
			data->excHandle(MAKEINT64(WCH_LockData,0));
			return;
		}
		//data->getParam(WCHDATA_JXJMainRoleRefreshFlag, param);
		//if (*(unsigned char *)param && m_this->getMainRole())
		//{
		//	mainrolerefesh();
		//}
		int dt = t1 - *updateTimer;
		if(dt>0)
		{
			struct tm *pnow;  
			pnow=localtime(&t1);
			int nowsec = pnow->tm_hour * 3600 + pnow->tm_min * 60 + pnow->tm_sec;
			int nowhour = pnow->tm_hour;
			int nowday = pnow->tm_mday;
			//零点刷新
			if(dt>m_maxInterval)
				dt = m_maxInterval;
			if(t1 - getNextUpdateTime(*updateTimer) >= 172800)
			{//隔天上线
				zeroRefresh(t1,false);
			}
			else if(t1 - getNextUpdateTime(*updateTimer) >= 86400)
			{//隔天上线
				zeroRefresh(t1,true);
			}
			else
			{
				struct tm *plast;  
				plast=localtime(updateTimer);
				int lasthour = plast->tm_hour;
				int lastday = plast->tm_mday;
				//int lastsec = plast->tm_hour * 3600 + plast->tm_min * 60 + plast->tm_sec;
				//if(nowsec<lastsec)
				//{//零点
				if((nowhour>=5&&(lasthour<5||nowday!=lastday/*5*3600*/)) || (nowday!=lastday && lasthour <5))
				{//5点刷新
					zeroRefresh(t1,true);
				}
			}
			*updateTimer = t1;
			//building timer
			data->getParam(WCHDATA_JXJBuildingTimes,param);
			crVector4i* buildingTimes = (crVector4i *)param;
			data->getParam(WCHDATA_JXJRecruitTimes,param);
			crVector4i* recruitTimes = (crVector4i *)param;
			for(int i = 0; i<4; i++)
			{
				if((*buildingTimes)[i]>0)
				{
					(*buildingTimes)[i] -= dt;
					if((*buildingTimes)[i]<0)
						(*buildingTimes)[i] = 0;
				}

				if((*recruitTimes)[i]>0)
				{
					(*recruitTimes)[i] -= dt;
					if((*recruitTimes)[i]<0)
						(*recruitTimes)[i] = 0;
				}
			}
			/*data->getParam(WCHDATA_JXJTreasonBufferTimer,param);
			int* treabufTimes = (int *)param;
			if (treabufTimes > 0)
			{
			treabufTimes -= dt;
			if(treabufTimes < 0)
			treabufTimes = 0;
			}*/
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//////////////////////////////////////////////////////////////////////////
			//数据更新 
			//time_t timep;  
			//struct tm *p;  
			//time(&timep);  
			//p=localtime(&timep);
			//int sec = p->tm_hour * 3600 + p->tm_min * 60 + p->tm_sec;
			m_this->doEvent(WCH_JXJGameServerUpdate,MAKEINT64(&dt,nowsec));
			//////////////////////////////////////////////////////////////////////////
			//将更新数据发给客户端
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			data->excHandle(MAKEINT64(WCH_BuildUpdateStream,stream.get()));
			//data->getParam(WCHDATA_DataStream,param);
			//ref_ptr<crStreamBuf> updateStream;
			//if(param)
			//{
				//updateStream = *((ref_ptr<crStreamBuf>*)param);
				crPlayerDataUpdateStreamPacket packet;
				crPlayerDataUpdateStreamPacket::buildReplyPacket(packet,m_player->getPlayerID(),stream.get());
				crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
				netConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(),packet);
			//}
		}
		else
		{
			*updateTimer = t1;
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJResUpdateMethod
//
/////////////////////////////////////////
crJXJResUpdateMethod::crJXJResUpdateMethod():
m_dt(0),
m_foodDelta(0.0f),
m_woodDelta(0.0f),
m_ironDelta(0.0f),
m_horseDelta(0.0f)
{
}
crJXJResUpdateMethod::crJXJResUpdateMethod(const crJXJResUpdateMethod& handle):
crMethod(handle),
m_dt(0),
m_foodDelta(0.0f),
m_woodDelta(0.0f),
m_ironDelta(0.0f),
m_horseDelta(0.0f)
{
}
void crJXJResUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((int*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0;
		}
		break;
	}
}
void crJXJResUpdateMethod::addParam(int i, const std::string& str)
{
}
float crJXJResUpdateMethod::getExtraProduce(unsigned char type,float base,float dt,ExtraProduceMap *extraProduceMap)
{
	void *param;
	float extraProduct = 0;
	crData *data = m_this->getDataClass();
	//采金卡加成,资源加成建筑加成
	crTableIO::StrVec ResAddBuildingrecord;
	ref_ptr<crTableIO> ResAddBuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResAddBuildingTab);
	int buildinglvindex = ResAddBuildingTab->getTitleIndex("lv");
	int addindex = ResAddBuildingTab->getTitleIndex("加成");
	if (buildinglvindex >= 0 && addindex >= 0)
	{
		int buildingid = 0;
		int extratype = 0;
		switch (type)
		{
		case T_Food:
			buildingid = WCHDATA_JXJShuichelv;
			extratype = T_FoodExtraProduce;
			break;
		case T_Wood:
			buildingid = WCHDATA_JXJGongshelv;
			extratype = T_WoodExtraProduce;
			break;
		case T_Iron:
			buildingid = WCHDATA_JXJRonglulv;
			extratype = T_IronExtraProduce;
			break;
		case T_Horse:
			buildingid = WCHDATA_JXJMochuanlv;
			extratype = T_HorseExtraProduce;
			break;
		default:
			break;
		}
		data->getParam(buildingid, param);
		unsigned char buildinglv = *(unsigned char *)param;
		if (ResAddBuildingTab->queryOneRecord(0, crArgumentParser::appItoa(buildingid), buildinglvindex, crArgumentParser::appItoa(buildinglv), ResAddBuildingrecord) >= 0)
		{
			float percent = atof(ResAddBuildingrecord[addindex].c_str());
			ExtraProduceMap::iterator itr = extraProduceMap->find(type);
			if (itr != extraProduceMap->end())
			{
				ref_ptr<crExtraProduce> extraProduce = itr->second;
				if (extraProduce->timer() > m_dt)
				{
					extraProduce->timer() -= m_dt;
					extraProduct += base * (/*1.0f + */percent * 0.01f) * dt;
				}
				else
				{
					extraProduct += base * (/*1.0f + */percent * 0.01f) * (float)(extraProduce->timer()) / 3600.0f;
					extraProduce->timer() = 0; //先计算完资源加成 再将加成时间置零
					extraProduceMap->erase(itr);
				}
			}
		}
		if(extratype>0)
		{
			ExtraProduceMap::iterator itr = extraProduceMap->find(extratype);
			if (itr != extraProduceMap->end())
			{
				ref_ptr<crExtraProduce> extraProduce = itr->second;
				if (extraProduce->timer() > m_dt)
				{
					extraProduce->timer() -= m_dt;
					extraProduct += base * (extraProduce->getPercent() * 0.01f) * dt;
				}
				else
				{
					extraProduct += base * (extraProduce->getPercent() * 0.01f) * (float)(extraProduce->timer()) / 3600.0f;
					extraProduce->timer() = 0; //先计算完资源加成 再将加成时间置零
					extraProduceMap->erase(itr);
				}
			}
		}
		/*data->getParam(WCHDATA_JXJTreasonPunishTimer,param);
		int punishtime = *(int *)param; 
		if (punishtime > 0)
		{
		if (punishtime > m_dt)
		extraProduct -= base * (0.5f) * dt;
		else
		extraProduct -= base * (0.5f) * (float)(punishtime/3600.0f);
		}*/
	}
	return extraProduct;
}
void crJXJResUpdateMethod::operator()(crHandle &handle)
{
	if(m_this && m_this->getDataClass())
	{
		void *param;
		crData *playerData = m_this->getDataClass();
		playerData->getParam(WCHDATA_JXJFukulv,param);
		unsigned char fukulv = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJNongtianlv,param);
		_crInt64 nongtianlv = *(_crInt64 *)param;
		int lo32 = LOINT64(nongtianlv);
		int hi32 = HIINT64(nongtianlv);
		short lo16 = LOINT32(lo32);
		short hi16 = HIINT32(lo32);
		unsigned char nongtian[8];
		nongtian[0] = (unsigned char)LOINT16(lo16);
		nongtian[1] = (unsigned char)HIINT16(lo16);
		nongtian[2] = (unsigned char)LOINT16(hi16);
		nongtian[3] = (unsigned char)HIINT16(hi16);
		lo16 = LOINT32(hi32);
		hi16 = HIINT32(hi32);
		nongtian[4] = (unsigned char)LOINT16(lo16);
		nongtian[5] = (unsigned char)HIINT16(lo16);
		nongtian[6] = (unsigned char)LOINT16(hi16);
		nongtian[7] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJMuchanglv,param);
		_crInt32 muchanglv = *(_crInt32 *)param;
		lo16 = LOINT32(muchanglv);
		hi16 = HIINT32(muchanglv);
		unsigned char muchang[4];
		muchang[0] = (unsigned char)LOINT16(lo16);
		muchang[1] = (unsigned char)HIINT16(lo16);
		muchang[2] = (unsigned char)LOINT16(hi16);
		muchang[3] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJLingdilv,param);
		_crInt32 lingdilv = *(_crInt32 *)param;
		lo16 = LOINT32(lingdilv);
		hi16 = HIINT32(lingdilv);
		unsigned char lingdi[4];
		lingdi[0] = (unsigned char)LOINT16(lo16);
		lingdi[1] = (unsigned char)HIINT16(lo16);
		lingdi[2] = (unsigned char)LOINT16(hi16);
		lingdi[3] = (unsigned char)HIINT16(hi16);
		playerData->getParam(WCHDATA_JXJKuangshanlv,param);
		_crInt32 kuangshanlv = *(_crInt32 *)param;
		lo16 = LOINT32(kuangshanlv);
		hi16 = HIINT32(kuangshanlv);
		unsigned char kuangshan[4];
		kuangshan[0] = (unsigned char)LOINT16(lo16);
		kuangshan[1] = (unsigned char)HIINT16(lo16);
		kuangshan[2] = (unsigned char)LOINT16(hi16);
		kuangshan[3] = (unsigned char)HIINT16(hi16);

		playerData->getParam(WCHDATA_JXJFood,param);
		int* food = (int *)param;
		playerData->getParam(WCHDATA_JXJWood,param);
		int* wood = (int *)param;
		playerData->getParam(WCHDATA_JXJIron,param);
		int* iron = (int *)param;
		playerData->getParam(WCHDATA_JXJHorse,param);
		int* horse = (int *)param;

		ref_ptr<crTableIO>resproduceTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
		ref_ptr<crTableIO>fukuTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
		crTableIO::StrVec record,limitrecord;
		if(fukuTab->queryOneRecord(0,crArgumentParser::appItoa(fukulv),limitrecord)<0)
			return;
		//铜钱
		float ffuku = (float)fukulv;
		float product;
		//粮食
		int foodid = resproduceTab->getTitleIndex("粮食");
		int woodid = resproduceTab->getTitleIndex("木材");
		int ironid = resproduceTab->getTitleIndex("铁矿");
		int horseid = resproduceTab->getTitleIndex("马匹");

		float fukulimitaddpercent = 0.0f;
		m_this->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
		int limit = atoi(limitrecord[fukuTab->getTitleIndex("粮食")].c_str()) * (1.0f + fukulimitaddpercent);

		float dt = (float)m_dt / 3600.0f;
		int output;
		crRole *mainRole = m_this->getMainRole();
		float percent = 0.0f;
		float percent1 = 0.0f;
		float extraProduct;
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJExtraProduceMap,param);
		ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
		unsigned char type = T_Panguo;
		ExtraProduceMap::iterator itrpunish = extraProduceMap->find(type);
		if(*food < limit)
		{
			product = 0.0f;
			for (int i = 0; i < 8; i++)
			{
				if (nongtian[i]>=1)
				{
					if(resproduceTab->queryOneRecord(0,crArgumentParser::appItoa(nongtian[i]),record)>=0)
						product += atof(record[foodid].c_str());
				}
			}

			int times = 0;
			ExtraProduceMap::iterator itr = extraProduceMap->find(T_Food);
			if (itr != extraProduceMap->end())
				times = itr->second->timer();

			extraProduct = getExtraProduce(T_Food,product,dt,extraProduceMap);
			percent = 0.0f;
			percent1 = 0.0f;
			if(mainRole)
			{
				mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent,T_Food));
				m_this->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1,T_Food));
				percent += percent1;
			}
			product *= 1.0f+percent;

			//因叛国扣除资源产量
			if (itrpunish != extraProduceMap->end())
			{
				ref_ptr<crExtraProduce> extraProduce = itrpunish->second;
				if (extraProduce->timer() > m_dt)
				{
					//extraProduce->timer() -= m_dt;
					product = product * 0.5;
					extraProduct = extraProduct * 0.5;
				}
				else
				{
					product = product * (1 - 0.5*((float)extraProduce->timer()/(float)m_dt));
					if(times <= extraProduce->timer() && extraProduce->timer() != 0)
						extraProduct = extraProduct * 0.5;
					else 
						extraProduct = extraProduct * (1 - ((float)extraProduce->timer()/(float)(2*times)));
					//extraProduce->timer() = 0; //先计算完资源加成 再将加成时间置零
					//extraProduceMap->erase(itr);
				}
			}

			m_foodDelta += product * dt + extraProduct;
			output = (int)m_foodDelta;
			m_foodDelta -= output;
			INTLIMITADD(*food,output,limit)
			//*food += output;
			//if(*food > limit) *food = limit;
		}
		else
		{
			getExtraProduce(T_Food,0,dt,extraProduceMap);
		}
		//木材
		limit = atoi(limitrecord[fukuTab->getTitleIndex("木材")].c_str()) * (1.0f + fukulimitaddpercent);
		if(*wood < limit)
		{
			product = 0.0f;
			for (int i = 0; i < 4; i++)
			{
				if (lingdi[i]>=1)
				{
					if(resproduceTab->queryOneRecord(0,crArgumentParser::appItoa(lingdi[i]),record)>=0)
						product += atof(record[woodid].c_str());
				}
			}

			int times = 0;
			ExtraProduceMap::iterator itr = extraProduceMap->find(T_Wood);
			if (itr != extraProduceMap->end())
				times = itr->second->timer();

			extraProduct = getExtraProduce(T_Wood,product,dt,extraProduceMap);
			percent = 0.0f;
			if(mainRole)
			{
				mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent,T_Wood));
				m_this->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1,T_Wood));
				percent += percent1;
			}
			product *= 1.0f+percent;

			//因叛国扣除资源产量
			if (itrpunish != extraProduceMap->end())
			{
				ref_ptr<crExtraProduce> extraProduce = itrpunish->second;
				if (extraProduce->timer() > m_dt)
				{
					//extraProduce->timer() -= m_dt;
					product = product * 0.5;
					extraProduct = extraProduct * 0.5;
				}
				else
				{
					product = product * (1 - 0.5*((float)extraProduce->timer()/(float)m_dt));
					if(times <= extraProduce->timer() && extraProduce->timer() != 0)
						extraProduct = extraProduct * 0.5;
					else
						extraProduct = extraProduct * (1 - ((float)extraProduce->timer()/(float)(2*times)));
					//extraProduce->timer() = 0; //先计算完资源加成 再将加成时间置零
					//extraProduceMap->erase(itr);
				}
			}

			m_woodDelta += product * dt + extraProduct;
			output = (int)m_woodDelta;
			m_woodDelta -= output;
			INTLIMITADD(*wood,output,limit)
			//*wood += output;
			//if(*wood > limit) *wood = limit;
		}
		else
		{
			getExtraProduce(T_Wood,0,dt,extraProduceMap);
		}
		//铁
		limit = atoi(limitrecord[fukuTab->getTitleIndex("铁矿")].c_str()) * (1.0f + fukulimitaddpercent);
		if(*iron < limit)
		{
			product = 0.0f;
			for (int i = 0; i < 4; i++)
			{
				if (kuangshan[i]>=1)
				{
					if(resproduceTab->queryOneRecord(0,crArgumentParser::appItoa(kuangshan[i]),record)>=0)
						product += atof(record[ironid].c_str());
				}
			}

			int times = 0;
			ExtraProduceMap::iterator itr = extraProduceMap->find(T_Iron);
			if (itr != extraProduceMap->end())
				times = itr->second->timer();

			extraProduct = getExtraProduce(T_Iron,product,dt,extraProduceMap);
			percent = 0.0f;
			if(mainRole)
			{
				mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent,T_Iron));
				m_this->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1,T_Iron));
				percent += percent1;
			}
			product *= 1.0f+percent;

			//因叛国扣除资源产量
			if (itrpunish != extraProduceMap->end())
			{
				ref_ptr<crExtraProduce> extraProduce = itrpunish->second;
				if (extraProduce->timer() > m_dt)
				{
					//extraProduce->timer() -= m_dt;
					product = product * 0.5;
					extraProduct = extraProduct * 0.5;
				}
				else
				{
					product = product * (1 - 0.5*((float)extraProduce->timer()/(float)m_dt));
					if(times <= extraProduce->timer() && extraProduce->timer() != 0)
						extraProduct = extraProduct * 0.5;
					else
						extraProduct = extraProduct * (1 - ((float)extraProduce->timer()/(float)(2*times)));
					//extraProduce->timer() = 0; //先计算完资源加成 再将加成时间置零
					//extraProduceMap->erase(itr);
				}
			}

			m_ironDelta += product * dt + extraProduct;
			output = (int)m_ironDelta;
			m_ironDelta -= output;
			INTLIMITADD(*iron,output,limit)
			//*iron += output;
			//if(*iron > limit) *iron = limit;
		}
		else
		{
			getExtraProduce(T_Iron,0,dt,extraProduceMap);
		}
		//马匹
		limit = atoi(limitrecord[fukuTab->getTitleIndex("马匹")].c_str()) * (1.0f + fukulimitaddpercent);
		if(*horse < limit)
		{
			product = 0.0f;
			for (int i = 0; i < 4; i++)
			{
				if (muchang[i]>=1)
				{
					if(resproduceTab->queryOneRecord(0,crArgumentParser::appItoa(muchang[i]),record)>=0)
						product += atof(record[horseid].c_str());
				}
			}

			int times = 0;
			ExtraProduceMap::iterator itr = extraProduceMap->find(T_Horse);
			if (itr != extraProduceMap->end())
				times = itr->second->timer();

			extraProduct = getExtraProduce(T_Horse,product,dt,extraProduceMap);
			percent = 0.0f;
			if(mainRole)
			{
				mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent,T_Horse));
				m_this->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1,T_Horse));
				percent += percent1;
			}
			product *= 1.0f+percent;

			//因叛国扣除资源产量
			if (itrpunish != extraProduceMap->end())
			{
				ref_ptr<crExtraProduce> extraProduce = itrpunish->second;
				if (extraProduce->timer() > m_dt)
				{
					extraProduce->timer() -= m_dt;
					product = product * 0.5;
					extraProduct = extraProduct * 0.5;
				}
				else
				{
					product = product * (1 - 0.5*((float)extraProduce->timer()/(float)m_dt));
					if(times <= extraProduce->timer() && extraProduce->timer() != 0)
						extraProduct = extraProduct * 0.5;
					else
						extraProduct = extraProduct * (1 - ((float)extraProduce->timer()/(float)(2*times)));
				}
			}

			m_horseDelta += product * dt + extraProduct;
			output = (int)m_horseDelta;
			m_horseDelta -= output;
			INTLIMITADD(*horse,output,limit)
			//*horse += output;
			//if(*horse > limit) *horse = limit;
		}
		else
		{
			getExtraProduce(T_Horse,0,dt,extraProduceMap);
		}

		if (itrpunish != extraProduceMap->end())
		{
			ref_ptr<crExtraProduce> extraProduce = itrpunish->second;
			if (extraProduce->timer() > m_dt)
				extraProduce->timer() -= m_dt;
			else
			{
				extraProduce->timer() = 0; //先计算完资源加成 再将加成时间置零
				extraProduceMap->erase(itrpunish);
			}
		}
		///额外税收
		ExtraProduceMap::iterator copperitr = extraProduceMap->find(T_CopperExtraProduce);
		if(copperitr != extraProduceMap->end())
		{
			ref_ptr<crExtraProduce> extraProduce = copperitr->second;
			if (extraProduce->timer() > m_dt)
				extraProduce->timer() -= m_dt;
			else
			{
				extraProduce->timer() = 0;
				extraProduceMap->erase(copperitr);
			}
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJJunlingProduceMethod
//
/////////////////////////////////////////
crJXJJunlingProduceMethod::crJXJJunlingProduceMethod():
	m_dt(0),
	m_delta(0.0f)
{
}
crJXJJunlingProduceMethod::crJXJJunlingProduceMethod(const crJXJJunlingProduceMethod& handle):
	crMethod(handle),
	m_dt(0),
	m_delta(0.0f)
{
}
void crJXJJunlingProduceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((int*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0;
		}
		break;
	}
}
void crJXJJunlingProduceMethod::addParam(int i, const std::string& str)
{
}
void crJXJJunlingProduceMethod::operator()(crHandle &handle)
{
	int playerid = m_this->getPlayerID();
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
	if(playerData.valid())
	{
		crData *data = m_this->getDataClass();
		if(data)
		{
			//m_dt += m_dt_record;
			//m_dt_record = 0.0f;

			void *param;
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int limit = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str());
			float produce = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJunlingProduce,viplv).c_str());

			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJJunling,param);
			unsigned short *junling = (unsigned short *)param;
			limit *= 100;
			if(*junling < limit)
			{
				float dt = (float)m_dt / 3600.0f;
				m_delta += produce * dt * 100.0f;
				int output = (int)m_delta;
				if(output>0)
				{
					int last = *junling/100;
					m_delta -= output;
					*junling += output;
					if(*junling > limit) *junling = limit;
					int newcount = *junling/100;
					if(newcount > last)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(2);
						stream->_writeUShort(*junling);
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvJunling,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
		//else
		//{
		//	m_dt_record += m_dt;
		//}
	}
}
/////////////////////////////////////////
//
//crJXJRecvJunlingMethod
//
/////////////////////////////////////////
crJXJRecvJunlingMethod::crJXJRecvJunlingMethod():
	m_netType(GameClient_Game){}
crJXJRecvJunlingMethod::crJXJRecvJunlingMethod(const crJXJRecvJunlingMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvJunlingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvJunlingMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvJunlingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			unsigned short junling = m_stream->_readUShort();

			thisData->getParam(WCHDATA_JXJJunling,param);
			unsigned short oldJunling = *(unsigned short *)param;
			int extra = junling/100 - (oldJunling/100);
			if(extra>0)
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_JunLing,extra));

			thisData->inputParam(WCHDATA_JXJJunling,&junling);
		}
	}
}
/////////////////////////////////////////
//
//crJXJCameraMouseMoveMethod
//
/////////////////////////////////////////
crJXJCameraMouseMoveMethod::crJXJCameraMouseMoveMethod():
m_delta(0.015f),
m_delta_extra(0.1f)
{
}
crJXJCameraMouseMoveMethod::crJXJCameraMouseMoveMethod(const crJXJCameraMouseMoveMethod& handle):
crMethod(handle),
m_delta(handle.m_delta),
m_delta_extra(handle.m_delta_extra)
{
}
void crJXJCameraMouseMoveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJCameraMouseMoveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_delta = atof(str.c_str());
		break;
	case 1:
		m_delta_extra = atof(str.c_str());
		break;
	}
}
void crJXJCameraMouseMoveMethod::operator()(crHandle &handle)
{
	bool mouseOnEdge = false;
	if(m_ea)
	{
		float x = m_ea->getXnormalized();
		float y = m_ea->getYnormalized();
		unsigned char cameraMove = crCameraData::None;
		if(x<=-1.0f+m_delta)
		{
			cameraMove = crCameraData::MoveLeft;
		}
		else if(x>=1.0f-m_delta)
		{
			cameraMove = crCameraData::MoveRight;
		}
		else if(y<=-1.0f+m_delta)
		{
			cameraMove = crCameraData::MoveUp;
		}
		else if(y>=1.0f-m_delta)
		{
			cameraMove = crCameraData::MoveDown;
		}
		//四个角的判断区域比边的判断区域稍大，优先级高
		if(x<-1.0f+m_delta_extra && y>1.0f-m_delta_extra)
		{
			cameraMove = crCameraData::MoveLeft | crCameraData::MoveDown;
		}
		else if(x>1.0f-m_delta_extra && y>1.0f-m_delta_extra)
		{
			cameraMove = crCameraData::MoveRight | crCameraData::MoveDown;
		}
		else if(x>1.0f-m_delta_extra && y<-1.0f+m_delta_extra)
		{
			cameraMove = crCameraData::MoveRight | crCameraData::MoveUp;
		}
		else if(x<-1.0f+m_delta_extra && y<-1.0f+m_delta_extra)
		{
			cameraMove = crCameraData::MoveLeft | crCameraData::MoveUp;
		}

		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_CameraMove,&cameraMove);
		mouseOnEdge = cameraMove != crCameraData::None;
	}
	handle.outputParam(0,&mouseOnEdge);
}
/////////////////////////////////////////
//
//crJXJCameraMoveUpdateMethod
//
/////////////////////////////////////////
crJXJCameraMoveUpdateMethod::crJXJCameraMoveUpdateMethod():
m_speed(0.0f){}
crJXJCameraMoveUpdateMethod::crJXJCameraMoveUpdateMethod(const crJXJCameraMoveUpdateMethod& handle):
crMethod(handle),
m_speed(handle.m_speed),
m_limitOffset(handle.m_limitOffset)
{
}
void crJXJCameraMoveUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_updateVisitor = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_updateVisitor = (CRUtil::crUpdateVisitor *)(LOINT64(param64));
		}
		else
		{
			m_updateVisitor = NULL;
		}
		break;
	}
}
void crJXJCameraMoveUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_speed = atof(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_limitOffset);
		break;
	}
}
void crJXJCameraMoveUpdateMethod::domove(CRCore::crMatrix &mat,crVector3 &campos,CRProducer::crViewer *viewer)
{
	//crVector3 pos = mat.getTrans();
	//pos[0] = CRCore::clampTo(pos[0],-xlimit+m_limitOffset[0],xlimit-m_limitOffset[1]);
	//pos[1] = CRCore::clampTo(pos[1],-ylimit+m_limitOffset[2],ylimit-m_limitOffset[3]);
	//mat.setTrans(pos);
	m_this->setMatrix(mat);

	crCamera *camera = viewer->getViewCameraNode();
	crVector3 dir = camera->getCameraDir();
	crVector3 newPos = campos + dir * 2.0f;
	//需要做相机与模型交叉判定
	if(!m_lineSegment.valid())
		m_lineSegment = new crLineSegment;
	m_lineSegment->set(campos,newPos);
	m_iv.reset();
	m_iv.addLineSegment(m_lineSegment.get());
	crSceneManager::getInstance()->getStaticRoot()->accept(m_iv);
	if (m_iv.hits())
	{
		CRCore::crIntersectVisitor::HitList& hitList = m_iv.getHitList(m_lineSegment.get());
		if (!hitList.empty())
		{
			crVector3f lv = campos - hitList.front().getWorldIntersectPoint();
			campos = campos - dir * (lv.length()+2.0f);
			mat.setTrans(campos);
			m_this->setMatrix(mat);
		}
	}
}
void crJXJCameraMoveUpdateMethod::operator()(crHandle &handle)
{
	CRProducer::crViewer *viewer = crKeyboardMouseHandle::getInstance()->getBindViewer();
	if(viewer && viewer->isInited() && m_updateVisitor)
	{
		//读取配置文件
// 		crTableIO::StrVec strVec;
// 		ref_ptr<crTableIO> sysSettingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSystermSettingTab);
// 
// 		if(sysSettingTab && sysSettingTab->queryOneRecord(0,"mousespeed",strVec))
// 		{
// 			int valueIndex = sysSettingTab->getTitleIndex("value");
// 			if(valueIndex>=0)
// 			{
// 				m_speed = atof(strVec[valueIndex].c_str());
// 			}
// 		}
		m_speed = 10.0f;
// 		char speedValue[16];
// 		char filePath[MAX_PATH];
// 		std::string strPath = crGlobalHandle::getInstance()->getGameDir();
// 		sprintf(filePath,"%ssystem.ini",strPath.c_str());
// 		::GetPrivateProfileString("mouse","MoveSpeed","40",speedValue,16,filePath);
// 
// 		
// 		m_speed += atof(speedValue);


		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJBattleCameraMovable,param);
		bool moveable = *(bool *)param;
		if(!moveable) return;

		data->getParam(WCHDATA_JXJCameraMoveSpeed,param);
		float speedValue = *(float *)param;
		m_speed += speedValue;

		data->getParam(WCHDATA_CameraMove,param);
		if(param)
		{
			crMatrix viewerMat = viewer->getViewMatrix();
			viewerMat.setTrans(0,0,0);
			unsigned char cameraMove = *(unsigned char *)param;
			float delta = m_speed * crFrameStamp::getInstance()->getFrameInterval();
			bool changed = false;
			crVector3 movevalue;
			if(cameraMove & crCameraData::MoveLeft)
			{
				movevalue[0] = -delta;
				changed = true;
			}
			else if(cameraMove & crCameraData::MoveRight)
			{
				movevalue[0] = delta;
				changed = true;
			}
			if(cameraMove & crCameraData::MoveUp)
			{
				movevalue[1] = -delta;
				changed = true;
			}
			else if(cameraMove & crCameraData::MoveDown)
			{
				movevalue[1] = delta;
				changed = true;
			}
			if(changed)
			{
				crVector3 _move = viewerMat * movevalue;
				//trans = viewerMat * trans;
				_move[2] = 0.0f;
				crMatrix translate = CRCore::crMatrix::translate(_move);

				crMatrix mat = m_this->getMatrix();
				crVector3 trans = m_this->getTrans();
				crMatrix put_mat = crMatrix::translate(trans);
				crMatrix inv_put = crMatrix::inverse(put_mat);
				mat.postMult(inv_put);
				mat.postMult(translate);
				mat.postMult(put_mat);

				crVector3 campos = mat.getTrans();
				crMatrixf rotation = mat;
				rotation.setTrans(0.0f,0.0f,0.0f);
				crVector3 camDir = (-Y_AXIS * rotation).normalize();
				float x = -campos[2]/camDir[2];
				crVector3 tpos = campos + camDir * x;
				const crVector3f& worldSize = crBrain::getInstance()->getWorldSize();
				float xlimit = worldSize[0] * 0.5f + delta + m_limitOffset[0];
				float ylimit = worldSize[1] * 0.5f + delta + m_limitOffset[1];
				if(fabs(tpos[0])<=xlimit && fabs(tpos[1])<=ylimit)
				{
					domove(mat,campos,viewer);
				}
				else if(fabs(tpos[0])<=xlimit)
				{//Y不能移动
					movevalue[1] = 0.0f;
					_move = viewerMat * movevalue;
					_move[2] = 0.0f;
					translate = CRCore::crMatrix::translate(_move);

					mat = m_this->getMatrix();
					trans = m_this->getTrans();
					put_mat = crMatrix::translate(trans);
					inv_put = crMatrix::inverse(put_mat);
					mat.postMult(inv_put);
					mat.postMult(translate);
					mat.postMult(put_mat);

					campos = mat.getTrans();
					rotation = mat;
					rotation.setTrans(0.0f,0.0f,0.0f);
					camDir = (-Y_AXIS * rotation).normalize();
					x = -campos[2]/camDir[2];
					tpos = campos + camDir * x;
					xlimit = worldSize[0] * 0.5f + delta;
					ylimit = worldSize[1] * 0.5f + delta;
					if(fabs(tpos[0])<=xlimit && fabs(tpos[1])<=ylimit)
					{
						domove(mat,campos,viewer);
					}
				}
				else if(fabs(tpos[1])<=ylimit)
				{//X不能移动
					movevalue[0] = 0.0f;
					_move = viewerMat * movevalue;
					_move[2] = 0.0f;
					translate = CRCore::crMatrix::translate(_move);

					mat = m_this->getMatrix();
					trans = m_this->getTrans();
					put_mat = crMatrix::translate(trans);
					inv_put = crMatrix::inverse(put_mat);
					mat.postMult(inv_put);
					mat.postMult(translate);
					mat.postMult(put_mat);

					campos = mat.getTrans();
					rotation = mat;
					rotation.setTrans(0.0f,0.0f,0.0f);
					camDir = (-Y_AXIS * rotation).normalize();
					x = -campos[2]/camDir[2];
					tpos = campos + camDir * x;
					xlimit = worldSize[0] * 0.5f + delta;
					ylimit = worldSize[1] * 0.5f + delta;
					if(fabs(tpos[0])<=xlimit && fabs(tpos[1])<=ylimit)
					{
						domove(mat,campos,viewer);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCameraScrollMethod
//
/////////////////////////////////////////
float crJXJCameraScrollMethod::s_value = 0.0f;
crJXJCameraScrollMethod::crJXJCameraScrollMethod():
m_step(-1.0f),
m_minDist(5.0f)
{
	s_value = 0.0f;
}

crJXJCameraScrollMethod::crJXJCameraScrollMethod(const crJXJCameraScrollMethod& handle):
crMethod(handle),
m_step(handle.m_step),
m_minDist(handle.m_minDist)
{
	s_value = 0.0f;
}

void crJXJCameraScrollMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCameraScrollMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atof(str.c_str());
		break;
	case 1:
		m_minDist = atof(str.c_str());
		break;
	case 2:
		s_value = atof(str.c_str());
		break;
	}
}

void crJXJCameraScrollMethod::operator()(crHandle &handle)
{
	ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
	if(camera.valid())
	{
		float dt = crFrameStamp::getInstance()->getFrameInterval();
		float offset = m_step * dt * crDisplaySettings::instance()->getMouseSpeed();
		if(offset<0.0f && s_value<-offset)
		{
			offset = -s_value;
		}
		crVector3 dir = camera->getCameraDir();
		crVector3 trans = m_this->getTrans();
		crVector3 newPos = trans + dir * (offset+m_minDist);
		//需要做相机与模型交叉判定
		if(!m_lineSegment.valid())
			m_lineSegment = new crLineSegment;
		if(trans != newPos)
		{
			m_lineSegment->set(trans,newPos);
			m_iv.reset();
			m_iv.addLineSegment(m_lineSegment.get());
			crSceneManager::getInstance()->getStaticRoot()->accept(m_iv);
			if (!m_iv.hits())
			{
				s_value += offset;
				newPos = trans + dir * offset;
				m_this->setPosition(newPos);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCameraRotMethod
//
/////////////////////////////////////////
crJXJCameraRotMethod::crJXJCameraRotMethod():
	m_flg(0)
{
}

crJXJCameraRotMethod::crJXJCameraRotMethod(const crJXJCameraRotMethod& handle):
	crMethod(handle),
	m_flg(handle.m_flg)
{
}

void crJXJCameraRotMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCameraRotMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_flg = (unsigned char)(atoi(str.c_str()));
		break;
	}
}

void crJXJCameraRotMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_CameraRot,&m_flg);
}
/////////////////////////////////////////
//
//crJXJCameraRotUpdateMethod
//
/////////////////////////////////////////
crJXJCameraRotUpdateMethod::crJXJCameraRotUpdateMethod():
	m_speed(CRCore::PI_4),
	m_recoverSpeed(CRCore::PI_4),
	m_cameraRot(0.0f)
{
}

crJXJCameraRotUpdateMethod::crJXJCameraRotUpdateMethod(const crJXJCameraRotUpdateMethod& handle):
	crMethod(handle),
	m_speed(handle.m_speed),
	m_recoverSpeed(handle.m_recoverSpeed),
	m_cameraRot(0.0f)
{
}

void crJXJCameraRotUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}

void crJXJCameraRotUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_speed = CRCore::DegreesToRadians(atof(str.c_str()));
		break;
	case 1:
		m_recoverSpeed = CRCore::DegreesToRadians(atof(str.c_str()));
		break;
	}
}

void crJXJCameraRotUpdateMethod::operator()(crHandle &handle)
{
	void * param;
	crData *cameraData = m_this->getDataClass();
	cameraData->getParam(WCHDATA_CameraRot,param);
	unsigned char rot = *(unsigned char *)param;
	if(rot == crCameraData::None)
	{
		if(m_cameraRot!=0.0f)
		{
			float dt = crFrameStamp::getInstance()->getFrameInterval();
			float offset = m_recoverSpeed * dt;
			if(m_cameraRot>0.0f)
			{
				offset = -offset;
			}
			if(fabs(offset)>=fabs(m_cameraRot))
			{
				offset = -(m_cameraRot);
				m_cameraRot = 0.0f;
			}
			else
				m_cameraRot += offset;

			crMatrix rotate = CRCore::crMatrix::rotate(offset, Z_AXIS);

			crVector3 campos = m_this->getTrans();
			crMatrixf rotation = m_this->getMatrix();
			rotation.setTrans(0.0f,0.0f,0.0f);
			crVector3 camDir = (-Y_AXIS * rotation).normalize();
			float x = -campos[2]/camDir[2];
			crVector3 centerpos = campos + camDir * x;

			rotation.postMult(rotate);
			crVector3 newDir = (-Y_AXIS * rotation).normalize();
			crVector3 newPos = centerpos - newDir*x;
			rotation.setTrans(newPos);

			m_this->setMatrix(rotation);
		}
	}
	else if (rot == crCameraData::RotRight || rot == crCameraData::RotLeft)
	{
		float dt = crFrameStamp::getInstance()->getFrameInterval();
		float offset = m_speed * dt;
		if(rot == crCameraData::RotRight)
			offset = -offset;
		if(fabs(m_cameraRot + offset)>(float)CRCore::PI)
		{
			offset = (float)(CRCore::PI) - fabs(m_cameraRot);
			if(m_cameraRot<0.0f)
				offset = -offset;
		}
		if(offset != 0.0f)
		{
			m_cameraRot += offset;
			crMatrix rotate = CRCore::crMatrix::rotate(offset, Z_AXIS);

			crVector3 campos = m_this->getTrans();
			crMatrixf rotation = m_this->getMatrix();
			rotation.setTrans(0.0f,0.0f,0.0f);
			crVector3 camDir = (-Y_AXIS * rotation).normalize();
			float x = -campos[2]/camDir[2];
			crVector3 centerpos = campos + camDir * x;

			rotation.postMult(rotate);
			crVector3 newDir = (-Y_AXIS * rotation).normalize();
			crVector3 newPos = centerpos - newDir*x;
			rotation.setTrans(newPos);

			m_this->setMatrix(rotation);
		}
	}
}
/////////////////////////////////////////
//
//crJXJBuildingLevelUpCheckMethod
//
/////////////////////////////////////////
crJXJBuildingLevelUpCheckMethod::crJXJBuildingLevelUpCheckMethod():
	m_this(NULL),
	m_buildingid(0),
	m_result(NULL)
{
}
crJXJBuildingLevelUpCheckMethod::crJXJBuildingLevelUpCheckMethod(const crJXJBuildingLevelUpCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_buildingid(handle.m_buildingid),
	m_result(NULL)
{
}
void crJXJBuildingLevelUpCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_result = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_buildingid = LOINT64(param64);
			m_result = (BuildingLevelUpCheckResult *)(HIINT64(param64));
		}
		else
		{
			m_result = NULL;
		}
		break;
	}
}
void crJXJBuildingLevelUpCheckMethod::addParam(int i, const std::string& str)
{
}
void crJXJBuildingLevelUpCheckMethod::operator()(crHandle &handle)
{
	void *param;
	crData *playerData = m_this->getDataClass();
	playerData -> getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());
	if(m_this && m_result && m_buildingid > 0)
	{
		int buildingid2 = 0;
		if (m_buildingid >=WCHDATA_JXJMingjulv1 && m_buildingid <= WCHDATA_JXJMingjulv8)
		{
			buildingid2 = WCHDATA_JXJMingjulv;
		}
		if (m_buildingid >=WCHDATA_JXJNongtianlv1 && m_buildingid <= WCHDATA_JXJNongtianlv8)
		{
			buildingid2 = WCHDATA_JXJNongtianlv;
		}
		if (m_buildingid >=WCHDATA_JXJMuchanglv1 && m_buildingid <= WCHDATA_JXJMuchanglv4)
		{
			buildingid2 = WCHDATA_JXJMuchanglv;
		}
		if (m_buildingid >=WCHDATA_JXJLingdilv1 && m_buildingid <= WCHDATA_JXJLingdilv4)
		{
			buildingid2 = WCHDATA_JXJLingdilv;
		}
		if (m_buildingid >=WCHDATA_JXJKuangshanlv1 && m_buildingid <= WCHDATA_JXJKuangshanlv4)
		{
			buildingid2 = WCHDATA_JXJKuangshanlv;
		}
		if (buildingid2 == 0)
		{
			buildingid2 = m_buildingid;
		}
		std::string idStr = crArgumentParser::appItoa(buildingid2);
		//playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(m_buildingid,param);
		unsigned char buildinglv;
		int nextlv;
		if(param)
		{
			buildinglv = *(unsigned char *)(param);
			nextlv = buildinglv + 1;
		}
		///
		ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
		int timeid = buildinglvTab->getTitleIndex("时间");
		int copperid = buildinglvTab->getTitleIndex("铜钱");
		int woodid = buildinglvTab->getTitleIndex("木材");
		int ironid = buildinglvTab->getTitleIndex("铁矿");
		int foodid = buildinglvTab->getTitleIndex("粮食");
		crTableIO::StrVec record;
		if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
		{
			playerData->getParam(WCHDATA_JXJBuildingTimes,param);
			crVector4i buildingTimes = *(crVector4i *)param;
			playerData->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
			int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime,viplv).c_str()));
			int i = 0;
			int timeRemain = 0;
			/////时间
			for(; i<4; i++)
			{
				if(crGlobalHandle::isClient())
				{
					if(buildingTimes[i]>=0 && buildingTimes[i]<overTimes-60)
						timeRemain += overTimes - buildingTimes[i] + credittime;
				}
				else
				{
					if(buildingTimes[i]>=0 && buildingTimes[i]<overTimes)
						timeRemain += overTimes - buildingTimes[i] + credittime;
				}
				//break;
			}
			m_result->m_timeNeed = atoi(record[timeid].c_str());
			float speed = 0.0f;
			m_this->doEvent(WCH_JXJGetBuildingLevelUpSpeed,MAKEINT64(&speed,NULL));
			m_result->m_timeNeed = ceil((float)m_result->m_timeNeed * (1.0f - speed));
			///
			m_result->m_code = 1;
			///
			float consume = 0.0f;
			m_this->doEvent(WCH_JXJGetBuildingLevelUpConsume,MAKEINT64(&consume,NULL));
			//铜钱
			playerData->getParam(WCHDATA_JXJCoppercash,param);
			int coppercash = *(int *)param;
			m_result->m_coppercashNeed = atoi(record[copperid].c_str());
			m_result->m_coppercashNeed = ceil((float)m_result->m_coppercashNeed * (1.0f - consume));		
			//木材
			playerData->getParam(WCHDATA_JXJWood,param);
			int wood = *(int *)param;
			m_result->m_woodNeed = atoi(record[woodid].c_str());
			m_result->m_woodNeed = ceil((float)m_result->m_woodNeed * (1.0f - consume));
			//铁矿
			playerData->getParam(WCHDATA_JXJIron,param);
			int iron = *(int *)param;
			m_result->m_ironNeed = atoi(record[ironid].c_str());
			m_result->m_ironNeed = ceil((float)m_result->m_ironNeed * (1.0f - consume));
			//粮食
			playerData->getParam(WCHDATA_JXJFood,param);
			int food = *(int *)param;
			m_result->m_foodNeed = atoi(record[foodid].c_str());
			m_result->m_foodNeed = ceil((float)m_result->m_foodNeed * (1.0f - consume));
			///
			do 
			{
				playerData->getParam(WCHDATA_JXJFuyalv,param);
				unsigned char fuyalv = *(unsigned char *)param;
				if(m_buildingid == WCHDATA_JXJFuyalv)
				{//角色等级
					crRole *mainRole = m_this->getMainRole();
					if(mainRole && mainRole->getDataClass())
					{
						crData *roleData = mainRole->getDataClass();
						roleData->getParam(WCHDATA_Level,param);
						unsigned char rolelv = *(unsigned char *)param;
						if(nextlv > maxlv)
						{//超过最高等级
							m_result->m_code = -8;
							break;
						}
						else if(nextlv>(int)rolelv)
						{//超过角色等级
							m_result->m_code = -1;
							break;
						}
					}
				}
				else 
				{
					if(nextlv > maxlv)
					{//超过最高等级
						m_result->m_code = -8;
						break;
					}
					else if(nextlv > (int)fuyalv)
					{//超过府衙等级
						m_result->m_code = -1;
						break;
					}
				}

				if(timeRemain<m_result->m_timeNeed)
				{//没有建筑时间
					m_result->m_code = -2;
					break;
				}
				if(coppercash < m_result->m_coppercashNeed)
				{//铜钱不足
					m_result->m_code = -3;
					break;
				}
				if(wood < m_result->m_woodNeed)			
				{//木材不足
					m_result->m_code = -4;
					break;
				}

				if(iron < m_result->m_ironNeed)
				{//铁矿不足
					m_result->m_code = -5;
					break;
				}
				if(food < m_result->m_foodNeed)
				{//粮食不足
					m_result->m_code = -6;
					break;
				}
			}while (0);
		} 
		else
		{
			m_result->m_code = -7;
		}
		//playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}


/////////////////////////////////////////
//
//crJXJBuildingLevelUpMethod
//
/////////////////////////////////////////
crJXJBuildingLevelUpMethod::crJXJBuildingLevelUpMethod()
{
}
crJXJBuildingLevelUpMethod::crJXJBuildingLevelUpMethod(const crJXJBuildingLevelUpMethod& handle):
	crMethod(handle)
{
}
void crJXJBuildingLevelUpMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	default:
		break;
	}
}
void crJXJBuildingLevelUpMethod::addParam(int i, const std::string& str)
{
}
void crJXJBuildingLevelUpMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	//bool cancelTask = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!myPlayer) return;

	// check level up
	void *param;
	crData *canvasData = canvas->getDataClass();
	canvasData->getParam(WCHDATA_JXJCheckBuildingID,param);
	int buildingid = *(int *)param;
	//
	BuildingLevelUpCheckResult result;
	result.m_code = 0;
	myPlayer->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(result.m_code <= 0 || !netConductor) return;

	// parse and send package
	crData *playerData = myPlayer->getDataClass();
	playerData->getParam(buildingid,param);
	unsigned char buildinglv = *(unsigned char *)(param);
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(4);
	stream->_writeInt(buildingid);
	//stream->_writeUChar(buildinglv);
	//stream->_writeInt(int(m_this));
	crPlayerDataEventPacket packet;
	crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuildingLevelUp,stream.get());
	netConductor->getNetManager()->sendPacket("all",packet);
	
	//播放特效
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(scene && buildingid>0)
	{
		crData *itemdata;
		void *param;
		crInstanceItem *item;
		int itembuildingid;
		CRNetApp::crScene::SceneItemMap &sceneItemMap = scene->getSceneItemMap();
		for( CRNetApp::crScene::SceneItemMap::iterator itr = sceneItemMap.begin();
			itr != sceneItemMap.end();
			++itr )
		{
			item = itr->second.get();
			itemdata = item->getDataClass();
			itemdata->getParam(WCHDATA_JXJBuildingID,param);
			if(param)
			{
				itembuildingid = *(int *)param;
				if(itembuildingid == buildingid)
				{
					item->doEvent(WCH_JXJBuildingLevelChange);
					break;
				}
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIBuildLevelUpCheckMethod
//
/////////////////////////////////////////
crJXJUIBuildLevelUpCheckMethod::crJXJUIBuildLevelUpCheckMethod()
{
}
crJXJUIBuildLevelUpCheckMethod::crJXJUIBuildLevelUpCheckMethod(const crJXJUIBuildLevelUpCheckMethod& handle):
	crMethod(handle),
	m_levelup(handle.m_levelup),
	m_prompt(handle.m_prompt),
	m_time(handle.m_time),
	m_need(handle.m_need),
	m_money(handle.m_money),
	m_wood(handle.m_wood),
	m_iron(handle.m_iron),
	m_food(handle.m_food),
	m_canvasname(handle.m_canvasname),
	m_level(handle.m_level),
	m_nowproduce(handle.m_nowproduce),
	m_nextproduce(handle.m_nextproduce),
	m_onekeylevelup(handle.m_onekeylevelup)
{
}
void crJXJUIBuildLevelUpCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIBuildLevelUpCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_levelup = str;
		break;
	case 1:
		m_prompt = str;
		break;
	case 2:
		m_time = str;
		break;
	case 3:
		m_need = str;
		break;
	case 4:
		m_money = str;
		break;
	case 5:
		m_wood = str;
		break;
	case 6:
		m_iron = str;
		break;
	case 7:
		m_food = str;
		break;
	case 8:
		m_canvasname = str;
		break;
	case 9:
		m_level = str;
		break;
	case 10:
		m_nowproduce = str;
		break;
	case 11:
		m_nextproduce = str;
		break;
	case 12:
		m_onekeylevelup = str;
		break;
	}
}
void crJXJUIBuildLevelUpCheckMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());
		crButtonWidgetNode *levelup = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_levelup));
		crButtonWidgetNode *onekeylevelup = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_onekeylevelup));
		ref_ptr<crCanvasNode> canvas = m_this;//dynamic_cast<crCanvasNode *>(m_this->getWidget(m_canvasname));
		crStaticTextWidgetNode *warning = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_prompt));
		crStaticTextWidgetNode *time = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_time));
		crStaticTextWidgetNode *need = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_need));
		crStaticTextWidgetNode *money = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_money));
		crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_wood));
		crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_iron));
		crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_food));
		crStaticTextWidgetNode *lv = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_level));
		//crStaticTextWidgetNode *nowproduce = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nowproduce));
		//crStaticTextWidgetNode *nextproduce = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextproduce));
		crHypertextWidgetNode *nowproduce = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_nowproduce));
		crHypertextWidgetNode *nextproduce = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_nextproduce));


		std::string warningtext;
		crVector4f colorwhite = (crVector4f(32.0f,32.0f,32.0f,255.0f)/255.0f);
		crVector4f colorred = (crVector4f(140.0f,40.0f,40.0f,255.0f)/255.0f);
		crData *canvasdata = canvas ->getDataClass();
		canvasdata -> getParam(WCHDATA_JXJCheckBuildingID,param);
		int buildingid = *(int *)param;
		if (buildingid > 0)
		{
			int resourcereduce = 0; //资源需求减少量
			BuildingLevelUpCheckResult result;
			result.m_code = 0;
			myPlayer->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
			if(levelup)levelup->setEnable(result.m_code>0);
			if(onekeylevelup)onekeylevelup->setEnable(result.m_code>0);
			
			///////////////////////////////////////
			float percent[4] = {0.0f};
			float percent1[4] = {0.0f};
			crRole *mainRole = myPlayer->getMainRole();
			//crData *mainRole
			if(mainRole && data)
			{
				for (int i = 0; i < 4; i++)
				{
					mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent[i],i+1));//1.food,2.wood,3.iron,4.horse
					myPlayer->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1[i],i+1));
					percent[i] += percent1[i];
				}
			}

			///////////////////////////////////////////////
			data->getParam(buildingid,param);
			unsigned char buildinglv = *(unsigned char *)param;
			int nextlv = buildinglv + 1;
			int buildingid2 = 0;
			if (buildingid >=WCHDATA_JXJMingjulv1 && buildingid <= WCHDATA_JXJMingjulv8)
			{
				buildingid2 = WCHDATA_JXJMingjulv;
			}
			if (buildingid >=WCHDATA_JXJNongtianlv1 && buildingid <= WCHDATA_JXJNongtianlv8)
			{
				buildingid2 = WCHDATA_JXJNongtianlv;
			}
			if (buildingid >=WCHDATA_JXJMuchanglv1 && buildingid <= WCHDATA_JXJMuchanglv4)
			{
				buildingid2 = WCHDATA_JXJMuchanglv;
			}
			if (buildingid >=WCHDATA_JXJLingdilv1 && buildingid <= WCHDATA_JXJLingdilv4)
			{
				buildingid2 = WCHDATA_JXJLingdilv;
			}
			if (buildingid >=WCHDATA_JXJKuangshanlv1 && buildingid <= WCHDATA_JXJKuangshanlv4)
			{
				buildingid2 = WCHDATA_JXJKuangshanlv;
			}
			if (buildingid2 == 0)
			{
				buildingid2 = buildingid;
			}
			std::string idStr = crArgumentParser::appItoa(buildingid2);
			std::string str;

			if(lv)
			{
				unsigned char oldlv = atoi(lv->getUTF8String().c_str());
				if (oldlv != buildinglv)
				{
					cancelTask = false;
				}
				lv->setString(crArgumentParser::appItoa(buildinglv));
			}
			if(need)
			{
				data->getParam(WCHDATA_JXJFuyalv,param);
				unsigned char fuyalv = *(unsigned char *)param;
				if (buildingid2 != WCHDATA_JXJFuyalv)
				{
					need->setColor(colorwhite);
					if (fuyalv < nextlv)
					{
						need->setColor(colorred);
					}
					std::string str;
					str = crArgumentParser::appItoa(nextlv);
					need->setString(str);
				}
				else
				{
					crData *RoleData = myPlayer->getMainRole()->getDataClass();
					if (RoleData)
					{
						RoleData->getParam(WCHDATA_Level,param);
						unsigned char characterlv = *(unsigned char *)param;
						need->setColor(colorwhite);
						if (characterlv < nextlv)
						{
							need->setColor(colorred);
						}
						std::string str;
						str = crArgumentParser::appItoa(nextlv);
						need->setString(str);
					}
				}
			}
			int tempbuildinglv = buildinglv;
			int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());

			if (nowproduce && nextproduce)
			{
				std::string kuangshiLevStr0;
				std::string kuangshiLevStr1;
				std::string kuangshiLevStr2;
				std::string kuangshiNextLevStr0;
				std::string kuangshiNextLevStr1;
				std::string kuangshiNextLevStr2;

				bool levLow = false;
				bool levHeig = false;
				bool peopleShow = false;
				
				std::vector<float> v_i;
				crVector4f colorGreen = crVector4f(0.0f,255.0f,0.0f,255.0f);
				for (int i = 0; i<4;i++)
				{
					v_i.push_back(colorGreen[i]);
				}

				for (int ii = 0; ii < 2; ii++)
				{
					std::string population, food, wood, iron, horse,foodadd,woodadd,ironadd,horseadd;
					std::string strproduce;
					std::string nowlv = crArgumentParser::appItoa(tempbuildinglv);
					crTableIO::StrVec recordproduce;
					ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);

					if (tempbuildinglv == 0)
					{
						//strproduce = "当前无产出。";
						//nowproduce->setString(strproduce);
						levLow = true;
					}
					else if (tempbuildinglv > maxlv)
					{
						//strproduce = "已达到最高级。";
						//nextproduce->setString(strproduce);
						levHeig = true;
					}
					else if(resbuildingTab->queryOneRecord(0,nowlv,recordproduce)>=0)
					{			
						population = recordproduce[1].c_str();
						//粮食
						food = recordproduce[2].c_str();
						foodadd =  crArgumentParser::appItoa(atoi(food.c_str()) * percent[0]);
						int totalFood = atoi(food.c_str()) * (1 + percent[0]);
						//木材
						wood = recordproduce[3].c_str();
						woodadd =  crArgumentParser::appItoa(atoi(wood.c_str()) * percent[1]);
						int totalWood = atoi(wood.c_str()) * (1 + percent[1]);
						//铁矿
						iron = recordproduce[4].c_str();
						ironadd =  crArgumentParser::appItoa(atoi(iron.c_str()) * percent[2]);
						int totalIron = atoi(iron.c_str()) * (1 + percent[2]);
						//马匹
						horse = recordproduce[5].c_str();
						horseadd =  crArgumentParser::appItoa(atoi(horse.c_str()) * percent[3]);
						int totalHorse = atoi(horse.c_str()) * (1 + percent[3]);
						switch (buildingid)
						{
						case WCHDATA_JXJMingjulv1:
						case WCHDATA_JXJMingjulv2:
						case WCHDATA_JXJMingjulv3:
						case WCHDATA_JXJMingjulv4:
						case WCHDATA_JXJMingjulv5:
						case WCHDATA_JXJMingjulv6:
						case WCHDATA_JXJMingjulv7:
						case WCHDATA_JXJMingjulv8:
							if (ii == 0)
							{
								//nowproduce->setString(population+"人口");
								kuangshiLevStr1 = population+"人口";
								peopleShow = true;
							}
							else
							{
								//nextproduce->setString(population+"人口");
								kuangshiNextLevStr1 = population+"人口";
								peopleShow = true;
							}
							break;
						case WCHDATA_JXJNongtianlv1:
						case WCHDATA_JXJNongtianlv2:
						case WCHDATA_JXJNongtianlv3:
						case WCHDATA_JXJNongtianlv4:
						case WCHDATA_JXJNongtianlv5:
						case WCHDATA_JXJNongtianlv6:
						case WCHDATA_JXJNongtianlv7:
						case WCHDATA_JXJNongtianlv8:	
							if (ii == 0)
							{
								//nowproduce->setString(food+"(+"+foodadd+") 粮食/小时");
								//kuangshiLevStr0 = food + foodadd;
								kuangshiLevStr0 = crArgumentParser::appItoa(totalFood);
								kuangshiLevStr1 = "(+"+foodadd+")";
								kuangshiLevStr2 = " 粮食/小时";
							}
							else
							{
								//nextproduce->setString(food+"(+"+foodadd+") 粮食/小时");
								kuangshiNextLevStr0 = crArgumentParser::appItoa(totalFood);
								//kuangshiNextLevStr0 = food + foodadd;
								kuangshiNextLevStr1 = "(+"+foodadd+")";
								kuangshiNextLevStr2 = " 粮食/小时";
							}
							break;
						case WCHDATA_JXJLingdilv1:
						case WCHDATA_JXJLingdilv2:
						case WCHDATA_JXJLingdilv3:
						case WCHDATA_JXJLingdilv4:
							if (ii == 0)
							{
								//nowproduce->setString(wood+"(+"+woodadd+") 木材/小时");
								kuangshiLevStr0 = crArgumentParser::appItoa(totalWood);
								//kuangshiLevStr0 = wood + woodadd;
								kuangshiLevStr1 = "(+"+woodadd+")";
								kuangshiLevStr2 = " 木材/小时";
							}
							else
							{
								//nextproduce->setString(wood+"(+"+woodadd+") 木材/小时");
								kuangshiNextLevStr0 = crArgumentParser::appItoa(totalWood);
								//kuangshiNextLevStr0 = wood + woodadd;
								kuangshiNextLevStr1 = "(+"+woodadd+")";
								kuangshiNextLevStr2 = " 木材/小时";
							}
							break;
						case WCHDATA_JXJMuchanglv1:
						case WCHDATA_JXJMuchanglv2:
						case WCHDATA_JXJMuchanglv3:
						case WCHDATA_JXJMuchanglv4:
							if (ii == 0)
							{
								//nowproduce->setString(horse+"(+"+horseadd+") 马匹/小时");
								kuangshiLevStr0 = crArgumentParser::appItoa(totalHorse);
								//kuangshiLevStr0 = horse + horseadd;
								kuangshiLevStr1 = "(+"+horseadd+")";
								kuangshiLevStr2 = " 马匹/小时";
							}
							else
							{
								//nextproduce->setString(horse+"(+"+horseadd+") 马匹/小时");
								kuangshiNextLevStr0 = crArgumentParser::appItoa(totalHorse);
								//kuangshiNextLevStr0 = horse + horseadd;
								kuangshiNextLevStr1 = "(+"+horseadd+")";
								kuangshiNextLevStr2 = " 马匹/小时";
							}
							break;
						case WCHDATA_JXJKuangshanlv1:
						case WCHDATA_JXJKuangshanlv2:
						case WCHDATA_JXJKuangshanlv3:
						case WCHDATA_JXJKuangshanlv4:
							if (ii == 0)
							{
								//nowproduce->setString(iron+"(+"+ironadd+") 矿石/小时");
								kuangshiLevStr0 = crArgumentParser::appItoa(totalIron);
								//kuangshiLevStr0 = iron + ironadd;
								kuangshiLevStr1 = "(+"+ironadd+")";
								kuangshiLevStr2 = " 矿石/小时";
							}
							else
							{
								//nextproduce->setString(iron+"(+"+ironadd+") 矿石/小时");
								kuangshiNextLevStr0 = crArgumentParser::appItoa(totalIron);
								//kuangshiNextLevStr0 = iron + ironadd;
								kuangshiNextLevStr1 = "(+"+ironadd+")";
								kuangshiNextLevStr2 = " 矿石/小时";
							}
							break;
						}
					}
					tempbuildinglv++;
				} // for (int ii = 0; ii < 2; ii++)

				//std::string kuangshiLevStr1;
				//std::string kuangshiLevStr2;
				//std::string kuangshiNextLevStr1;
				//std::string kuangshiNextLevStr2;
				if (levLow)
				{
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					int index = 1;
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					//cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", "当前无产出。");
					cfg_script.Pop();

					cfg_script.Pop();
					nowproduce->setHypertext(cfg_script);
					//cfg_script.Close();
				}
				else
				{
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					int index = 1;

					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					//cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", kuangshiLevStr0);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					if (!peopleShow)
						cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", kuangshiLevStr1);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					//cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", kuangshiLevStr2);
					cfg_script.Pop();

					cfg_script.Pop();
					nowproduce->setHypertext(cfg_script);
					//cfg_script.Close();
				}

				if (levHeig)
				{
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					int index = 1;
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					//cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", "已达到最高级。");
					cfg_script.Pop();

					cfg_script.Pop();
					nextproduce->setHypertext(cfg_script);
					//cfg_script.Close();
				}
				else
				{
				
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					int index = 1;

					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					//cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", kuangshiNextLevStr0);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					if (!peopleShow)
						cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", kuangshiNextLevStr1);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					//cfg_script.Add("Color",v_i);
					cfg_script.Add("Text", kuangshiNextLevStr2);
					cfg_script.Pop();

					cfg_script.Pop();
					nextproduce->setHypertext(cfg_script);
					//cfg_script.Close();
					
				}
	
			} // if (nowproduce && nextproduce)

			////////////////////////////////////////
			//BuildingLevelUpCheckResult result;
			//result.m_code = 0;
			//myPlayer->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
			///////////////////////
			ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
			int timeid = buildinglvTab->getTitleIndex("时间");
			int copperid = buildinglvTab->getTitleIndex("铜钱");
			int woodid = buildinglvTab->getTitleIndex("木材");
			int ironid = buildinglvTab->getTitleIndex("铁矿");
			int foodid = buildinglvTab->getTitleIndex("粮食");
			if(warning)warning->clearString();
			crTableIO::StrVec record;
			if (nextlv>=maxlv)
			{
				if(money) money->setColor(colorred);
				warningtext = "已达到最高等级";
				if(warning)warning->setString(warningtext);
			}
			if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
			{
				//float cdpercent = 0.0f;
				//int times = atoi(record[timeid].c_str());
				int times = 0;
				times = result.m_timeNeed;
				//myPlayer->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&cdpercent,NULL));
				warningtext = "资源不足";
				if(time)
				{
					time->setColor(colorwhite);

					int hour = times/3600;
					int t = times%3600;
					int minute = t/60;
					int s = t%60;
					time->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
				}
				if(money)
				{
					money->setColor(colorwhite);
					data->getParam(WCHDATA_JXJCoppercash,param);
					int coppercash = *(int *)param;
					if (coppercash<result.m_coppercashNeed)
					{
						money->setColor(colorred);
						if(warning)warning->setString(warningtext);
					}
					//money->setString(record[copperid] + "-" + "(" +crArgumentParser::appItoa(result.m_coppercashNeed)  + ")");
					money->setString(crArgumentParser::appItoa(result.m_coppercashNeed));
				}
				if(wood)
				{
					//木材
					wood->setColor(colorwhite);
					data->getParam(WCHDATA_JXJWood,param);
					int woodgot = *(int *)param;
					if (woodgot<result.m_woodNeed)
					{
						wood->setColor(colorred);
						if(warning)warning->setString(warningtext);
					}
					//wood->setString(record[woodid]);
					wood->setString(crArgumentParser::appItoa(result.m_woodNeed));
				}
				if(iron)
				{
					//铁矿
					iron->setColor(colorwhite);
					data->getParam(WCHDATA_JXJIron,param);
					int irongot = *(int *)param;
					if (irongot<result.m_ironNeed)
					{
						iron->setColor(colorred);
						if(warning)warning->setString(warningtext);
					}
					//iron->setString(record[ironid]);
					iron->setString(crArgumentParser::appItoa(result.m_ironNeed));
				}
				if(food)
				{
					//粮食
					food->setColor(colorwhite);
					data->getParam(WCHDATA_JXJFood,param);
					int foodgot = *(int *)param;
					if (foodgot<result.m_foodNeed)
					{
						food->setColor(colorred);
						if(warning)warning->setString(warningtext);
					}
					//food->setString(record[foodid]);
					food->setString(crArgumentParser::appItoa(result.m_foodNeed));
				}
				/////////////////////////////////////////////
				data->getParam(WCHDATA_JXJFuyalv,param);
				unsigned char fuyalv = *(unsigned char *)param;
				if(buildingid == WCHDATA_JXJFuyalv)
				{//角色等级
					crRole *mainRole = myPlayer->getMainRole();
					crData *roleData = mainRole->getDataClass();
					roleData->getParam(WCHDATA_Level,param);
					unsigned char rolelv = *(unsigned char *)param;
					if(nextlv>(int)rolelv)
					{//超过角色等级
						warningtext = "角色等级不足";
						if(warning)warning->setString(warningtext);
					}
				}
				else if(nextlv > (int)fuyalv)
				{//超过府衙等级
					warningtext = "府衙等级不足";
					if(warning)warning->setString(warningtext);
				}
				ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
				int timeid = buildinglvTab->getTitleIndex("时间");
				crTableIO::StrVec record;
				if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
				{
					/////时间
					data->getParam(WCHDATA_JXJBuildingTimes,param);
					crVector4i buildingTimes = *(crVector4i *)param;
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char*)param;
					short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
					int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime,viplv).c_str()));
					int i = 0;
					int timeRemain = 0;
					for(; i<4; i++)
					{
						if(buildingTimes[i]>=0 && buildingTimes[i]<overTimes)
							timeRemain += overTimes - buildingTimes[i] + credittime;
					}
					if(timeRemain<times)
					{//没有建筑时间
						warningtext = "建筑时间不足";
						if(time)time->setColor(colorred);
						if(warning)warning->setString(warningtext);
					}
				}
			}
			else
			{
				//////
				if (nextlv>maxlv)
				{
					if(time)time->clearString();
					if(money)money->clearString();
					if(wood)wood->clearString();
					if(iron)iron->clearString();
					if(food)food->clearString();
				}
			}
		}
		//////////
	}
	handle.outputParam(0,&cancelTask);
}


/////////////////////////////////////////
//
//crJXJRecvBuildingLevelUpMethod
//
/////////////////////////////////////////
crJXJRecvBuildingLevelUpMethod::crJXJRecvBuildingLevelUpMethod():
	m_netType(GameClient_Game){}
crJXJRecvBuildingLevelUpMethod::crJXJRecvBuildingLevelUpMethod(const crJXJRecvBuildingLevelUpMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBuildingLevelUpMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvBuildingLevelUpMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvBuildingLevelUpMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int buildingid = m_stream->_readInt();
			//unsigned char buildinglv = m_stream->_readUChar();
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(buildingid,param);
			unsigned char sbuildinglv = *(unsigned char *)param;
			if(sbuildinglv==0)
				return;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			BuildingLevelUpCheckResult result;
			result.m_code = 0;
			int *coppercash = NULL;
			int *wood = NULL;
			int *iron = NULL;
			int *food = NULL;
			bool bFree = false;
			crVector4i* buildingTimes = NULL;
			//if(sbuildinglv == buildinglv)
			//{
				m_this->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
				if(result.m_code>0)
				{
					///////时间
					data->getParam(WCHDATA_JXJBuildingTimes,param);
					buildingTimes = (crVector4i *)param;
					short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
					int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime,viplv).c_str()));
					int i = 0;
					int t;
					for(int i = 0; result.m_timeNeed>0 && i<4; i++)
					{
						if((*buildingTimes)[i]>=0 && (*buildingTimes)[i]<overTimes)
						{
							t = overTimes + credittime - (*buildingTimes)[i];
							if(result.m_timeNeed>t)
							{
								(*buildingTimes)[i] += t;
								result.m_timeNeed -= t;
							}
							else
							{
								(*buildingTimes)[i] += result.m_timeNeed;
								result.m_timeNeed = 0;
							}
						}
					}
					if(result.m_timeNeed>0)
					{
						for(int i = 0; i<4; i++)
						{
							if((*buildingTimes)[i]>=0 && (*buildingTimes)[i]<=overTimes)
							{

								(*buildingTimes)[i] += result.m_timeNeed ;						
								break;
							}
						}
					}
					//铜钱
					data->getParam(WCHDATA_JXJCoppercash,param);
					coppercash = (int *)param;
					*coppercash -= result.m_coppercashNeed;
					//木材
					data->getParam(WCHDATA_JXJWood,param);
					wood = (int *)param;
					*wood -= result.m_woodNeed;
					//铁矿
					data->getParam(WCHDATA_JXJIron,param);
					iron = (int *)param;
					*iron -= result.m_ironNeed;
					//粮食
					data->getParam(WCHDATA_JXJFood,param);
					food = (int *)param;
					*food -= result.m_foodNeed;

					sbuildinglv += 1;
					data->inputParam(buildingid,&sbuildinglv);
					if (buildingid == WCHDATA_JXJFuyalv)
					{//酒肆，市场，兵营，工坊等级等于府衙等级
						data->inputParam(WCHDATA_JXJJiusilv,&sbuildinglv);
						data->inputParam(WCHDATA_JXJShijilv,&sbuildinglv);
						data->inputParam(WCHDATA_JXJBingyinglv,&sbuildinglv);
						data->inputParam(WCHDATA_JXJGongfanglv,&sbuildinglv);
					}
					//市集30级送免费购买资源
					if (buildingid == WCHDATA_JXJShijilv)
					{
						int freeLevel = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMarketFreeBuyLevel,viplv).c_str());
						if (sbuildinglv == freeLevel)
						{
							bFree = true;
							data->inputParam(WCHDATA_JXJFreeBuyInfo,0);
						}
					}
                    m_this->doEvent(WCH_JXJCheck7Day);
				}
				//}
			data->excHandle(MAKEINT64(WCH_LockData,0));

			//建筑升级增加成长值
		//	int bulidingToVipExpFactor = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBulidingLvUpToVipExpFactor,viplv).c_str());
		//	m_this->doEvent(WCH_JXJAddVipExp,MAKEINT64(bulidingToVipExpFactor,NULL));

			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(39/* + 4*/);
				stream->_writeChar(result.m_code);
				stream->_writeInt(buildingid);
				stream->_writeUChar(sbuildinglv);
				if(result.m_code>0)
				{
					stream->_writeVec4i(*buildingTimes);//16
					stream->_writeInt(*coppercash);//4
					stream->_writeInt(*wood);//4
					stream->_writeInt(*iron);//4
					stream->_writeInt(*food);//4
				}
				stream->_writeBool(bFree);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuildingLevelUp,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				if(result.m_code>0)
				{
					///游戏日志
					std::string logdata = "建筑升级id,lv:" + crArgumentParser::appVectoa(crVector2i(buildingid,sbuildinglv));
					GameLogData gamelog(Log_BuildLevelup,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			//void *param;
			//char *ptr = m_stream->getPtr();
			crData *braindata = crBrain::getInstance()->getDataClass();
			char returnCode = m_stream->_readChar();
			int buildingid = m_stream->_readInt();
			unsigned char sbuildinglv = m_stream->_readUChar();
			crData *data = m_this->getDataClass();
			data->inputParam(buildingid,&sbuildinglv);
			if(returnCode>0)
			{
				crVector4i buildingTimes = m_stream->_readVec4i();
				data->inputParam(WCHDATA_JXJBuildingTimes,&buildingTimes);
				int coppercash = m_stream->_readInt();
				data->inputParam(WCHDATA_JXJCoppercash,&coppercash);
				int wood = m_stream->_readInt();
				data->inputParam(WCHDATA_JXJWood,&wood);
				int iron = m_stream->_readInt();
				data->inputParam(WCHDATA_JXJIron,&iron);
				int food = m_stream->_readInt();
				data->inputParam(WCHDATA_JXJFood,&food);
				m_this->doEvent(WCH_JXJBuildingLevelChange,MAKEINT64(buildingid,sbuildinglv));
				
				if (buildingid == WCHDATA_JXJFuyalv)
				{//酒肆，市场，兵营，工坊等级等于府衙等级
					data->inputParam(WCHDATA_JXJJiusilv,&sbuildinglv);
					data->inputParam(WCHDATA_JXJShijilv,&sbuildinglv);
					data->inputParam(WCHDATA_JXJBingyinglv,&sbuildinglv);
					data->inputParam(WCHDATA_JXJGongfanglv,&sbuildinglv);
					m_this->doEvent(WCH_JXJBuildingLevelChange,MAKEINT64(WCHDATA_JXJJiusilv,sbuildinglv));
					m_this->doEvent(WCH_JXJBuildingLevelChange,MAKEINT64(WCHDATA_JXJShijilv,sbuildinglv));
					m_this->doEvent(WCH_JXJBuildingLevelChange,MAKEINT64(WCHDATA_JXJBingyinglv,sbuildinglv));
					m_this->doEvent(WCH_JXJBuildingLevelChange,MAKEINT64(WCHDATA_JXJGongfanglv,sbuildinglv));
				}
			}
			if (buildingid == WCHDATA_JXJBingyinglv || buildingid == WCHDATA_JXJFuyalv)
			{
				bool ifset = true;
				if (braindata)
				{
					braindata->inputParam(WCHDATA_JXJIfSetArmyNum,&ifset);
				}
			}
			bool bFree = m_stream->_readBool();
			if(bFree)
			{
				data->inputParam(WCHDATA_JXJFreeBuyInfo,0);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBuildingLevelChangeMethod
//
/////////////////////////////////////////
crJXJBuildingLevelChangeMethod::crJXJBuildingLevelChangeMethod():
	m_buildingid(0),
m_buildinglv(0){}
crJXJBuildingLevelChangeMethod::crJXJBuildingLevelChangeMethod(const crJXJBuildingLevelChangeMethod& handle):
	crMethod(handle),
	m_buildingid(0),
	m_buildinglv(0),
	m_shijiCanvas(handle.m_shijiCanvas)
{
}
void crJXJBuildingLevelChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_buildingid = LOINT64(param64);
			m_buildinglv = (unsigned char)(HIINT64(param64));
		}
		else
		{
			m_buildingid = 0;
			m_buildinglv = 0;
		}
		break;
	}
}
void crJXJBuildingLevelChangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_shijiCanvas = str;
		break;
	}
}
void crJXJBuildingLevelChangeMethod::operator()(crHandle &handle)
{
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(scene && m_buildingid>0)
	{
		crData *itemdata;
		void *param;
		crInstanceItem *item;
		CRCore::crMultiSwitch *constructtionNode;
		int itembuildingid;
		crData *playerData = m_this->getDataClass();
		playerData->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		float factor = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingFactor,viplv).c_str());
		float limit = atof( crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitFuyaFactor,viplv).c_str());
		float buildingfactor;
		CRNetApp::crScene::SceneItemMap &sceneItemMap = scene->getSceneItemMap();
		for( CRNetApp::crScene::SceneItemMap::iterator itr = sceneItemMap.begin();
			itr != sceneItemMap.end();
			++itr )
		{
			item = itr->second.get();
			itemdata = item->getDataClass();
			itemdata->getParam(WCHDATA_JXJBuildingID,param);
			if(param)
			{
				itembuildingid = *(int *)param;
				if(itembuildingid == m_buildingid)
				{
					constructtionNode = dynamic_cast<crMultiSwitch *>(dynamic_cast<crGroup *>(item->getRelNode())->getChild(0));
					if(constructtionNode)
					{
						if(m_buildingid == WCHDATA_JXJBingyinglv)
						{
							playerData->getParam(WCHDATA_JXJShiliID,param);
							unsigned char shiliid = *(unsigned char *)param;
							//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
							unsigned char activechildindex = shiliid - c_startShiliID;
							constructtionNode->setActiveSwitchSet(activechildindex);
							constructtionNode = dynamic_cast<crMultiSwitch *>(constructtionNode->getFirstActiveChild());
							buildingfactor = floor(m_buildinglv * factor);
							if (buildingfactor>limit)
							{
								buildingfactor = limit;
							}
							constructtionNode->setActiveSwitchSet(buildingfactor);
						}
						else
						{
							buildingfactor = floor(m_buildinglv * factor);
							if (buildingfactor>limit)
							{
								buildingfactor = limit;
							}
							constructtionNode->setActiveSwitchSet(buildingfactor);
							if(m_buildingid == WCHDATA_JXJShijilv)
							{
								ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_shijiCanvas);
								if(canvas.valid())
								{
									canvas->doEvent(WCH_UI_UpdateData);
								}
							}
						}
					}
					//item->doEvent(WCH_JXJBuildingLevelChange);
					break;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBuildingLevelCanvasMethod
//
/////////////////////////////////////////
crJXJBuildingLevelCanvasMethod::crJXJBuildingLevelCanvasMethod():
	m_this(NULL)/*,
				m_ea(NULL)*/
{
}

crJXJBuildingLevelCanvasMethod::crJXJBuildingLevelCanvasMethod(const crJXJBuildingLevelCanvasMethod& handle):
crMethod(handle),
//m_ea(NULL),
m_canvasName(handle.m_canvasName),
m_title(handle.m_title),
m_lv(handle.m_lv),
m_nowproduce(handle.m_nowproduce),
m_nextproduce(handle.m_nextproduce),
m_info(handle.m_info),
m_timing(handle.m_timing),
m_need(handle.m_need),
m_money(handle.m_money),
m_wood(handle.m_wood),
m_iron(handle.m_iron),
m_food(handle.m_food),
m_warning(handle.m_warning)
{
}

void crJXJBuildingLevelCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_ea = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	//case 2:
	//	if(param)
	//	{
	//		_crInt64 param64 = *(_crInt64*)param;
	//		m_ea = (crGUIEventAdapter *)(LOINT64(param64));
	//	}
	//	else
	//	{
	//		m_ea = NULL;
	//	}
	//	break;
	}
}

void crJXJBuildingLevelCanvasMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_lv = str;
		break;
	case 3:
		m_nowproduce = str;
		break;
	case 4: 
		m_nextproduce = str;
		break;
	case 5:
		m_timing = str;
		break;
	case 6:
		m_need = str;
		break;
	case 7:
		m_money = str;
		break;
	case 8:
		m_wood = str;
		break;
	case 9:
		m_iron = str;
		break;
	case 10:
		m_food = str;
		break;
	case 11:
		m_info = str;
		break;
	case 12:
		m_warning = str;
		break;
	}
}
void crJXJBuildingLevelCanvasMethod::operator()(crHandle &handle)
{
	bool cancelTask = false;
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && canvas.valid() && myPlayer /*&& m_ea*/)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_title));
		crStaticTextWidgetNode *lv = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_lv));
		crStaticTextWidgetNode *nowproduce = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nowproduce));
		crStaticTextWidgetNode *nextproduce = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextproduce));
		crHypertextWidgetNode *info = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_info));
		crStaticTextWidgetNode *timing = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_timing));
		crStaticTextWidgetNode *need = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_need));
		crStaticTextWidgetNode *money = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_money));
		crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_wood));
		crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_iron));
		crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_food));
		crStaticTextWidgetNode *warning = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_warning));

		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJBuildingID,param);
		int buildingid = *(int *)param;
		crData *canvasdata = canvas->getDataClass();
		canvasdata -> inputParam(WCHDATA_JXJCheckBuildingID,&buildingid);
		canvasdata -> inputParam(WCHDATA_JXJCanvasBuildingItem, m_this);
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->inputParam(WCHDATA_JXJCurBuildingID,&buildingid);
		data->getParam(buildingid,param);
		unsigned char buildinglv = *(unsigned char *)param;
		if (buildinglv < 1)
		{
			cancelTask = true;
		}
		int buildingid2 = 0;
		if (buildingid >=WCHDATA_JXJMingjulv1 && buildingid <= WCHDATA_JXJMingjulv8)
		{
			buildingid2 = WCHDATA_JXJMingjulv;
		}
		if (buildingid >=WCHDATA_JXJNongtianlv1 && buildingid <= WCHDATA_JXJNongtianlv8)
		{
			buildingid2 = WCHDATA_JXJNongtianlv;
		}
		if (buildingid >=WCHDATA_JXJMuchanglv1 && buildingid <= WCHDATA_JXJMuchanglv4)
		{
			buildingid2 = WCHDATA_JXJMuchanglv;
		}
		if (buildingid >=WCHDATA_JXJLingdilv1 && buildingid <= WCHDATA_JXJLingdilv4)
		{
			buildingid2 = WCHDATA_JXJLingdilv;
		}
		if (buildingid >=WCHDATA_JXJKuangshanlv1 && buildingid <= WCHDATA_JXJKuangshanlv4)
		{
			buildingid2 = WCHDATA_JXJKuangshanlv;
		}
		if (buildingid2 == 0)
		{
			buildingid2 = buildingid;
		}
		crVector4f colorwhite = (crVector4f(1.0f,1.0f,1.0f,1.0f));
		crVector4f colorred = (crVector4f(1.0f,0.0f,0.0f,1.0f));
		int resourcereduce = 0; //资源需求减少量
		BuildingLevelUpCheckResult result;
		result.m_code = 0;
		myPlayer->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
		///////////////////////////////////////
		float percent[4] = {0.0f};
		float percent1[4] = {0.0f};
		crRole *mainRole = myPlayer->getMainRole();
		//crData *mainRole
		if(mainRole && data)
		{
			for (int i = 0; i < 4; i++)
			{
				mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent[i],i+1));//1.food,2.wood,3.iron,4.horse
				myPlayer->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1[i],i+1));
				percent[i] += percent1[i];
			}
		}
		ref_ptr<crTableIO>infoTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInfoTab);
		std::string idStr = crArgumentParser::appItoa(buildingid2);
		crTableIO::StrVec infoRec;
		infoTab->queryOneRecord(0,idStr,infoRec);
		if(title)
		{
			std::string name = infoRec[1];
			title->setString(name);
		}
		if(lv)
		{
			lv->setString(crArgumentParser::appItoa(buildinglv));
		}
		int nextlv = buildinglv+1;
		if(need)
		{
			std::string str;
			if(buildingid == WCHDATA_JXJFuyalv)
			{
				str = crArgumentParser::appItoa(nextlv);
			}
			else
			{
				str = crArgumentParser::appItoa(nextlv);
			}
			need->setString(str);
		}

		int tempbuildinglv = buildinglv;
		int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());
		for (int ii = 0; ii < 2; ii++)
		{
			if (nowproduce && nextproduce)
			{
				int foodint = 0, woodint = 0, ironint = 0, horseint = 0;
				std::string population, food, wood, iron, horse,foodadd,woodadd,ironadd,horseadd;
				std::string strproduce;
				std::string nowlv = crArgumentParser::appItoa(tempbuildinglv);
				crTableIO::StrVec recordproduce;
				ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
				if (tempbuildinglv == 0)
				{
					strproduce = "当前无产出。";
					nowproduce->setString(strproduce);
				}
				else if (tempbuildinglv > maxlv)
				{
					strproduce = "已达到最高级。";
					nextproduce->setString(strproduce);
				}
				else if(resbuildingTab->queryOneRecord(0,nowlv,recordproduce)>=0)
				{
					population = recordproduce[1].c_str();
					//粮食
					foodint = atoi(recordproduce[2].c_str());
					food = crArgumentParser::appItoa(foodint * (1 + percent[0]));
					foodadd = crArgumentParser::appItoa(foodint * percent[0]);
					//木材
					woodint = atoi(recordproduce[3].c_str());
					wood = crArgumentParser::appItoa(woodint * (1 + percent[1]));
					woodadd = crArgumentParser::appItoa(woodint * percent[1]);
					//铁矿
					ironint = atoi(recordproduce[4].c_str());
					iron = crArgumentParser::appItoa(ironint * (1 + percent[2]));
					ironadd = crArgumentParser::appItoa(ironint * percent[2]);
					//马匹
					horseint = atoi(recordproduce[5].c_str());
					horse = crArgumentParser::appItoa(horseint * (1 + percent[3]));
					horseadd = crArgumentParser::appItoa(horseint * percent[3]);
					switch (buildingid)
					{
					case WCHDATA_JXJMingjulv1:
					case WCHDATA_JXJMingjulv2:
					case WCHDATA_JXJMingjulv3:
					case WCHDATA_JXJMingjulv4:
					case WCHDATA_JXJMingjulv5:
					case WCHDATA_JXJMingjulv6:
					case WCHDATA_JXJMingjulv7:
					case WCHDATA_JXJMingjulv8:
						if (ii == 0)
						{
							nowproduce->setString(population+"人口");
						}
						else
						{
							nextproduce->setString(population+"人口");
						}
						break;
					case WCHDATA_JXJNongtianlv1:
					case WCHDATA_JXJNongtianlv2:
					case WCHDATA_JXJNongtianlv3:
					case WCHDATA_JXJNongtianlv4:
					case WCHDATA_JXJNongtianlv5:
					case WCHDATA_JXJNongtianlv6:
					case WCHDATA_JXJNongtianlv7:
					case WCHDATA_JXJNongtianlv8:	
						if (ii == 0)
						{
							nowproduce->setString(food+"(+"+foodadd+") 粮食/小时");
						}
						else
						{
							nextproduce->setString(food+"(+"+foodadd+") 粮食/小时");
						}
						break;
					case WCHDATA_JXJLingdilv1:
					case WCHDATA_JXJLingdilv2:
					case WCHDATA_JXJLingdilv3:
					case WCHDATA_JXJLingdilv4:
						if (ii == 0)
						{
							nowproduce->setString(wood+"(+"+woodadd+") 木材/小时");
						}
						else
						{
							nextproduce->setString(wood+"(+"+woodadd+") 木材/小时");
						}
						break;
					case WCHDATA_JXJMuchanglv1:
					case WCHDATA_JXJMuchanglv2:
					case WCHDATA_JXJMuchanglv3:
					case WCHDATA_JXJMuchanglv4:
						if (ii == 0)
						{
							nowproduce->setString(horse+"(+"+horseadd+") 马匹/小时");
						}
						else
						{
							nextproduce->setString(horse+"(+"+horseadd+") 马匹/小时");
						}
						break;
					case WCHDATA_JXJKuangshanlv1:
					case WCHDATA_JXJKuangshanlv2:
					case WCHDATA_JXJKuangshanlv3:
					case WCHDATA_JXJKuangshanlv4:
						if (ii == 0)
						{
							nowproduce->setString(iron+"(+"+ironadd+") 矿石/小时");
						}
						else
						{
							nextproduce->setString(iron+"(+"+ironadd+") 矿石/小时");
						}
						break;
					}
				}
				tempbuildinglv++;
			}
		}
		//////////////////////////////
		if(info)
		{
			std::string file = infoRec[2];
			if(!file.empty())
			{
				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
				info->setHypertext(file);
			}
			else
			{
				info->clearText();
			}
		}
		/////////////////////////////
		ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
		int timeid = buildinglvTab->getTitleIndex("时间");
		int copperid = buildinglvTab->getTitleIndex("铜钱");
		int woodid = buildinglvTab->getTitleIndex("木材");
		int ironid = buildinglvTab->getTitleIndex("铁矿");
		int foodid = buildinglvTab->getTitleIndex("粮食");
		std::string warningtext = "资源不足";
		if(warning)warning->clearString();
		crTableIO::StrVec record;
		if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
		{
			//float cdpercent = 0.0f;
			//int times = atoi(record[timeid].c_str());
			int times = 0;
			times = result.m_timeNeed;
			//myPlayer->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&cdpercent,NULL));
			warningtext = "资源不足";
			if(timing)
			{
				timing->setColor(colorwhite);

				int hour = times/3600;
				int t = times%3600;
				int minute = t/60;
				int s = t%60;
				timing->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
			}
			if(money)
			{
				money->setColor(colorwhite);
				data->getParam(WCHDATA_JXJCoppercash,param);
				int coppercash = *(int *)param;
				if (coppercash<result.m_coppercashNeed)
				{
					money->setColor(colorred);
					if(warning)warning->setString(warningtext);
				}
				//money->setString(record[copperid] + "-" + "(" +crArgumentParser::appItoa(result.m_coppercashNeed)  + ")");
				money->setString(crArgumentParser::appItoa(result.m_coppercashNeed));
			}
			if(wood)
			{
				//木材
				wood->setColor(colorwhite);
				data->getParam(WCHDATA_JXJWood,param);
				int woodgot = *(int *)param;
				if (woodgot<result.m_woodNeed)
				{
					wood->setColor(colorred);
					if(warning)warning->setString(warningtext);
				}
				//wood->setString(record[woodid]);
				wood->setString(crArgumentParser::appItoa(result.m_woodNeed));
			}
			if(iron)
			{
				//铁矿
				iron->setColor(colorwhite);
				data->getParam(WCHDATA_JXJIron,param);
				int irongot = *(int *)param;
				if (irongot<result.m_ironNeed)
				{
					iron->setColor(colorred);
					if(warning)warning->setString(warningtext);
				}
				//iron->setString(record[ironid]);
				iron->setString(crArgumentParser::appItoa(result.m_ironNeed));
			}
			if(food)
			{
				//粮食
				food->setColor(colorwhite);
				data->getParam(WCHDATA_JXJFood,param);
				int foodgot = *(int *)param;
				if (foodgot<result.m_foodNeed)
				{
					food->setColor(colorred);
					if(warning)warning->setString(warningtext);
				}
				//food->setString(record[foodid]);
				food->setString(crArgumentParser::appItoa(result.m_foodNeed));
			}
			/////////////////////////////////////////////
			data->getParam(WCHDATA_JXJFuyalv,param);
			unsigned char fuyalv = *(unsigned char *)param;
			if(buildingid == WCHDATA_JXJFuyalv)
			{//角色等级
				crData *roleData = mainRole->getDataClass();
				roleData->getParam(WCHDATA_Level,param);
				unsigned char rolelv = *(unsigned char *)param;
				if(nextlv>(int)rolelv)
				{//超过角色等级
					warningtext = "角色等级不足";
					if(warning)warning->setString(warningtext);
				}
			}
			else if(nextlv > (int)fuyalv)
			{//超过府衙等级
				warningtext = "府衙等级不足";
				if(warning)warning->setString(warningtext);
			}
			ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
			int timeid = buildinglvTab->getTitleIndex("时间");
			crTableIO::StrVec record;
			if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
			{
				/////时间
				data->getParam(WCHDATA_JXJBuildingTimes,param);
				crVector4i buildingTimes = *(crVector4i *)param;
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
				int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime,viplv).c_str()));
				int i = 0;
				int timeRemain = 0;
				for(; i<4; i++)
				{
					if(buildingTimes[i]>=0 && buildingTimes[i]<overTimes)
						timeRemain += overTimes - buildingTimes[i] + credittime;
				}
				int m_timeNeed = atoi(record[timeid].c_str());
				if(timeRemain<m_timeNeed)
				{//没有建筑时间
					warningtext = "建筑时间不足";
					if(warning)warning->setString(warningtext);
				}
			}
			////////////////////////////////////////////
		}
	}
	handle.outputParam(0,&cancelTask);
}


///////////////////////////////////////////
////
////crJXJBuildingLevelCanvas2Method
////
///////////////////////////////////////////
//crJXJBuildingLevelCanvas2Method::crJXJBuildingLevelCanvas2Method():
//	m_this(NULL),
//	m_ea(NULL)
//{
//}
//
//crJXJBuildingLevelCanvas2Method::crJXJBuildingLevelCanvas2Method(const crJXJBuildingLevelCanvas2Method& handle):
//	crMethod(handle),
//	m_ea(NULL),
//	m_canvasName(handle.m_canvasName),
//	m_title(handle.m_title),
//	m_lv(handle.m_lv),
//	m_nowproduce(handle.m_nowproduce),
//	m_nextproduce(handle.m_nextproduce),
//	m_info(handle.m_info),
//	m_timing(handle.m_timing),
//	m_need(handle.m_need),
//	m_money(handle.m_money),
//	m_wood(handle.m_wood),
//	m_iron(handle.m_iron),
//	m_food(handle.m_food),
//	m_warning(handle.m_warning),
//	m_buildingname(handle.m_buildingname)
//{
//}
//
//void crJXJBuildingLevelCanvas2Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_ea = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_ea = (crGUIEventAdapter *)(LOINT64(param64));
//		}
//		else
//		{
//			m_ea = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJBuildingLevelCanvas2Method::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_canvasName = str;
//		break;
//	case 1:
//		m_title = str;
//		break;
//	case 2:
//		m_lv = str;
//		break;
//	case 3:
//		m_nowproduce = str;
//		break;
//	case 4: 
//		m_nextproduce = str;
//		break;
//	case 5:
//		m_timing = str;
//		break;
//	case 6:
//		m_need = str;
//		break;
//	case 7:
//		m_money = str;
//		break;
//	case 8:
//		m_wood = str;
//		break;
//	case 9:
//		m_iron = str;
//		break;
//	case 10:
//		m_food = str;
//		break;
//	case 11:
//		m_info = str;
//		break;
//	case 12:
//		m_warning = str;
//		break;
//	case 13:
//		m_buildingname = str;
//		break;
//	}
//}
//
//void crJXJBuildingLevelCanvas2Method::operator()(crHandle &handle)
//{
//	bool cancelTask = false;
//	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && canvas.valid() && myPlayer/* && m_ea*/)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		data->getParam(WCHDATA_JXJVipLv,param);
//		unsigned char viplv = *(unsigned char *)param;
//		crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_title));
//		crStaticTextWidgetNode *lv = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_lv));
//		crStaticTextWidgetNode *nowproduce = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nowproduce));
//		crStaticTextWidgetNode *nextproduce = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextproduce));
//		crHypertextWidgetNode *info = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_info));
//		crStaticTextWidgetNode *timing = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_timing));
//		crStaticTextWidgetNode *need = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_need));
//		crStaticTextWidgetNode *money = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_money));
//		crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_wood));
//		crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_iron));
//		crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_food));
//		crStaticTextWidgetNode *warning = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_warning));
//		//crMultiSwitch *nameswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_buildingname));
//
//		crVector4f colorwhite = (crVector4f(1.0f,1.0f,1.0f,1.0f));
//		crVector4f colorred = (crVector4f(1.0f,0.0f,0.0f,1.0f));
//		int resourcereduce = 0; //资源需求减少量
//		BuildingLevelUpCheckResult result;
//		result.m_code = 0;
//		crData *thisData = m_this->getDataClass();
//		crRole *mainRole = myPlayer->getMainRole();
//		//crData *mainRole
//		thisData->getParam(WCHDATA_JXJBuildingID,param);
//		int buildingid = *(int *)param;
//		myPlayer->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
//		///////////////////////////////////////
//		float percent[4] = {0.0f};
//		float percent1[4] = {0.0f};
//		if(mainRole && data)
//		{
//			for (int i = 0; i < 4; i++)
//			{
//				mainRole->doEvent(WCH_JXJGetResProductPercent,MAKEINT64(&percent[i],i+1));//1.food,2.wood,3.iron,4.horse
//				myPlayer->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&percent1[i],i+1));
//				percent[i] += percent1[i];
//			}
//		}
//		crData *canvasdata = canvas->getDataClass();
//		canvasdata -> inputParam(WCHDATA_JXJCheckBuildingID,&buildingid);
//		//crData *brainData = crBrain::getInstance()->getDataClass();
//		//brainData->inputParam(WCHDATA_JXJCurBuildingID,&buildingid);
//		data->getParam(buildingid,param);
//		unsigned char buildinglv = *(unsigned char *)param;
//		if (buildinglv < 1)
//		{
//			cancelTask = true;
//		}
//		else
//		{
//
//			int buildingid2 = 0;
//			if (buildingid >=WCHDATA_JXJMingjulv1 && buildingid <= WCHDATA_JXJMingjulv8)
//			{
//				buildingid2 = WCHDATA_JXJMingjulv;
//			}
//			if (buildingid >=WCHDATA_JXJNongtianlv1 && buildingid <= WCHDATA_JXJNongtianlv8)
//			{
//				buildingid2 = WCHDATA_JXJNongtianlv;
//			}
//			if (buildingid >=WCHDATA_JXJMuchanglv1 && buildingid <= WCHDATA_JXJMuchanglv4)
//			{
//				buildingid2 = WCHDATA_JXJMuchanglv;
//			}
//			if (buildingid >=WCHDATA_JXJLingdilv1 && buildingid <= WCHDATA_JXJLingdilv4)
//			{
//				buildingid2 = WCHDATA_JXJLingdilv;
//			}
//			if (buildingid >=WCHDATA_JXJKuangshanlv1 && buildingid <= WCHDATA_JXJKuangshanlv4)
//			{
//				buildingid2 = WCHDATA_JXJKuangshanlv;
//			}
//			if (buildingid2 == 0)
//			{
//				buildingid2 = buildingid;
//			}
//			ref_ptr<crTableIO>infoTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInfoTab);
//			std::string idStr = crArgumentParser::appItoa(buildingid2);
//			crTableIO::StrVec infoRec;
//			infoTab->queryOneRecord(0,idStr,infoRec);
//			if(title)
//			{
//				std::string name = infoRec[1];
//				title->setString(name);
//			}
//			if(lv)
//			{
//				lv->setString(crArgumentParser::appItoa(buildinglv));
//			}
//			int nextlv = buildinglv+1;
//			if(need)
//			{
//				std::string str;
//				if(buildingid == WCHDATA_JXJFuyalv)
//				{
//					str = crArgumentParser::appItoa(nextlv);
//				}
//				else
//				{
//					str = crArgumentParser::appItoa(nextlv);
//				}
//				need->setString(str);
//			}
//
//			int tempbuildinglv = buildinglv;
//			int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());
//			for (int ii = 0; ii < 2; ii++)
//			{
//				if (nowproduce && nextproduce)
//				{
//					std::string population, food, wood, iron, horse,foodadd,woodadd,ironadd,horseadd;
//					std::string strproduce;
//					std::string nowlv = crArgumentParser::appItoa(tempbuildinglv);
//					crTableIO::StrVec recordproduce;
//					ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
//					if (tempbuildinglv == 0)
//					{
//						strproduce = "当前无产出。";
//						nowproduce->setString(strproduce);
//					}
//					else if (tempbuildinglv > maxlv)
//					{
//						strproduce = "已达到最高级。";
//						nextproduce->setString(strproduce);
//					}
//					else if(resbuildingTab->queryOneRecord(0,nowlv,recordproduce)>=0)
//					{
//						population = recordproduce[1].c_str();
//						//粮食
//						food = recordproduce[2].c_str();
//						foodadd =  crArgumentParser::appItoa(atoi(food.c_str()) * percent[0]);
//						//木材
//						wood = recordproduce[3].c_str();
//						woodadd =  crArgumentParser::appItoa(atoi(wood.c_str()) * percent[1]);
//						//铁矿
//						iron = recordproduce[4].c_str();
//						ironadd =  crArgumentParser::appItoa(atoi(iron.c_str()) * percent[2]);
//						//马匹
//						horse = recordproduce[5].c_str();
//						horseadd =  crArgumentParser::appItoa(atoi(horse.c_str()) * percent[3]);
//						switch (buildingid)
//						{
//						case WCHDATA_JXJMingjulv1:
//						case WCHDATA_JXJMingjulv2:
//						case WCHDATA_JXJMingjulv3:
//						case WCHDATA_JXJMingjulv4:
//						case WCHDATA_JXJMingjulv5:
//						case WCHDATA_JXJMingjulv6:
//						case WCHDATA_JXJMingjulv7:
//						case WCHDATA_JXJMingjulv8:
//							if (ii == 0)
//							{
//								nowproduce->setString(population+"人口/小时");
//							}
//							else
//							{
//								nextproduce->setString(population+"人口/小时");
//							}
//							break;
//						case WCHDATA_JXJNongtianlv1:
//						case WCHDATA_JXJNongtianlv2:
//						case WCHDATA_JXJNongtianlv3:
//						case WCHDATA_JXJNongtianlv4:
//						case WCHDATA_JXJNongtianlv5:
//						case WCHDATA_JXJNongtianlv6:
//						case WCHDATA_JXJNongtianlv7:
//						case WCHDATA_JXJNongtianlv8:	
//							if (ii == 0)
//							{
//								nowproduce->setString(food+"(+"+foodadd+") 粮食/小时");
//							}
//							else
//							{
//								nextproduce->setString(food+"(+"+foodadd+") 粮食/小时");
//							}
//							break;
//						case WCHDATA_JXJLingdilv1:
//						case WCHDATA_JXJLingdilv2:
//						case WCHDATA_JXJLingdilv3:
//						case WCHDATA_JXJLingdilv4:
//							if (ii == 0)
//							{
//								nowproduce->setString(wood+"(+"+woodadd+") 木材/小时");
//							}
//							else
//							{
//								nextproduce->setString(wood+"(+"+woodadd+") 木材/小时");
//							}
//							break;
//						case WCHDATA_JXJMuchanglv1:
//						case WCHDATA_JXJMuchanglv2:
//						case WCHDATA_JXJMuchanglv3:
//						case WCHDATA_JXJMuchanglv4:
//							if (ii == 0)
//							{
//								nowproduce->setString(horse+"(+"+horseadd+") 马匹/小时");
//							}
//							else
//							{
//								nextproduce->setString(horse+"(+"+horseadd+") 马匹/小时");
//							}
//							break;
//						case WCHDATA_JXJKuangshanlv1:
//						case WCHDATA_JXJKuangshanlv2:
//						case WCHDATA_JXJKuangshanlv3:
//						case WCHDATA_JXJKuangshanlv4:
//							if (ii == 0)
//							{
//								nowproduce->setString(iron+"(+"+ironadd+") 矿石/小时");
//							}
//							else
//							{
//								nextproduce->setString(iron+"(+"+ironadd+") 矿石/小时");
//							}
//							break;
//						}
//					}
//					tempbuildinglv++;
//				}
//			}
//			if(info)
//			{
//				std::string file = infoRec[2];
//				if(!file.empty())
//				{
//					file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//					info->setHypertext(file);
//				}
//				else
//				{
//					info->clearText();
//				}
//			}
//			/////////////////////////////
//			ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
//			int timeid = buildinglvTab->getTitleIndex("时间");
//			int copperid = buildinglvTab->getTitleIndex("铜钱");
//			int woodid = buildinglvTab->getTitleIndex("木材");
//			int ironid = buildinglvTab->getTitleIndex("铁矿");
//			int foodid = buildinglvTab->getTitleIndex("粮食");
//			std::string warningtext = "资源不足";
//			if(warning)warning->clearString();
//			crTableIO::StrVec record;
//			if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
//			{
//				//float cdpercent = 0.0f;
//				//int times = atoi(record[timeid].c_str());
//				int times = 0;
//				times = result.m_timeNeed;
//				//myPlayer->doEvent(WCH_JXJGetTechResProductPercent,MAKEINT64(&cdpercent,NULL));
//				warningtext = "资源不足";
//				if(timing)
//				{
//					timing->setColor(colorwhite);
//
//					int hour = times/3600;
//					int t = times%3600;
//					int minute = t/60;
//					int s = t%60;
//					timing->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
//				}
//				if(money)
//				{
//					money->setColor(colorwhite);
//					data->getParam(WCHDATA_JXJCoppercash,param);
//					int coppercash = *(int *)param;
//					if (coppercash<result.m_coppercashNeed)
//					{
//						money->setColor(colorred);
//						if(warning)warning->setString(warningtext);
//					}
//					//money->setString(record[copperid] + "-" + "(" +crArgumentParser::appItoa(result.m_coppercashNeed)  + ")");
//					money->setString(crArgumentParser::appItoa(result.m_coppercashNeed));
//				}
//				if(wood)
//				{
//					//木材
//					wood->setColor(colorwhite);
//					data->getParam(WCHDATA_JXJWood,param);
//					int woodgot = *(int *)param;
//					if (woodgot<result.m_woodNeed)
//					{
//						wood->setColor(colorred);
//						if(warning)warning->setString(warningtext);
//					}
//					//wood->setString(record[woodid]);
//					wood->setString(crArgumentParser::appItoa(result.m_woodNeed));
//				}
//				if(iron)
//				{
//					//铁矿
//					iron->setColor(colorwhite);
//					data->getParam(WCHDATA_JXJIron,param);
//					int irongot = *(int *)param;
//					if (irongot<result.m_ironNeed)
//					{
//						iron->setColor(colorred);
//						if(warning)warning->setString(warningtext);
//					}
//					//iron->setString(record[ironid]);
//					iron->setString(crArgumentParser::appItoa(result.m_ironNeed));
//				}
//				if(food)
//				{
//					//粮食
//					food->setColor(colorwhite);
//					data->getParam(WCHDATA_JXJFood,param);
//					int foodgot = *(int *)param;
//					if (foodgot<result.m_foodNeed)
//					{
//						food->setColor(colorred);
//						if(warning)warning->setString(warningtext);
//					}
//					//food->setString(record[foodid]);
//					food->setString(crArgumentParser::appItoa(result.m_foodNeed));
//				}
//				////////////////////////////////////////////
//				data->getParam(WCHDATA_JXJFuyalv,param);
//				unsigned char fuyalv = *(unsigned char *)param;
//				if(buildingid == WCHDATA_JXJFuyalv)
//				{//角色等级
//					crRole *mainRole = myPlayer->getMainRole();
//					crData *roleData = mainRole->getDataClass();
//					roleData->getParam(WCHDATA_Level,param);
//					unsigned char rolelv = *(unsigned char *)param;
//					if(nextlv>(int)rolelv)
//					{//超过角色等级
//						warningtext = "角色等级不足";
//						if(warning)warning->setString(warningtext);
//					}
//				}
//				else if(nextlv > (int)fuyalv)
//				{//超过府衙等级
//					warningtext = "府衙等级不足";
//					if(warning)warning->setString(warningtext);
//				}
//				ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
//				int timeid = buildinglvTab->getTitleIndex("时间");
//				crTableIO::StrVec record;
//				if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
//				{
//					/////时间
//					data->getParam(WCHDATA_JXJBuildingTimes,param);
//					crVector4i buildingTimes = *(crVector4i *)param;
//					data->getParam(WCHDATA_JXJVipLv,param);
//					unsigned char viplv = *(unsigned char *)param;
//					short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
//					int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime,viplv).c_str()));
//					int i = 0;
//					int timeRemain = 0;
//					for(; i<4; i++)
//					{
//						if(buildingTimes[i]>=0 && buildingTimes[i]<overTimes)
//							timeRemain += overTimes - buildingTimes[i] + credittime;
//					}
//					int m_timeNeed = atoi(record[timeid].c_str());
//					if(timeRemain<m_timeNeed)
//					{//没有建筑时间
//						warningtext = "建筑时间不足";
//						if(warning)warning->setString(warningtext);
//					}
//				}
//				////////////////
//			}
//		}
//	}
//	handle.outputParam(0,&cancelTask);
//}


///////////////////////////////////////////
////
////crJXJUIBuildingCanvasUpdateMethod
////
///////////////////////////////////////////
//crJXJUIBuildingCanvasUpdateMethod::crJXJUIBuildingCanvasUpdateMethod():
//	m_this(NULL)
//{
//}
//crJXJUIBuildingCanvasUpdateMethod::crJXJUIBuildingCanvasUpdateMethod(const crJXJUIBuildingCanvasUpdateMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_title(handle.m_title),
//	m_lv(handle.m_lv),
//	m_nowproduce(handle.m_nowproduce),
//	m_nextproduce(handle.m_nextproduce),
//	m_info(handle.m_info),
//	m_timing(handle.m_timing),
//	m_need(handle.m_need),
//	m_money(handle.m_money),
//	m_wood(handle.m_wood),
//	m_iron(handle.m_iron),
//	m_food(handle.m_food),
//	m_warning(handle.m_warning)
//{
//}
//void crJXJUIBuildingCanvasUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_this = (crWidgetNode*)(HIINT64(param64));
//		}
//		break;
//	}
//}
//void crJXJUIBuildingCanvasUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_title = str;
//		break;
//	case 1:
//		m_lv = str;
//		break;
//	case 2:
//		m_nowproduce = str;
//		break;
//	case 3:
//		m_nextproduce = str;
//		break;
//	case 4: 
//		m_timing = str;
//		break;
//	case 5:
//		m_need = str;
//		break;
//	case 6:
//		m_money = str;
//		break;
//	case 7:
//		m_wood = str;
//		break;
//	case 8:
//		m_iron = str;
//		break;
//	case 9:
//		m_food = str;
//		break;
//	case 10:
//		m_info = str;
//		break;
//	case 11:
//		m_warning = str;
//		break;
//	}
//}
//void crJXJUIBuildingCanvasUpdateMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && playerGameData)
//	{
//		ref_ptr<crCanvasNode> canvas =  m_this->getParentCanvas();
//		crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_title));
//		crStaticTextWidgetNode *lv = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_lv));
//		crStaticTextWidgetNode *nowproduce= dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nowproduce));
//		crStaticTextWidgetNode *nextproduce= dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextproduce));		
//		crHypertextWidgetNode *info = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_info));
//		crStaticTextWidgetNode *timing = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_timing));
//		crStaticTextWidgetNode *need = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_need));
//		crStaticTextWidgetNode *money = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_money));
//		crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_wood));
//		crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_iron));
//		crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_food));
//		crStaticTextWidgetNode *warning = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_warning));
//
//		void *param;
//		crData *canvasdata = canvas->getDataClass();
//		canvasdata -> getParam(WCHDATA_JXJCheckBuildingID,param);
//		int buildingid = *(int *)param;
//		crData *data = playerGameData->getDataClass();
//		data->getParam(buildingid,param);
//		unsigned char buildinglv = *(unsigned char *)param;
//		int buildingid2 = 0;
//		if (buildingid >=WCHDATA_JXJMingjulv1 && buildingid <= WCHDATA_JXJMingjulv8)
//		{
//			buildingid2 = WCHDATA_JXJMingjulv;
//		}
//		if (buildingid >=WCHDATA_JXJNongtianlv1 && buildingid <= WCHDATA_JXJNongtianlv8)
//		{
//			buildingid2 = WCHDATA_JXJNongtianlv;
//		}
//		if (buildingid >=WCHDATA_JXJMuchanglv1 && buildingid <= WCHDATA_JXJMuchanglv4)
//		{
//			buildingid2 = WCHDATA_JXJMuchanglv;
//		}
//		if (buildingid >=WCHDATA_JXJLingdilv1 && buildingid <= WCHDATA_JXJLingdilv4)
//		{
//			buildingid2 = WCHDATA_JXJLingdilv;
//		}
//		if (buildingid >=WCHDATA_JXJKuangshanlv1 && buildingid <= WCHDATA_JXJKuangshanlv4)
//		{
//			buildingid2 = WCHDATA_JXJKuangshanlv;
//		}
//		if (buildingid2 == 0)
//		{
//			buildingid2 = buildingid;
//		}
//		ref_ptr<crTableIO>infoTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInfoTab);
//		std::string idStr = crArgumentParser::appItoa(buildingid2);
//		crTableIO::StrVec infoRec;
//		infoTab->queryOneRecord(0,idStr,infoRec);
//		if(title)
//		{
//			std::string name = infoRec[1];
//			title->setString(name);
//		}
//		if(lv)
//		{
//			lv->setString(crArgumentParser::appItoa(buildinglv));
//		}
//		int nextlv = buildinglv+1;
//		if(need)
//		{
//			std::string str;
//			str = crArgumentParser::appItoa(nextlv);
//			need->setString(str);
//		}
//
//		if (nowproduce)
//		{
//			std::string population, food, wood, iron, horse;
//			std::string strproduce;
//			std::string nowlv;
//			crTableIO::StrVec recordproduce;
//			ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
//			nowlv = crArgumentParser::appItoa(buildinglv);
//			if (buildinglv == 0)
//			{
//				strproduce = "当前无产出。";
//				nowproduce->setString(strproduce);
//			}
//			else
//			{			
//				resbuildingTab->queryOneRecord(0,nowlv,recordproduce);
//				population = recordproduce[1].c_str();
//				food = recordproduce[2].c_str();
//				wood = recordproduce[3].c_str();
//				iron = recordproduce[4].c_str();
//				horse = recordproduce[5].c_str();
//				switch (buildingid)
//				{
//				case WCHDATA_JXJMingjulv1:
//				case WCHDATA_JXJMingjulv2:
//				case WCHDATA_JXJMingjulv3:
//				case WCHDATA_JXJMingjulv4:
//				case WCHDATA_JXJMingjulv5:
//				case WCHDATA_JXJMingjulv6:
//				case WCHDATA_JXJMingjulv7:
//				case WCHDATA_JXJMingjulv8:
//					nowproduce->setString("产出："+population+"人口/小时");
//					break;
//				case WCHDATA_JXJNongtianlv1:
//				case WCHDATA_JXJNongtianlv2:
//				case WCHDATA_JXJNongtianlv3:
//				case WCHDATA_JXJNongtianlv4:
//				case WCHDATA_JXJNongtianlv5:
//				case WCHDATA_JXJNongtianlv6:
//				case WCHDATA_JXJNongtianlv7:
//				case WCHDATA_JXJNongtianlv8:	
//					nowproduce->setString("产出："+food+"粮食/小时");
//					break;
//				case WCHDATA_JXJLingdilv1:
//				case WCHDATA_JXJLingdilv2:
//				case WCHDATA_JXJLingdilv3:
//				case WCHDATA_JXJLingdilv4:
//					nowproduce->setString("产出："+wood+"木材/小时");
//					break;
//				case WCHDATA_JXJMuchanglv1:
//				case WCHDATA_JXJMuchanglv2:
//				case WCHDATA_JXJMuchanglv3:
//				case WCHDATA_JXJMuchanglv4:
//					nowproduce->setString("产出："+iron+"马匹/小时");
//					break;
//				case WCHDATA_JXJKuangshanlv1:
//				case WCHDATA_JXJKuangshanlv2:
//				case WCHDATA_JXJKuangshanlv3:
//				case WCHDATA_JXJKuangshanlv4:
//					nowproduce->setString("产出："+horse+"矿石/小时");
//					break;
//				}
//			}
//		}
//		if (nextproduce)
//		{
//			std::string population, food, wood, iron, horse;
//			std::string strproduce;
//			std::string nextlv;
//			int nextlevel=buildinglv+1;
//			crTableIO::StrVec recordproduce;
//			ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
//			nextlv = crArgumentParser::appItoa(nextlevel);
//			resbuildingTab->queryOneRecord(0,nextlv,recordproduce);
//			population = recordproduce[1].c_str();
//			food = recordproduce[2].c_str();
//			wood = recordproduce[3].c_str();
//			iron = recordproduce[4].c_str();
//			horse = recordproduce[5].c_str();
//			switch (buildingid)
//			{
//			case WCHDATA_JXJMingjulv1:
//			case WCHDATA_JXJMingjulv2:
//			case WCHDATA_JXJMingjulv3:
//			case WCHDATA_JXJMingjulv4:
//			case WCHDATA_JXJMingjulv5:
//			case WCHDATA_JXJMingjulv6:
//			case WCHDATA_JXJMingjulv7:
//			case WCHDATA_JXJMingjulv8:
//				nextproduce->setString("产出："+population+"人口/小时");
//				break;
//			case WCHDATA_JXJNongtianlv1:
//			case WCHDATA_JXJNongtianlv2:
//			case WCHDATA_JXJNongtianlv3:
//			case WCHDATA_JXJNongtianlv4:
//			case WCHDATA_JXJNongtianlv5:
//			case WCHDATA_JXJNongtianlv6:
//			case WCHDATA_JXJNongtianlv7:
//			case WCHDATA_JXJNongtianlv8:	
//				nextproduce->setString("产出："+food+"粮食/小时");
//				break;
//			case WCHDATA_JXJLingdilv1:
//			case WCHDATA_JXJLingdilv2:
//			case WCHDATA_JXJLingdilv3:
//			case WCHDATA_JXJLingdilv4:
//				nextproduce->setString("产出："+wood+"木材/小时");
//				break;
//			case WCHDATA_JXJMuchanglv1:
//			case WCHDATA_JXJMuchanglv2:
//			case WCHDATA_JXJMuchanglv3:
//			case WCHDATA_JXJMuchanglv4:
//				nextproduce->setString("产出："+iron+"马匹/小时");
//				break;
//			case WCHDATA_JXJKuangshanlv1:
//			case WCHDATA_JXJKuangshanlv2:
//			case WCHDATA_JXJKuangshanlv3:
//			case WCHDATA_JXJKuangshanlv4:
//				nextproduce->setString("产出："+horse+"矿石/小时");
//				break;
//			}
//		}
//		if(info)
//		{
//			std::string file = infoRec[2];
//			if(!file.empty())
//			{
//				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//				info->setHypertext(file);
//			}
//			else
//			{
//				info->clearText();
//			}
//		}
//		//////////////////////////////////////////
//		ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
//		int timeid = buildinglvTab->getTitleIndex("时间");
//		int copperid = buildinglvTab->getTitleIndex("铜钱");
//		int woodid = buildinglvTab->getTitleIndex("木材");
//		int ironid = buildinglvTab->getTitleIndex("铁矿");
//		int foodid = buildinglvTab->getTitleIndex("粮食");
//		crTableIO::StrVec record;
//		std::string warningtext = "资源不足";
//		if(warning)warning->clearString();
//		if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
//		{
//			if(timing)
//			{
//				int times = atoi(record[timeid].c_str());
//				int minute = times/60;
//				int s = times%60;
//				timing->setString(crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
//			}
//			if(money)
//			{
//				data->getParam(WCHDATA_JXJCoppercash,param);
//				int coppercash = *(int *)param;
//				if (coppercash<atoi(record[copperid].c_str()))
//				{
//					money->setColor(crVector4(1.0f,1.0f,0.0f,0.0f));
//					if(warning)warning->setString(warningtext);
//				}
//				money->setString(record[copperid]);
//			}
//			if(wood)
//			{
//				//木材
//				data->getParam(WCHDATA_JXJWood,param);
//				int woodgot = *(int *)param;
//				if (woodgot<atoi(record[woodid].c_str()))
//				{
//					wood->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
//					if(warning)warning->setString(warningtext);
//				}
//				wood->setString(record[woodid]);
//			}
//			if(iron)
//			{
//				//铁矿
//				data->getParam(WCHDATA_JXJIron,param);
//				int irongot = *(int *)param;
//				if (irongot<atoi(record[ironid].c_str()))
//				{
//					iron->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
//					if(warning)warning->setString(warningtext);
//				}
//				iron->setString(record[ironid]);
//			}
//			if(food)
//			{
//				//粮食
//				data->getParam(WCHDATA_JXJFood,param);
//				int foodgot = *(int *)param;
//				if (foodgot<atoi(record[foodid].c_str()))
//				{
//					food->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
//					if(warning)warning->setString(warningtext);
//				}
//				food->setString(record[foodid]);
//			}
//			////////////////////////////////////////////
//			data->getParam(WCHDATA_JXJFuyalv,param);
//			unsigned char fuyalv = *(unsigned char *)param;
//			if(buildingid == WCHDATA_JXJFuyalv)
//			{//角色等级
//				crRole *mainRole = playerGameData->getMainRole();
//				crData *roleData = mainRole->getDataClass();
//				roleData->getParam(WCHDATA_Level,param);
//				unsigned char rolelv = *(unsigned char *)param;
//				if(nextlv>(int)rolelv)
//				{//超过角色等级
//					warningtext = "角色等级不足";
//					if(warning)warning->setString(warningtext);
//				}
//			}
//			else if(nextlv > (int)fuyalv)
//			{//超过府衙等级
//				warningtext = "府衙等级不足";
//				if(warning)warning->setString(warningtext);
//			}
//			ref_ptr<crTableIO>buildinglvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBuildinglvTab);
//			int timeid = buildinglvTab->getTitleIndex("时间");
//			crTableIO::StrVec record;
//			if(buildinglvTab->queryOneRecord(0,idStr,1,crArgumentParser::appItoa(nextlv),record)>=0)
//			{
//				/////时间
//				data->getParam(WCHDATA_JXJBuildingTimes,param);
//				crVector4i buildingTimes = *(crVector4i *)param;
//				ref_ptr<crTableIO>gameGlobalTable = crGlobalHandle::gData()->gGameGlobalTable();
//				crTableIO::StrVec overTimeRec;
//				gameGlobalTable->queryOneRecord(0,crArgumentParser::appItoa(WCHDATA_JXJOverloadTime),overTimeRec);
//				short overTimes = (short)(atoi(overTimeRec[1].c_str()));
//				int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime).c_str()));
//				int i = 0;
//				int timeRemain = 0;
//				for(; i<4; i++)
//				{
//					if(buildingTimes[i]>=0 && buildingTimes[i]<overTimes)
//						timeRemain += overTimes - buildingTimes[i] + credittime;
//				}
//				int m_timeNeed = atoi(record[timeid].c_str());
//				if(timeRemain<m_timeNeed)
//				{//没有建筑时间
//					warningtext = "建筑时间不足";
//					if(warning)warning->setString(warningtext);
//				}
//			}
//		}
//	}
//}


/////////////////////////////////////////
//
//crJXJTechLevelUpCheckMethod
//
/////////////////////////////////////////
crJXJTechLevelUpCheckMethod::crJXJTechLevelUpCheckMethod():
	m_this(NULL),
	m_techid(0),
	m_result(NULL)
{
}

crJXJTechLevelUpCheckMethod::crJXJTechLevelUpCheckMethod(const crJXJTechLevelUpCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_techid(handle.m_techid),
	m_result(NULL)
{
}

void crJXJTechLevelUpCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_result = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_techid = LOINT64(param64);
			m_result = (TechLevelUpCheckResult *)(HIINT64(param64));
		}
		else
		{
			m_result = NULL;
		}
		break;
	}
}

void crJXJTechLevelUpCheckMethod::addParam(int i, const std::string& str)
{
}

void crJXJTechLevelUpCheckMethod::operator()(crHandle &handle)
{
	if(m_this && m_result)
	{
		std::string techidStr = crArgumentParser::appItoa(m_techid);
		void *param;
		crData *playerData = m_this->getDataClass();
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(m_techid,param);
		unsigned char tech = *(unsigned char *)(param);
		ref_ptr<crTableIO>techlvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		crTableIO::DataVec records;
		techlvTab->queryRecords(0,techidStr,records);
		std::string nextTech = crArgumentParser::appItoa(tech+1);
		int techColID = techlvTab->getTitleIndex(techidStr);
		m_result->first = 1;
		for( crTableIO::DataVec::iterator itr = records.begin();
			itr != records.end();
			++itr )
		{
			if((*itr)[techColID] == nextTech)
			{
				playerData->getParam(WCHDATA_JXJFuyalv,param);
				unsigned char fuyalv = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJCoppercash,param);
				int coppercash = *(int *)param;

				unsigned char techlv[19];
				playerData->getParam(WCHDATA_JXJInfantrylv,param);
				techlv[0] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJCavalrylv,param);
				techlv[1] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJArcherlv,param);
				techlv[2] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJSiegelv,param);
				techlv[3] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJShieldlv,param);
				techlv[4] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJGuardlv,param);
				techlv[5] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJSaddlelv,param);
				techlv[6] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJAssaultlv,param);
				techlv[7] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJAssistlv,param);
				techlv[8] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJPenetratelv,param);
				techlv[9] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJManufacturelv,param);
				techlv[10] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJGunpowderlv,param);
				techlv[11] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJBravelv,param);
				techlv[12] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJIroncavalrylv,param);
				techlv[13] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJGearlv,param);
				techlv[14] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJFireboltlv,param);
				techlv[15] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJMasterlv,param);
				techlv[16] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJJuntunlv,param);
				techlv[17] = *(unsigned char *)param;
				playerData->getParam(WCHDATA_JXJReformlv,param);
				techlv[18] = *(unsigned char *)param;

				m_result->second = atoi((*itr)[1].c_str());
				do 
				{
					if(coppercash<atoi((*itr)[1].c_str()))
					{
						m_result->first = -1;
						break;
					}
					if((int)fuyalv<atoi((*itr)[2].c_str()))
					{
						m_result->first = -2;
						break;
					}
					for(int i = 3; i<19; i++)
					{
						if(techColID != i && techlv[i-3]<(unsigned char)atoi((*itr)[i].c_str()))
						{
							m_result->first = 0;
							break;
						}
					}
				} while (0);
				break;
			}
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJTechLevelUpMethod
//
/////////////////////////////////////////
//crJXJTechLevelUpMethod::crJXJTechLevelUpMethod():
//	m_this(NULL)
//{
//}
//
//crJXJTechLevelUpMethod::crJXJTechLevelUpMethod(const crJXJTechLevelUpMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//
//void crJXJTechLevelUpMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//
//void crJXJTechLevelUpMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJTechLevelUpMethod::operator()(crHandle &handle)
//{
//	bool cancelTask = true;
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && myPlayer)
//	{
//		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
//		void *param;
//		crData *data = canvas->getDataClass();
//		data->getParam(WCHDATA_JXJTechID,param);
//		int techid = *(int *)param;
//
//		TechLevelUpCheckResult result;
//		result.first = 0;
//		myPlayer->doEvent(WCH_JXJTechLevelUpCheck,MAKEINT64(techid,&result));
//		if(result.first>0)
//		{
//			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//			if(netConductor)
//			{
//				crWaitNetReturnStreamLogic::getLock();
//				cancelTask = false;
//				void *param;
//				crData *playerData = myPlayer->getDataClass();
//				playerData->getParam(techid,param);
//				unsigned char techlv = *(unsigned char *)(param);
//
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(5);
//				stream->_writeInt(techid);
//				stream->_writeUChar(techlv);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvTechLevelUp,stream.get());
//				netConductor->getNetManager()->sendPacket("all",packet);
//			}
//		}
//	}
//	handle.outputParam(0,&cancelTask);
//}
/////////////////////////////////////////
//
//crJXJRecvTechLevelUpMethod
//
/////////////////////////////////////////
//crJXJRecvTechLevelUpMethod::crJXJRecvTechLevelUpMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvTechLevelUpMethod::crJXJRecvTechLevelUpMethod(const crJXJRecvTechLevelUpMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvTechLevelUpMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvTechLevelUpMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvTechLevelUpMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			int techid = m_stream->_readInt();
//			unsigned char techlv = m_stream->_readUChar();
//			void *param;
//			crData *data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->getParam(techid,param);
//			unsigned char *stechlv = (unsigned char *)param;
//			TechLevelUpCheckResult result;
//			result.first = 0;
//			int *coppercash = NULL;
//			if(*stechlv == techlv)
//			{
//				m_this->doEvent(WCH_JXJTechLevelUpCheck,MAKEINT64(techid,&result));
//				if(result.first>0)
//				{
//					data->getParam(WCHDATA_JXJCoppercash,param);
//					coppercash = (int *)param;
//					*coppercash -= result.second;
//					*stechlv += 1;
//				}
//			}
//			int playerid = m_this->getPlayerID();
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(10);
//				stream->_writeChar(result.first);
//				stream->_writeInt(techid);
//				stream->_writeUChar(*stechlv);
//				if(result.first>0)
//					stream->_writeInt(*coppercash);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvTechLevelUp,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			char *ptr = m_stream->getPtr();
//			char returnCode = m_stream->_readChar();
//			int techid = m_stream->_readInt();
//			unsigned char stechlv = m_stream->_readUChar();
//			void *param;
//			crData *data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->getParam(techid,param);
//			unsigned char *techlv = (unsigned char *)param;
//			*techlv = stechlv;
//			if(returnCode>0)
//			{
//				int coppercash = m_stream->_readInt();
//				data->inputParam(WCHDATA_JXJCoppercash,&coppercash);
//			}
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//			char *ptr2 = m_stream->getPtr();
//			m_stream->seek(ptr - ptr2);
//			crWaitNetReturnStreamLogic::netReturn(m_stream.get());
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUITimerUpdateMethod
//
/////////////////////////////////////////
crJXJUITimerUpdateMethod::crJXJUITimerUpdateMethod()
{
}
crJXJUITimerUpdateMethod::crJXJUITimerUpdateMethod(const crJXJUITimerUpdateMethod& handle):
	crMethod(handle),
	m_ui_building1(handle.m_ui_building1),
	m_ui_buildingSpeed1(handle.m_ui_buildingSpeed1),
	m_ui_building2(handle.m_ui_building2),
	m_ui_buildingSpeed2(handle.m_ui_buildingSpeed2),
	m_building3Back(handle.m_building3Back),
	m_ui_building3(handle.m_ui_building3),
	m_ui_buildingSpeed3(handle.m_ui_buildingSpeed3),
	m_building4Back(handle.m_building4Back),
	m_ui_building4(handle.m_ui_building4),
	m_ui_buildingSpeed4(handle.m_ui_buildingSpeed4),
	m_ui_conscriptionCD1(handle.m_ui_conscriptionCD1),
	m_ui_speed_01(handle.m_ui_speed_01),
	m_ui_conscriptionCD2(handle.m_ui_conscriptionCD2),
	m_ui_speed_02(handle.m_ui_speed_02),
	m_conscriptionBack3(handle.m_conscriptionBack3),
	m_ui_conscriptionCD3(handle.m_ui_conscriptionCD3),
	m_ui_speed_03(handle.m_ui_speed_03),
	m_conscriptionBack4(handle.m_conscriptionBack4),
	m_ui_conscriptionCD4(handle.m_ui_conscriptionCD4),
	m_ui_speed_04(handle.m_ui_speed_04),
	m_ui_buildingSpeedAdd1(handle.m_ui_buildingSpeedAdd1),
	m_ui_buildingSpeedAdd2(handle.m_ui_buildingSpeedAdd2),
	m_ui_buildingSpeedAdd3(handle.m_ui_buildingSpeedAdd3),
	m_ui_buildingSpeedAdd4(handle.m_ui_buildingSpeedAdd4),
	m_ui_SpeedAdd1(handle.m_ui_SpeedAdd1),
	m_ui_SpeedAdd2(handle.m_ui_SpeedAdd2),
	m_ui_SpeedAdd3(handle.m_ui_SpeedAdd3),
	m_ui_SpeedAdd4(handle.m_ui_SpeedAdd4)
{
}
void crJXJUITimerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUITimerUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_ui_building1 = str;
		break;
	case 1:
		m_ui_buildingSpeed1 = str;
		break;
	case 2:
		m_ui_building2 = str;
		break;
	case 3:
		m_ui_buildingSpeed2 = str;
		break;
	case 4:
		m_building3Back = str;
		break;
	case 5:
		m_ui_building3 = str;
		break;
	case 6:
		m_ui_buildingSpeed3 = str;
		break;
	case 7:
		m_building4Back = str;
		break;
	case 8:
		m_ui_building4 = str;
		break;
	case 9:
		m_ui_buildingSpeed4 = str;
		break;
	case 10:
		m_ui_conscriptionCD1 = str;
		break;
	case 11:
		m_ui_speed_01 = str;
		break;
	case 12:
		m_ui_conscriptionCD2 = str;
		break;
	case 13:
		m_ui_speed_02 = str;
		break;
	case 14:
		m_conscriptionBack3 = str;
		break;
	case 15:
		m_ui_conscriptionCD3 = str;
		break;
	case 16:
		m_ui_speed_03 = str;
		break;
	case 17:
		m_conscriptionBack4 = str;
		break;
	case 18:
		m_ui_conscriptionCD4 = str;
		break;
	case 19:
		m_ui_speed_04 = str;
		break;
	case 20:
		m_ui_buildingSpeedAdd1 = str;
		break;
	case 21:
		m_ui_buildingSpeedAdd2 = str;
		break;
	case 22:
		m_ui_buildingSpeedAdd3 = str;
		break;
	case 23:
		m_ui_buildingSpeedAdd4 = str;
		break;
	case 24:
		m_ui_SpeedAdd1 = str;
		break;
	case 25:
		m_ui_SpeedAdd2 = str;
		break;
	case 26:
		m_ui_SpeedAdd3 = str;
		break;
	case 27:
		m_ui_SpeedAdd4 = str;
		break;
	}
}
void crJXJUITimerUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		crStaticTextWidgetNode *stBuilding1 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_building1));
		crButtonWidgetNode *bBuildingSpeed1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeed1));
		crStaticTextWidgetNode *stBuilding2 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_building2));
		crButtonWidgetNode *bBuildingSpeed2 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeed2));
		crNode *nBuilding3Back = m_this->getChildNode(m_building3Back);
		crStaticTextWidgetNode *stBuilding3 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_building3));
		crButtonWidgetNode *bBuildingSpeed3 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeed3));
		crNode *nBuilding4Back = m_this->getChildNode(m_building4Back);
		crStaticTextWidgetNode *stBuilding4 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_building4));
		crButtonWidgetNode *bBuildingSpeed4 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeed4));

		crStaticTextWidgetNode *stConscription1 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_conscriptionCD1));
		crButtonWidgetNode *bSpeed1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_speed_01));
		crStaticTextWidgetNode *stConscription2 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_conscriptionCD2));
		crButtonWidgetNode *bSpeed2 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_speed_02));
		crNode *nConscriptionBack3 = m_this->getChildNode(m_conscriptionBack3);
		crStaticTextWidgetNode *stConscription3 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_conscriptionCD3));
		crButtonWidgetNode *bSpeed3 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_speed_03));
		crNode *nConscriptionBack4 = m_this->getChildNode(m_conscriptionBack4);
		crStaticTextWidgetNode *stConscription4 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ui_conscriptionCD4));
		crButtonWidgetNode *bSpeed4 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_speed_04));
		crButtonWidgetNode *buildingSpeedAdd1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeedAdd1));
		crButtonWidgetNode *buildingSpeedAdd2 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeedAdd2));
		crButtonWidgetNode *buildingSpeedAdd3 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeedAdd3));
		crButtonWidgetNode *buildingSpeedAdd4 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_buildingSpeedAdd4));
		crButtonWidgetNode *SpeedAdd1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_SpeedAdd1));
		crButtonWidgetNode *SpeedAdd2 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_SpeedAdd2));
		crButtonWidgetNode *SpeedAdd3 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_SpeedAdd3));
		crButtonWidgetNode *SpeedAdd4 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ui_SpeedAdd4));

		int nowbuildingbar = 0;
		int nowrecruitbar = 0;
		void *param;
		crData *data = playerGameData->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData, 1));
		data->getParam(WCHDATA_JXJBuildingTimes,param);
		crVector4i *buildingTimes = (crVector4i *)param;
		data->getParam(WCHDATA_JXJRecruitTimes,param);
		crVector4i *recruitTimes = (crVector4i *)param;
		// update time
		for(int i = 0; i < 4; i++)
		{
			if((*buildingTimes)[i] > 0)
			{
				(*buildingTimes)[i] -= 1;
			}

			if((*recruitTimes)[i] > 0)
			{
				(*recruitTimes)[i] -= 1;
			}

			if((*buildingTimes)[i] >= 0)
				nowbuildingbar++;
			if((*recruitTimes)[i] >= 0)
				nowrecruitbar++;
		}
		//data->getParam(WCHDATA_JXJBuildingTimes,param);
		//(*(crVector4i *)param) = buildingTimes;
		//data->getParam(WCHDATA_JXJRecruitTimes,param);
		//(*(crVector4i *)param) = buildingTimes;
		data->excHandle(MAKEINT64(WCH_LockData, 0));
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));

		int maxbuildingcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,viplv).c_str()));
		int maxrecruitcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,viplv).c_str()));
		if (maxbuildingcount > nowbuildingbar)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeChar(0);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOpenTimer,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		if (maxrecruitcount > nowrecruitbar)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeChar(1);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOpenTimer,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		ref_ptr<crTableIO> viplvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJVipLevelTab);

		int times,t;
		int hour,minute,s;
		std::string showtime;
		///////////////////////////Building1
		if(stBuilding1)
		{
			if ((*buildingTimes)[0] == 0)
			{
				stBuilding1->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
				stBuilding1->setString(L"空闲");
				stBuilding1->setAlignment(CRText::crText::CENTER_BASE_LINE);
			}
			else
			{
				times = (*buildingTimes)[0];
				hour = times/3600;
				t = times%3600;
				minute = t/60;
				s = t%60;
				if((*buildingTimes)[0]>=overTimes)
					stBuilding1->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
				else
					stBuilding1->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
				showtime = IfHourOverOneDay(hour);
				if (showtime == "0")stBuilding1->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
				else stBuilding1->setString(showtime);
			}
		}
		if(bBuildingSpeed1)
		{
			bBuildingSpeed1->setVisiable((*buildingTimes)[0]>0);
		}
		//if (buildingSpeedAdd1)
		//{
		//	buildingSpeedAdd1->setVisiable((*buildingTimes)[0] < 0);
		//}
		///////////////////////////Building2
		if(stBuilding2)
		{
			if((*buildingTimes)[1]>=0)
			{
				if ((*buildingTimes)[1] == 0)
				{
					stBuilding2->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
					stBuilding2->setString(L"空闲");
					stBuilding2->setAlignment(CRText::crText::CENTER_BASE_LINE);
				}
				else
				{
					times = (*buildingTimes)[1];
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					if((*buildingTimes)[1]>=overTimes)
						stBuilding2->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
					else
						stBuilding2->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
					showtime = IfHourOverOneDay(hour);
					if (showtime == "0")stBuilding2->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
					else stBuilding2->setString(showtime);
					stBuilding2->setCanFocus(false);
				}
			}
			else
			{
				//stBuilding2->setString(L"购买建筑时间轴");
				int vip = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					int barcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,i).c_str()));
					if (barcount == 2)
					{
						vip = i;
						break;
					}
				}
				//std::string str = "VIP"+crArgumentParser::appItoa(vip)+"开放";
				std::string str = "未开启";
				stBuilding2->setString(str);
			}
		}
		if(bBuildingSpeed2)
		{
			bBuildingSpeed2->setVisiable((*buildingTimes)[1]>0);
		}
		if (buildingSpeedAdd2)
		{
			buildingSpeedAdd2->setVisiable((*buildingTimes)[1] < 0);
		}
		///////////////////////////Building3
		if(nBuilding3Back)
		{
			//nBuilding3Back->setVisiable((*buildingTimes)[1]>=0);
			nBuilding3Back->setVisiable(true); //默认开启状态
		}
		if(stBuilding3)
		{
			//stBuilding3->setVisiable((*buildingTimes)[1]>=0);
			stBuilding3->setVisiable(true); //默认开启状态
			if((*buildingTimes)[2]>=0)
			{
				if ((*buildingTimes)[2] == 0)
				{
					stBuilding3->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
					stBuilding3->setString(L"空闲");
					stBuilding3->setAlignment(CRText::crText::CENTER_BASE_LINE);
				}
				else
				{
					times = (*buildingTimes)[2];
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					if((*buildingTimes)[2]>=overTimes)
						stBuilding3->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
					else
						stBuilding3->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
					showtime = IfHourOverOneDay(hour);
					if (showtime == "0")stBuilding3->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
					else stBuilding3->setString(showtime);
					stBuilding3->setCanFocus(false);
				}
			}
			else
			{
				//stBuilding3->setString(L"购买建筑时间轴");
				int vip = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					int barcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,i).c_str()));
					if (barcount == 3)
					{
						vip = i;
						break;
					}
				}
				//std::string str = "VIP"+crArgumentParser::appItoa(vip)+"开放";
				std::string str = "未开启";
				stBuilding3->setString(str);
			}
		}
		if(bBuildingSpeed3)
		{
			bBuildingSpeed3->setVisiable((*buildingTimes)[2]>0);
		}
		if (nBuilding3Back->getVisiable())
		{
			if (buildingSpeedAdd3)
			{
				buildingSpeedAdd3->setVisiable((*buildingTimes)[2] < 0);
			}
		}
		///////////////////////////Building4
		if(nBuilding4Back)
		{
			//nBuilding4Back->setVisiable((*buildingTimes)[2]>=0);
			nBuilding4Back->setVisiable(true); //默认状开启态
		}
		if(stBuilding4)
		{
			//stBuilding4->setVisiable((*buildingTimes)[2]>=0);
			stBuilding4->setVisiable(true); //默认开启状态
			if((*buildingTimes)[3]>=0)
			{
				if ((*buildingTimes)[3] == 0)
				{
					stBuilding4->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
					stBuilding4->setString(L"空闲");
					stBuilding4->setAlignment(CRText::crText::CENTER_BASE_LINE);
				}
				else
				{
					times = (*buildingTimes)[3];
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					if((*buildingTimes)[3]>=overTimes)
						stBuilding4->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
					else
						stBuilding4->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
					showtime = IfHourOverOneDay(hour);
					if (showtime == "0")stBuilding4->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
					else stBuilding4->setString(showtime);
					stBuilding4->setCanFocus(false);
				}
			}
			else
			{
				//stBuilding4->setString(L"购买建筑时间轴");
				int vip = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					int barcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,i).c_str()));
					if (barcount == 4)
					{
						vip = i;
						break;
					}
				}
				//std::string str = "VIP"+crArgumentParser::appItoa(vip)+"开放";
				std::string str = "未开启";
				stBuilding4->setString(str);
			}
		}
		if(bBuildingSpeed4)
		{
			bBuildingSpeed4->setVisiable((*buildingTimes)[3]>0);
		}
		if (nBuilding4Back->getVisiable())
		{
			if (buildingSpeedAdd4)
			{
				buildingSpeedAdd4->setVisiable((*buildingTimes)[3] < 0);
			}
		}
		///////////////////////////Conscription1
		if(stConscription1)
		{
			if ((*recruitTimes)[0] == 0)
			{
				stConscription1->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
				stConscription1->setString(L"空闲");
				stConscription1->setAlignment(CRText::crText::CENTER_BASE_LINE);
			}
			else
			{
				times = (*recruitTimes)[0];
				hour = times/3600;
				t = times%3600;
				minute = t/60;
				s = t%60;
				if((*recruitTimes)[0]>=overTimes)
					stConscription1->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
				else
					stConscription1->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
				showtime = IfHourOverOneDay(hour);
				if (showtime == "0")stConscription1->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
				else stConscription1->setString(showtime);
			}
		}
		if(bSpeed1)
		{
			bSpeed1->setVisiable((*recruitTimes)[0]>0);
		}
		//if (SpeedAdd1)
		//{
		//	SpeedAdd1->setVisiable((*recruitTimes)[0] < 0);
		//}
		///////////////////////////Conscription2
		if(stConscription2)
		{
			if((*recruitTimes)[1]>=0)
			{
				if ((*recruitTimes)[1] == 0)
				{
					stConscription2->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
					stConscription2->setString(L"空闲");
					stConscription2->setAlignment(CRText::crText::CENTER_BASE_LINE);
				}
				else
				{
					times = (*recruitTimes)[1];
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					if((*recruitTimes)[1]>=overTimes)
						stConscription2->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
					else
						stConscription2->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
					showtime = IfHourOverOneDay(hour);
					if (showtime == "0")stConscription2->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
					else stConscription2->setString(showtime);
					stConscription2->setCanFocus(false);
				}
			}
			else
			{
				//stConscription2->setString(L"购买征兵时间轴");
				int vip = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					int barcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,i).c_str()));
					if (barcount == 2)
					{
						vip = i;
						break;
					}
				}
				//std::string str = "VIP"+crArgumentParser::appItoa(vip)+"开放";
				std::string str = "未开启";
				stConscription2->setString(str);
			}
		}
		if(bSpeed2)
		{
			bSpeed2->setVisiable((*recruitTimes)[1]>0);
		}
		if (SpeedAdd2)
		{
			SpeedAdd2->setVisiable((*recruitTimes)[1] < 0);
		}
		///////////////////////////Conscription3
		if(nConscriptionBack3)
		{
			//nConscriptionBack3->setVisiable((*recruitTimes)[1]>=0);
			nConscriptionBack3->setVisiable(true); //默认为开启状态
		}
		if(stConscription3)
		{
			//stConscription3->setVisiable((*recruitTimes)[1]>=0);
			stConscription3->setVisiable(true); //默认开启状态
			if((*recruitTimes)[2]>=0)
			{
				if ((*recruitTimes)[2] == 0)
				{
					stConscription3->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
					stConscription3->setString(L"空闲");
					stConscription3->setAlignment(CRText::crText::CENTER_BASE_LINE);
				}
				else
				{
					times = (*recruitTimes)[2];
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					if((*recruitTimes)[2]>=overTimes)
						stConscription3->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
					else
						stConscription3->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
					showtime = IfHourOverOneDay(hour);
					if (showtime == "0")stConscription3->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
					else stConscription3->setString(showtime);
					stConscription3->setCanFocus(false);
				}
			}
			else
			{
				//stConscription3->setString(L"购买征兵时间轴");
				int vip = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					int barcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,i).c_str()));
					if (barcount == 3)
					{
						vip = i;
						break;
					}
				}
				//std::string str = "VIP"+crArgumentParser::appItoa(vip)+"开放";
				std::string str = "未开启";
				stConscription3->setString(str);
			}
		}
		if(bSpeed3)
		{
			bSpeed3->setVisiable((*recruitTimes)[2]>0);
		}
		if (nConscriptionBack3->getVisiable())
		{
			if (SpeedAdd3)
			{
				SpeedAdd3->setVisiable((*recruitTimes)[2] < 0);
			}
		}
		///////////////////////////Conscription4
		if(nConscriptionBack4)
		{
			//nConscriptionBack4->setVisiable((*recruitTimes)[2]>=0);
			nConscriptionBack4->setVisiable(true); //默认为开启状态
		}
		if(stConscription4)
		{
			//stConscription4->setVisiable((*recruitTimes)[2]>=0);
			stConscription4->setVisiable(true); //默认开启状态
			if((*recruitTimes)[3]>=0)
			{
				if ((*recruitTimes)[3] == 0)
				{
					stConscription4->setColor(crVector4(0.0f, 0.6f, 0.0f, 1.0f));
					stConscription4->setString(L"空闲");
					stConscription4->setAlignment(CRText::crText::CENTER_BASE_LINE);
				}
				else
				{
					times = (*recruitTimes)[3];
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					if((*recruitTimes)[3]>=overTimes)
						stConscription4->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
					else
						stConscription4->setColor(crVector4(1.0f,1.0f,1.0f,1.0f));
					showtime = IfHourOverOneDay(hour);
					if (showtime == "0")stConscription4->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
					else stConscription4->setString(showtime);
					stConscription4->setCanFocus(false);
				}
			}
			else
			{
				//stConscription4->setString(L"购买征兵时间轴");
				int vip = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					int barcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,i).c_str()));
					if (barcount == 4)
					{
						vip = i;
						break;
					}
				}
				//std::string str = "VIP"+crArgumentParser::appItoa(vip)+"开放";
				std::string str = "未开启";
				stConscription4->setString(str);
			}
		}
		if(bSpeed4)
		{
			bSpeed4->setVisiable((*recruitTimes)[3]>0);
		}
		if (nConscriptionBack4->getVisiable())
		{
			if (SpeedAdd4)
			{
				SpeedAdd4->setVisiable((*recruitTimes)[3] < 0);
			}
		}
	}
}
std::string crJXJUITimerUpdateMethod::IfHourOverOneDay(int hour)
{
	std::string str; 
	int i = 0;
	if (hour<24)
	{
		//str = crArgumentParser::appItoa(hour);
		str = "0";
		return str;
	}
	for (int j = 0; j < 7; j++)
	{
		i += 24;
		if (hour >= i && hour < i + 24)
		{
			str = "大于"+crArgumentParser::appItoa(j+1)+"天";
			return str;
		}
	}
	i = 0;
	for (int j = 0; j < 4; j++)
	{
		i += 24 * 7;
		if (hour >= i && hour < i + 24 * 7)
		{
			str = "大于"+crArgumentParser::appItoa(j+1)+"周";
			return str;
		}
	}
	i = 0;
	for (int j = 0; j < 12; j++)
	{
		i += 24 * 7 * 4;
		if (hour >= i && hour < i + 24 * 7 * 4)
		{
			str = "大于"+crArgumentParser::appItoa(j+1)+"月";
			return str;
		}
	}
	str = "大于一年";
	return str;
	
}


/////////////////////////////////////////
//
//crJXJUIRecruitUpdateMethod
//
/////////////////////////////////////////
crJXJUIRecruitUpdateMethod::crJXJUIRecruitUpdateMethod()
{
}
crJXJUIRecruitUpdateMethod::crJXJUIRecruitUpdateMethod(const crJXJUIRecruitUpdateMethod& handle):
	crMethod(handle),
	m_armyRadio(handle.m_armyRadio),
	m_armyTypeRadio(handle.m_armyTypeRadio),
	m_armUp(handle.m_armUp),
	m_armDown(handle.m_armDown)
{
}
void crJXJUIRecruitUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIRecruitUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_armyRadio = str;
		break;
	case 1:
		m_armyTypeRadio = str;
		break;
	case 2:
		m_armUp = str;
		break;
	case 3:
		m_armDown = str;
		break;
	}
}
void crJXJUIRecruitUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		crRadioGroupWidgetNode *armyRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_armyRadio));
		crRadioGroupWidgetNode *armyTypeRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_armyTypeRadio));
		crButtonWidgetNode *armUp = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_armUp));
		crButtonWidgetNode *armDown = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_armDown));
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		if(troopsTab.valid())
		{
			crRadioGroupWidgetNode::RadioGroup &radioGroup = armyRadioGroup->getRadioGroup();
			int armType = armyTypeRadioGroup->getSelect();
			int canindex = troopsTab->getTitleIndex("可招募");
			crTableIO::DataVec recordVec;
			troopsTab->queryRecords(2,crArgumentParser::appItoa(armType),canindex,"1",recordVec);
			void *param;
			crData *data = crBrain::getInstance()->getDataClass();
			data->getParam(WCHDATA_JXJRecruitArmyVec,param);
			RecruitArmyVec *recruitarmyvec = (RecruitArmyVec *)param;
			recruitarmyvec->clear();
			data->getParam(WCHDATA_JXJCurRecruitArmID,param);
			int curRecruitRow = *(int *)param;
			int rowCount = recordVec.size();
			armUp->setEnable(curRecruitRow > 0);
			int count = rowCount - radioGroup.size();
			armDown->setEnable(curRecruitRow < count);
			std::string iconfile1;
			crMultiSwitch *radioButton;
			crStateSet *ss1;
			crTexture2D *tex2d;
			crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
			int cursel = armyRadioGroup->getSelect();
			int abastactid = 0;
			int selAbastactid = 0;
			RecruitCheckResult recruitCheck;
			int iconid = troopsTab->getTitleIndex("icon");
			int iconid1 = troopsTab->getTitleIndex("icon灰");
			int row = 0;
			//int row = curRecruitRow;
			std::vector<int> EnableRowVec;
			std::vector<int> DisableRowVec;
			int i = 0;
			for( ; row<rowCount && itr != radioGroup.end(); ++row)
			{
				abastactid = atoi(recordVec[row][0].c_str());
				playerData->doEvent(WCH_JXJRecruitCheck,MAKEINT64(abastactid,&recruitCheck));
				if(recruitCheck.m_code == -3 || recruitCheck.m_code == -4)
				{
					DisableRowVec.push_back(row);
					//continue;
				}
				else
				{
					EnableRowVec.push_back(row);
				}
			}
			if (!EnableRowVec.empty())
			{
				for( int j = curRecruitRow;
					itr != radioGroup.end() && j<EnableRowVec.size();
					/*++itr,*/++j )
				{
					row = EnableRowVec[j];
					abastactid = atoi(recordVec[row][0].c_str());
					recruitarmyvec->push_back(abastactid);
					if(cursel == i)
						selAbastactid = abastactid;
					iconfile1 = recordVec[row][iconid];

					radioButton = itr->second->getButton();
					radioButton->setVisiable(true);
					ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

					tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
					if(tex2d)
					{
						if(tex2d->getImageNameID().compare(iconfile1)!=0)
							tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
					}
					else
					{
						tex2d = new crTexture2D;
						tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
						tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
						tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
						tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
						tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
						tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
						ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
					}
					++itr;
					++i;
				}
			}
			if(i<radioGroup.size())
			{
				if(!DisableRowVec.empty())
				{
					for( int j = curRecruitRow + i - EnableRowVec.size();
						itr != radioGroup.end() && j<DisableRowVec.size();
						++itr,++j )
					{
						row = DisableRowVec[j];
						abastactid = atoi(recordVec[row][0].c_str());
						recruitarmyvec->push_back(abastactid);
						if(cursel == i)
							selAbastactid = abastactid;
						iconfile1 = recordVec[row][iconid1];
						radioButton = itr->second->getButton();
						radioButton->setVisiable(true);
						ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

						tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
						if(tex2d)
						{
							if(tex2d->getImageNameID().compare(iconfile1)!=0)
								tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
						}
						else
						{
							tex2d = new crTexture2D;
							tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
							tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
							tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
							tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
							ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
						}
						++i;
					}
				}
			}
			for( ;
				itr != radioGroup.end();
				++itr )
			{
				radioButton = itr->second->getButton();
				radioButton->setVisiable(false);
			}
			if(i>0) i--;
			if(cursel>i)
			{
 				cursel = i;
				armyRadioGroup->select(i);
				selAbastactid = abastactid;
			}
			data->getParam(WCHDATA_JXJCurSelRecruitArmAID,param);
			int oldid = *(int *)param;
			if (oldid != selAbastactid)
			{
				bool setnum = true;
				data->inputParam(WCHDATA_JXJIfSetArmyNum, &setnum);
			}
			data->inputParam(WCHDATA_JXJCurSelRecruitArmAID,&selAbastactid);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIRecruitSelInfoUpdateMethod
//
/////////////////////////////////////////
crJXJUIRecruitSelInfoUpdateMethod::crJXJUIRecruitSelInfoUpdateMethod():
	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f))
{
}
crJXJUIRecruitSelInfoUpdateMethod::crJXJUIRecruitSelInfoUpdateMethod(const crJXJUIRecruitSelInfoUpdateMethod& handle):
	crMethod(handle),
	m_condition(handle.m_condition),
	m_armyInfo(handle.m_armyInfo),
	m_armyInput(handle.m_armyInput),
	m_equip(handle.m_equip),
	m_equipTotal(handle.m_equipTotal),
	m_coppercashTotal(handle.m_coppercashTotal),
	m_foodTotal(handle.m_foodTotal),
	m_timeTotal(handle.m_timeTotal),
	m_recruitBtn(handle.m_recruitBtn),
	m_equipForge(handle.m_equipForge),
	m_inputInc(handle.m_inputInc),
	m_inputDec(handle.m_inputDec),
	m_namecolor(handle.m_namecolor)
{
}
void crJXJUIRecruitSelInfoUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIRecruitSelInfoUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_condition = str;
		break;
	case 1:
		m_armyInfo = str;
		break;
	case 2:
		m_armyInput = str;
		break;
	case 3:
		m_equip = str;
		break;
	case 4:
		m_equipTotal = str;
		break;
	case 5:
		m_coppercashTotal = str;
		break;
	case 6:
		m_foodTotal = str;
		break;
	case 7:
		m_timeTotal = str;
		break;
	case 8:
		m_recruitBtn = str;
		break;
	case 9:
		m_equipForge = str;
		break;
	case 10:
		m_inputInc = str;
		break;
	case 11:
		m_inputDec = str;
		break;
	case 12:
		crArgumentParser::appAtoVec(str,m_namecolor);
		break;
	case 13:
		m_ironinput = str;
		break;
	case 14:
		m_woodinput = str;
		break;
	case 15:
		m_horseinput = str;
		break;
	}
}
void crJXJUIRecruitSelInfoUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		crHypertextWidgetNode *condition = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_condition));
 		crHypertextWidgetNode *armyInfo = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_armyInfo));
		crEditWidgetNode *armyInput = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_armyInput));
		crStaticTextWidgetNode *equip = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_equip));
		crStaticTextWidgetNode *equipTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_equipTotal));
		crStaticTextWidgetNode *coppercashTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_coppercashTotal));
		crStaticTextWidgetNode *foodTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodTotal));
		crStaticTextWidgetNode *timeTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timeTotal));
		crButtonWidgetNode *recruitBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_recruitBtn));
		crButtonWidgetNode *equipForge = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_equipForge));
		crButtonWidgetNode *inputInc = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_inputInc));
		crButtonWidgetNode *inputDec = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_inputDec));
		crStaticTextWidgetNode *woodTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodinput));
		crStaticTextWidgetNode *ironTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironinput));
		crStaticTextWidgetNode *horseTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseinput));
		if (armyInput)armyInput->setEnable(false);

		void *param;
		crData *data = crBrain::getInstance()->getDataClass();
		data->getParam(WCHDATA_JXJCurSelRecruitArmAID,param);
		int selAbastactid = *(int *)param;
		if(selAbastactid>0)
		{
			crTableIO::StrVec record,recordtech;
			std::string str;
			std::vector< int > needtechvec;
			ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			ref_ptr<crTableIO>TroopsTechTab = CRNetApp::crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTechTab);	// troops look-up table 
			int conditionid = troopsTab->getTitleIndex("条件");
			int infoid = troopsTab->getTitleIndex("说明");
			int levelid = troopsTab->getTitleIndex("兵营等级");
			int techneedindex = troopsTab->getTitleIndex("需求军备ID");
			int nameindex = TroopsTechTab->getTitleIndex("name");
			std::string needtechstring;
			if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa(selAbastactid),record)<0)
				return;
			crArgumentParser::appAtoVec(record[techneedindex].c_str(),needtechvec);
			/////////////////
			if (condition)
			{
				ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
				crTableIO::StrVec record;
				std::string str= "需求:";
				if(textTab.valid() && textTab->queryOneRecord(0,crArgumentParser::appItoa(9185),record)>=0)
				{
					str = record[1];
				}

				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content");
				cfg_script.Add("Text",str);
				cfg_script.Pop();

				int contentindex = 2;
				for (int i = 0; i < needtechvec.size(); )
				{
					if (TroopsTechTab->queryOneRecord(0,crArgumentParser::appItoa(needtechvec[i]),recordtech)>=0)
					{
						cfg_script.Add("Content");
						cfg_script.Push("Content",contentindex);
						v_i.clear();
						v_i.push_back(m_namecolor[0]);
						v_i.push_back(m_namecolor[1]);
						v_i.push_back(m_namecolor[2]);
						v_i.push_back(m_namecolor[3]);
						cfg_script.Add("Color",v_i);
						char tmpText[160];
						sprintf(tmpText,"【%s】\0",recordtech[nameindex].c_str());
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
						++contentindex;
					}
					++i;
				}
				//cfg_script.Add("Content");
				//cfg_script.Push("Content",2);
				//v_i.clear();
				//v_i.push_back(m_namecolor[0]);
				//v_i.push_back(m_namecolor[1]);
				//v_i.push_back(m_namecolor[2]);
				//v_i.push_back(m_namecolor[3]);
				//cfg_script.Add("Color",v_i);
				//char tmpText[160];
				//sprintf(tmpText,"【%d】\0",atoi(record[levelid].c_str()));
				//cfg_script.Add("Text",tmpText);
				//cfg_script.Pop();

				//cfg_script.Add("Content");
				//cfg_script.Push("Content",3);
				//cfg_script.Add("Text","级");
				//cfg_script.Pop();

				cfg_script.Pop();
				condition->setHypertext(cfg_script);
			}
			//if(condition)
			//{
			//	std::string file = record[conditionid];
			//	if(!file.empty())
			//	{
			//		file = crGlobalHandle::getInstance()->getTextDir() + file;
			//		if(condition)condition->setHypertext(file);
			//	}
			//	else
			//	{
			//		if(condition)condition->clearText();
			//	}
			//}
			if(armyInfo)
			{
				std::string file = record[infoid];
				if(!file.empty())
				{
					file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
					if(armyInfo)armyInfo->setHypertext(file);
				}
				else
				{
					if(armyInfo)armyInfo->clearText();
				}
			}
			RecruitCheckResult recruitCheck;
			playerData->doEvent(WCH_JXJRecruitCheck,MAKEINT64(selAbastactid,&recruitCheck));

			if(armyInput)armyInput->setEnable(true);
			int armys = atoi(armyInput->getUTF8String().c_str());
			if (armys > 0)
			{
				if(armys>recruitCheck.m_maxRecruitCount)
				{
					if (recruitCheck.m_maxRecruitCount < 0)
					{
						recruitCheck.m_maxRecruitCount = 0;
					}
					armys = recruitCheck.m_maxRecruitCount;
					if(armyInput)armyInput->setString(crArgumentParser::appItoa(armys));
				}
			}
			//else if(armys == 0)
			//{
			//	armys = 1;
			//	if(armyInput)armyInput->setString(crArgumentParser::appItoa(armys));
			//}
			if(inputInc)inputInc->setEnable(armys<recruitCheck.m_maxRecruitCount);
			if(inputDec)inputDec->setEnable(armys>1);
			unsigned short equipid = recruitCheck.m_equipid;
			if(equipid>0)
			{
				int equipgot = 0;
				crData *data2 = playerData->getDataClass();
				ref_ptr<crTableIO>equipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
				if(equipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record)>=0)
				{

					str = "需求"+record[1];
					if(equip)equip->setString(str);

					////////////////////////////////////////////////
					data2->getParam(WCHDATA_JXJTroopsEquipMap,param);
					TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
					data->inputParam(WCHDATA_JXJEquipID,&equipid);
					TroopsEquipMap::iterator itr = equipMap->find(recruitCheck.m_equipid);
					if(itr != equipMap->end())
					{
						equipgot = itr->second;
					}
					////////////////////////////////////////////////////
					//record[troopsTab->getTitleIndex("装备数量")] ;
					//if(equipTotal)
					//{
					//	equipTotal->setVisiable(true);
					//	equipTotal->setString(record[1] + "("+ crArgumentParser::appItoa(recruitCheck.m_equipCount * armys)/*+"/"+crArgumentParser::appItoa(equipgot)*/ + ")");
					//}
				}
				if(equip)equip->setVisiable(true);
				if(equipForge)equipForge->setVisiable(true);
			}
			else
			{
				if(equip)equip->setVisiable(false);
				//if(equipTotal)equipTotal->setVisiable(false);
				if(equipForge)equipForge->setVisiable(false);
			}
			if (coppercashTotal)coppercashTotal->setString(crArgumentParser::appItoa(ceil(recruitCheck.m_needresourcevec[T_Copper - T_Food] * armys)));
			if (foodTotal)foodTotal->setString(crArgumentParser::appItoa(ceil(recruitCheck.m_needresourcevec[T_Food - T_Food] * armys)));
			if (woodTotal)woodTotal->setString(crArgumentParser::appItoa(ceil(recruitCheck.m_needresourcevec[T_Wood - T_Food] * armys)));
			if (ironTotal)ironTotal->setString(crArgumentParser::appItoa(ceil(recruitCheck.m_needresourcevec[T_Iron - T_Food] * armys)));
			if (horseTotal)horseTotal->setString(crArgumentParser::appItoa(ceil(recruitCheck.m_needresourcevec[T_Horse - T_Food] * armys)));
			int times = recruitCheck.m_timeNeed * armys;
			int t,hour,minute,s;
			hour = times/3600;
			t = times%3600;
			minute = t/60;
			s = t%60;
			if(timeTotal)timeTotal->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
			if(recruitBtn)recruitBtn->setEnable(recruitCheck.m_code>0);
		}
		else
		{
			if (condition)
			{
				condition->clearText();
			}
			if (armyInfo)
			{
				armyInfo->clearText();
			}
			if (armyInput)armyInput->clearString();
			if (equip)equip->setVisiable(false);
			if (equipTotal)equipTotal->setVisiable(false);
			if (coppercashTotal)coppercashTotal->clearString();
			if (foodTotal)foodTotal->clearString();
			if (timeTotal)timeTotal->clearString();
			if (recruitBtn)recruitBtn->setEnable(false);
			if (equipForge)equipForge->setVisiable(false);
			if (woodTotal)woodTotal->clearString();
			if (ironTotal)ironTotal->clearString();
			if (horseTotal)horseTotal->clearString();
		}
	}
}
/////////////////////////////////////////
//
//crJXJUITroopsListUpdateMethod
//
/////////////////////////////////////////
crJXJUITroopsListUpdateMethod::crJXJUITroopsListUpdateMethod()
{
}
crJXJUITroopsListUpdateMethod::crJXJUITroopsListUpdateMethod(const crJXJUITroopsListUpdateMethod& handle):
	crMethod(handle),
	m_troopsList(handle.m_troopsList)
{
}
void crJXJUITroopsListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUITroopsListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_troopsList = str;
		break;
	}
}
void crJXJUITroopsListUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		crTableIO::StrVec record;
		crTableWidgetNode *troopsList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_troopsList));
		void *param;
		crData *data = playerData->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troopsMap = (TroopsMap *)param;
		troopsList->clearData();
		int row = 0;
		for( TroopsMap::iterator itr = troopsMap->begin();
			itr != troopsMap->end();
			++itr)
		{
			if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa(itr->first),record) >= 0)
			{
				troopsList->addData(0,row,record[1]);
				troopsList->addData(1,row,crArgumentParser::appItoa(itr->second));
				++row;
			}
		}
		//troopsList->selectRow(0);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecruitCheckMethod
//
/////////////////////////////////////////
crJXJRecruitCheckMethod::crJXJRecruitCheckMethod():
	m_this(NULL),
	m_troopsAbstractID(0),
	m_result(NULL)
{
}

crJXJRecruitCheckMethod::crJXJRecruitCheckMethod(const crJXJRecruitCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_troopsAbstractID(handle.m_troopsAbstractID),
	m_result(NULL)
{
}

void crJXJRecruitCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_result = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_troopsAbstractID = LOINT64(param64);
			m_result = (RecruitCheckResult *)(HIINT64(param64));
		}
		else
		{
			m_result = NULL;
		}
		break;
	}
}

void crJXJRecruitCheckMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecruitCheckMethod::operator()(crHandle &handle)
{
	if(m_result)
	{
		void *param;
		crData *playerData = m_this->getDataClass();
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troopsMap = (TroopsMap *)param;
		m_result->m_code = 0;
		if(troopsMap)
		{
			playerData->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int maxSoldiers = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxSoldiers,viplv).c_str());
			TroopsMap::iterator itr = troopsMap->find(m_troopsAbstractID);
			if(itr != troopsMap->end())
			{
				int count = itr->second;
				if(count>=maxSoldiers)
				{//部队人数上限
					m_result->m_code = -1;
				}
				else
				{
					m_result->m_maxRecruitCount = maxSoldiers - count;
				}
			}
			else
			{
				//playerData->getParam(WCHDATA_JXJMaxTroops,param);
				//unsigned char maxtroops = *(unsigned char*)param;
				//if(troopsMap->size()>=maxtroops)
				//{//队伍数量上限
				//	m_result->m_code = -2;
				//}
				m_result->m_maxRecruitCount = maxSoldiers;
			}
			ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			crTableIO::StrVec record;
			std::string idStr = crArgumentParser::appItoa(m_troopsAbstractID);
			troopsTab->queryOneRecord(0,idStr,record);

			if (record.size()>0)
			{
				//int index = 3;//兵营等级
				int index = 4;
				//兵营等级// 此条废除
				//m_result->m_bingyinglvNeed = (unsigned char)(atoi(record[index++].c_str()));
				//playerData->getParam(WCHDATA_JXJBingyinglv,param);
				//unsigned char mybylv = *(unsigned char *)param;
				//if(m_result->m_bingyinglvNeed>mybylv)
				//{
				//	m_result->m_code = -3;
				//}
				int canindex = troopsTab->getTitleIndex("可招募");
				if(record[canindex]=="0")
					m_result->m_code = -12;//不可招募
				//军备条件
				m_result->m_needjunbeivec.clear();
				int needjunbeiindex = troopsTab->getTitleIndex("需求军备ID");
				crArgumentParser::appAtoVec(record[needjunbeiindex].c_str(),m_result->m_needjunbeivec);
				playerData->getParam(WCHDATA_JXJTroopsTechMap,param);
				TroopsTechMap *troopstechmap = (TroopsTechMap *)param;
				TroopsTechMap::iterator techitr;
				for (std::vector<int>::iterator itr = m_result->m_needjunbeivec.begin();
					itr != m_result->m_needjunbeivec.end();
					++itr)
				{
					if ((*itr) > 0)
					{
						techitr = troopstechmap->find((*itr));
						if (techitr == troopstechmap->end() || techitr->second <= 0)
						{
							m_result->m_code = -3;
							break;
						}
					}
				}
				//驻地条件
				m_result->m_stationidNeed = atoi(record[index++].c_str());
				if(m_result->m_stationidNeed>0)
				{
					playerData->getParam(WCHDATA_JXJChengchiID,param);
					unsigned short myStationID = *(unsigned short *)param;
					if(m_result->m_stationidNeed!=myStationID)
					{
						m_result->m_code = -4;
					}
				}
				int canRecruitCount = 0;
				//时间条件
				m_result->m_timeNeed = atof(record[index++].c_str());
				float speed = 0.0f;
				m_this->doEvent(WCH_JXJGetRecruitSpeed,MAKEINT64(&speed,NULL));
				m_result->m_timeNeed = (float)m_result->m_timeNeed * (1.0f - speed);

				playerData->getParam(WCHDATA_JXJRecruitTimes,param);
				crVector4i recruitTimes = *(crVector4i *)param;
				short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
				int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitCreditTime,viplv).c_str()));
				int i = 0;
				int timeRemain = 0;
				for(; i<4; i++)
				{
					if(crGlobalHandle::isClient())
					{
						if(recruitTimes[i]>=0 && recruitTimes[i] < overTimes-60)
							timeRemain += overTimes - recruitTimes[i] + credittime;
					}
					else
					{
						if(recruitTimes[i]>=0 && recruitTimes[i] < overTimes)
							timeRemain += overTimes - recruitTimes[i] + credittime;
					}
				}
				if(timeRemain==0)
				{//没有招募时间
					if (m_result->m_code != -3 && m_result->m_code != -4)
					{
						m_result->m_code = -5;
					}
				}
				else
				{
					//timeRemain += (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreditTime).c_str()));
					if (m_result->m_timeNeed <= 0)
					{
						canRecruitCount = m_result->m_maxRecruitCount;
					}
					else
					{
						canRecruitCount = (float)timeRemain / (m_result->m_timeNeed);
					}
					m_result->m_maxRecruitCount = CRCore::minimum(canRecruitCount,m_result->m_maxRecruitCount);
				}
				//消耗减少
				double consume = 0.0;
				m_this->doEvent(WCH_JXJGetRecruitConsume,MAKEINT64(&consume,NULL));

				//装备条件
				m_result->m_equipid = atoi(record[index++].c_str());
				m_result->m_equipCount = atoi(record[index++].c_str());
				//装备改为自动打造
				//if(m_result->m_equipid>0)
				//{
				//	playerData->getParam(WCHDATA_JXJTroopsEquipMap,param);
				//	TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
				//	TroopsEquipMap::iterator itr = equipMap->find(m_result->m_equipid);
				//	if (m_result->m_equipCount != 0)
				//	{
				//		if(itr != equipMap->end() && itr->second >= m_result->m_equipCount)
				//		{
				//			if (m_result->m_equipCount)
				//			{
				//				canRecruitCount = itr->second/m_result->m_equipCount;
				//			}
				//			m_result->m_maxRecruitCount = CRCore::minimum(canRecruitCount,m_result->m_maxRecruitCount);
				//		}
				//		else
				//		{
				//			m_result->m_code = -6;
				//		}
				//	}
				//}
				//else
				//{
				//	m_result->m_equipCount = 0;
				//}
				//资源条件
				int resourceindex[5] = {0};
				resourceindex[0] = troopsTab->getTitleIndex("粮食");
				resourceindex[1] = troopsTab->getTitleIndex("木材");
				resourceindex[2] = troopsTab->getTitleIndex("铁矿");
				resourceindex[3] = troopsTab->getTitleIndex("马匹");
				resourceindex[4] = troopsTab->getTitleIndex("铜钱");
				float needresource = 0.0f;
				int resource[5] = {0};
				for (int i = 0; i < 4; ++i)
				{
					playerData->getParam(WCHDATA_JXJFood + i,param);
					resource[i] = *(int *)param;
				}
				playerData->getParam(WCHDATA_JXJCoppercash,param);
				resource[4] = *(int *)param;

				m_result->m_needresourcevec.clear();
				for (int i = 0; i < 5; ++i)
				{
					needresource = ceil(atof(record[resourceindex[i]].c_str()));
					needresource = needresource * (1.0f - consume);
					m_result->m_needresourcevec.push_back(needresource);
					if(needresource<resource[i] || needresource == 0)
					{
						if (needresource <= 0)
						{
							canRecruitCount = m_result->m_maxRecruitCount;
						}
						else
						{
							canRecruitCount = resource[i]/needresource;
						}
						m_result->m_maxRecruitCount = CRCore::minimum(canRecruitCount,m_result->m_maxRecruitCount);
					}
					else
					{
						if (m_result->m_code != -3 && m_result->m_code != -4)
						{
							//char val = m_result->m_code;
							m_result->m_code = -7 - i;
							//if ((!((m_troopsAbstractID>=20013 && m_troopsAbstractID<20018) ||m_troopsAbstractID==20509 ||m_troopsAbstractID==20510)) && i ==3)
							//{
								//m_result->m_code = val;
							//}
						}
					}
				}
				////粮食条件
				//m_result->m_foodNeed = atoi(record[index++].c_str());
				//m_result->m_foodNeed = ceil((float)m_result->m_foodNeed * (1.0f - consume));
				//playerData->getParam(WCHDATA_JXJFood,param);
				//int food = *(int *)param;
				//if(m_result->m_foodNeed<food)
				//{
				//	if (m_result->m_foodNeed <= 0)
				//	{
				//		canRecruitCount = m_result->m_maxRecruitCount;
				//	}
				//	else
				//	{
				//		canRecruitCount = food/m_result->m_foodNeed;
				//	}
				//	m_result->m_maxRecruitCount = CRCore::minimum(canRecruitCount,m_result->m_maxRecruitCount);
				//}
				//else
				//{
				//	if (m_result->m_code != -3 && m_result->m_code != -4)
				//	{
				//		m_result->m_code = -8;
				//	}
				//}
				//所有条件都满足
				if(m_result->m_code == 0) 
					m_result->m_code = 1;
				else
					m_result->m_maxRecruitCount = 1;
			}
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIRecruitArmWalkMethod
//
/////////////////////////////////////////
crJXJUIRecruitArmWalkMethod::crJXJUIRecruitArmWalkMethod():
	m_this(NULL),
	m_step(1)
{
}
crJXJUIRecruitArmWalkMethod::crJXJUIRecruitArmWalkMethod(const crJXJUIRecruitArmWalkMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_step(handle.m_step),
	m_armyTypeRadio(handle.m_armyTypeRadio)
{
}
void crJXJUIRecruitArmWalkMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIRecruitArmWalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	case 1:
		m_armyTypeRadio = str;
		break;
	}
}
void crJXJUIRecruitArmWalkMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		if (canvas.get())
		{
			crRadioGroupWidgetNode *armyTypeRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_armyTypeRadio));
			ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			if(troopsTab.valid() && armyTypeRadioGroup)
			{
				int armtype;
				int currentSelectArmType = armyTypeRadioGroup->getSelect();
				int rowCount = troopsTab->getRowCount();
				int armCount = 0;
				for( int i = 0; i<rowCount; i++)
				{
					armtype = atoi((*troopsTab)(i,2).c_str());
					if(armtype == currentSelectArmType)
					{
						armCount++;
					}
				}
				void *param;
				crData *data = crBrain::getInstance()->getDataClass();
				data->getParam(WCHDATA_JXJCurRecruitArmID,param);
				int* curArmID = (int *)param;
				int tryID = *curArmID + m_step;
				if(tryID<0)
					*curArmID = 0;
				else if(tryID < armCount)
					*curArmID = tryID;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIRecruitCountStepMethod
//
/////////////////////////////////////////
crJXJUIRecruitCountStepMethod::crJXJUIRecruitCountStepMethod():
	m_this(NULL),
	m_step(1)
{
}
crJXJUIRecruitCountStepMethod::crJXJUIRecruitCountStepMethod(const crJXJUIRecruitCountStepMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_step(handle.m_step),
	m_input(handle.m_input),
	m_min(handle.m_min)
{
}
void crJXJUIRecruitCountStepMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIRecruitCountStepMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_min = atoi(str.c_str());
		break;
	}
}
void crJXJUIRecruitCountStepMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crEditWidgetNode *input = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input));
		int armys = _wtoi(input->getString().c_str());
		int curnumber = armys + m_step;
		if (curnumber>=m_min)
		{
			input->setString(crArgumentParser::appItoa(armys+m_step));
		}
	}
}

////////////////////////////////////////////
//
//crJXJUISetCountScrolPosMethod
//
////////////////////////////////////////////
crJXJUISetCountScrolPosMethod::crJXJUISetCountScrolPosMethod():
	m_this(NULL),
	m_min(0.0),m_max(1.0)
{
}
crJXJUISetCountScrolPosMethod::crJXJUISetCountScrolPosMethod(const crJXJUISetCountScrolPosMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_min(handle.m_min),m_max(handle.m_max),m_sourceCount(NULL)
{
}

void crJXJUISetCountScrolPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISetCountScrolPosMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_min = atof(str.c_str());
		break;
	case 1:
		m_max = atof(str.c_str());
		break;
	case 2:
		m_type = atoi(str.c_str());
		break;
	case 3:
		m_scrollbar = str;
		break;
	case 4:
		m_input_f = str;
		break;
	case 5:
		m_input_w = str;
		break;
	case 6:
		m_input_i = str;
		break;
	case 7:
		m_input_h = str;
		break;
	}
}
void crJXJUISetCountScrolPosMethod::operator ()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	crScrollBarWidgetNode *slider = dynamic_cast<crScrollBarWidgetNode*>(canvas->getWidget(m_scrollbar));
	crEditWidgetNode *sourceCount_f = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input_f));
	crEditWidgetNode *sourceCount_w = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input_w));
	crEditWidgetNode *sourceCount_i = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input_i));
	crEditWidgetNode *sourceCount_h = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input_h));
	ref_ptr<crTableIO>shijiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShijiTab);
	crEditWidgetNode *sourceCount = NULL;
	//slider->setRange(m_min,m_max);
	std::string str ;
	if (myPlayer)
	{
		int _value;
		int count;
 		void *param;
 		crData *data = myPlayer->getDataClass();
		switch (m_type)
		{
		case 0:
			data->getParam(WCHDATA_JXJFood,param);
			count = *(int *)param;
			_value = /**(int *)param **/slider->getValue();
			sourceCount = sourceCount_f;
			break;
		case 1:
			data->getParam(WCHDATA_JXJWood,param);
			count = *(int *)param;
			_value = /**(int *)param **/slider->getValue();
			sourceCount = sourceCount_w;
			break;
		case 2:
			data->getParam(WCHDATA_JXJIron,param);
			count = *(int *)param;
			_value = /**(int *)param **/slider->getValue();
			sourceCount = sourceCount_i;
			break;
		case 3:
			data->getParam(WCHDATA_JXJHorse,param);
			count = *(int *)param;
			_value = /**(int *)param **/slider->getValue();
			sourceCount = sourceCount_h;
			break;
		}
		data->getParam(WCHDATA_JXJShijilv,param);
		unsigned char shijilv = *(unsigned char *)param;
		int id = shijiTab->getRowByID((int)shijilv);
		int maxcount = atoi((*shijiTab)(id,1).c_str());

		data->getParam(WCHDATA_JXJSaleList,param);
		SaleList *saleList = (SaleList *)param;
		int salecount = 0;
		for( SaleList::iterator itr = saleList->begin();
			itr != saleList->end();
			++itr )
		{
			salecount += (*itr)->getCount();
		}
		int tempcount =0;
		tempcount = _wtoi(sourceCount_f->getString().c_str()) + _wtoi(sourceCount_w->getString().c_str()) + _wtoi(sourceCount_i->getString().c_str()) + _wtoi(sourceCount_h->getString().c_str());
		int remaincount = maxcount - salecount/*-tempcount*/;
		if(remaincount<0)
			remaincount = 0;
		if(_value>remaincount)
			slider->outerSetValue(remaincount/*/(float)CRCore::minimum(count,maxcount)*/);
		_value = (_value>remaincount)?remaincount:_value;
		str = crArgumentParser::appItoa(_value);
	}
	sourceCount->setString(str);
}
/////////////////////////////////////////
//
//crJXJUIRecruitCountInputMethod
//
/////////////////////////////////////////
crJXJUIRecruitCountInputMethod::crJXJUIRecruitCountInputMethod():
	m_this(NULL)
{
}
crJXJUIRecruitCountInputMethod::crJXJUIRecruitCountInputMethod(const crJXJUIRecruitCountInputMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUIRecruitCountInputMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crEditWidgetNode*)param;
		break;
	}
}
void crJXJUIRecruitCountInputMethod::addParam(int i, const std::string& str)
{
}
void crJXJUIRecruitCountInputMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int armys = atoi(m_this->getUTF8String().c_str());
		if(armys<=0)
		{
			m_this -> clearString();
			armys = 0;
		}
		m_this->setString(crArgumentParser::appItoa(armys));
	}
}
/////////////////////////////////////////
//
//crJXJUIRecruitArmResetMethod
//
/////////////////////////////////////////
crJXJUIRecruitArmResetMethod::crJXJUIRecruitArmResetMethod()
{
}
crJXJUIRecruitArmResetMethod::crJXJUIRecruitArmResetMethod(const crJXJUIRecruitArmResetMethod& handle):
	crMethod(handle)
{
}
void crJXJUIRecruitArmResetMethod::inputParam(int i, void *param)
{
}
void crJXJUIRecruitArmResetMethod::addParam(int i, const std::string& str)
{
}
void crJXJUIRecruitArmResetMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = crBrain::getInstance()->getDataClass();
	data->getParam(WCHDATA_JXJCurRecruitArmID,param);
	int* curArmID = (int *)param;
	*curArmID = 0;
}
/////////////////////////////////////////
//
//crJXJUIRecruitMethod
//
/////////////////////////////////////////
crJXJUIRecruitMethod::crJXJUIRecruitMethod():
	m_this(NULL)
{
}
crJXJUIRecruitMethod::crJXJUIRecruitMethod(const crJXJUIRecruitMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_armyInput(handle.m_armyInput),
	m_recruiteCanvas(handle.m_recruiteCanvas)
{
}
void crJXJUIRecruitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIRecruitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_armyInput = str;
		break;
	case 1:
		m_recruiteCanvas = str;
		break;
	default:
		break;
	}
}
void crJXJUIRecruitMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_recruiteCanvas);
		if (!canvas.valid()) return;
		crEditWidgetNode *armyInput = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_armyInput));
		if (armyInput)
		{
			int armys = _wtoi(armyInput->getString().c_str());
			void *param;
			crData *data = crBrain::getInstance()->getDataClass();
			data->getParam(WCHDATA_JXJCurSelRecruitArmAID,param);
			int selAbastactid = *(int *)param;
			if(selAbastactid>0 && armys>0)
			{
				RecruitCheckResult recruitCheck;
				myPlayer->doEvent(WCH_JXJRecruitCheck,MAKEINT64(selAbastactid,&recruitCheck));
				if(recruitCheck.m_code>0 && armys<=recruitCheck.m_maxRecruitCount)
				{
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(8);
						stream->_writeInt(selAbastactid);
						stream->_writeInt(armys);
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRecruit,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvRecruitMethod
//
/////////////////////////////////////////
crJXJRecvRecruitMethod::crJXJRecvRecruitMethod():
	m_netType(GameClient_Game){}
crJXJRecvRecruitMethod::crJXJRecvRecruitMethod(const crJXJRecvRecruitMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRecruitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRecruitMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvRecruitMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int abstractid = m_stream->_readInt();
			int count = m_stream->_readInt();
			int relcount = count;
			void *param;
			bool enoughequip = false;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJCoppercash,param);
			int *coppercash = (int *)param;
			data->getParam(WCHDATA_JXJFood,param);
			int *food = (int *)param;
			data->getParam(WCHDATA_JXJWood,param);
			int *wood = (int *)param;
			data->getParam(WCHDATA_JXJIron,param);
			int *iron = (int *)param;
			data->getParam(WCHDATA_JXJHorse,param);
			int *horse = (int *)param;
			data->getParam(WCHDATA_JXJRecruitTimes,param);
			crVector4i *recruitTimes = (crVector4i *)param;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			unsigned short equipid = 0;
			int equipCount = 0;
			RecruitCheckResult recruitCheck;
			m_this->doEvent(WCH_JXJRecruitCheck,MAKEINT64(abstractid,&recruitCheck));
			if(recruitCheck.m_code==1)
			{
				//修正招募数量
				if(relcount>recruitCheck.m_maxRecruitCount)
				{
					relcount = recruitCheck.m_maxRecruitCount;
				}
				int coppercashNeed = ceil(relcount * recruitCheck.m_needresourcevec[T_Copper - T_Food]);//粮食;;
				int foodNeed = ceil(relcount * recruitCheck.m_needresourcevec[T_Food - T_Food]);//粮食;;
				int woodNeed = ceil(relcount * recruitCheck.m_needresourcevec[T_Wood - T_Food]);//粮食;
				int ironNeed = ceil(relcount * recruitCheck.m_needresourcevec[T_Iron - T_Food]);//粮食;
				int horseNeed = ceil(relcount * recruitCheck.m_needresourcevec[T_Horse - T_Food]);//粮食;
				int timeNeed = ceil(relcount * recruitCheck.m_timeNeed);
				equipid = recruitCheck.m_equipid;
				if(equipid>0)
				{
					int equipNeed = relcount * recruitCheck.m_equipCount;
					if(equipNeed == 0) enoughequip = true;
					data->getParam(WCHDATA_JXJTroopsEquipMap,param);
					TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
					TroopsEquipMap::iterator itr = equipMap->find(equipid);
					if(itr != equipMap->end() && itr->second >= equipNeed)
					{
						itr->second -= equipNeed;
						equipCount = itr->second;
						enoughequip = true;
					}
				}
				if (enoughequip && coppercashNeed >= 0 && foodNeed >= 0 && timeNeed >= 0)
				{
					*coppercash -= coppercashNeed;
					*food -= foodNeed;
					*wood -= woodNeed;
					*iron -= ironNeed;
					*horse -= horseNeed;

					short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime,viplv).c_str()));
					int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitCreditTime,viplv).c_str()));
					int t;
					for(int i = 0; timeNeed>0 && i<4; i++)
					{
						if((*recruitTimes)[i]>=0 && (*recruitTimes)[i]<overTimes)
						{
							t = overTimes + credittime - (*recruitTimes)[i];
							if(timeNeed>t)
							{
								(*recruitTimes)[i] += t;
								timeNeed -= t;
							}
							else
							{
								(*recruitTimes)[i] += timeNeed;
								timeNeed = 0;
							}
						}
					}
					if(timeNeed>0)
					{
						for(int i = 0; i<4; i++)
						{
							if((*recruitTimes)[i]>=0 && (*recruitTimes)[i]<=overTimes)
							{

								(*recruitTimes)[i] += timeNeed;						
								break;
							}
						}
					}
					//募兵暴击
					m_this->doEvent(MAKEINT64(WCH_JXJVIPExtend, WCH_JXJVIPRecruit), MAKEINT64(&relcount, NULL));
					
					//募兵
					data->getParam(WCHDATA_JXJTroopsMap,param);
					TroopsMap *troopsMap = (TroopsMap *)param;
					TroopsMap::iterator itr = troopsMap->find(abstractid);
					if(itr != troopsMap->end())
					{
						itr->second += relcount;
						relcount = itr->second;
					}
					else
					{
						troopsMap->insert(std::make_pair(abstractid,relcount));
					}
				}
			}
			//返回信息
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(51);
				stream->_writeChar(recruitCheck.m_code);
				if(recruitCheck.m_code==1)
				{
					stream->_writeInt(abstractid);
					stream->_writeInt(relcount);
					stream->_writeInt(*coppercash);
					stream->_writeInt(*food);//4
					stream->_writeInt(*wood);//4
					stream->_writeInt(*iron);//4
					stream->_writeInt(*horse);//4
					stream->_writeUShort(equipid);//2
					if(equipid>0)
						stream->_writeInt(equipCount);//4
					stream->_writeVec4i(*recruitTimes);//16
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvRecruit,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			if(recruitCheck.m_code==1)
			{
				//增加活跃度/////////////////////////////////
				m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKEINT64(HYD_RecruitArmy, 1));
				///////////////////////////////////////////////
				///游戏日志
				std::string logdata = "招兵" + crArgumentParser::appVectoa(crVector2i(abstractid,relcount));
				GameLogData gamelog(Log_ReCruitArmy,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				int abstractid = m_stream->_readInt();
				int count = m_stream->_readInt();
				int coppercash = m_stream->_readInt();
				int food = m_stream->_readInt();
				int wood = m_stream->_readInt();
				int iron = m_stream->_readInt();
				int horse = m_stream->_readInt();
				unsigned short equipid = m_stream->_readUShort();
				int equipCount = 0;
				if(equipid>0)
					equipCount = m_stream->_readInt();
				crVector4i recruitTimes = m_stream->_readVec4i();

				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJCoppercash,param);
				int *curcoppercash = (int *)param;
				data->getParam(WCHDATA_JXJFood,param);
				int *curfood = (int *)param;
				data->getParam(WCHDATA_JXJWood,param);
				int *curwood = (int *)param;
				data->getParam(WCHDATA_JXJIron,param);
				int *curiron = (int *)param;
				data->getParam(WCHDATA_JXJHorse,param);
				int *curhorse = (int *)param;
				data->getParam(WCHDATA_JXJTroopsEquipMap,param);
				TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
				(*equipMap)[equipid] = equipCount;
				data->inputParam(WCHDATA_JXJRecruitTimes,&recruitTimes);

				//募兵
				data->getParam(WCHDATA_JXJTroopsMap,param);
				TroopsMap *troopsMap = (TroopsMap *)param;
				//显示招募成功信息
				int extra = 0;
				TroopsMap::iterator itr = troopsMap->find(abstractid);
				if(itr!=troopsMap->end())
				{
					extra = count - (*troopsMap)[abstractid];
				}
				else
				{
					extra = count;
				}

				(*troopsMap)[abstractid] = count;
				
				if(extra!=0)crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(abstractid,extra));
				extra = coppercash - (*curcoppercash);
				if(extra!=0)crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Copper,extra));
				extra = food - (*curfood);
				if(extra!=0)crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Food,extra));
				extra = wood - (*curwood);
				if(extra!=0)crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Wood,extra));
				extra = iron - (*curiron);
				if(extra!=0)crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Iron,extra));
				extra = horse - (*curhorse);
				if(extra!=0)crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Horse,extra));
				*curcoppercash = coppercash;
				*curfood = food;
				*curwood = wood;
				*curiron = iron;
				*curhorse = horse;
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUITechUpdateInitMethod
//
/////////////////////////////////////////
crJXJUITechUpdateInitMethod::crJXJUITechUpdateInitMethod():
	m_techid(0)
{
}
crJXJUITechUpdateInitMethod::crJXJUITechUpdateInitMethod(const crJXJUITechUpdateInitMethod& handle):
	crMethod(handle),
	m_techid(handle.m_techid),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJUITechUpdateInitMethod::inputParam(int i, void *param)
{
}
void crJXJUITechUpdateInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_techid = atoi(str.c_str());
		break;
	case 1:
		m_canvasName = str;
		break;
	}
}
void crJXJUITechUpdateInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvas.valid())
	{
		crData *data = canvas->getDataClass();
		data->inputParam(WCHDATA_JXJTechID,&m_techid);
	}
}
/////////////////////////////////////////
//
//crJXJUITechTipInfoMethod
//
/////////////////////////////////////////
crJXJUITechTipInfoMethod::crJXJUITechTipInfoMethod():
	m_techid(0)
{
}
crJXJUITechTipInfoMethod::crJXJUITechTipInfoMethod(const crJXJUITechTipInfoMethod& handle):
	crMethod(handle),
	m_techid(handle.m_techid),
	m_canvasName(handle.m_canvasName),
	m_titleName(handle.m_titleName),
	m_info(handle.m_info),
	m_money(handle.m_money),
	m_nextlvDes(handle.m_nextlvDes)
{
}
void crJXJUITechTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUITechTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_techid = atoi(str.c_str());
		break;
	case 1:
		m_canvasName = str;
		break;
	case 2:
		m_titleName = str;
		break;
	case 3:
		m_info = str;
		break;
	case 4:
		m_money = str;
		break;
	case 5:
		m_nextlvDes = str;
		break;
	}
}
void crJXJUITechTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(canvas.valid() && myPlayer)
	{
		crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_titleName));
		crHypertextWidgetNode *info = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_info));
		crStaticTextWidgetNode *money = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_money));
		crHypertextWidgetNode *nextlvDes = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_nextlvDes));

		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(m_techid,param);
		unsigned char lv = *(unsigned char *)param;

		ref_ptr<crTableIO>infoTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInfoTab);
		std::string idStr = crArgumentParser::appItoa(m_techid);
		crTableIO::StrVec infoRec;
		infoTab->queryOneRecord(0,idStr,infoRec);
		if(title)
		{
			std::string name = infoRec[1] + crArgumentParser::appItoa(lv);
			title->setString(name);
		}
		if(info)
		{
			std::string file = infoRec[2];
			if(!file.empty())
			{
				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
				info->setHypertext(file);
			}
			else
			{
				info->clearText();
			}
		}

		ref_ptr<crTableIO>techlvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		int techColID = techlvTab->getTitleIndex(idStr);
		crTableIO::DataVec records;
		techlvTab->queryRecords(0,idStr,records);
		std::string nextTech = crArgumentParser::appItoa(lv+1);
		for( crTableIO::DataVec::iterator itr = records.begin();
			itr != records.end();
			++itr )
		{
			if((*itr)[techColID] == nextTech)
			{
				if(money)
				{
					money->setString((*itr)[1]);
				}
				if(nextlvDes)
				{
					std::string file = (*itr)[22];
					
					if(!file.empty())
					{
						file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						nextlvDes->setHypertext(file);
					}
					else
					{
						nextlvDes->clearText();
					}
				}
			}
		}
		crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
		canvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
		canvas->setCanFocus(false);
		crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
	}
}
/////////////////////////////////////////
//
//crJXJUITechUpdateMethod
//
/////////////////////////////////////////
crJXJUITechUpdateMethod::crJXJUITechUpdateMethod():
	m_techstartid(0)
{
}

crJXJUITechUpdateMethod::crJXJUITechUpdateMethod(const crJXJUITechUpdateMethod& handle):
	crMethod(handle),
	m_techstartid(handle.m_techstartid),
	m_techlvStrVec(handle.m_techlvStrVec),
	m_techbtnStrVec(handle.m_techbtnStrVec)
{
}

void crJXJUITechUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUITechUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_techstartid = atoi(str.c_str());
		break;
	default:
		if(i<20)
			m_techlvStrVec.push_back(str);
		else
			m_techbtnStrVec.push_back(str);
	}
}

void crJXJUITechUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		crStaticTextWidgetNode *techlvWidget;
		crButtonWidgetNode *techbtnWidget;
		int techid = m_techstartid;
		unsigned char lv;
		TechLevelUpCheckResult result;
		for( int i = 0; i<19; ++i,++techid)
		{
			techlvWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_techlvStrVec[i]));
			if(techlvWidget)
			{
				data->getParam(techid,param);
				lv = *(unsigned char *)param;
				techlvWidget->setString(crArgumentParser::appItoa(lv));
			}
			techbtnWidget = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_techbtnStrVec[i]));
			if(techbtnWidget)
			{
				result.first = 0;
				myPlayer->doEvent(WCH_JXJTechLevelUpCheck,MAKEINT64(techid,&result));
				techbtnWidget->setEnable(result.first>0);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFormationArmyUpdateMethod
//
/////////////////////////////////////////
crJXJUIFormationArmyUpdateMethod::crJXJUIFormationArmyUpdateMethod()
{
}
crJXJUIFormationArmyUpdateMethod::crJXJUIFormationArmyUpdateMethod(const crJXJUIFormationArmyUpdateMethod& handle):
	crMethod(handle),
	m_armyRadio(handle.m_armyRadio),
	m_phalanxRadio(handle.m_phalanxRadio),
	m_army01(handle.m_army01),
	m_army02(handle.m_army02),
	m_army03(handle.m_army03),
	m_army04(handle.m_army04),
	m_army05(handle.m_army05),
	m_army06(handle.m_army06),
	m_phalanx01(handle.m_phalanx01),
	m_phalanx02(handle.m_phalanx02),
	m_phalanx03(handle.m_phalanx03)
{
}
void crJXJUIFormationArmyUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIFormationArmyUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_armyRadio = str;
		break;
	case 1:
		m_phalanxRadio = str;
		break;
	case 2:
		m_army01 = str;
		break;
	case 3:
		m_army02 = str;
		break;
	case 4:
		m_army03 = str;
		break;
	case 5:
		m_army04 = str;
		break;
	case 6:
		m_army05 = str;
		break;
	case 7:
		m_army06 = str;
		break;
	case 8:
		m_phalanx01 = str;
		break;
	case 9:
		m_phalanx02 = str;
		break;
	case 10:
		m_phalanx03 = str;
		break;
	}
}
void crJXJUIFormationArmyUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		crRadioGroupWidgetNode *armyRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_armyRadio));
		crRadioGroupWidgetNode *phalanxRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_phalanxRadio));
		crStaticTextWidgetNode *armys[6];
		crStaticTextWidgetNode *phalanxes[6];
		armys[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_army01));
		armys[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_army02));
		armys[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_army03));
		armys[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_army04));
		armys[4] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_army05));
		armys[5] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_army06));
		phalanxes[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_phalanx01));
		phalanxes[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_phalanx02));
		phalanxes[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_phalanx03));
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		if(troopsTab.valid())
		{
			int rowCount = troopsTab->getRowCount();
			std::string iconfile1;
			crRadioGroupWidgetNode::RadioGroup &radioGroup = armyRadioGroup->getRadioGroup();
			crMultiSwitch *radioButton;
			crStateSet *ss1;
			crTexture2D *tex2d;
			crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
			unsigned int cursel = armyRadioGroup->getSelect();
			void *param;
			crData *data = crBrain::getInstance()->getDataClass();
			data->getParam(WCHDATA_JXJCurFormationArmID,param);
			int curid = *(int *)param;
			int abastactid = 0;
			int selAbastactid = 0;
			crData *myData = playerData->getDataClass();
			myData->excHandle(MAKEINT64(WCH_LockData,1));
			myData->getParam(WCHDATA_JXJTroopsMap,param);
			TroopsMap *troopsMap = (TroopsMap *)param;
			int i = 0;
			crTableIO::StrVec record;
			int iconid = troopsTab->getTitleIndex("icon");
			TroopsMap::iterator titr = troopsMap->begin();
			for( int iid = 0; iid<curid && titr!= troopsMap->end(); iid++)
			{
				titr++;
			}
			for( ;
				 itr != radioGroup.end() && titr!= troopsMap->end();
				 ++itr,++titr,++i )
			{
				abastactid = titr->first;
				//显示已有数量
				armys[i]->setVisiable(true);
				armys[i]->setString(crArgumentParser::appItoa(titr->second));
				////////////
				troopsTab->queryOneRecord(0,crArgumentParser::appItoa(abastactid),record);
				iconfile1 = record[iconid];

				radioButton = itr->second->getButton();
				radioButton->setVisiable(true);
				ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

				tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
				if(tex2d)
				{
					if(tex2d->getImageNameID().compare(iconfile1)!=0)
						tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				}
				else
				{
					tex2d = new crTexture2D;
					tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
					tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
					tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
					ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				}

				if(i == cursel)
				{
					selAbastactid = abastactid;
				}
			}
			for( ;
				itr != radioGroup.end();
				++itr,++i )
			{
				radioButton = itr->second->getButton();
				radioButton->setVisiable(false);
				armys[i]->setVisiable(false);
			}
			if(i<cursel)
			{
				selAbastactid = abastactid;
				armyRadioGroup->select(i);
			}
			data->inputParam(WCHDATA_JXJCurSelFormationArmAID,&selAbastactid);
			//编队信息
			myData->getParam(WCHDATA_JXJFormationInfoVec,param);
			crFormationInfo *fi;
			FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
			i = 0;
			crRadioGroupWidgetNode::RadioGroup &phyRadioGroup = phalanxRadioGroup->getRadioGroup();
			for( FormationInfoVec::iterator itr = formationInfoVec->begin();
				 itr != formationInfoVec->end();
				 ++itr,++i )
			{
				fi = itr->get();
				abastactid = fi->getAbstractID();
				//显示已有数量
				phalanxes[i]->setVisiable(true);
				phalanxes[i]->setString(crArgumentParser::appItoa(fi->getCount()));

				troopsTab->queryOneRecord(0,crArgumentParser::appItoa(abastactid),record);
				iconfile1 = record[iconid];

				radioButton = phalanxRadioGroup->getRadio(i)->getButton();
				radioButton->setVisiable(true);
				ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

				tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
				if(tex2d)
				{
					if(tex2d->getImageNameID().compare(iconfile1)!=0)
						tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				}
				else
				{
					tex2d = new crTexture2D;
					tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
					tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
					tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
					ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				}
			}
			for ( ; i<phyRadioGroup.size(); ++i)
			{
				radioButton = phalanxRadioGroup->getRadio(i)->getButton();
				radioButton->setVisiable(false);
				phalanxes[i]->setVisiable(false);
			}
			myData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFormationArmyWalkMethod
//
/////////////////////////////////////////
crJXJUIFormationArmyWalkMethod::crJXJUIFormationArmyWalkMethod():
	m_step(1)
{
}
crJXJUIFormationArmyWalkMethod::crJXJUIFormationArmyWalkMethod(const crJXJUIFormationArmyWalkMethod& handle):
	crMethod(handle),
	m_step(handle.m_step)
{
}
void crJXJUIFormationArmyWalkMethod::inputParam(int i, void *param)
{
}
void crJXJUIFormationArmyWalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	}
}
void crJXJUIFormationArmyWalkMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		void *param;
        crData *myData = playerData->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		myData->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troopsMap = (TroopsMap *)param;
		int armCount = troopsMap->size();
		crData *data = crBrain::getInstance()->getDataClass();
		data->getParam(WCHDATA_JXJCurFormationArmID,param);
		int* curArmID = (int *)param;
		int tryID = *curArmID + m_step;
		if(tryID<0)
			*curArmID = 0;
		else if(tryID < armCount)
			*curArmID = tryID;
		myData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIFormationMethod
//
/////////////////////////////////////////
crJXJUIFormationMethod::crJXJUIFormationMethod():
	m_this(NULL)
{
}
crJXJUIFormationMethod::crJXJUIFormationMethod(const crJXJUIFormationMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_input(handle.m_input)
{
}
void crJXJUIFormationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIFormationMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	}
}
void crJXJUIFormationMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crEditWidgetNode *countInput = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input));
		unsigned short inputarms = _wtoi(countInput->getString().c_str());

		void *param;
		crData *data = crBrain::getInstance()->getDataClass();
		data->getParam(WCHDATA_JXJCurSelFormationArmAID,param);
		int selAbastactid = *(int *)param;
		crRole *mainRole = myPlayer->getMainRole();
		if(mainRole && selAbastactid>0 && inputarms>0 && netConductor)
		{
			crData *playerData = myPlayer->getDataClass();
			playerData->excHandle(MAKEINT64(WCH_LockData,1));
			playerData->getParam(WCHDATA_JXJTroopsMap,param);
			TroopsMap *troopsMap = (TroopsMap*)param;
			TroopsMap::iterator titr = troopsMap->find(selAbastactid);
			unsigned short relarms = inputarms;
			if(titr != troopsMap->end())
			{
				//maxSoldiers应该为我对应官职的最大数量
				ref_ptr<crTableIO>govTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				crData *mainRoleData = mainRole->getDataClass();
				mainRoleData->getParam(WCHDATA_JXJGovPost,param);
				unsigned char govPost = *(unsigned char *)param;
				unsigned short maxSoldiers = (unsigned short)(atoi(govTab->getData(govTab->getRowByID(govPost),2).c_str()));
				if(relarms>maxSoldiers)
					relarms = maxSoldiers;
				if(relarms>titr->second)
					relarms = titr->second;
				if(relarms>0)
				{//可编队校验
					playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
					crFormationInfo *fi;
					unsigned short armcount;
					unsigned short remainarms = relarms;
					unsigned short arms;
					FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
					for( FormationInfoVec::iterator itr = formationInfoVec->begin();
						itr != formationInfoVec->end() && remainarms>0;
						++itr )
					{
						fi = itr->get();
						if(fi->getAbstractID() == selAbastactid)
						{
							armcount = fi->getCount();
							if(armcount<maxSoldiers)
							{
								arms = maxSoldiers-armcount;
								if(arms>remainarms)
								{
									remainarms = 0;
								}
								else
								{
									remainarms -= arms;
								}
							}
						}
					}
					if(remainarms>0 && formationInfoVec->size()<3)
					{
						remainarms = 0;
					}
					relarms -= remainarms;
					//crMyPlayerData::getInstance()->lockGameRoleMap();
					//CRNetApp::GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
					//crRole *myRole;
					//crData *roleData;
					///*unsigned short*/int armcount;
					//unsigned short remainarms = relarms;
					//unsigned short arms;
					//for( CRNetApp::GameRoleMap::iterator itr = gameRoleMap.begin();
					//	 itr != gameRoleMap.end() && remainarms>0;
					//	 ++itr )
					//{
					//	myRole = itr->second.get();
					//	if(myRole->getAbstractItemID() == selAbastactid)
					//	{//
					//		roleData = myRole->getDataClass();
					//		roleData->excHandle(MAKEINT64(WCH_LockData,1));
					//		roleData->getParam(WCHDATA_JXJArmyCount,param);
					//		armcount = *(/*unsigned short*/int *)param;
					//		if(armcount<maxSoldiers)
					//		{
					//			arms = maxSoldiers-armcount;
					//			if(arms>remainarms)
					//			{
					//				remainarms = 0;
					//			}
					//			else
					//			{
					//				remainarms -= arms;
					//			}
					//			//roleData->excHandle(MAKEINT64(WCH_BuildDataStream,SaveStream));
					//			//roleData->getParam(WCHDATA_DataStream,param);
					//			//if(param)
					//			//{
					//			//	stream = *((ref_ptr<crStreamBuf>*)param);
					//			//	crSaveItemStreamPacket packet;
					//			//	crSaveItemStreamPacket::buildRequestPacket(packet,myRole->getInstanceItemID(),stream.get());
					//			//	netConductor->getNetManager()->sendPacket("all",packet);
					//			//}
					//		}
					//		roleData->excHandle(MAKEINT64(WCH_LockData,0));
					//	}
					//}
					//crMyPlayerData::getInstance()->unlockGameRoleMap();

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(6);
					stream->_writeInt(selAbastactid);
					stream->_writeUShort(relarms);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvFormation,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			playerData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvFormationMethod
//
/////////////////////////////////////////
crJXJRecvFormationMethod::crJXJRecvFormationMethod():
	m_netType(GameClient_Game){}
crJXJRecvFormationMethod::crJXJRecvFormationMethod(const crJXJRecvFormationMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvFormationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFormationMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvFormationMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int abstractid = m_stream->_readInt();
			unsigned short relarms = m_stream->_readUShort();
			char done = 0;
			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJTroopsMap,param);
			TroopsMap *troopsMap = (TroopsMap*)param;
			TroopsMap::iterator titr = troopsMap->find(abstractid);
			unsigned short troopsRemain = 0;
			if(titr != troopsMap->end() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				//maxSoldiers应该为我对应官职的最大数量
				ref_ptr<crTableIO>govTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				crData *mainRoleData = m_this->getMainRole()->getDataClass();
				mainRoleData->getParam(WCHDATA_JXJGovPost,param);
				unsigned char govPost = *(unsigned char *)param;
				unsigned short maxSoldiers = (unsigned short)(atoi(govTab->getData(govTab->getRowByID(govPost),2).c_str()));
				if(relarms>maxSoldiers)
					relarms = maxSoldiers;
				if(relarms>titr->second)
					relarms = titr->second;
				if(relarms>0)
				{
					data->getParam(WCHDATA_JXJFormationInfoVec,param);
					ref_ptr<crFormationInfo>fi;
					unsigned short armcount;
					unsigned short remainarms = relarms;
					unsigned short arms;
					FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
					for( FormationInfoVec::iterator itr = formationInfoVec->begin();
						itr != formationInfoVec->end() && remainarms>0;
						++itr )
					{
						fi = itr->get();
						if(fi->getAbstractID() == abstractid)
						{
							armcount = fi->getCount();
							if(armcount<maxSoldiers)
							{
								arms = maxSoldiers-armcount;
								if(arms>remainarms)
								{
									fi->setCount(armcount + remainarms);
									remainarms = 0;
								}
								else
								{
									fi->setCount(armcount + arms);
									remainarms -= arms;
								}
							}
						}
					}
					if(remainarms>0 && formationInfoVec->size()<3)
					{
						fi = new crFormationInfo;
						fi->setAbstractID(abstractid);
						fi->setCount(remainarms);
						formationInfoVec->push_back(fi.get());
						remainarms = 0;
					}
					relarms -= remainarms;
					titr->second -= relarms;
					troopsRemain = titr->second;
					if(titr->second == 0)
					{
						troopsMap->erase(titr);
					}
					done = 1;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//返回信息
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(9);
				stream->_writeChar(done);
				if(done==1)
				{
					stream->_writeInt(abstractid);
					stream->_writeUShort(relarms);
					stream->_writeUShort(troopsRemain);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvFormation,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}				
			///游戏日志
			std::string logdata = "编队";
			GameLogData gamelog(Log_Formation,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				void *param;
				int abstractid = m_stream->_readInt();
				unsigned short relarms = m_stream->_readUShort();
				crData *playerData = m_this->getDataClass();
				playerData->excHandle(MAKEINT64(WCH_LockData,1));
				playerData->getParam(WCHDATA_JXJTroopsMap,param);
				TroopsMap *troopsMap = (TroopsMap*)param;
				TroopsMap::iterator titr = troopsMap->find(abstractid);
				if(titr != troopsMap->end())
				{
					titr->second = m_stream->_readUShort();
					if(relarms>0)
					{
						//maxSoldiers应该为我对应官职的最大数量
						ref_ptr<crTableIO>govTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
						crData *mainRoleData = m_this->getMainRole()->getDataClass();
						mainRoleData->getParam(WCHDATA_JXJGovPost,param);
						unsigned char govPost = *(unsigned char *)param;
						unsigned short maxSoldiers = (unsigned short)(atoi(govTab->getData(govTab->getRowByID(govPost),2).c_str()));

						playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
						ref_ptr<crFormationInfo>fi;
						unsigned short armcount;
						unsigned short remainarms = relarms;
						unsigned short arms;
						FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
						for( FormationInfoVec::iterator itr = formationInfoVec->begin();
							 itr != formationInfoVec->end() && remainarms>0;
							 ++itr )
						{
							fi = itr->get();
							if(fi->getAbstractID() == abstractid)
							{
								armcount = fi->getCount();
								if(armcount<maxSoldiers)
								{
									arms = maxSoldiers-armcount;
									if(arms>remainarms)
									{
										fi->setCount(armcount + remainarms);
										remainarms = 0;
									}
									else
									{
										fi->setCount(armcount + arms);
										remainarms -= arms;
									}
								}
							}
						}
						if(remainarms>0 && formationInfoVec->size()<3)
						{
							fi = new crFormationInfo;
							fi->setAbstractID(abstractid);
							fi->setCount(remainarms);
							formationInfoVec->push_back(fi.get());
							remainarms = 0;
						}
						relarms -= remainarms;
						//titr->second -= relarms;
						if(titr->second == 0)
						{
							troopsMap->erase(titr);
						}
					}
					//ref_ptr<crTableIO>govTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
					//crData *mainRoleData = m_this->getMainRole()->getDataClass();
					//mainRoleData->getParam(WCHDATA_JXJGovPost,param);
					//unsigned char govPost = *(unsigned char *)param;
					//unsigned short maxSoldiers = (unsigned short)(govTab->getData(govTab->getRowByID(govPost),2).c_str());

					//crMyPlayerData::getInstance()->lockGameRoleMap();
					//CRNetApp::GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
					//crRole *myRole;
					//crData *roleData;
					///*unsigned short*/int* armcount;
					//unsigned short arms;
					//ref_ptr<crStreamBuf> stream;
					//crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					//crSaveItemStreamPacket packet;
					//for( CRNetApp::GameRoleMap::iterator itr = gameRoleMap.begin();
					//	 itr != gameRoleMap.end() && relarms>0;
					//	 ++itr )
					//{
					//	myRole = itr->second.get();
					//	if(myRole->getAbstractItemID() == abstractid)
					//	{//
					//		roleData = myRole->getDataClass();
					//		roleData->excHandle(MAKEINT64(WCH_LockData,1));
					//		roleData->getParam(WCHDATA_JXJArmyCount,param);
					//		armcount = (/*unsigned short*/ *)param;
					//		if(*armcount<maxSoldiers)
					//		{
					//			arms = maxSoldiers-*armcount;
					//			if(arms>relarms)
					//			{
					//				*armcount+=relarms;
					//				relarms = 0;
					//			}
					//			else
					//			{
					//				*armcount += arms;
					//				relarms -= arms;
					//			}
					//			roleData->excHandle(MAKEINT64(WCH_BuildDataStream,SaveStream));
					//			roleData->getParam(WCHDATA_DataStream,param);
					//			if(param)
					//			{
					//				stream = *((ref_ptr<crStreamBuf>*)param);
					//				crSaveItemStreamPacket::buildRequestPacket(packet,myRole->getInstanceItemID(),stream.get());
					//				netConductor->getNetManager()->sendPacket("all",packet);
					//			}
					//		}
					//		roleData->excHandle(MAKEINT64(WCH_LockData,0));
					//	}
					//}
					//crMyPlayerData::getInstance()->unlockGameRoleMap();
				}
				playerData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCreateRolesMethod
//
/////////////////////////////////////////
crJXJCreateRolesMethod::crJXJCreateRolesMethod(){}
crJXJCreateRolesMethod::crJXJCreateRolesMethod(const crJXJCreateRolesMethod& handle):
	crMethod(handle)
{
}
void crJXJCreateRolesMethod::inputParam(int i, void *param)
{
}

void crJXJCreateRolesMethod::addParam(int i, const std::string& str)
{
}

void crJXJCreateRolesMethod::operator()(crHandle &handle)
{
	void *param;
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	if(netConductor && playerData)
	{
		playerData->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		char maxFormation = (char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxFormation,viplv).c_str()));
		std::string name = "troops";
		for(char i = 0; i<maxFormation; i++)
		{
			crCreateRolePacket packet;
			crCreateRolePacket::buildRequestPacket(packet,0,0,name+crArgumentParser::appItoa(i));
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGameRoleListStreamMethod
//
/////////////////////////////////////////
crJXJRecvGameRoleListStreamMethod::crJXJRecvGameRoleListStreamMethod(){}
crJXJRecvGameRoleListStreamMethod::crJXJRecvGameRoleListStreamMethod(const crJXJRecvGameRoleListStreamMethod& handle):
	crMethod(handle),
	m_recvDataStream(handle.m_recvDataStream)
{
}
void crJXJRecvGameRoleListStreamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_recvDataStream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recvDataStream = (crRecvDataStream *)(LOINT64(param64));
		}
		else
		{
			m_recvDataStream = NULL;
		}
		break;
	}
}
void crJXJRecvGameRoleListStreamMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvGameRoleListStreamMethod::operator()(crHandle &handle)
{
	if(m_recvDataStream.valid())
	{
		crMyPlayerData::getInstance()->clearGameRoleMap();
		crStreamBuf *stream = m_recvDataStream->getStream();
		int count = (int)(stream->_readUChar());
		ref_ptr<crInstanceItem> item;
		for(int i = 0; i<count; i++)
		{
			readItem(item,stream,false);
			//crBrain::getInstance()->doEvent(WCH_SetSelectRolePosition,MAKEINT64(item.get(),i));
			//download role and loadrole
			if(item->getAbstractItem())
				crGlobalHandle::getInstance()->doEvent(WCH_DownloadItem,MAKEINT64(item.get(),HttpD_DownLoadItem));
			else
				crGlobalHandle::getInstance()->doEvent(WCH_LoadItem,MAKEINT64(item.get(),NULL));
			crMyPlayerData::getInstance()->addGameRole(dynamic_cast<crRole *>(item.get()));
			//if(i == 0)
			//	crMyPlayerData::getInstance()->setSelectedGameRole(dynamic_cast<crRole *>(item.get()));
		}
		void *param;
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		if(netConductor && playerData)
		{
			playerData->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			char maxFormation = (char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxFormation,viplv).c_str()));
			std::string name = "troops";
			for(char i = count; i<maxFormation; i++)
			{
				crCreateRolePacket packet;
				crCreateRolePacket::buildRequestPacket(packet,0,0,name+crArgumentParser::appItoa(i));
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckRolesCreatedMethod
//
/////////////////////////////////////////
crJXJCheckRolesCreatedMethod::crJXJCheckRolesCreatedMethod():
m_count(1),
m_trueExecCount(0){}
crJXJCheckRolesCreatedMethod::crJXJCheckRolesCreatedMethod(const crJXJCheckRolesCreatedMethod& handle):
	crMethod(handle),
	m_count(handle.m_count),
	m_trueExecCount(0)
{
}
void crJXJCheckRolesCreatedMethod::inputParam(int i, void *param)
{
}

void crJXJCheckRolesCreatedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_count = atoi(str.c_str());
		break;
	}
}

void crJXJCheckRolesCreatedMethod::operator()(crHandle &handle)
{
	bool loaded = false;
	if(m_trueExecCount==0)
	{
		loaded = crMyPlayerData::getInstance()->getGameRoleCount() == atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxFormation,0).c_str());
		if(loaded)
		{
			m_trueExecCount = 1;
		}
	}
	handle.outputParam(0,&loaded);
}
/////////////////////////////////////////
//
//crJXJUIRevocationMethod
//
/////////////////////////////////////////
crJXJUIRevocationMethod::crJXJUIRevocationMethod():
	m_this(NULL)
{
}
crJXJUIRevocationMethod::crJXJUIRevocationMethod(const crJXJUIRevocationMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_phalanxRadio(handle.m_phalanxRadio)
{
}
void crJXJUIRevocationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIRevocationMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_phalanxRadio = str;
		break;
	}
}
void crJXJUIRevocationMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crRadioGroupWidgetNode *phalanxRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_phalanxRadio));
		unsigned int curSel = phalanxRadioGroup->getSelect();

		void *param;
		crData *playerData = myPlayer->getDataClass();
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
		if(curSel<formationInfoVec->size())
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt((*formationInfoVec)[curSel]->getAbstractID());
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRevocation,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvRevocationMethod
//
/////////////////////////////////////////
crJXJRecvRevocationMethod::crJXJRecvRevocationMethod():
	m_netType(GameClient_Game){}
crJXJRecvRevocationMethod::crJXJRecvRevocationMethod(const crJXJRecvRevocationMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRevocationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRevocationMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvRevocationMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int abstractid = m_stream->_readInt();
			char done = 0;
			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJFormationInfoVec,param);
			ref_ptr<crFormationInfo>fi;
			unsigned short armcount = 0;
			FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
			for( FormationInfoVec::iterator itr = formationInfoVec->begin();
				itr != formationInfoVec->end();
				++itr )
			{
				fi = itr->get();
				if(fi->getAbstractID() == abstractid)
				{
					armcount = fi->getCount();
					data->getParam(WCHDATA_JXJTroopsMap,param);
					TroopsMap *troopsMap = (TroopsMap*)param;
					TroopsMap::iterator titr = troopsMap->find(abstractid);
					if(titr != troopsMap->end())
					{
						titr->second+=armcount;
					}
					else
					{
						troopsMap->insert(std::make_pair(abstractid,armcount));
					}
					formationInfoVec->erase(itr);
					done = 1;
					break;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//返回信息
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(7);
				stream->_writeChar(done);
				if(done==1)
				{
					stream->_writeInt(abstractid);
					stream->_writeUShort(armcount);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvRevocation,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				void *param;
				int abstractid = m_stream->_readInt();
				unsigned short armcount = m_stream->_readUShort();
				crData *playerData = m_this->getDataClass();
				playerData->excHandle(MAKEINT64(WCH_LockData,1));
				playerData->getParam(WCHDATA_JXJFormationInfoVec,param);
				ref_ptr<crFormationInfo>fi;
				FormationInfoVec *formationInfoVec = (FormationInfoVec*)param;
				for( FormationInfoVec::iterator itr = formationInfoVec->begin();
					itr != formationInfoVec->end();
					++itr )
				{
					fi = itr->get();
					if(fi->getAbstractID() == abstractid)
					{
						//armcount = fi->getCount();
						playerData->getParam(WCHDATA_JXJTroopsMap,param);
						TroopsMap *troopsMap = (TroopsMap*)param;
						TroopsMap::iterator titr = troopsMap->find(abstractid);
						if(titr != troopsMap->end())
						{
							titr->second+=armcount;
						}
						else
						{
							troopsMap->insert(std::make_pair(abstractid,armcount));
						}
						formationInfoVec->erase(itr);
						break;
					}
				}
				playerData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICheckAndSetCDPromptMethod
//
/////////////////////////////////////////
crJXJUICheckAndSetCDPromptMethod::crJXJUICheckAndSetCDPromptMethod():
	m_cdhintid(0),
	m_timeid(0),
	m_font("simhei.ttf"),
	m_characterSize(16)
{
}
crJXJUICheckAndSetCDPromptMethod::crJXJUICheckAndSetCDPromptMethod(const crJXJUICheckAndSetCDPromptMethod& handle):
	crMethod(handle),
	m_cdhintid(handle.m_cdhintid),
	m_timeid(handle.m_timeid),
	m_promptCanvas(handle.m_promptCanvas),
	m_information(handle.m_information),
	m_hintCheck(handle.m_hintCheck),
	m_font(handle.m_font),
	m_characterSize(handle.m_characterSize),
	m_textColor(handle.m_textColor),
	m_goldColor(handle.m_goldColor),
	m_hintbackboard(handle.m_hintbackboard)
{
}
void crJXJUICheckAndSetCDPromptMethod::inputParam(int i, void *param)
{
}
void crJXJUICheckAndSetCDPromptMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cdhintid = atoi(str.c_str());
		break;
	case 1:
		m_timeid = atoi(str.c_str());
		break;
	case 2:
		m_promptCanvas = str;
		break;
	case 3:
		m_information = str;
		break;
	case 4:
		m_hintCheck = str;
		break;
	case 5:
		m_font = str;
		break;
	case 6:
		m_characterSize = atoi(str.c_str());
		break;
	case 7:
		crArgumentParser::appAtoVec(str,m_textColor);
		break;
	case 8:
		crArgumentParser::appAtoVec(str,m_goldColor);
		break;
	case 9:
		m_hintbackboard = str;
		break;
	}
}
void crJXJUICheckAndSetCDPromptMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *playerData = myPlayer->getDataClass();
		ref_ptr<crTableIO>hintTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHintTab);
		crTableIO::StrVec record;
		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
		if (hintTable->queryOneRecord(0,crArgumentParser::appItoa(m_cdhintid),record)>=0 && canvas.valid())
		{
			crHypertextWidgetNode *information = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_information));
			crCheckBoxWidgetNode *hintCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_hintCheck));
			crNode *hintbackboard = canvas->getChildNode(m_hintbackboard);
			if(m_cdhintid == WCHDATA_JXJBuyBuildingTimeHint || m_cdhintid == WCHDATA_JXJBuyRecruitTimeHint)
			{//买时间条0
				ref_ptr<crTableIO> viplvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJVipLevelTab);
				int id = m_cdhintid == WCHDATA_JXJBuyBuildingTimeHint ? WCHDATA_JXJBuildingTimes : WCHDATA_JXJRecruitTimes;
				playerData->getParam(id, param);
				int maxcount = 0;
				crVector4i timers = *(crVector4i *)param;
				for (int i = 0; i < 4; ++i)
				{
					if (timers[i] >= 0)
					{
						maxcount++;
					}
				}
				int nextmaxcount = 0;
				int needlv = 0;
				for (int i = 0; i <= viplvtab->getRowCount(); ++i)
				{
					nextmaxcount = 0;
					//vipstr.clear();
					if (m_cdhintid == WCHDATA_JXJBuyBuildingTimeHint)
					{
						nextmaxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,i).c_str()));
					}
					else if (m_cdhintid == WCHDATA_JXJBuyRecruitTimeHint)
					{
						nextmaxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,i).c_str()));
					}
					if (nextmaxcount > maxcount)
					{
						needlv = i;//vipstr = "需要VIP"+crArgumentParser::appItoa(i)+",";
						break;
					}
				}
				playerData->getParam(WCHDATA_JXJVipLv, param);
				unsigned char viplv = *(unsigned char *)param;

				playerData->getParam(WCHDATA_JXJGiftGold,param);
				int giftgold = *(int *)param;

				playerData->getParam(WCHDATA_Money,param);
				int money = *(int *)param;

				money += giftgold;

				if (viplv<needlv)
				{
					myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2111, NULL));//VIP不足
				}
				else if(money<50)
				{
					myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2036, NULL));//元宝不足
				}
				else
				{
					playerData->getParam(WCHDATA_JXJGoldCostHintInt,param);
					if(param)
					{
						unsigned int cdhint = 0;
						int hinttype = 0;
						if (m_cdhintid == WCHDATA_JXJBuyBuildingTimeHint)
						{
							hinttype = JXJGoldCostType_BuildingCDHint;
							cdhint = *(unsigned int *)param & JXJGoldCostType_BuildingCDHint;
						}
						else
						{
							hinttype = JXJGoldCostType_RecruitCDHint;
							cdhint = *(unsigned int *)param & JXJGoldCostType_RecruitCDHint;
						}
						if(cdhint)
						{ //购买征兵（建筑）时间轴与购买征兵（建筑）时间共用一个 消费提示设置，但各自的提示内容是独立的

							crData *braindata = crBrain::getInstance()->getDataClass();
							braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);

							//if(hintCheck) hintCheck->setVisiable(false);
							if(hintCheck)
							{
								hintCheck->setVisiable(true);
								hintCheck->select(false);
							}
							if(hintbackboard) hintbackboard->setVisiable(false);

							std::string text = record[1];

							std::vector<float>v_i;
							ItemMap itemMap;
							rcfg::ConfigScript cfg_script(&itemMap);
							cfg_script.Add("Hypertext");
							cfg_script.Push("Hypertext");
							cfg_script.Add("Font",m_font);
							cfg_script.Add("CharacterSize",m_characterSize);
							v_i.clear();
							v_i.push_back(m_textColor[0]);
							v_i.push_back(m_textColor[1]);
							v_i.push_back(m_textColor[2]);
							v_i.push_back(m_textColor[3]);
							cfg_script.Add("Color",v_i);

							cfg_script.Add("Content");
							cfg_script.Push("Content",1);
							cfg_script.Add("Text","您确认要花费");
							cfg_script.Pop();

							cfg_script.Add("Content");
							cfg_script.Push("Content",2);
							v_i.clear();
							v_i.push_back(m_goldColor[0]);
							v_i.push_back(m_goldColor[1]);
							v_i.push_back(m_goldColor[2]);
							v_i.push_back(m_goldColor[3]);
							cfg_script.Add("Color",v_i);
							char tmpText[32];
							sprintf(tmpText,"%d礼金/元宝\0",atoi(record[2].c_str()));
							cfg_script.Add("Text",tmpText);
							cfg_script.Pop();

							cfg_script.Add("Content");
							cfg_script.Push("Content",3);
							cfg_script.Add("Text",text);
							cfg_script.Pop();

							cfg_script.Pop();
							if(information)information->setHypertext(cfg_script);
							cancelTask = false;

							crData *brainData = crBrain::getInstance()->getDataClass();
							brainData->inputParam(WCHDATA_JXJCurCDHintID,&m_cdhintid);
							brainData->inputParam(WCHDATA_JXJCurTimesID,0);
						}
						else
						{//购买
							crData *braindata = crBrain::getInstance()->getDataClass();
							braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);

							braindata->inputParam(WCHDATA_JXJCurCDHintID,&m_cdhintid);
							braindata->inputParam(WCHDATA_JXJCurTimesID,0);

							myPlayer->doEvent(WCH_JXJUIBuyCD,NULL);
						}
					}
				}
			}
			else
			{
				//计算所需元宝数量
				playerData->getParam(m_timeid,param);
				if(param)
				{
					int time = *(int *)param;
					if(time>0)
					{
						int price = ceil((float)time * atof(record[2].c_str()));
						if(price<1) price = 1;
						playerData->getParam(WCHDATA_JXJGoldCostHintInt,param);
						if(param)
						{
							unsigned int cdhint = 0;
							int hinttype = 0;
							if (m_cdhintid == WCHDATA_JXJBuildingCDHint)
							{
								hinttype = JXJGoldCostType_BuildingCDHint;
								cdhint = *(unsigned int *)param & JXJGoldCostType_BuildingCDHint;
							}
							else
							{
								hinttype = JXJGoldCostType_RecruitCDHint;
								cdhint = *(unsigned int *)param & JXJGoldCostType_RecruitCDHint;
							}
							if(cdhint)
							{
								crData *braindata = crBrain::getInstance()->getDataClass();
								braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
								//ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
								//crHypertextWidgetNode *information = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_information));
								//crCheckBoxWidgetNode *hintCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_hintCheck));
								if(hintCheck)
								{
									hintCheck->setVisiable(true);
									hintCheck->select(false);
								}
								if(hintbackboard) hintbackboard->setVisiable(true);

								std::string text = record[1];

								std::vector<float>v_i;
								ItemMap itemMap;
								rcfg::ConfigScript cfg_script(&itemMap);
								cfg_script.Add("Hypertext");
								cfg_script.Push("Hypertext");
								cfg_script.Add("Font",m_font);
								cfg_script.Add("CharacterSize",m_characterSize);
								v_i.clear();
								v_i.push_back(m_textColor[0]);
								v_i.push_back(m_textColor[1]);
								v_i.push_back(m_textColor[2]);
								v_i.push_back(m_textColor[3]);
								cfg_script.Add("Color",v_i);

								cfg_script.Add("Content");
								cfg_script.Push("Content");
								cfg_script.Add("Text","您确认要花费");
								cfg_script.Pop();

								cfg_script.Add("Content");
								cfg_script.Push("Content",2);
								v_i.clear();
								v_i.push_back(m_goldColor[0]);
								v_i.push_back(m_goldColor[1]);
								v_i.push_back(m_goldColor[2]);
								v_i.push_back(m_goldColor[3]);
								cfg_script.Add("Color",v_i);
								char tmpText[32];
								sprintf(tmpText,"%d礼金/元宝\0",price);
								cfg_script.Add("Text",tmpText);
								cfg_script.Pop();

								cfg_script.Add("Content");
								cfg_script.Push("Content",3);
								cfg_script.Add("Text",text + "吗？\n购买建筑时间轴可以让您同时建造更多的建筑。");
								cfg_script.Pop();

								cfg_script.Pop();
								if(information)information->setHypertext(cfg_script);
								cancelTask = false;

								crData *brainData = crBrain::getInstance()->getDataClass();
								brainData->inputParam(WCHDATA_JXJCurCDHintID,&m_cdhintid);
								brainData->inputParam(WCHDATA_JXJCurTimesID,&m_timeid);
							}
							else
							{//购买提示
								ref_ptr<crStreamBuf> stream = new crStreamBuf;
								stream->createBuf(8);
								stream->_writeInt(m_cdhintid);
								stream->_writeInt(m_timeid);
								myPlayer->doEvent(WCH_JXJBuyCD,MAKEINT64(stream.get(),price));
							}
						}
					}
				}
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJBuyCDMethod
//
/////////////////////////////////////////
crJXJBuyCDMethod::crJXJBuyCDMethod():
	m_this(NULL),
	m_price(0)
{
}
crJXJBuyCDMethod::crJXJBuyCDMethod(const crJXJBuyCDMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_price(0)
{
}
void crJXJBuyCDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_price = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
			m_price = 0;
		}
		break;
	}
}
void crJXJBuyCDMethod::addParam(int i, const std::string& str)
{
}
void crJXJBuyCDMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(m_this == myPlayer && netConductor)
	{
		void *param;
		crData *playerData = myPlayer->getDataClass();
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJGoldingot,param);
		int goldingot = *(int*)param;
		playerData->getParam(WCHDATA_JXJGiftGold,param);
		int giftgold = *(int*)param;
		goldingot += giftgold;
		if(m_price<=goldingot)
		{
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuyCD,m_stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		else
		{//提示元宝不够
			m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvBuyCDMethod
//
/////////////////////////////////////////
crJXJRecvBuyCDMethod::crJXJRecvBuyCDMethod():
	m_netType(GameClient_Game){}
crJXJRecvBuyCDMethod::crJXJRecvBuyCDMethod(const crJXJRecvBuyCDMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBuyCDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBuyCDMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvBuyCDMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int cdhintid = m_stream->_readInt();
			int timesid = m_stream->_readInt();
			ref_ptr<crTableIO>hintTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHintTab);
			crTableIO::StrVec record;
			hintTable->queryOneRecord(0,crArgumentParser::appItoa(cdhintid),record);
			//计算所需元宝数量
			char done = 0;
			void *param;
			crData *data = m_this->getDataClass();
			bool needdeductgold = false;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			//data->getParam(WCHDATA_JXJGoldingot,param);
			//int *goldingot = (int*)param;
			data->getParam(timesid,param);
			if(param)
			{
				int* time = (int *)param;
				if (*time > 0)
				{
					int price = ceil((float)(*time) * atof(record[2].c_str()));
					//if(price<1) price = 1;
					MoneyChangeData moneydata(price,timesid>=WCHDATA_JXJRecruitTime0?"秒招兵CD":"秒建筑CD");
					m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&moneydata,&needdeductgold));
					if (moneydata.first == 0)
					{
						done = 1;
						*time = 0.0f;
					}
					else
					{
						done = -1;//元宝不够
					}
					//if(*goldingot<price)
					//	done = -1;//元宝不够
					//else
					//{
					//	*goldingot -= price;
					//	*time = 0.0f;
					//	done = 1;
					//}
				}
				else
				{
					done = 1;
				}
			}
			//返回信息
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeChar(done);
				if(done==1)
				{
					stream->_writeInt(timesid);
					//stream->_writeInt(*goldingot);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuyCD,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			if (needdeductgold)
			{
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
				if(playerData.valid())
				{
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					callback->savePlayerData(playerData.get());
				}
			}
			if(done==1)
			{
				///游戏日志
				std::string logdata = "秒时间条" + crArgumentParser::appVectoa(crVector2i(done,timesid));
				GameLogData gamelog(Log_ClearTimers,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				void *param;
				int timesid = m_stream->_readInt();
				//int goldingot = m_stream->_readInt();
				crData *playerData = m_this->getDataClass();
				playerData->excHandle(MAKEINT64(WCH_LockData,1));
				//playerData->getParam(WCHDATA_JXJGoldingot,param);
				//int *mygoldingot = (int*)param;
				//int dif = goldingot - *mygoldingot;//客户端需要提示dif
				//*mygoldingot = goldingot;
				playerData->getParam(timesid,param);
				if(param)
				{
					int* time = (int *)param;
					*time = 0.0f;
				}
				playerData->excHandle(MAKEINT64(WCH_LockData,0));
				bool ifsetarmynum = true;
				crData *data = crBrain::getInstance()->getDataClass();
				data->inputParam(WCHDATA_JXJIfSetArmyNum,&ifsetarmynum);
			}
			else if(returnCode == -1)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBuyCDMethod
//
/////////////////////////////////////////
crJXJUIBuyCDMethod::crJXJUIBuyCDMethod()
{
}
crJXJUIBuyCDMethod::crJXJUIBuyCDMethod(const crJXJUIBuyCDMethod& handle):
	crMethod(handle),
	m_checkbox(handle . m_checkbox)
{
}
void crJXJUIBuyCDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIBuyCDMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_checkbox = str;
		break;
	default:
		break;
	}
}
void crJXJUIBuyCDMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		bool curcdhint = true;
		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_CD_Prompt");
		if (canvas.valid())
		{
			crCheckBoxWidgetNode *checkbox = dynamic_cast<crCheckBoxWidgetNode *>(canvas -> getWidget(m_checkbox));
			if (checkbox)
			{
				if (checkbox->getSelect())
				{
					curcdhint = false;
				}
			}
		}
		void *param;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->getParam(WCHDATA_JXJCurCDHintID,param);
		if(param)
		{
			int cdhintid = *(int *)param;
			if(cdhintid == WCHDATA_JXJBuyBuildingTimeHint || cdhintid == WCHDATA_JXJBuyRecruitTimeHint)
			{
				crData *playerData = myPlayer->getDataClass();
				ref_ptr<crTableIO>hintTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHintTab);
				crTableIO::StrVec record;
				hintTable->queryOneRecord(0,crArgumentParser::appItoa(cdhintid),record);
				int price = atoi(record[2].c_str());
				int id = cdhintid == WCHDATA_JXJBuyBuildingTimeHint?WCHDATA_JXJBuildingTimes:WCHDATA_JXJRecruitTimes;
				playerData->getParam(id,param);
				crVector4i timers = *(crVector4i *)param;
				for(int i = 1; i<4; i++)
				{
					if(timers[i] < 0)
					{//可以购买
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(cdhintid);
						myPlayer->doEvent(WCH_JXJBuyTimers,MAKEINT64(stream.get(),price));
						break;
					}
				}
			}
			else
			{
				brainData->getParam(WCHDATA_JXJCurTimesID,param);
				if(param)
				{
					int timesid = *(int *)param;
					crData * playerData = myPlayer->getDataClass();
					playerData->getParam(WCHDATA_JXJGoldCostHintInt,param);
					if(param)
					{
						unsigned int *goldcosthint = (unsigned int *)param;
						unsigned int cdhint = 0;
						int hinttype = 0;
						int m_cdhintid = cdhintid;
						if (m_cdhintid == WCHDATA_JXJBuyBuildingTimeHint)
						{
							hinttype = JXJGoldCostType_BuildingCDHint;
							//cdhint = *(unsigned int *)param & JXJGoldCostType_BuildingCDHint;
						}
						else
						{
							hinttype = JXJGoldCostType_RecruitCDHint;
							//cdhint = *(unsigned int *)param & JXJGoldCostType_RecruitCDHint;
						}
						if (curcdhint)
						{
							*goldcosthint |= hinttype;
						}
						else
						{
							*goldcosthint &=~ hinttype;
						}
					}
					if(cdhintid>0 && timesid>0)
					{
						crData *playerData = myPlayer->getDataClass();
						ref_ptr<crTableIO>hintTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHintTab);
						crTableIO::StrVec record;
						hintTable->queryOneRecord(0,crArgumentParser::appItoa(cdhintid),record);
						//计算所需元宝数量
						playerData->inputParam(cdhintid,&curcdhint);
						playerData->getParam(timesid,param);
						if(param)
						{
							int time = *(int *)param;
							if(time>0)
							{
								int price = floor((float)time * atof(record[2].c_str()));
								if(price<1) price = 1;
								ref_ptr<crStreamBuf> stream = new crStreamBuf;
								stream->createBuf(8);
								stream->_writeInt(cdhintid);
								stream->_writeInt(timesid);
								myPlayer->doEvent(WCH_JXJBuyCD,MAKEINT64(stream.get(),price));
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICDHintMethod
//
/////////////////////////////////////////
crJXJUICDHintMethod::crJXJUICDHintMethod():
	m_this(NULL)
{
}
crJXJUICDHintMethod::crJXJUICDHintMethod(const crJXJUICDHintMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUICDHintMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCheckBoxWidgetNode*)param;
		break;
	}
}
void crJXJUICDHintMethod::addParam(int i, const std::string& str)
{
}
void crJXJUICDHintMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		void *param;
		crData *playerData = myPlayer->getDataClass();
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->getParam(WCHDATA_JXJCurGoldHintType,param);
		int goldhinttypd = *(int *)param;
		if (goldhinttypd >= 0)
		{
			playerData->getParam(WCHDATA_JXJGoldCostHintInt,param);
			unsigned int *goldcosthint = (unsigned int *)param;
			if (!m_this->getSelect())
			{
				*goldcosthint |= goldhinttypd;
			}
			else
			{
				*goldcosthint &=~ goldhinttypd;
			}
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeUInt(*goldcosthint);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvChangeGoldCostHind,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCDHintMethod
//
/////////////////////////////////////////
//crJXJRecvCDHintMethod::crJXJRecvCDHintMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvCDHintMethod::crJXJRecvCDHintMethod(const crJXJRecvCDHintMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvCDHintMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvCDHintMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvCDHintMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			void *param;
//			int cdhintid = m_stream->_readInt();
//			bool hint = m_stream->_readBool();
//			crData *data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->getParam(WCHDATA_JXJGoldCostHintInt,param);
//			unsigned int *goldcosthint = (unsigned int *)param;
//			unsigned int curhintid = 0;
//			if (cdhintid == WCHDATA_JXJBuildingCDHint)
//			{
//				curhintid = JXJGoldCostType_BuildingCDHint;
//			}
//			else
//			{
//				curhintid = JXJGoldCostType_RecruitCDHint;
//			}
//			if (hint)
//			{
//				*goldcosthint |= curhintid;
//			}
//			else
//			{
//				*goldcosthint &= ~curhintid;
//			}
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIResetCDHintMethod
//
/////////////////////////////////////////
crJXJUIResetCDHintMethod::crJXJUIResetCDHintMethod()
{
}
crJXJUIResetCDHintMethod::crJXJUIResetCDHintMethod(const crJXJUIResetCDHintMethod& handle):
	crMethod(handle)
{
}
void crJXJUIResetCDHintMethod::inputParam(int i, void *param)
{
}
void crJXJUIResetCDHintMethod::addParam(int i, const std::string& str)
{
}
void crJXJUIResetCDHintMethod::operator()(crHandle &handle)
{
	crData *brainData = crBrain::getInstance()->getDataClass();
	brainData->inputParam(WCHDATA_JXJCurCDHintID,0);
	brainData->inputParam(WCHDATA_JXJCurTimesID,0);
}
/////////////////////////////////////////
//
//crJXJBuyTimersMethod
//
/////////////////////////////////////////
crJXJBuyTimersMethod::crJXJBuyTimersMethod():
	m_this(NULL),
	m_price(0)
{
}
crJXJBuyTimersMethod::crJXJBuyTimersMethod(const crJXJBuyTimersMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_price(0)
{
}
void crJXJBuyTimersMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_price = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
			m_price = 0;
		}
		break;
	}
}
void crJXJBuyTimersMethod::addParam(int i, const std::string& str)
{
}
void crJXJBuyTimersMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(m_this == myPlayer && netConductor)
	{
		char done = 0;
		int cdhintid = m_stream->_readInt();
		void *param;
		if (cdhintid == 0)
		{
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->getParam(WCHDATA_JXJCurCDHintID,param);
			cdhintid = *(int *)param;
		}
		crData *playerData = myPlayer->getDataClass();
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJGoldingot,param);
		int goldingot = *(int*)param;
		playerData->getParam(WCHDATA_JXJGiftGold,param);
		int giftgold = *(int*)param;
		playerData->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxcount = 0;
		if (cdhintid == WCHDATA_JXJBuyBuildingTimeHint)
		{
			maxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,viplv).c_str()));
		}
		if (cdhintid == WCHDATA_JXJBuyRecruitTimeHint)
		{
			maxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,viplv).c_str()));
		}
		if (maxcount > 4)
		{
			maxcount = 4;
		}
		int id = cdhintid == WCHDATA_JXJBuyBuildingTimeHint?WCHDATA_JXJBuildingTimes:WCHDATA_JXJRecruitTimes;
		playerData->getParam(id,param);
		crVector4i timers = *(crVector4i *)param;
		for(int i = 1; i<maxcount; i++)
		{
			if(timers[i] < 0)
			{//可以购买
				timers[i] = 0;
				done = 1;
				break;
			}
		}
		if (done == 1)
		{
			goldingot += giftgold;
			if(m_price<=goldingot)
			{
				m_stream->seekBegin();
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuyTimers,m_stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			else
			{//提示元宝不够
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
			}
		}
		else
		{
			myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2100,NULL));//时间条达上限
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvBuyTimersMethod
//
/////////////////////////////////////////
crJXJRecvBuyTimersMethod::crJXJRecvBuyTimersMethod():
	m_netType(GameClient_Game){}
crJXJRecvBuyTimersMethod::crJXJRecvBuyTimersMethod(const crJXJRecvBuyTimersMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBuyTimersMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBuyTimersMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvBuyTimersMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			char done = 0;
			int cdhintid = m_stream->_readInt();
			//int *goldingot;
			char i;
			int id;
			void *param;
			crData *data = m_this->getDataClass();
			bool needdeductgold = false;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			if(cdhintid == WCHDATA_JXJBuyBuildingTimeHint || cdhintid == WCHDATA_JXJBuyRecruitTimeHint)
			{
				data->getParam(WCHDATA_JXJVipLv, param);
				unsigned char viplv = *(unsigned char *)param;
				ref_ptr<crTableIO>hintTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHintTab);
				crTableIO::StrVec record;
				hintTable->queryOneRecord(0,crArgumentParser::appItoa(cdhintid),record);
				//计算所需元宝数量
				int price = atoi(record[2].c_str());
				//data->getParam(WCHDATA_JXJGoldingot,param);
				//goldingot = (int*)param;
				//if(*goldingot<price)
				//	done = -1;//元宝不够
				int maxcount = 0;
				if (cdhintid == WCHDATA_JXJBuyBuildingTimeHint)
				{
					maxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuildingTimeBarMaxCount,viplv).c_str()));
				}
				if (cdhintid == WCHDATA_JXJBuyRecruitTimeHint)
				{
					maxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitTimeBarMaxCount,viplv).c_str()));
				}
				if (maxcount > 4)
				{
					maxcount = 4;
				}
				id = cdhintid == WCHDATA_JXJBuyBuildingTimeHint?WCHDATA_JXJBuildingTimes:WCHDATA_JXJRecruitTimes;
				data->getParam(id,param);
				crVector4i* timers = (crVector4i *)param;
				for(i = 1; i<maxcount; i++)
				{
					if((*timers)[i] < 0)
					{//可以购买
						//*goldingot -= price;
						(*timers)[i] = 0;
						done = 1;
						MoneyChangeData moneydata(price,"买时间轴");
						m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&moneydata,&needdeductgold));
						if (moneydata.first == -1)
						{
							done = -1;//元宝不够
						}
						break;
					}
				}
				if (done != 1)
				{
					done = -2;
				}
			}
			//返回信息
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(6);
				stream->_writeChar(done);
				if(done==1)
				{
	//				stream->_writeInt(*goldingot);
					stream->_writeInt(id);
					stream->_writeChar(i);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuyTimers,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			if (needdeductgold)
			{
				//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				//ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
				if(playerData.valid())
				{
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					callback->savePlayerData(playerData.get());
				}
			}
			std::string logdata = "秒CD" + crArgumentParser::appVectoa(crVector3i(done,id,i));
			GameLogData gamelog(Log_BuyTimers,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				void *param;
			//	int goldingot = m_stream->_readInt();
				int id = m_stream->_readInt();
				char i = m_stream->_readChar();
				crData *playerData = m_this->getDataClass();
				playerData->excHandle(MAKEINT64(WCH_LockData,1));
				//playerData->getParam(WCHDATA_JXJGoldingot,param);
				//int *mygoldingot = (int*)param;
				//int dif = goldingot - *mygoldingot;//客户端需要提示dif
				//*mygoldingot = goldingot;
				playerData->getParam(id,param);
				crVector4i* timers = (crVector4i *)param;
				(*timers)[i] = 0;
				playerData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			else if(returnCode == -1)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
			}
			else if(returnCode == -2)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2100,NULL));//时间条达上限
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBuildFubenListMethod
//
/////////////////////////////////////////
crJXJUIBuildFubenListMethod::crJXJUIBuildFubenListMethod():
m_this(NULL){}
crJXJUIBuildFubenListMethod::crJXJUIBuildFubenListMethod(const crJXJUIBuildFubenListMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_modeRaido(handle.m_modeRaido)
{
}
void crJXJUIBuildFubenListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}

void crJXJUIBuildFubenListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_modeRaido = str;
		break;
	}
}

void crJXJUIBuildFubenListMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crRadioGroupWidgetNode *modeRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_modeRaido));
		int mode = modeRadioGroup->getSelect();
		int modeid = fubentab->getTitleIndex("mode");
		int iconid = fubentab->getTitleIndex("icon");
		crTableIO::DataVec records;
		fubentab->queryRecords(modeid,crArgumentParser::appItoa(mode),records);
		m_this->setListNodeCount(records.size());
		crListControlWidgetNode::ListNodeVec& listNodeVec = m_this->getListNodeVec();
		std::string iconfile;
		ref_ptr<crListControlNode> listNode;
		int i = 0;
		for( crTableIO::DataVec::iterator itr = records.begin();
			 itr != records.end();
			 ++itr,++i )
		{
			iconfile = (*itr)[iconid];
			listNodeVec[i]->setData(atoi((*itr)[0].c_str()));
			listNodeVec[i]->setImageName(iconfile);
			listNodeVec[i]->setVisiable(true);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFubenSelectChangeMethod
//
/////////////////////////////////////////
crJXJUIFubenSelectChangeMethod::crJXJUIFubenSelectChangeMethod():
	m_this(NULL){}
crJXJUIFubenSelectChangeMethod::crJXJUIFubenSelectChangeMethod(const crJXJUIFubenSelectChangeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_strJiangLing(handle.m_strJiangLing),
	m_strNeedLv(handle.m_strNeedLv),
	m_strCanRelive(handle.m_strCanRelive),
	m_strTechImg(handle.m_strTechImg),
	m_strDrop(handle.m_strDrop)	
{
}
void crJXJUIFubenSelectChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRadioGroupWidgetNode*)param;
		break;
	}
}

void crJXJUIFubenSelectChangeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_strJiangLing = str;
		break;
	case 1:
		m_strNeedLv = str;
		break;
	case 2:
		m_strCanRelive = str;
		break;
	case 3:
		m_strTechImg = str;
		break;
	case 4:
		m_strDrop = str;
		break;
	case 5:
		m_strDefaultImage = str;
		break;
	}
}

void crJXJUIFubenSelectChangeMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
	ref_ptr<crTableIO>qualitytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJQualityTab);
	ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && fubentab.valid() && itemtab.valid() && qualitytab.valid() && playerData && techlvtab.valid())
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		ref_ptr<crStaticTextWidgetNode> jiangling = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_strJiangLing));
		ref_ptr<crStaticTextWidgetNode> needLv = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_strNeedLv));
		ref_ptr<crStaticTextWidgetNode> canReliveCount = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_strCanRelive));
		ref_ptr<crImageBoxWidgetNode> tech = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_strTechImg));
		ref_ptr<crHypertextWidgetNode> diaoluo = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_strDrop));
		
		void *param;
		//crListControlNode *selectNode = m_this->getSelectNode();
		//if(selectNode)
		crData *data = playerData->getDataClass();
		crData *canvasdata = canvas->getDataClass();
		canvasdata->getParam(WCHDATA_JXJSelFubenID,param);
		unsigned short fubenid = *(unsigned short *)param;
	
		if(fubenid > 0)
		{
			crTableIO::StrVec record,record2;
			if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
			{
				int jlid = fubentab->getTitleIndex("将领");
				int djid = fubentab->getTitleIndex("需求等级");
				int dlid = fubentab->getTitleIndex("掉落");
				int smid = fubentab->getTitleIndex("说明");
				int reliveindex = fubentab->getTitleIndex("允许补兵次数");
				int jindumaxid = fubentab->getTitleIndex("结束进度");
				int iconid = fubentab->getTitleIndex("将领icon");
				int qualityid = itemtab->getTitleIndex("品质");
				int tecnIconIndex = techlvtab->getTitleIndex("icon");
				int fubenIndex = techlvtab->getTitleIndex("前置副本");
				short jindunow = 0;
				crVector4s closevec;
				crArgumentParser::appAtoVec(record[jindumaxid],closevec);
				short jindumax = closevec[0];
				for(int i = 1; i<4; i++)
				{
					if(jindumax<closevec[i])
						jindumax = closevec[i];
				}

				if(jiangling.valid())
				{
					jiangling->setString(record[jlid]);
				}
				if(needLv.valid())
				{
					needLv->setString(record[djid]);
				}
				if(canReliveCount.valid())
				{
					canReliveCount->setString(record[reliveindex]);
				}
				if(diaoluo.valid())
				{
					//crVector4i itemids;
					//crArgumentParser::appAtoVec(record[dlid],itemids);
					//if(itemids == crVector4i(0,0,0,0))
					//{
						//crVector4f color = crVector4f(255.0f,255.0f,255.0f,255.0f);
						//std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						int nContent = 1;
						cfg_script.Add("Content");
						cfg_script.Push("Content",nContent++);
						//v_i.clear();
						//v_i.push_back(color[0]);
						//v_i.push_back(color[1]);
						//v_i.push_back(color[2]);
						//v_i.push_back(color[3]);
						//cfg_script.Add("Color",v_i);
						cfg_script.Add("Text",record[dlid]);
						cfg_script.Pop();
						cfg_script.Pop();
						diaoluo->setHypertext(cfg_script);
					//}
					//else
					//{
					//	crTableIO::StrVec itemrecord,colorRec;
					//	int abatractid = 0;
					//	std::vector<float>v_i;
					//	ItemMap itemMap;
					//	rcfg::ConfigScript cfg_script(&itemMap);
					//	cfg_script.Add("Hypertext");
					//	cfg_script.Push("Hypertext");
					//	int nContent = 1;
					//	crVector4i color;
					//	for(int i = 0; i<4; i++)
					//	{
					//		abatractid = itemids[i];
					//		if(abatractid>0)
					//		{
					//			if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(abatractid),itemrecord)>=0)
					//			{
					//				qualitytab->queryOneRecord(0,itemrecord[qualityid],colorRec);
					//				crArgumentParser::appAtoVec(colorRec[1],color);

					//				if(i!=0)
					//				{
					//					cfg_script.Add("Content");
					//					cfg_script.Push("Content",nContent++);
					//					cfg_script.Add("Text","、");
					//					cfg_script.Pop();
					//				}
					//				cfg_script.Add("Content");
					//				cfg_script.Push("Content",nContent++);
					//				v_i.clear();
					//				v_i.push_back(color[0]);
					//				v_i.push_back(color[1]);
					//				v_i.push_back(color[2]);
					//				v_i.push_back(color[3]);
					//				cfg_script.Add("Color",v_i);
					//				cfg_script.Add("Text",itemrecord[1] + " ");
					//				cfg_script.Pop();
					//			}
					//		}
					//	}
					//	cfg_script.Pop();
					//	diaoluo->setHypertext(cfg_script);
					//}
				}
				if(tech.valid())
				{
					tech->setImageName(m_strDefaultImage);
				}
				if(fubenIndex>=0 && techlvtab->queryOneRecord(fubenIndex,crArgumentParser::appItoa(fubenid),record2)>=0)
				{
					if(tech.valid())
					{
						tech->setImageName(record2[tecnIconIndex]);
					}
				}
			}
			else
			{
				if(jiangling.valid())
				{
					jiangling->clearString();
				}
				if(needLv.valid())
				{
					needLv->clearString();
				}
				if(canReliveCount.valid())
				{
					canReliveCount->clearString();
				}
				if(diaoluo.valid())
				{
					diaoluo->clearText();
				}
				if(tech.valid())
				{
					tech->clearImage();
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFubenClickMethod
//
/////////////////////////////////////////
crJXJUIFubenClickMethod::crJXJUIFubenClickMethod(){}
crJXJUIFubenClickMethod::crJXJUIFubenClickMethod(const crJXJUIFubenClickMethod& handle):
	crMethod(handle),
	m_enterFuben(handle.m_enterFuben),
	m_info(handle.m_info)
{
}
void crJXJUIFubenClickMethod::inputParam(int i, void *param)
{
}

void crJXJUIFubenClickMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_enterFuben = str;
		break;
	case 1:
		m_info = str;
		break;
	}
}

void crJXJUIFubenClickMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(fubentab.valid())
	{
		//crListControlNode *selectNode = m_this->getSelectNode();
		//if(selectNode)
		//{
		//	int fubenid = selectNode->getData();
		void *param;
		//crRole *mainrole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
		//crData *mainroledata = mainrole->getDataClass();
		//mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
		//mainroledata->getParam(WCHDATA_Level,param);
		//int mylv = *(int *)param;
		//mainroledata->excHandle(MAKEINT64(WCH_LockData,0));
		
		crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		playerData->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short fubenid = *(unsigned short *)param;
		if(type== FT_Fuben && fubenid > 0)
		{
			crTableIO::StrVec record;
			if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
			{
				int nameid = fubentab->getTitleIndex("name");
				ref_ptr<crCanvasNode> enterFuben = dynamic_cast<crCanvasNode *>(crFilterRenderManager::getInstance()->findCanvas(m_enterFuben));
				if(enterFuben.valid())
				{
					crStaticTextWidgetNode *info = dynamic_cast<crStaticTextWidgetNode *>(enterFuben->getWidget(m_info));
					if(info)
					{
						std::string str = "是否进入副本【"+record[nameid]+"】?";
						info->setString(str);
					}
					crFilterRenderManager::getInstance()->doModal(m_enterFuben);
				}
			}
		}
		//}
	}
}
/////////////////////////////////////////
//
//crJXJCheckSelectRolesMethod
//
/////////////////////////////////////////
crJXJCheckSelectRolesMethod::crJXJCheckSelectRolesMethod():
m_chekPostArmCount(false),
m_sendtoserver(false){}
crJXJCheckSelectRolesMethod::crJXJCheckSelectRolesMethod(const crJXJCheckSelectRolesMethod& handle):
crMethod(handle),
m_chekPostArmCount(handle.m_chekPostArmCount),
m_sendtoserver(handle.m_sendtoserver)
{
}
void crJXJCheckSelectRolesMethod::inputParam(int i, void *param)
{
}

void crJXJCheckSelectRolesMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chekPostArmCount = (bool)atoi(str.c_str());
		break;
	case 1:
		m_sendtoserver = (bool)atoi(str.c_str());
		break;
	}
}

void crJXJCheckSelectRolesMethod::operator()(crHandle &handle)
{
	bool success = false;
	char code = 0;//-1表示没有部队，-2表示所带部队未达到城战最低要求。
	int minpower = 0;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *myData = myPlayer->getDataClass();
		myData->excHandle(MAKEINT64(WCH_LockData,1));
		myData->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		int formationCount = formationInfoVec->size();
		do 
		{
			if(formationCount<=0)
				break;
			int powercost = 0;
			int power,powerid;
			ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			powerid = troopsTab->getTitleIndex("领导力");
			crTableIO::StrVec record;
			for( FormationInfoVec::iterator itr = formationInfoVec->begin();
				 itr != formationInfoVec->end();
				 ++itr )
			{
				if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getAbstractID()),record)>=0)
				{
					power = atoi(record[powerid].c_str());
					powercost += power * (*itr)->getCount();
				}
			}
			if(powercost == 0)
			{
				code = -1;
				break;
			}
			//crRole *mainRole = myPlayer->getMainRole();
			//crData *mainRoleData = mainRole->getDataClass();
			//mainRoleData->getParam(WCHDATA_JXJGovPost,param);
			//unsigned char post = *(unsigned char *)param;
			//postTab->queryOneRecord(0,crArgumentParser::appItoa(post),record);
			//int mypower = atoi(record[postpowerid].c_str());
			//if(powercost<mypower)
			//{
			//	code = -3;//未带满部队
			//}
			if(m_chekPostArmCount)
			{
				//加入部队数量不低于最低官职带兵量
				ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				int postpowerid = postTab->getTitleIndex("领导力");
				postTab->queryOneRecord(0,"1",record);
				minpower = atoi(record[postpowerid].c_str()) * 0.5f;
				if(powercost<minpower)
				{
					code = -2;//所带部队未达到城战最低要求。
					break;
				}
			}
			crMyPlayerData::getInstance()->clearSelectedGameRoles();
			CRNetApp::GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
			if(gameRoleMap.size()>0)
			{
				crRole *role;
				int i = 0;
				for( CRNetApp::GameRoleMap::iterator itr = gameRoleMap.begin();
					itr != gameRoleMap.end();
					++itr)
				{
					if(myPlayer->getMainRoleID()==itr->first)
						continue;
					if(i<formationCount)
					{
						(*formationInfoVec)[i]->setRoleID(0);
						if((*formationInfoVec)[i]->getAbstractID()>0 && (*formationInfoVec)[i]->getCount()>0)
						{//如果客户端编队信息错误，将会导致玩家无法进战场
							if(m_sendtoserver)
							{
								role = dynamic_cast<crRole *>(itr->second->clone());
								if(crMyPlayerData::getInstance()->addSelectedGameRole(role))
								{
									role->setAbstractItemID((*formationInfoVec)[i]->getAbstractID());
									(*formationInfoVec)[i]->setRoleID(role->getRoleID());
								}
							}
							success = true;
						}
						++i;
					}
					else
					{
						break;
					}
				}
			}
			if(success && m_sendtoserver)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(8*formationCount+1);
				stream->_writeChar((char)formationCount);
				for (int i = 0; i<formationCount; i++)
				{
					stream->_writeInt((*formationInfoVec)[i]->getRoleID());
					stream->_writeInt((*formationInfoVec)[i]->getAbstractID());
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCheckRoles,stream.get());
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		} while (0);
		myData->excHandle(MAKEINT64(WCH_LockData,0));
		if(!success)
		{
			//std::string str = "进入战场失败！";
			if(code == -1)
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1003,NULL));
			//crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1003,NULL));
			else
			{
				//str += "所带兵力领导力不得低于"+crArgumentParser::appItoa(minpower);
				ref_ptr<crTableIO>textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
				crTableIO::StrVec record;
				if(textTab->queryOneRecord(0,crArgumentParser::appItoa(1004),record)>=0)
				{
					std::string str = record[1]+crArgumentParser::appItoa(minpower);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(0,&str));			
				}
			}
		}
	}
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crJXJRecvCheckRolesMethod
//
/////////////////////////////////////////
crJXJRecvCheckRolesMethod::crJXJRecvCheckRolesMethod():
	m_netType(GameClient_Game){}
crJXJRecvCheckRolesMethod::crJXJRecvCheckRolesMethod(const crJXJRecvCheckRolesMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCheckRolesMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCheckRolesMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCheckRolesMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			char count = m_stream->_readChar();
			bool success = true;
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_JXJFormationInfoVec,param);
			FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
			int fsize = formationInfoVec->size();
			int roleid = 0;
			int abstractid = 0;
			int playerid = m_this->getPlayerID();
			for(int i = 0; i<count && i<fsize; i++)
			{
				roleid = m_stream->_readInt();
				abstractid = m_stream->_readInt();
				if ((*formationInfoVec)[i]->getAbstractID() != abstractid)
				{
					success = false;
					//CRCore::notify(CRCore::ALWAYS) << "crJXJRecvCheckRolesMethod Error 客户端编队信息和服务器编队信息不一致:playerid=" << playerid << std::endl;
				}
				(*formationInfoVec)[i]->setRoleID(roleid);
				//if((*formationInfoVec)[i]->getCount()>0 && (*formationInfoVec)[i]->getAbstractID()>0)
				//	(*formationInfoVec)[i]->setRoleID(roleid);
				//else
				//{
				//	(*formationInfoVec)[i]->setRoleID(0);
				//}
			}
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(16);
			stream->_writeBool(success);
			if (!success)
			{
				stream->_writeChar(fsize);
				for (FormationInfoVec::iterator itr = formationInfoVec->begin();
					 itr != formationInfoVec->end();
					 ++itr)
				{
					stream->_writeInt((*itr)->getAbstractID());
					stream->_writeUShort((*itr)->getCount());
					stream->_writeVec2i((*itr)->getEquips());
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData, 0));
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet, WCH_JXJRecvCheckRoles, stream.get());
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid())
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet);
		}
		else if (m_netType == GameClient_Game)
		{
			bool  success = m_stream->_readBool();
			if (!success)
			{
				void *param;
				crData *thisData = m_this->getDataClass();
				char formationCount = m_stream->_readChar();
				bool success = true;
				thisData->excHandle(MAKEINT64(WCH_LockData, 1));
				thisData->getParam(WCHDATA_JXJFormationInfoVec, param);
				FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
				formationInfoVec->resize(formationCount);
				for (int i = 0; i < formationCount; i++)
				{
					(*formationInfoVec)[i]->setAbstractID(m_stream->_readInt());
					(*formationInfoVec)[i]->setCount(m_stream->_readUShort());
					(*formationInfoVec)[i]->setEquips(m_stream->_readVec2i());
				}
				if (crRunGameHandle::getInstance()->isInManor())
				{
					crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
					crMyPlayerData::getInstance()->clearSelectedGameRoles();
					CRNetApp::GameRoleMap &gameRoleMap = crMyPlayerData::getInstance()->getGameRoleMap();
					if (gameRoleMap.size() > 0)
					{
						crRole *role;
						int i = 0;
						for (CRNetApp::GameRoleMap::iterator itr = gameRoleMap.begin();
							itr != gameRoleMap.end();
							++itr)
						{
							if (myPlayer->getMainRoleID() == itr->first)
								continue;
							if (i < formationCount)
							{
								(*formationInfoVec)[i]->setRoleID(0);
								if ((*formationInfoVec)[i]->getAbstractID()>0 && (*formationInfoVec)[i]->getCount() > 0)
								{//如果客户端编队信息错误，将会导致玩家无法进战场
									role = dynamic_cast<crRole *>(itr->second->clone());
									if (crMyPlayerData::getInstance()->addSelectedGameRole(role))
									{
										role->setAbstractItemID((*formationInfoVec)[i]->getAbstractID());
										(*formationInfoVec)[i]->setRoleID(role->getRoleID());
									}
								}
								++i;
							}
							else
							{
								break;
							}
						}
					}
				}
				thisData->excHandle(MAKEINT64(WCH_LockData, 0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSyncFormationMethod
//
/////////////////////////////////////////
crJXJSyncFormationMethod::crJXJSyncFormationMethod(){}
crJXJSyncFormationMethod::crJXJSyncFormationMethod(const crJXJSyncFormationMethod& handle):
	crMethod(handle)
{
}
void crJXJSyncFormationMethod::inputParam(int i, void *param)
{
}

void crJXJSyncFormationMethod::addParam(int i, const std::string& str)
{
}

void crJXJSyncFormationMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvSyncFormation,NULL);
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvSyncFormationMethod
//
/////////////////////////////////////////
crJXJRecvSyncFormationMethod::crJXJRecvSyncFormationMethod():
	m_netType(GameClient_Game){}
crJXJRecvSyncFormationMethod::crJXJRecvSyncFormationMethod(const crJXJRecvSyncFormationMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSyncFormationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSyncFormationMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSyncFormationMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				crData *thisData = m_this->getDataClass();
				thisData->excHandle(MAKEINT64(WCH_LockData,1));
				thisData->getParam(WCHDATA_JXJFormationInfoVec,param);
				FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
				int fsize = formationInfoVec->size();
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(fsize*14+1);
				stream->_writeUChar(fsize);
				for( FormationInfoVec::iterator itr = formationInfoVec->begin();
					itr != formationInfoVec->end();
					++itr )
				{
					stream->_writeInt((*itr)->getAbstractID());
					stream->_writeUShort((*itr)->getCount());
					stream->_writeVec2i((*itr)->getEquips());
				}
				thisData->excHandle(MAKEINT64(WCH_LockData,0));

				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvSyncFormation,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_JXJFormationInfoVec,param);
			FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
			unsigned char fsize = m_stream->_readUChar();
			formationInfoVec->resize(fsize);
			for( int i = 0; i<fsize; i++)
			{
				(*formationInfoVec)[i]->setAbstractID(m_stream->_readInt());
				(*formationInfoVec)[i]->setCount(m_stream->_readUShort());
				(*formationInfoVec)[i]->setEquips(m_stream->_readVec2i());
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}

/////////////////////////////////////////
//
//crJXJLoginGameSceneMethod
//
/////////////////////////////////////////
crJXJLoginGameSceneMethod::crJXJLoginGameSceneMethod(){}
crJXJLoginGameSceneMethod::crJXJLoginGameSceneMethod(const crJXJLoginGameSceneMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_button(handle.m_button)
{
}
void crJXJLoginGameSceneMethod::inputParam(int i, void *param)
{
}

void crJXJLoginGameSceneMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_button = str;
		break;
	default:
		break;
	}
}

void crJXJLoginGameSceneMethod::operator()(crHandle &handle)
{
	//bool taskCanceled = true;
	void *param;
	crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char type = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
	unsigned short fubenid = *(unsigned short *)param;
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	crTableIO::StrVec record;
	if(type == FT_Fuben && fubenid>0 && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
	{
		int sceneindex = fubentab->getTitleIndex("sceneid");
		int sceneid = atoi(record[sceneindex].c_str());
		if(sceneid>0)
		{
			//crWaitNetReturnStreamLogic::getLock();
			//crMyPlayerData::getInstance()->setLoginGameSceneMode(1);
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1060,NULL));
			crLoginScenePacket packet;
			crLoginScenePacket::buildRequestPacket(packet,sceneid,WCH_JXJLoginFuben);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			netConductor->getNetManager()->sendPacket("all",packet);
			//taskCanceled = false;
		}
	}
	//if(taskCanceled)
	//{
	//	//std::string str = "进入副本失败！请正确选择副本！";
	//	crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1005,NULL));
	//	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	//	if (canvas)
	//	{
	//		crWidgetNode *targetWidget = canvas->getWidget(m_button);
	//		if (targetWidget)
	//		{
	//			targetWidget->setEnable(true);
	//		}
	//	}
	//}
	//handle.outputParam(0,&taskCanceled);
}
/////////////////////////////////////////
//
//crJXJUIIsMultiFubenMethod
//
/////////////////////////////////////////
crJXJUIIsMultiFubenMethod::crJXJUIIsMultiFubenMethod()
{}
crJXJUIIsMultiFubenMethod::crJXJUIIsMultiFubenMethod(const crJXJUIIsMultiFubenMethod& handle):
crMethod(handle)
{
}
void crJXJUIIsMultiFubenMethod::inputParam(int i, void *param)
{
}

void crJXJUIIsMultiFubenMethod::addParam(int i, const std::string& str)
{
}

void crJXJUIIsMultiFubenMethod::operator()(crHandle &handle)
{
	bool isMultiFuben = false;
	void *param;
	crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char type = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
	unsigned short fubenid = *(unsigned short *)param;
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	crTableIO::StrVec record;
	if (type == FT_Fuben && fubenid>0 && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
	{
		int modeid = fubentab->getTitleIndex("多人副本");
		int mode = atoi(record[modeid].c_str());
		if(mode == 1)
			isMultiFuben = true;
	}
	handle.outputParam(0,&isMultiFuben);
}
/////////////////////////////////////////
//
//crJXJUIInitMultiFubenMethod
//
/////////////////////////////////////////
crJXJUIInitMultiFubenMethod::crJXJUIInitMultiFubenMethod(){}
crJXJUIInitMultiFubenMethod::crJXJUIInitMultiFubenMethod(const crJXJUIInitMultiFubenMethod& handle):
	crMethod(handle),
	m_multiFubenCanvas(handle.m_multiFubenCanvas),
	m_frame(handle.m_frame)
{
}
void crJXJUIInitMultiFubenMethod::inputParam(int i, void *param)
{
}

void crJXJUIInitMultiFubenMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_multiFubenCanvas = str;
		break;
	case 1:
		m_frame  = str;
		break;
	}
}

void crJXJUIInitMultiFubenMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_multiFubenCanvas);
	if(canvas.valid())
	{
		crStaticTextWidgetNode *frame = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_frame));
		if(frame)
		{
			void *param;
			crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char type = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short fubenid = *(unsigned short *)param;
			ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			crTableIO::StrVec record;
			if(type == FT_Fuben && fubenid>0 && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record)>=0)
			{
				int nameid = fubentab->getTitleIndex("name");
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				int texid = 1039;//多人副本[%s]
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
				int mode = 2;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameid]));
				std::string output;
				noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
				frame->setString(output);
			}

		}
	}
}
/////////////////////////////////////////
//
//crJXJHasTeamMethod
//
/////////////////////////////////////////
crJXJHasTeamMethod::crJXJHasTeamMethod(){}
crJXJHasTeamMethod::crJXJHasTeamMethod(const crJXJHasTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJHasTeamMethod::inputParam(int i, void *param)
{
}

void crJXJHasTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJHasTeamMethod::operator()(crHandle &handle)
{
	bool hasteam = false;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyTeam,param);
		TeamMemberVec *myTeam = (TeamMemberVec *)param;
		if(!myTeam->empty())
		{
			hasteam = true;
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	//if(hasteam)
	//{
	//	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
	//	//if(noticeText)
	//	//{
	//	//	std::string str = "你在组队里";
	//	//	noticeText->setText(CRIOManager::convertUTF8toUTF16(str).c_str());
	//	//	noticeText->setVisiable(true);
	//	//}
	//	crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1007,NULL));
	//}
	handle.outputParam(0,&hasteam);
}
/////////////////////////////////////////
//
//crJXJCreateTeamMethod
//
/////////////////////////////////////////
crJXJCreateTeamMethod::crJXJCreateTeamMethod(){}
crJXJCreateTeamMethod::crJXJCreateTeamMethod(const crJXJCreateTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJCreateTeamMethod::inputParam(int i, void *param)
{
}

void crJXJCreateTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJCreateTeamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyTeam,param);
		TeamMemberVec *myTeam = (TeamMemberVec *)param;
		if(myTeam->empty())
		{
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char type = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short id = *(unsigned short *)param;
			if(id>0)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(3);
				stream->_writeUChar(type);
				stream->_writeUShort(id);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCreateTeam,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvCreateTeamMethod
//
/////////////////////////////////////////
crJXJRecvCreateTeamMethod::crJXJRecvCreateTeamMethod():
	m_netType(GameClient_Game){}
crJXJRecvCreateTeamMethod::crJXJRecvCreateTeamMethod(const crJXJRecvCreateTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCreateTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCreateTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCreateTeamMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			char code = 0;
			void *param;
			crData *data = m_this->getDataClass();
			int playerid = m_this->getPlayerID();
			do 
			{
				data->getParam(WCHDATA_JXJTeamLeaderID,param);
				int leaderid = *(int *)param;
				if(leaderid != 0)
				{
					code = -1;//在组队里
					break;
				}
				data->getParam(WCHDATA_JXJBattleRoomID,param);
				_crInt64 battleroomid = *(_crInt64 *)param;
				if(battleroomid != 0)
				{
					code = -2;//已经在战场了
					break;
				}
				//data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				//unsigned char type = *(unsigned char *)param;
				//if(type == FT_Chengchi)
				//{
				//	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				//	unsigned short changchiid = *(unsigned short *)param;
				//	if(changchiid != 0)
				//	{
				//		code = -3;//已经在排队了
				//		break;
				//	}
				//}
				//{
					crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_JXJGSTeamMap,param);
					GSTeamMap *gsTeamMap = (GSTeamMap *)param;
					for( GSTeamMap::iterator itr = gsTeamMap->begin();
						itr != gsTeamMap->end();
						++itr )
					{
						if(itr->second == playerid)
						{
							//code = -5;//重复创建组队
							gsTeamMap->erase(itr);
							break;
						}
					}
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
					//if(code<0)
					//	break;
				//}

				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_PlayerIconID,param);
				unsigned char playericonid = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJMyTeam,param);
				TeamMemberVec *myTeam = (TeamMemberVec *)param;
				if(myTeam->empty() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
				{
					crData *mainRoleData = m_this->getMainRole()->getDataClass();
					mainRoleData->getParam(WCHDATA_Level,param);
					unsigned char lv = *(unsigned char *)param;
					crTeamMember *teamMember = new crTeamMember;
					teamMember->setPlayerID(playerid);
					teamMember->setIconID(playericonid);
					teamMember->setName(m_this->getMainRole()->getIName());
					teamMember->setLevel(lv);
					myTeam->push_back(teamMember);
					data->inputParam(WCHDATA_JXJTeamLeaderID,&playerid);

					unsigned char newtype = m_stream->_readUChar();
					unsigned short newID = m_stream->_readUShort();
					data->inputParam(WCHDATA_JXJFubenOrChengchiType,&newtype);
					data->inputParam(WCHDATA_JXJFubenOrChengchiID,&newID);
					////向GameServerBrain注册
					data->getParam(WCHDATA_JXJShiliID,param);
					unsigned char shiliid = *(unsigned char *)param;
					_crInt32 teamid = MAKEINT32(newID,MAKEINT16(newtype,shiliid));
					crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_JXJGSTeamMap,param);
					GSTeamMap *gsTeamMap = (GSTeamMap *)param;
					gsTeamMap->insert(std::make_pair(teamid,m_this->getPlayerID()));
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
					code = 1;
				}
				else
				{
					code = -4;//已经有队伍了
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			} while (0);
			//返回信息
			crNetConductor *sceneServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(sceneServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeChar(code);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCreateTeam,stream.get());
				sceneServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				void *param;
				crData *playerData = m_this->getDataClass();
				playerData->excHandle(MAKEINT64(WCH_LockData,1));
				playerData->getParam(WCHDATA_JXJMyTeam,param);
				TeamMemberVec *myTeam = (TeamMemberVec *)param;
				int playerid = m_this->getPlayerID();
				myTeam->clear();
				crData *mainRoleData = m_this->getMainRole()->getDataClass();
				mainRoleData->getParam(WCHDATA_Level,param);
				unsigned char lv = *(unsigned char *)param;
				crTeamMember *teamMember = new crTeamMember;
				playerData->getParam(WCHDATA_PlayerIconID,param);
				unsigned char playericonid = *(unsigned char *)param;
				teamMember->setIconID(playericonid);
				teamMember->setPlayerID(playerid);
				teamMember->setName(m_this->getMainRole()->getIName());
				teamMember->setLevel(lv);
				teamMember->setReady(false);
				myTeam->push_back(teamMember);
				playerData->inputParam(WCHDATA_JXJTeamLeaderID,&playerid);
				playerData->excHandle(MAKEINT64(WCH_LockData,0));
			}
			else
			{
				//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
				//if(noticeText)
				//{
				switch (returnCode)
				{
				case -1:
					//noticeText->setText(L"在组队里");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1007,NULL));
					break;
				case -2:
					//noticeText->setText(L"已经在战场了");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1008,NULL));
					break;
				case -3:
					//noticeText->setText(L"已经在排队了");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1009,NULL));
					break;
				case -4:
					//noticeText->setText(L"已经有队伍了");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1010,NULL));
					break;
				case -5:
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1077,NULL));
					break;
				}
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJLeaveTeamMethod
//
/////////////////////////////////////////
crJXJLeaveTeamMethod::crJXJLeaveTeamMethod(){}
crJXJLeaveTeamMethod::crJXJLeaveTeamMethod(const crJXJLeaveTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJLeaveTeamMethod::inputParam(int i, void *param)
{
}

void crJXJLeaveTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJLeaveTeamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJTeamLeaderID,param);
		int leaderid = *(int *)param;
		if(leaderid>0)
		{
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvLeaveTeam,NULL);
			netConductor->getNetManager()->sendPacket("all",packet);
			data->inputParam(WCHDATA_JXJTeamLeaderID,0);
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			myTeam->clear();
			//data->inputParam(WCHDATA_JXJFubenID,NULL);
			//data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
			//data->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
			//data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
		}
		//清理ID
		//data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		//data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);

		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvLeaveTeamMethod
//
/////////////////////////////////////////
crJXJRecvLeaveTeamMethod::crJXJRecvLeaveTeamMethod():
	m_netType(GameClient_Game){}
crJXJRecvLeaveTeamMethod::crJXJRecvLeaveTeamMethod(const crJXJRecvLeaveTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvLeaveTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvLeaveTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvLeaveTeamMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJTeamLeaderID,param);
			int leaderid = *(int *)param;
			if(leaderid!=0)
			{
				data->inputParam(WCHDATA_JXJTeamLeaderID,0);
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> leaderPlayerData;
				leaderPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderid));
				if(leaderPlayerData.valid())
				{
					ref_ptr<crPlayerGameData> leaderData = leaderPlayerData->getPlayerGameData();
					if(leaderData.valid() && leaderData->getDataClass())
					{
						crData *ldata = leaderData->getDataClass();
						ldata->excHandle(MAKEINT64(WCH_LockData,1));
						ldata->getParam(WCHDATA_JXJMyTeam,param);
						TeamMemberVec *myTeam = (TeamMemberVec *)param;
						crPlayerDataEventPacket packet;
						ref_ptr<crGameServerPlayerData> memberPlayer;
						ref_ptr<crPlayerGameData> memberData;
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(playerid);
						crPlayerGameData *playerGameData;
						crData *gameData;
						for( TeamMemberVec::iterator itr = myTeam->begin();
							itr != myTeam->end();)
						{
							if((*itr)->getPlayerID() != playerid)
							{
								memberPlayer = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
								if(memberPlayer.valid())
								{
									crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJClientRecvLeaveTeam,stream.get());
									gameServer->getNetManager()->sendPacket(memberPlayer->getPlayerConnectServerAddress(),packet);
									if(playerid == leaderid)
									{//队长离开
										playerGameData = memberPlayer->getPlayerGameData();
										if(playerGameData && playerGameData->getDataClass())
										{
											gameData = playerGameData->getDataClass();
											gameData->inputParam(WCHDATA_JXJTeamLeaderID,0);
											//if(memberPlayer->getSceneID() == 0)
											//{
											//	gameData->inputParam(WCHDATA_JXJFubenID,NULL);
											//	gameData->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
											//	gameData->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
											//	gameData->inputParam(WCHDATA_JXJBattleRoomID,NULL);
											//}
										}
									}
								}
								++itr;
							}
							else
							{
								itr = myTeam->erase(itr);
							}
						}
						if(playerid == leaderid)
						{
							////向GameServerBrain注册
							//data->getParam(WCHDATA_JXJShiliID,param);
							//unsigned char shiliid = *(unsigned char *)param;
							//data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
							//unsigned char fttype = *(unsigned char *)param;
							//data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
							//unsigned short ftid = *(unsigned short *)param;
							//_crInt32 teamid = MAKEINT32(ftid,MAKEINT16(fttype,shiliid));
							crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
							serverData->excHandle(MAKEINT64(WCH_LockData,1));
							serverData->getParam(WCHDATA_JXJGSTeamMap,param);
							GSTeamMap *gsTeamMap = (GSTeamMap *)param;
							for( GSTeamMap::iterator itr = gsTeamMap->begin();
								 itr != gsTeamMap->end();
								 ++itr )
							{
								if(itr->second == playerid)
								{
									gsTeamMap->erase(itr);
									break;
								}
							}
							serverData->excHandle(MAKEINT64(WCH_LockData,0));
							myTeam->clear();
							//ldata->inputParam(WCHDATA_JXJFubenID,0);
							//ldata->inputParam(WCHDATA_JXJBattleChengchiID,0);
						}
						ldata->excHandle(MAKEINT64(WCH_LockData,0));

						//data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
						//data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
						//data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
						//data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			int leaveid = m_stream->_readInt();
			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJTeamLeaderID,param);
			int leaderid = *(int*)param;
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			if(!myTeam->empty())
			{
				if(leaveid == leaderid || leaveid == m_this->getPlayerID())
				{
					myTeam->clear();
					data->inputParam(WCHDATA_JXJTeamLeaderID,0);
					if(crRunGameHandle::getInstance()->isInManor())
						m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1022,NULL));//队伍已解散！
					//std::string tipstr = "队伍已解散！";
					//crCanvasNode *teamcanvas = crFilterRenderManager::getInstance()->findCanvas(m_teamcanvas);
					//if (teamcanvas && teamcanvas->getVisiable())
					//{
					//	crFilterRenderManager::getInstance()->showCanvas(teamcanvas,false);
					//}
					//crCanvasNode *tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
					//if (tipcanvas)
					//{
					//	crStaticTextWidgetNode *tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					//	if (tipcontent)
					//	{
					//		tipcontent->setString(tipstr);
					//	}
					//	crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
					//}
					//data->inputParam(WCHDATA_JXJFubenID,NULL);
					//data->inputParam(WCHDATA_JXJCurFubenProgress,NULL);
					//data->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
					//data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
				}
				else
				{
					for( TeamMemberVec::iterator itr = myTeam->begin();
						 itr != myTeam->end();
						 ++itr )
					{
						if((*itr)->getPlayerID() == leaveid)
						{
							myTeam->erase(itr);
							break;
						}
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJTeamClosedMethod
//
/////////////////////////////////////////
crJXJTeamClosedMethod::crJXJTeamClosedMethod(){}
crJXJTeamClosedMethod::crJXJTeamClosedMethod(const crJXJTeamClosedMethod& handle):
	crMethod(handle)
{
}
void crJXJTeamClosedMethod::inputParam(int i, void *param)
{
}

void crJXJTeamClosedMethod::addParam(int i, const std::string& str)
{
}

void crJXJTeamClosedMethod::operator()(crHandle &handle)
{
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(player && netConductor)
	{
		crData *data = player->getDataClass();
		data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
		data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvTeamClosed,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvTeamClosedMethod
//
/////////////////////////////////////////
crJXJRecvTeamClosedMethod::crJXJRecvTeamClosedMethod():
	m_netType(GameClient_Game){}
crJXJRecvTeamClosedMethod::crJXJRecvTeamClosedMethod(const crJXJRecvTeamClosedMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvTeamClosedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTeamClosedMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvTeamClosedMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
			data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryTeamMethod
//
/////////////////////////////////////////
crJXJQueryTeamMethod::crJXJQueryTeamMethod(){}
crJXJQueryTeamMethod::crJXJQueryTeamMethod(const crJXJQueryTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJQueryTeamMethod::inputParam(int i, void *param)
{
}

void crJXJQueryTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJQueryTeamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short id = *(unsigned short *)param;
		if(type>0 && id>0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeUChar(type);
			stream->_writeUShort(id);
			stream->_writeUChar(0);//startid
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryTeam,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryTeamMethod
//
/////////////////////////////////////////
crJXJRecvQueryTeamMethod::crJXJRecvQueryTeamMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryTeamMethod::crJXJRecvQueryTeamMethod(const crJXJRecvQueryTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvQueryTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvQueryTeamMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				unsigned char fttype = m_stream->_readUChar();
				unsigned short ftid = m_stream->_readUShort();
				if(fttype == 0 || ftid == 0)
					return;
				unsigned char queryIndex = m_stream->_readUChar();
				crData *data = m_this->getDataClass();
				short myfubenprogress = 0;
				short leaderfubenprogress = 0;
				FubenProgressMap *fubenProgressMap;
				FubenProgressMap::iterator fpitr;
				if(fttype == FT_Fuben)
				{
					data->getParam(WCHDATA_JXJFubenProgressMap,param);
					fubenProgressMap = (FubenProgressMap *)param;
					fpitr = fubenProgressMap->find(ftid);
					if(fpitr != fubenProgressMap->end())
					{
						myfubenprogress = fpitr->second->getFubenProgress();
					}
				}
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				//data->inputParam(WCHDATA_JXJQueryTeamIndex,&queryIndex);
				//data->getParam(WCHDATA_JXJQueryTeamVec,param);
				//TeamVec *teamVec = (TeamVec *)param;
				//ref_ptr<crTeamInfo> teamInfo;
				//teamVec->clear();
				int maxMember = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxTeamMember,viplv).c_str());
				char maxQueryCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQueryTeamCount,viplv).c_str());

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1+26*maxQueryCount);
				char count = 0;
				short maxcount = (short)queryIndex + (short)maxQueryCount;
				stream->_writeChar(count);
				TeamMemberVec *team;
				char teamsize;
				int i = 0;
				unsigned char lv;
				////向GameServerBrain注册
				ref_ptr<crGameServerPlayerData> leaderPlayer;
				ref_ptr<crPlayerGameData> leaderPlayerGameData;
				ref_ptr<crRole> leaderMainRole;
				ref_ptr<crData> leaderData;
				ref_ptr<crData> leaderMainData;
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;
				_crInt32 teamid = MAKEINT32(ftid,MAKEINT16(fttype,shiliid));
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJGSTeamMap,param);
				GSTeamMap *gsTeamMap = (GSTeamMap *)param;
				for( GSTeamMap::iterator itr = gsTeamMap->find(teamid);
					itr != gsTeamMap->end() && itr->first == teamid && count<maxcount; )
				{
					leaderPlayer =  dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(itr->second));
					if(leaderPlayer.valid() && leaderPlayer->getPlayerGameData() && leaderPlayer->getPlayerGameData()->getDataClass())
					{
						leaderPlayerGameData = leaderPlayer->getPlayerGameData();
						leaderMainRole = leaderPlayerGameData->getMainRole();
						if(leaderMainRole.valid() && leaderMainRole->getDataClass())
						{
							++itr;
							if(leaderPlayer->getPlayerID()!=playerid && leaderPlayer->getSceneID() == 0)
							{
								leaderData = leaderPlayerGameData->getDataClass();
								leaderData->getParam(WCHDATA_JXJMyTeam,param);
								team = (TeamMemberVec *)param;
								teamsize = team->size();
								if(teamsize>0 && teamsize<maxMember)
								{
									leaderMainData = leaderMainRole->getDataClass();
									if(fttype == FT_Fuben)
									{
										leaderfubenprogress = 0;
										leaderData->getParam(WCHDATA_JXJFubenProgressMap,param);
										fubenProgressMap = (FubenProgressMap *)param;
										fpitr = fubenProgressMap->find(ftid);
										if(fpitr != fubenProgressMap->end())
										{
											leaderfubenprogress = fpitr->second->getFubenProgress();
										}
										if(myfubenprogress != leaderfubenprogress)
										{
											continue;
										}
									}
									if(i++<queryIndex)
									{
										continue;
									}
									leaderMainData->getParam(WCHDATA_Level,param);
									lv = *(unsigned char *)param;
									//teamInfo = new crTeamInfo;
									//teamInfo->setLeaderID(leaderPlayerGameData->getPlayerID());
									//teamInfo->setLeaderName(leaderPlayer->getCharacterName());
									//teamInfo->setLeaderLevel(lv);
									//teamInfo->setCount(teamsize);
									//teamVec->push_back(teamInfo);
									stream->_writeInt(leaderPlayer->getPlayerID());//4
									stream->_writeString(leaderPlayer->getCharacterName());//20
									stream->_writeUChar(lv);
									stream->_writeChar(teamsize);
									count++;
								}
							}
						}
						else
						{
							itr = gsTeamMap->erase(itr);
						}
					}
					else
					{
						itr = gsTeamMap->erase(itr);
					}
				}
				serverData->excHandle(MAKEINT64(WCH_LockData,0));

				int bufsize = stream->getBufSize();
				stream->seekBegin();
				stream->_writeUChar(count);
				stream->setBufSize(bufsize);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryTeam,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *playerData = m_this->getDataClass();
			playerData->excHandle(MAKEINT64(WCH_LockData,1));
			playerData->getParam(WCHDATA_JXJQueryTeamVec,param);
			TeamVec *teamVec = (TeamVec *)param;
			teamVec->clear();
			char count = m_stream->_readUChar();
			ref_ptr<crTeamInfo> teamInfo;
			for( char i = 0; i<count; ++i )
			{
				teamInfo = new crTeamInfo;
				teamInfo->setLeaderID(m_stream->_readInt());
				teamInfo->setLeaderName(m_stream->_readString());
				teamInfo->setLeaderLevel(m_stream->_readUChar());
				teamInfo->setCount(m_stream->_readChar());
				teamVec->push_back(teamInfo.get());
			}
			playerData->excHandle(MAKEINT64(WCH_LockData,0));
			m_this->doEvent(WCH_JXJUpdateTeamList);
		}
	}
}
/////////////////////////////////////////
//
//crJXJJoinTeamMethod
//
/////////////////////////////////////////
crJXJJoinTeamMethod::crJXJJoinTeamMethod(){}
crJXJJoinTeamMethod::crJXJJoinTeamMethod(const crJXJJoinTeamMethod& handle):
	crMethod(handle),
	m_teamTable(handle.m_teamTable)
{
}
void crJXJJoinTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJJoinTeamMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_teamTable = str;
		break;
	}
}

void crJXJJoinTeamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && myPlayer && myPlayer->getDataClass() && myPlayer->getMainRole() && myPlayer->getMainRole()->getDataClass())
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crTableWidgetNode *teamTable = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_teamTable));
		int selectRow = teamTable->getSelect();

		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short id = *(unsigned short *)param;
		if(type>0 && id>0)
		{
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			data->getParam(WCHDATA_JXJTeamLeaderID,param);
			int lastleaderid = *(int*)param;
			if(myTeam->empty() && lastleaderid == 0)
			{
				data->getParam(WCHDATA_JXJQueryTeamVec,param);
				TeamVec *teamVec = (TeamVec *)param;
				if(selectRow<teamVec->size())
				{
					bool canjoin = false;
					crData *roledata = myPlayer->getMainRole()->getDataClass();
					roledata->getParam(WCHDATA_Level,param);
					unsigned char mylv = *(unsigned char *)param;
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char myviplv = *(unsigned char *)param;
					if(type == FT_Chengchi)
					{
						int battlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevel,myviplv).c_str());
						int maxBattlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenMaxLimitLevel,myviplv).c_str());
						int IncreaseDate = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevelIncreaseDate,myviplv).c_str());
						int tianshu = 0;
						if (crGlobalHandle::isClient())
						{
							crGlobalHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
						}
						else
						{
							crServerBrainHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
						}
						if (mylv >= maxBattlelv)
						{
							//判断该城与我当前驻地是否连通
							if(id<TestChengchiID)
							{//>5000的是测试城
								bool connect = false;
								myPlayer->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
								if(connect)
								{
									canjoin = true;
								}
							}
						}
						else if (tianshu >= 0 && tianshu < IncreaseDate)
						{
							if (mylv >= battlelv)
							{
								//判断该城与我当前驻地是否连通
								if(id<TestChengchiID)
								{//>5000的是测试城
									bool connect = false;
									myPlayer->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
									if(connect)
									{
										canjoin = true;
									}
								}
							}
						}
						else if (tianshu >= IncreaseDate && tianshu < maxBattlelv-IncreaseDate)
						{
							int battlelv_1 = battlelv + tianshu - IncreaseDate + 1;
							if (mylv >= battlelv_1)
							{
								//判断该城与我当前驻地是否连通
								if(id<TestChengchiID)
								{//>5000的是测试城
									bool connect = false;
									myPlayer->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
									if(connect)
									{
										canjoin = true;
									}
								}
							}
						}
					}
					else if(id>0)
					{
						ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
						crTableIO::StrVec fubenrecord;
						int needlvindex = fubentab->getTitleIndex("需求等级");
						if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(id),fubenrecord)>=0)
						{
							if(mylv >= atoi(fubenrecord[needlvindex].c_str()))
							{
								//canjoin = true;
								data->getParam(WCHDATA_JXJFubenProgressMap,param);
								FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
								FubenProgressMap::iterator itr = fubenProgressMap->find(id);
								FubenProgressMap::iterator itr_front = fubenProgressMap->find(id-1);
								
								if(itr_front!=fubenProgressMap->end() && itr_front->second->getComplete()>=1)
								{
									canjoin = true;
								}
								if(itr != fubenProgressMap->end() && itr->second->getComplete()>=1)
								{
									canjoin = true;
								}
								if(itr == fubenProgressMap->end() && itr_front==fubenProgressMap->end() && fubentab->queryOneRecord(0,crArgumentParser::appItoa(id-1),fubenrecord)<0)
									canjoin = true;
							}
						}
					}
					if(canjoin)
					{
						crTeamInfo *teamInfo = (*teamVec)[selectRow].get();
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(7);
						stream->_writeInt(teamInfo->getLeaderID());
						stream->_writeUChar(type);
						stream->_writeUShort(id);
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvJoinTeam,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvJoinTeamMethod
//
/////////////////////////////////////////
crJXJRecvJoinTeamMethod::crJXJRecvJoinTeamMethod():
	m_netType(GameClient_Game){}
crJXJRecvJoinTeamMethod::crJXJRecvJoinTeamMethod(const crJXJRecvJoinTeamMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)/*,
	m_canvas2(handle.m_canvas2)*/
{
}
void crJXJRecvJoinTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvJoinTeamMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	//case 1:
	//	m_canvas2 = str;
	//	break;
	}
}

void crJXJRecvJoinTeamMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crPlayerDataEventPacket packet;
			int playerid = m_this->getPlayerID();
			char done = 0;
			void *param;
			crData *data = m_this->getDataClass();
			int leaderid = m_stream->_readInt();
			unsigned char recvtype = m_stream->_readUChar();
			unsigned short recvchengchiid = m_stream->_readUShort();
			unsigned char m_index = 0;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			ref_ptr<crStreamBuf> rtnstream = new crStreamBuf;
			data->getParam(WCHDATA_JXJTeamLeaderID,param);
			int lastleaderid = *(int*)param;
			if(myTeam->empty() && lastleaderid == 0 && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;
				ref_ptr<crGameServerPlayerData> leaderPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderid));
				if(leaderPlayerData.valid() && leaderPlayerData->getSceneID() == 0)
				{
					ref_ptr<crPlayerGameData> leaderData = leaderPlayerData->getPlayerGameData();
					if(leaderData.valid() && leaderData->getDataClass())
					{
						crData *leaderdata = leaderData->getDataClass();
						leaderdata->getParam(WCHDATA_JXJShiliID,param);
						unsigned char lshiliid = *(unsigned char *)param;
						unsigned char type = 0;
						unsigned short id = 0;
						if(shiliid == lshiliid)
						{
							leaderdata->getParam(WCHDATA_JXJVipLv,param);
							unsigned char viplv = *(unsigned char *)param;
							int maxMember = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxTeamMember,viplv).c_str());//WCHDATA_JXJBattleMaxTeamMember删除
							leaderdata->getParam(WCHDATA_JXJMyTeam,param);
							TeamMemberVec *leaderTeam = (TeamMemberVec *)param;
							if(!leaderTeam->empty() && leaderTeam->size()<maxMember && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
							{
								leaderdata->getParam(WCHDATA_JXJFubenOrChengchiType,param);
								type = *(unsigned char *)param;
								leaderdata->getParam(WCHDATA_JXJFubenOrChengchiID,param);
								id = *(unsigned short *)param;
								crRole *mainrole = m_this->getMainRole();
								bool canjoin = false;
								if(type == recvtype  && id == recvchengchiid && mainrole && mainrole->getDataClass())
								{
									crData *roledata = mainrole->getDataClass();
									roledata->getParam(WCHDATA_Level,param);
									unsigned char mylv = *(unsigned char *)param;
									data->getParam(WCHDATA_JXJVipLv,param);
									unsigned char myviplv = *(unsigned char *)param;
									if(type == FT_Chengchi)
									{
										int battlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevel,myviplv).c_str());
										int maxBattlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenMaxLimitLevel,myviplv).c_str());
										int IncreaseDate = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevelIncreaseDate,myviplv).c_str());
										int tianshu = 0;
										if (crGlobalHandle::isClient())
										{
											crGlobalHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
										}
										else
										{
											crServerBrainHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
										}
										if (mylv >= maxBattlelv)
										{
											//判断该城与我当前驻地是否连通
											if(id<TestChengchiID)
											{//>5000的是测试城
												bool connect = false;
												m_this->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
												if(connect)
												{
													canjoin = true;
												}
											}
											else
											{
												canjoin = true;
											}
										}
										else if (tianshu >= 0 && tianshu < IncreaseDate)
										{
											if (mylv >= battlelv)
											{
												//判断该城与我当前驻地是否连通
												if(id<TestChengchiID)
												{//>5000的是测试城
													bool connect = false;
													m_this->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
													if(connect)
													{
														canjoin = true;
													}
												}
												else
												{
													canjoin = true;
												}
											}
										}
										else if (tianshu >= IncreaseDate && tianshu < maxBattlelv-IncreaseDate)
										{
											int battlelv_1 = battlelv + tianshu - IncreaseDate + 1;
											if (mylv >= battlelv_1)
											{
												//判断该城与我当前驻地是否连通
												if(id<TestChengchiID)
												{//>5000的是测试城
													bool connect = false;
													m_this->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
													if(connect)
													{
														canjoin = true;
													}
												}
												else
												{
													canjoin = true;
												}
											}
										}

										//if(mylv>=battlelv)
										//{
										//	//判断该城与我当前驻地是否连通
										//	if(id<TestChengchiID)
										//	{//>5000的是测试城
										//		bool connect = false;
										//		m_this->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(id,&connect));
										//		if(connect)
										//		{
										//			canjoin = true;
										//		}
										//	}
										//	else
										//	{
										//		canjoin = true;
										//	}
										//}
									}
									else if(id>0)
									{
										ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
										crTableIO::StrVec fubenrecord;
										int needlvindex = fubentab->getTitleIndex("需求等级");
										if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(id),fubenrecord)>=0)
										{
											if(mylv >= atoi(fubenrecord[needlvindex].c_str()))
											{
												data->getParam(WCHDATA_JXJFubenProgressMap,param);
												FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
												FubenProgressMap::iterator itr = fubenProgressMap->find(id);
												FubenProgressMap::iterator itr_front = fubenProgressMap->find(id-1);
												if(itr_front!=fubenProgressMap->end() && itr_front->second->getComplete()>=1)
												{
													canjoin = true;
												}
												if(itr != fubenProgressMap->end() && itr->second->getComplete()>=1)
												{
													canjoin = true;
												}
												if(itr == fubenProgressMap->end() && itr_front==fubenProgressMap->end() && fubentab->queryOneRecord(0,crArgumentParser::appItoa(id-1),fubenrecord)<0)
													canjoin = true;
											}
										}
									}
								}
								if(canjoin)
								{
									data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
									data->inputParam(WCHDATA_JXJFubenOrChengchiID,&id);

									crData *mainRoleData = m_this->getMainRole()->getDataClass();
									mainRoleData->getParam(WCHDATA_Level,param);
									unsigned char lv = *(unsigned char *)param;
									ref_ptr<crTeamMember>teamMember = new crTeamMember;
									data->getParam(WCHDATA_PlayerIconID,param);
									unsigned char playericonid = *(unsigned char *)param;
									teamMember->setIconID(playericonid);
									teamMember->setPlayerID(playerid);
									teamMember->setName(m_this->getMainRole()->getIName());
									teamMember->setLevel(lv);
									data->inputParam(WCHDATA_JXJTeamLeaderID,&leaderid);
									done = 1;
									//send to teammember
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(26);
									stream->_writeUChar(playericonid);
									stream->_writeInt(playerid);
									stream->_writeString(teamMember->getName());//20
									stream->_writeUChar(lv);
									crPlayerDataEventPacket::buildReplyPacket(packet,leaderid,WCH_JXJRecvNewTeamMember,stream.get());
									gameServer->getNetManager()->sendPacket(leaderPlayerData->getPlayerConnectServerAddress(),packet);
									//
									ref_ptr<crGameServerPlayerData> memberPlayerData;
									rtnstream->createBuf(5+27*leaderTeam->size());
									rtnstream->_writeChar(done);
									rtnstream->_writeUChar(type);
									rtnstream->_writeUShort(id);
									rtnstream->_writeUChar(leaderTeam->size());
									for( TeamMemberVec::iterator itr = leaderTeam->begin();
										itr != leaderTeam->end(); 
										++itr)
									{
										if((*itr)->getPlayerID() != leaderid)
										{
											memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
											if(memberPlayerData.valid())
											{
												crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJRecvNewTeamMember,stream.get());
												gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
											}
										}
										rtnstream->_writeUChar((*itr)->getIconID());
										rtnstream->_writeInt((*itr)->getPlayerID());
										rtnstream->_writeString((*itr)->getName());//20
										rtnstream->_writeUChar((*itr)->getLevel());
										rtnstream->_writeBool((*itr)->isReady());
									}
									leaderTeam->push_back(teamMember.get());
								}
							}
							else
							{
								if (leaderTeam->empty())
								{
									m_index = 5;//组队已解散
								}
								else if (leaderTeam->size() >= maxMember)
								{
									m_index = 6;//组队已满
								}
							}
						}
						else
						{
							m_index = 4;//组队势力异常，加入失败
						}
					}
					else
					{
						m_index = 3;//组队数据异常，加入失败
					}
				}
				else
				{
					m_index = 2;//组队已开启，加入失败
				}
			}
			else
			{
				m_index = 1;//已在组队中，加入失败
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//返回信息
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				if(done!=1)
				{
					rtnstream->createBuf(2);
					rtnstream->_writeChar(done);
					rtnstream->_writeUChar(m_index);
					//rtnstream->_writeUChar(itype);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvJoinTeam,rtnstream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char done = m_stream->_readChar();
			if(done == 1)
			{
				unsigned char type = m_stream->_readUChar();
				unsigned short id = m_stream->_readUShort();
				char teamsize = m_stream->_readChar();
				if(teamsize > 0)
				{
					void *param;
					crData *playerData = m_this->getDataClass();
					playerData->excHandle(MAKEINT64(WCH_LockData,1));
					playerData->getParam(WCHDATA_JXJMyTeam,param);
					TeamMemberVec *myTeam = (TeamMemberVec *)param;
					int playerid = m_this->getPlayerID();
					myTeam->clear();
					crData *mainRoleData = m_this->getMainRole()->getDataClass();
					mainRoleData->getParam(WCHDATA_Level,param);
					unsigned char lv = *(unsigned char *)param;
					ref_ptr<crTeamMember> teamMember;
					for( int i = 0; i<teamsize;i++)
					{
						teamMember = new crTeamMember;
						teamMember->setIconID(m_stream->_readUChar());
						teamMember->setPlayerID(m_stream->_readInt());
						teamMember->setName(m_stream->_readString());
						teamMember->setLevel(m_stream->_readUChar());
						teamMember->setReady(m_stream->_readBool());
						myTeam->push_back(teamMember.get());
					}
					teamMember = new crTeamMember;
					playerData->getParam(WCHDATA_PlayerIconID,param);
					unsigned char playericonid = *(unsigned char *)param;
					teamMember->setIconID(playericonid);
					teamMember->setPlayerID(playerid);
					teamMember->setName(m_this->getMainRole()->getIName());
					teamMember->setLevel(lv);
					myTeam->push_back(teamMember.get());
					int leaderid = (*myTeam->begin())->getPlayerID();
					playerData->inputParam(WCHDATA_JXJTeamLeaderID,&leaderid);
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiID,&id);
					playerData->excHandle(MAKEINT64(WCH_LockData,0));
					crFilterRenderManager::getInstance()->showCanvas(m_canvas,true);
				}
			}
			else
			{
				unsigned char m_index = m_stream->_readUChar();
				switch (m_index)
				{
				case 0:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1021, NULL));//加入组队失败
					break;
				case 1:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1010, NULL));//已在组队中
					break;
				case 2:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(7015, NULL));//组队已进入战场
					break;
				case 3:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(7016, NULL));//组队数据异常
					break;
				case 4:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(7017, NULL));//组队势力异常
					break;
				case 5:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1022, NULL));//队伍已解散
					break;
				case 6:
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(7014, NULL));//组队已满
					break;
				default:
					break;
				}
				//m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1021,NULL));//加入组队失败
				//if(itype == Invite_Fuben)
				//{//加入副本组队失败，刷新列表
				//	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				//	if(canvas->getVisiable())
				//	{
				//		canvas->doEvent(WCH_UI_UpdateData);
				//	}
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvNewTeamMemberMethod
//
/////////////////////////////////////////
crJXJRecvNewTeamMemberMethod::crJXJRecvNewTeamMemberMethod():
	m_netType(GameClient_Game){}
crJXJRecvNewTeamMemberMethod::crJXJRecvNewTeamMemberMethod(const crJXJRecvNewTeamMemberMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvNewTeamMemberMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvNewTeamMemberMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvNewTeamMemberMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *playerData = m_this->getDataClass();
			playerData->excHandle(MAKEINT64(WCH_LockData,1));
			playerData->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			ref_ptr<crTeamMember> teamMember;
			teamMember = new crTeamMember;
			teamMember->setIconID(m_stream->_readUChar());
			teamMember->setPlayerID(m_stream->_readInt());
			teamMember->setName(m_stream->_readString());
			teamMember->setLevel(m_stream->_readUChar());
			myTeam->push_back(teamMember.get());
			playerData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJKickMemberFromTeamMethod
//
/////////////////////////////////////////
crJXJKickMemberFromTeamMethod::crJXJKickMemberFromTeamMethod(){}
crJXJKickMemberFromTeamMethod::crJXJKickMemberFromTeamMethod(const crJXJKickMemberFromTeamMethod& handle):
	crMethod(handle),
	m_nameinput(handle.m_nameinput)
{
}
void crJXJKickMemberFromTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJKickMemberFromTeamMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameinput = str;
		break;
	}
}

void crJXJKickMemberFromTeamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		//crStaticTextWidgetNode *nameinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nameinput));
		//std::string name = nameinput->getUTF8String();
		int memberindex = atoi(m_nameinput.c_str());

		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyTeam,param);
		TeamMemberVec *myTeam = (TeamMemberVec *)param;
		data->getParam(WCHDATA_JXJTeamLeaderID,param);
		int lastleaderid = *(int*)param;
		int i = 0;
		for(TeamMemberVec::iterator itr = myTeam->begin();
			itr != myTeam->end();
			++itr, i++)
		{
			if(i == memberindex)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt((*itr)->getPlayerID());
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvKickMemberFromTeam,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				itr = myTeam->erase(itr);
				if(itr == myTeam->end())
					break;
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvKickMemberFromTeamMethod
//
/////////////////////////////////////////
crJXJRecvKickMemberFromTeamMethod::crJXJRecvKickMemberFromTeamMethod():
	m_netType(GameClient_Game){}
crJXJRecvKickMemberFromTeamMethod::crJXJRecvKickMemberFromTeamMethod(const crJXJRecvKickMemberFromTeamMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvKickMemberFromTeamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvKickMemberFromTeamMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvKickMemberFromTeamMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crPlayerDataEventPacket packet;
			crData *data = m_this->getDataClass();
			int playerid = m_stream->_readInt();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			ref_ptr<crStreamBuf> rtnstream = new crStreamBuf;
			ref_ptr<crGameServerPlayerData> memberPlayerData;
			for (TeamMemberVec::iterator itr = myTeam->begin();
				itr!=myTeam->end();
				++itr)
			{
				if((*itr)->getPlayerID() != playerid)
				{
					memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
					if(memberPlayerData.valid())
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						stream->_writeInt(playerid);
						crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJClientRecvLeaveTeam,stream.get());
						gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
			for (TeamMemberVec::iterator itr = myTeam->begin();
				itr!=myTeam->end();
				++itr)
			{
				if((*itr)->getPlayerID() == playerid)
				{
					memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
					if(memberPlayerData.valid())
					{
						crData *memeberData = memberPlayerData->getPlayerGameData()->getDataClass();
						if(memeberData)
							memeberData->inputParam(WCHDATA_JXJTeamLeaderID,0);
						crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJRecvKickMemberFromTeam,NULL);
						gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
						myTeam->erase(itr);
						break;
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
			///////////////////////
		else if(m_netType == GameClient_Game)
		{
			void *param;
			//ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			//if(canvas)
			//{
			//	crStaticTextWidgetNode *input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
			//	if(input)
			//	{
			//		std::string str = "你已被队长请出队伍";
			//		input->setString(str);
			//		crFilterRenderManager::getInstance()->showCanvas(canvas,true);
			//	}
			//}
			m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1023,NULL));//你已被队长请出队伍！
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->inputParam(WCHDATA_JXJTeamLeaderID,0);
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			myTeam->clear();
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJTeamMemberReadyMethod
//
/////////////////////////////////////////
crJXJTeamMemberReadyMethod::crJXJTeamMemberReadyMethod(){}
crJXJTeamMemberReadyMethod::crJXJTeamMemberReadyMethod(const crJXJTeamMemberReadyMethod& handle):
	crMethod(handle)
{
}
void crJXJTeamMemberReadyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJTeamMemberReadyMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_value = atoi(str.c_str());
		break;
	}
}

void crJXJTeamMemberReadyMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		int playerid = myPlayer->getPlayerID();
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyTeam,param);
		TeamMemberVec *myTeam = (TeamMemberVec *)param;
		data->getParam(WCHDATA_JXJTeamLeaderID,param);
		int lastleaderid = *(int*)param;
		int i = 0;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		for(TeamMemberVec::iterator itr = myTeam->begin();
			itr != myTeam->end();
			++itr, i++)
		{
			if(itr->get()->getPlayerID() == playerid && i>0)
			{
				itr->get()->setReady(m_value);
				if(m_value==1)
				{
					stream->createBuf(4);
					stream->_writeInt((*itr)->getPlayerID());
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvMemberReady,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else if(m_value==0)
				{
					stream->createBuf(4);
					stream->_writeInt((*itr)->getPlayerID());
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvMemberCancelReady,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvMemberReadyMethod
//
/////////////////////////////////////////
crJXJRecvMemberReadyMethod::crJXJRecvMemberReadyMethod():
	m_netType(GameClient_Game){}
crJXJRecvMemberReadyMethod::crJXJRecvMemberReadyMethod(const crJXJRecvMemberReadyMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvMemberReadyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvMemberReadyMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvMemberReadyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameServer)
		{
			int playerid = m_stream->_readInt();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crPlayerDataEventPacket packet;
			crData *data = m_this->getDataClass();

			data->getParam(WCHDATA_JXJTeamLeaderID,param);
			int leaderid = *(int *)param;
			if(leaderid>0)
			{
				int playerid = m_this->getPlayerID();
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> leaderPlayerData;
				leaderPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderid));
				if(leaderPlayerData.valid())
				{
					ref_ptr<crPlayerGameData> leaderData = leaderPlayerData->getPlayerGameData();
					if(leaderData.valid() && leaderData->getDataClass())
					{
						void *param;
						crData *ldata = leaderData->getDataClass();
						ldata->excHandle(MAKEINT64(WCH_LockData,1));
						ldata->getParam(WCHDATA_JXJMyTeam,param);
						TeamMemberVec *myTeam = (TeamMemberVec *)param;
						ref_ptr<crStreamBuf> rtnstream = new crStreamBuf;
						ref_ptr<crGameServerPlayerData> memberPlayerData;
						for (TeamMemberVec::iterator itr = myTeam->begin();
							itr!=myTeam->end();
								++itr)
						{
							if((*itr)->getPlayerID() != playerid)
							{
								memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
								if(memberPlayerData.valid())
								{
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(4);
									stream->_writeInt(playerid);
									crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJRecvMemberReady,stream.get());
									gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
								}
							}
							else if(itr->get()->getPlayerID() == playerid )
							{
								itr->get()->setReady(true);
							}
						}
						ldata->excHandle(MAKEINT64(WCH_LockData,0));
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			int playerid = m_stream->_readInt();
			for (TeamMemberVec::iterator itr = myTeam->begin();itr!=myTeam->end();itr++)
			{
				if(itr->get()->getPlayerID() == playerid)
				{
					itr->get()->setReady(true);
					break;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvMemberCancelReadyMethod
//
/////////////////////////////////////////
crJXJRecvMemberCancelReadyMethod::crJXJRecvMemberCancelReadyMethod():
	m_netType(GameClient_Game){}
crJXJRecvMemberCancelReadyMethod::crJXJRecvMemberCancelReadyMethod(const crJXJRecvMemberCancelReadyMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvMemberCancelReadyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvMemberCancelReadyMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvMemberCancelReadyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameServer)
		{
			int playerid = m_stream->_readInt();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crPlayerDataEventPacket packet;
			crData *data = m_this->getDataClass();

			data->getParam(WCHDATA_JXJTeamLeaderID,param);
			int leaderid = *(int *)param;
			if(leaderid>0)
			{
				int playerid = m_this->getPlayerID();
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> leaderPlayerData;
				leaderPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderid));
				if(leaderPlayerData.valid())
				{
					ref_ptr<crPlayerGameData> leaderData = leaderPlayerData->getPlayerGameData();
					if(leaderData.valid() && leaderData->getDataClass())
					{
						void *param;
						crData *ldata = leaderData->getDataClass();
						ldata->excHandle(MAKEINT64(WCH_LockData,1));
						ldata->getParam(WCHDATA_JXJMyTeam,param);
						TeamMemberVec *myTeam = (TeamMemberVec *)param;
						ref_ptr<crStreamBuf> rtnstream = new crStreamBuf;
						ref_ptr<crGameServerPlayerData> memberPlayerData;
						for (TeamMemberVec::iterator itr = myTeam->begin();
							itr!=myTeam->end();
							++itr)
						{
							if((*itr)->getPlayerID() != playerid)
							{
								memberPlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
								if(memberPlayerData.valid())
								{
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(4);
									stream->_writeInt(playerid);
									crPlayerDataEventPacket::buildReplyPacket(packet,(*itr)->getPlayerID(),WCH_JXJRecvMemberCancelReady,stream.get());
									gameServer->getNetManager()->sendPacket(memberPlayerData->getPlayerConnectServerAddress(),packet);
								}
							}
							else if(itr->get()->getPlayerID() == playerid )
							{
								itr->get()->setReady(false);
							}
						}
						ldata->excHandle(MAKEINT64(WCH_LockData,0));
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJMyTeam,param);
			TeamMemberVec *myTeam = (TeamMemberVec *)param;
			int playerid = m_stream->_readInt();
			for (TeamMemberVec::iterator itr = myTeam->begin();itr!=myTeam->end();itr++)
			{
				if(itr->get()->getPlayerID() == playerid)
				{
					itr->get()->setReady(false);
					break;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIUpdateTeamInfoMethod
//
/////////////////////////////////////////
crJXJUIUpdateTeamInfoMethod::crJXJUIUpdateTeamInfoMethod():
m_this(NULL){}
crJXJUIUpdateTeamInfoMethod::crJXJUIUpdateTeamInfoMethod(const crJXJUIUpdateTeamInfoMethod& handle):
crMethod(handle),
m_this(NULL),
m_join(handle.m_join),
m_create(handle.m_create),
m_player0(handle.m_player0),
m_player1(handle.m_player1),
m_player2(handle.m_player2),
m_player3(handle.m_player3),
m_player4(handle.m_player4),
m_switch(handle.m_switch),
m_playerReady1(handle.m_playerReady1),
m_playerReady2(handle.m_playerReady2),
m_playerReady3(handle.m_playerReady3),
m_playerReady4(handle.m_playerReady4),
m_btswitch(handle.m_btswitch),
m_btStart(handle.m_btStart),
m_btStartSwitch(handle.m_btStartSwitch),
m_btStartBattle(handle.m_btStartBattle)
{
}
void crJXJUIUpdateTeamInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIUpdateTeamInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_join = str;
		break;
	case 1:
		m_create = str;
		break;
	case 2:
		m_player0 = str;
		break;
	case 3:
		m_player1 = str;
		break;
	case 4:
		m_player2 = str;
		break;
	case 5:
		m_player3 = str;
		break;
	case 6:
		m_player4 = str;
		break;
	case 7:
		m_switch = str;
		break;
	case 8:
		m_playerReady1 = str;
		break;
	case 9:
		m_playerReady2 = str;
		break;
	case 10:
		m_playerReady3 = str;
		break;
	case 11:
		m_playerReady4 = str;
		break;
	case 12:
		m_btswitch = str;
		break;
	case 13:
		m_btStart = str;
		break;
	case 14:
		m_btStartSwitch = str;
		break;
	case 15:
		m_btStartBattle = str;
		break;
	}
}

void crJXJUIUpdateTeamInfoMethod::operator()(crHandle &handle)
{
	if(crDisplaySettings::instance()->getRunMode()>0)
	{
		crButtonWidgetNode *join = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_join));
		crButtonWidgetNode *create = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_create));
		crStaticTextWidgetNode *players[5];
		players[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_player0));
		players[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_player1));
		players[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_player2));
		players[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_player3));
		players[4] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_player4));
		crMultiSwitch *isLeaderSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_switch));
		crMultiSwitch *btSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_btswitch));
		crMultiSwitch *pleayerReady[4];
		pleayerReady[0] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_playerReady1));
		pleayerReady[1] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_playerReady2));
		pleayerReady[2] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_playerReady3));
		pleayerReady[3] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_playerReady4));

		crButtonWidgetNode *btStart = NULL;
		crMultiSwitch *startSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_btStartSwitch));
		int activeid = 0;
		if(startSwitch) activeid = startSwitch->getActiveSwitchSet();
		if(activeid == 0)
			btStart = dynamic_cast<crButtonWidgetNode*>(m_this->getWidget(m_btStart));
		else
		{
			btStart = dynamic_cast<crButtonWidgetNode*>(m_this->getWidget(m_btStartBattle));
		}
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxMember = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxTeamMember,viplv).c_str());

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyTeam,param);
		TeamMemberVec *myTeam = (TeamMemberVec *)param;
		int playerid = myPlayer->getPlayerID();
		bool iisleader = false;
		bool isAllReady = true;
		int i = 0;
		if(myTeam->empty())
		{
			for (int i= 0;i<5;i++)
			{
				players[i]->setString(std::string(""));
				if(i>0)
					pleayerReady[i-1]->setActiveSwitchSet(0);
			}
			btSwitch->setActiveSwitchSet(0);
			
		}
		for( TeamMemberVec::iterator itr = myTeam->begin();
			itr != myTeam->end();
			++itr,i++ )
		{
			std::string &playerName = (*itr)->getName();
			if(players[i])
			{
				players[i]->setString(playerName+"LV"+crArgumentParser::appItoa((*itr)->getLevel()));
				players[i]->setVisiable(true);
			}
			if(i == 0)
			{
				iisleader = playerid == (*itr)->getPlayerID();
			}
			if(i>0)
			{
				isAllReady = (isAllReady&&itr->get()->isReady());
				if(pleayerReady[i-1])
				{
					unsigned int active = (itr->get()->isReady())?1:0;
					pleayerReady[i-1]->setActiveSwitchSet(active);
				}
			}
			if(playerid == itr->get()->getPlayerID())
			{
				if(btSwitch)
				{
					unsigned int active = (itr->get()->isReady())?1:0;
					btSwitch->setActiveSwitchSet(active);
				}
			}
		}
		for (int j = i;j<5;j++)
		{
			players[j]->setString(std::string(""));
			if(j>0)
			{
				pleayerReady[j-1]->setActiveSwitchSet(0);
			}
		}
		if(btStart)
		{
			if(isAllReady)
				btStart->setEnable(true);
			else 
				btStart->setEnable(false);
		}
		if(iisleader)
			isLeaderSwitch->setActiveSwitchSet(0);
		else 
			isLeaderSwitch->setActiveSwitchSet(1);

		if(myTeam->empty())
		{
			if(join)join->setEnable(true);
			if(create)create->setEnable(true);
			isLeaderSwitch->setVisiable(false);
		}
		else
		{
			if(join)join->setEnable(false);
			if(create)create->setEnable(false);
			isLeaderSwitch->setVisiable(true);
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUpdateTeamListMethod
//
/////////////////////////////////////////
crJXJUpdateTeamListMethod::crJXJUpdateTeamListMethod(){}
crJXJUpdateTeamListMethod::crJXJUpdateTeamListMethod(const crJXJUpdateTeamListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_teamTable(handle.m_teamTable)
{
}
void crJXJUpdateTeamListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJUpdateTeamListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_teamTable = str;
		break;
	}
}
void crJXJUpdateTeamListMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvas.valid())
	{
		crTableWidgetNode *teamTable = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_teamTable));
		if(teamTable)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int maxMember = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxTeamMember,viplv).c_str());

			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJQueryTeamVec,param);
			TeamVec *teams = (TeamVec *)param;

			int selectRow = teamTable->getSelect();
			teamTable->clearData();
			int row = 0;
			crTeamInfo *teamInfo;
			char buf[64];
			for( TeamVec::iterator itr = teams->begin();
				itr != teams->end();
				++itr,row++ )
			{
				teamInfo = itr->get();
				sprintf(buf,"%s(LV%d)的组队%d|%d\0",teamInfo->getLeaderName().c_str(),(int)(teamInfo->getLeaderLevel()),(int)(teamInfo->getCount()),maxMember);
				teamTable->addData(0,row,buf);
			}
			teamTable->selectRow(selectRow);
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFukuUpdateMethod
//
/////////////////////////////////////////
crJXJUIFukuUpdateMethod::crJXJUIFukuUpdateMethod():
	m_this(NULL){}
crJXJUIFukuUpdateMethod::crJXJUIFukuUpdateMethod(const crJXJUIFukuUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_normalColor(handle.m_normalColor),
	m_overColor(handle.m_overColor),
	m_fuKuList(handle.m_fuKuList),
	m_coppercash(handle.m_coppercash),
	m_food(handle.m_food),
	m_wood(handle.m_wood),
	m_iron(handle.m_iron),
	m_horse(handle.m_horse),
	m_jueSeCanvas(handle.m_jueSeCanvas)
{
}
void crJXJUIFukuUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIFukuUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_fuKuList = str;
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_normalColor);
		m_normalColor /= 255.0f;
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_overColor);
		m_overColor /= 255.0f;
		break;
	case 3:
		m_coppercash = str;
		break;
	case 4:
		m_food = str;
		break;
	case 5:
		m_wood = str;
		break;
	case 6:
		m_iron = str;
		break;
	case 7:
		m_horse = str;
		break;
	case 8:
		m_jueSeCanvas = str;
		break;
	}
}

void crJXJUIFukuUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode> jueSeCanvas = crFilterRenderManager::getInstance()->findCanvas(m_jueSeCanvas);
	if(jueSeCanvas.valid() && myPlayer)
	{
		crData *Canvasdata = jueSeCanvas->getDataClass();
		crTableWidgetNode *fuKuList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_fuKuList));
		crStaticTextWidgetNode *coppercash = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_coppercash));
		crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_food));
		crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_wood));
		crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_iron));
		crStaticTextWidgetNode *horse = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horse));
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFukulv,param);
		unsigned char fukulv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());
		int nextlv = CRCore::minimum((int)fukulv + 1,maxlv);
		ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
		ref_ptr<crTableIO>resnameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResNameTab);
		crTableIO::StrVec record,recordn,recordf;
		fukutab->queryOneRecord(0,crArgumentParser::appItoa((int)fukulv),record);
		int foodlimitid = fukutab->getTitleIndex("粮食");
		int woodlimitid = fukutab->getTitleIndex("木材");
		int ironlimitid = fukutab->getTitleIndex("铁矿");
		int horselimitid = fukutab->getTitleIndex("马匹");
		
		fukutab->queryOneRecord(0,crArgumentParser::appItoa(nextlv),recordf);
		float fukulimitaddpercent = 0.0f;
		myPlayer->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
		int foodlimit = atoi(record[foodlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int woodlimit = atoi(record[woodlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int ironlimit = atoi(record[ironlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int horselimit = atoi(record[horselimitid].c_str()) * (1.0f + fukulimitaddpercent);
		////
		int nfoodlimit = atoi(recordf[foodlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int nwoodlimit = atoi(recordf[woodlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int nironlimit = atoi(recordf[ironlimitid].c_str()) * (1.0f + fukulimitaddpercent);
		int nhorselimit = atoi(recordf[horselimitid].c_str()) * (1.0f + fukulimitaddpercent);
		if(fuKuList)
		{
			fuKuList->clearData();

			data->getParam(WCHDATA_JXJCoppercash,param);
			int curcoppercash = *(int *)param;
			coppercash->setString(crArgumentParser::appItoa(curcoppercash));
			coppercash->setColor(m_normalColor);
			data->getParam(WCHDATA_JXJFood,param);
			int curfood = *(int *)param;
			food->setString(crArgumentParser::appItoa(curfood));
			food->setColor(curfood>=foodlimit?m_overColor:m_normalColor);
			data->getParam(WCHDATA_JXJWood,param);
			int curwood = *(int *)param;
			wood->setString(crArgumentParser::appItoa(curwood));
			wood->setColor(curwood>=woodlimit?m_overColor:m_normalColor);
			data->getParam(WCHDATA_JXJIron,param);
			int curiron = *(int *)param;
			iron->setString(crArgumentParser::appItoa(curiron));
			iron->setColor(curiron>=ironlimit?m_overColor:m_normalColor);
			data->getParam(WCHDATA_JXJHorse,param);
			int curhorse = *(int *)param;
			horse->setString(crArgumentParser::appItoa(curhorse));
			horse->setColor(curhorse>=horselimit?m_overColor:m_normalColor);
			//std::string xiancun[5] = {crArgumentParser::appItoa(curcoppercash),crArgumentParser::appItoa(curfood),crArgumentParser::appItoa(curwood),crArgumentParser::appItoa(curiron),crArgumentParser::appItoa(curhorse)};
			int row = 0;
			int namepid = WCHDATA_JXJCoppercash;
			int nameid = resnameTab->getTitleIndex("name");
			Canvasdata->getParam(WCHDATA_JXJProFoodProduct,param);
			int foodpro = *(int *)param;
			Canvasdata->getParam(WCHDATA_JXJProWoodProduct,param);
			int woodpro = *(int *)param;
			Canvasdata->getParam(WCHDATA_JXJProIronProduct,param);
			int ironpro = *(int *)param;
			Canvasdata->getParam(WCHDATA_JXJProHorseProduct,param);
			int horsepro = *(int *)param;
			std::string dangqian[5] = {"无",crArgumentParser::appItoa(foodpro),crArgumentParser::appItoa(woodpro),crArgumentParser::appItoa(ironpro),crArgumentParser::appItoa(horsepro)};
			std::string dangqianlimit[5] = {"无",crArgumentParser::appItoa(foodlimit),crArgumentParser::appItoa(woodlimit),crArgumentParser::appItoa(ironlimit),crArgumentParser::appItoa(horselimit)};
			std::string nextlvlimit[5] = {"无",crArgumentParser::appItoa(nfoodlimit),crArgumentParser::appItoa(nwoodlimit),crArgumentParser::appItoa(nironlimit),crArgumentParser::appItoa(nhorselimit)};
			for( int i = 0;i <= 4;++i,row++ )
			{
				resnameTab->queryOneRecord(0,crArgumentParser::appItoa(namepid),recordn);
				namepid++;
				fuKuList->addData(0,row,recordn[nameid]);
				fuKuList->addData(1,row,dangqian[row]);

				//fuKuList->addData(2,row,xiancun[row]);
				//fuKuList->setColor(?m_overColor:m_normalColor);
				if (0 == row)
				{
					fuKuList->addData(2,row,"无上限");
				}
				else
				{
					fuKuList->addData(2,row,dangqianlimit[row]);
				}
				if((int)fukulv != nextlv)
				{
					if (0 == row)
					{
						fuKuList->addData(3,row,"无上限");
					}
					else
					{
						fuKuList->addData(3,row,nextlvlimit[row]);
					}
				}
				else 
				{
					if (0 == row)
					{
						fuKuList->addData(3,row,"无上限");
					}
					else
					{
						fuKuList->addData(3,row,dangqianlimit[row]);
					}
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJJiangkaTimerMethod
////
///////////////////////////////////////////
//crJXJJiangkaTimerMethod::crJXJJiangkaTimerMethod():
//	m_dt(0)
//{
//}
//crJXJJiangkaTimerMethod::crJXJJiangkaTimerMethod(const crJXJJiangkaTimerMethod& handle):
//	crMethod(handle),
//	m_dt(handle.m_dt)
//{
//}
//void crJXJJiangkaTimerMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((int*)(LOINT64(param64)));
//		}
//		else
//		{
//			m_dt = 0;
//		}
//		break;
//	}
//}
//void crJXJJiangkaTimerMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJJiangkaTimerMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		int playerid = m_this->getPlayerID();
//		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//		if(playerData.valid())
//		{
//			ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//			crTableIO::DataVec jiangkaRec;
//			int attrid = itemTable->getTitleIndex("类型");
//			itemTable->queryRecords(attrid,crArgumentParser::appItoa(IT_Jiangka),jiangkaRec);
//			int jiangkaCount = jiangkaRec.size();
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			thisData->excHandle(MAKEINT64(WCH_LockData,1));
//			thisData->getParam(WCHDATA_JXJHalltimer,param);
//			short *hallTimer = (short *)param;
//			ref_ptr<crStreamBuf> stream = new crStreamBuf;
//			crPlayerDataEventPacket packet;
//			*hallTimer-=m_dt;
//			if(*hallTimer>-1)
//			{
//				stream->createBuf(2);
//				stream->_writeShort(*hallTimer);
//			}
//			else
//			{
//				*hallTimer = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJHallRefresh).c_str()));
//				stream->createBuf(22);
//				stream->_writeShort(*hallTimer);
//				//hall将卡刷新，并通知客户端
//				//将卡刷新规则未定
//				thisData->getParam(WCHDATA_JXJHallCard,param);
//				int *hallJiangka = (int *)param;
//				int rnd;
//				CRCore::rangei r(0,jiangkaCount);
//				//for( int i = 0; i<5; ++i )
//				for( int i = 0; i<3; ++i )
//				{
//					rnd = r.get_random();
//					*(hallJiangka+i) = atoi(jiangkaRec[rnd][0].c_str());
//					stream->_writeInt(*(hallJiangka+i));
//				}
//			}
//			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvHallJiangka,stream.get());
//			gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//
//			thisData->getParam(WCHDATA_JXJPrivatetimer,param);
//			int *privateTimer = (int *)param;
//			*privateTimer-=m_dt;
//			if(*privateTimer>-1)
//			{
//				stream->createBuf(4);
//				stream->_writeInt(*privateTimer);
//			}
//			else
//			{
//				*privateTimer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPrivateRefresh).c_str());
//				stream->createBuf(16);
//				stream->_writeInt(*privateTimer);
//				//private将卡刷新，并通知客户端
//				//将卡刷新规则未定
//				thisData->getParam(WCHDATA_JXJPrivateCard,param);
//				int *privateJiangka = (int *)param;
//				int rnd;
//				CRCore::rangei r(0,jiangkaCount);
//				for( int i = 0; i<3; ++i )
//				{
//					rnd = r.get_random();
//					*(privateJiangka+i) = atoi(jiangkaRec[rnd][0].c_str());
//					stream->_writeInt(*(privateJiangka+i));
//				}
//			}
//			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPrivateJiangka,stream.get());
//			gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			thisData->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvHallJiangkaMethod
////
///////////////////////////////////////////
//crJXJRecvHallJiangkaMethod::crJXJRecvHallJiangkaMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvHallJiangkaMethod::crJXJRecvHallJiangkaMethod(const crJXJRecvHallJiangkaMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvHallJiangkaMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvHallJiangkaMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvHallJiangkaMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameClient_Game)
//		{
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			short hallTimer = m_stream->_readShort();
//			//thisData->getParam(WCHDATA_JXJHalltimer,param);
//			//int nowtimer = *(int *)param;
//			//if (nowtimer + 10 < hallTimer)
//			//{
//				thisData->inputParam(WCHDATA_JXJHalltimer,&hallTimer);
//			//}
//			if(!m_stream->eof())
//			{
//				thisData->excHandle(MAKEINT64(WCH_LockData,1));
//				thisData->getParam(WCHDATA_JXJHallCard,param);
//				int *hallJiangka = (int *)param;
//				for(int i = 0; i<5; i++)
//				{
//					*(hallJiangka+i) = m_stream->_readInt();
//				}
//				thisData->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvPrivateJiangkaMethod
////
///////////////////////////////////////////
//crJXJRecvPrivateJiangkaMethod::crJXJRecvPrivateJiangkaMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvPrivateJiangkaMethod::crJXJRecvPrivateJiangkaMethod(const crJXJRecvPrivateJiangkaMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvPrivateJiangkaMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvPrivateJiangkaMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvPrivateJiangkaMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameClient_Game)
//		{
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			int privateTimer = m_stream->_readInt();
//			//thisData->getParam(WCHDATA_JXJPrivatetimer,param);
//			//int nowtimer = *(int *)param;
//			//if (nowtimer + 10 < privateTimer)
//			//{
//				thisData->inputParam(WCHDATA_JXJPrivatetimer,&privateTimer);
//			//}
//			if(!m_stream->eof())
//			{
//				thisData->excHandle(MAKEINT64(WCH_LockData,1));
//				thisData->getParam(WCHDATA_JXJPrivateCard,param);
//				int *privateJiangka = (int *)param;
//				for(int i = 0; i<3; i++)
//				{
//					*(privateJiangka+i) = m_stream->_readInt();
//				}
//				thisData->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIJiushiUpdateMethod
//
/////////////////////////////////////////
//crJXJUIJiushiUpdateMethod::crJXJUIJiushiUpdateMethod():
//	m_this(NULL)
//{}
//crJXJUIJiushiUpdateMethod::crJXJUIJiushiUpdateMethod(const crJXJUIJiushiUpdateMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_tavernRaido(handle.m_tavernRaido),
//	m_tavernRoom(handle.m_tavernRoom),
//	m_input(handle.m_input),
//	m_luckybtn(handle.m_luckybtn),
//	m_zhitianming(handle.m_zhitianming)
//	//m_card1(handle.m_card1),
//	//m_card2(handle.m_card2),
//	//m_card3(handle.m_card3),
//	//m_card4(handle.m_card4),
//	//m_card5(handle.m_card5),
//	//m_cardBtn1(handle.m_cardBtn1),
//	//m_cardBtn2(handle.m_cardBtn2),
//	//m_cardBtn3(handle.m_cardBtn3),
//	//m_cardBtn4(handle.m_cardBtn4),
//	//m_cardBtn5(handle.m_cardBtn5),
//	//m_pcard1(handle.m_pcard1),
//	//m_pcard2(handle.m_pcard2),
//	//m_pcard3(handle.m_card3),
//	//m_pcardBtn1(handle.m_pcardBtn1),
//	//m_pcardBtn2(handle.m_pcardBtn2),
//	//m_pcardBtn3(handle.m_pcardBtn3),
//	//m_timer(handle.m_timer),
//	//m_coppercashRefresh(handle.m_coppercashRefresh),
//	//m_goldingotRefresh(handle.m_goldingotRefresh)
//{
//}
//void crJXJUIJiushiUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//
//void crJXJUIJiushiUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_tavernRaido = str;
//		break;
//	case 1:
//		m_tavernRoom = str;
//		break;
//	case 2:
//		m_input = str;
//		break;
//	case 3:
//		m_luckybtn = str;
//		break;
//	case 4:
//		m_zhitianming = str;
//		break;
//	//case 2:
//	//	m_card1 = str;
//	//	break;
//	//case 3:
//	//	m_card2 = str;
//	//	break;
//	//case 4:
//	//	m_card3 = str;
//	//	break;
//	//case 5:
//	//	m_card4 = str;
//	//	break;
//	//case 6:
//	//	m_card5 = str;
//	//	break;
//	//case 7:
//	//	m_cardBtn1 = str;
//	//	break;
//	//case 8:
//	//	m_cardBtn2 = str;
//	//	break;
//	//case 9:
//	//	m_cardBtn3 = str;
//	//	break;
//	//case 10:
//	//	m_cardBtn4 = str;
//	//	break;
//	//case 11:
//	//	m_cardBtn5 = str;
//	//	break;
//	//case 12:
//	//	m_pcard1 = str;
//	//	break;
//	//case 13:
//	//	m_pcard2 = str;
//	//	break;
//	//case 14:
//	//	m_pcard3 = str;
//	//	break;
//	//case 15:
//	//	m_pcardBtn1 = str;
//	//	break;
//	//case 16:
//	//	m_pcardBtn2 = str;
//	//	break;
//	//case 17:
//	//	m_pcardBtn3 = str;
//	//	break;
//	//case 18:
//	//	m_timer = str;
//	//	break;
//	//case 19:
//	//	m_coppercashRefresh = str;
//	//	break;
//	//case 20:
//	//	m_goldingotRefresh = str;
//	//	break;
//	}
//}
//
//void crJXJUIJiushiUpdateMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && myPlayer)
//	{
//		crRadioGroupWidgetNode *tavernRaido = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_tavernRaido));
//		crMultiSwitch *tavernRoom = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_tavernRoom));
//		crStaticTextWidgetNode *input = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input));
//		crButtonWidgetNode *luckybtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_luckybtn));
//		crButtonWidgetNode *zhitianming = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_zhitianming));
//		//crImageBoxWidgetNode *card[5],*pcard[3];
//		//crButtonWidgetNode *cardBtn[5],*pcardBtn[3];
//		//card[0] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_card1));
//		//card[1] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_card2));
//		//card[2] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_card3));
//		//card[3] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_card4));
//		//card[4] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_card5));
//		//cardBtn[0] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cardBtn1));
//		//cardBtn[1] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cardBtn2));
//		//cardBtn[2] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cardBtn3));
//		//cardBtn[3] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cardBtn4));
//		//cardBtn[4] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cardBtn5));
//		//pcard[0] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_pcard1));
//		//pcard[1] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_pcard2));
//		//pcard[2] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_pcard3));
//		//pcardBtn[0] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pcardBtn1));
//		//pcardBtn[1] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pcardBtn2));
//		//pcardBtn[2] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pcardBtn3));
//		//crStaticTextWidgetNode *timer = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timer));
//		//crButtonWidgetNode *coppercashRefresh = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_coppercashRefresh));
//		//crButtonWidgetNode *goldingotRefresh = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_goldingotRefresh));
//
//		//ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//		//int iconid = itemTable->getTitleIndex("icon");
//		//crTableIO::StrVec record;
//		void *param;
//		crData *jiusidata = m_this->getDataClass();
//		jiusidata->getParam(WCHDATA_JXJLuckyCardStep,param);
//		int step = *(int *)param;
//		if (zhitianming->getEnable())
//		{
//			if (step == 0)
//			{
//				zhitianming->setEnable(true);
//			}
//			else
//			{
//				zhitianming->setEnable(false);
//			}
//		}
//		ref_ptr<crTableIO>LuckyCardCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLuckyCardCostTab);
//		int copperindex = LuckyCardCostTab->getTitleIndex("铜钱");
//		int goldindex = LuckyCardCostTab->getTitleIndex("元宝");
//		crTableIO::StrVec record;
//		crData *data = myPlayer->getDataClass();	
//		int select = tavernRaido->getSelect();
//		if(tavernRoom)tavernRoom->setActiveSwitchSet(select);
//		if (select == 0)
//		{
//			data->getParam(WCHDATA_JXJLuckyCardCopperCost,param);
//			unsigned char coppercost = *(unsigned char *)param;
//			data->getParam(WCHDATA_JXJCoppercash,param);
//			int mycopper = *(int *)param;
//			if(LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(coppercost),record)>=0)
//			{
//				if(input)input->setString("消耗铜钱："+record[copperindex]);
//				int needcopper = atoi(record[copperindex].c_str());
//				if (mycopper >= needcopper)
//				{
//					if(luckybtn)luckybtn->setEnable(true);
//				}
//				else
//				{
//					if(luckybtn)luckybtn->setEnable(false);
//				}
//			}
//		}
//		else
//		{
//			data->getParam(WCHDATA_JXJLuckyCardGoldCost,param);
//			unsigned char goldcost = *(unsigned char *)param;
//			data->getParam(WCHDATA_JXJGoldingot,param);
//			int mygold = *(int*)param;
//			data->getParam(WCHDATA_JXJGiftGold,param);
//			int giftgold = *(int*)param;
//			mygold += giftgold;
//			if(LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(goldcost),record)>=0)
//			{
//				if(input)input->setString("消耗元宝："+record[goldindex]);
//				int needgold = atoi(record[goldindex].c_str());
//				if (mygold >= needgold)
//				{
//					if(luckybtn)luckybtn->setEnable(true);
//				}
//				else
//				{
//					if(luckybtn)luckybtn->setEnable(false);
//				}
//			}
//		}
		//if(coppercashRefresh)coppercashRefresh->setVisiable(select==0);
		//if(goldingotRefresh)goldingotRefresh->setVisiable(select==1);
		//void *param;
		//crData *data = myPlayer->getDataClass();
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//int times,t;
		//int hour,minute,s;
		//if(select == 0)
		//{
		//	for( int i=0; i<3; i++)
		//	{
		//		pcard[i]->setVisiable(false);
		//		pcardBtn[i]->setVisiable(false);
		//	}
		//	data->getParam(WCHDATA_JXJHallCard,param);
		//	int *hallCard = (int *)param;
		//	int cardid;
		//	for( int i = 0; i<5; i++)
		//	{
		//		cardid = *(hallCard+i);
		//		if(cardid == 0)
		//		{
		//			card[i]->setVisiable(false);
		//			cardBtn[i]->setVisiable(false);
		//		}
		//		else
		//		{
		//			card[i]->setVisiable(true);
		//			cardBtn[i]->setVisiable(true);
		//			itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record);
		//			card[i]->setImageName(record[iconid]);
		//		}
		//	}

		//	data->getParam(WCHDATA_JXJHalltimer,param);
		//	short *jiangkaTimer = (short *)param;
		//	*jiangkaTimer -= 1;
		//	times = *jiangkaTimer;
		//}
		//else
		//{
		//	for( int i=0; i<5; i++)
		//	{
		//		card[i]->setVisiable(false);
		//		cardBtn[i]->setVisiable(false);
		//	}
		//	data->getParam(WCHDATA_JXJPrivateCard,param);
		//	int *privateCard = (int *)param;
		//	int cardid;
		//	for( int i = 0; i<3; i++)
		//	{
		//		cardid = *(privateCard+i);
		//		if(cardid == 0)
		//		{
		//			pcard[i]->setVisiable(false);
		//			pcardBtn[i]->setVisiable(false);
		//		}
		//		else
		//		{
		//			pcard[i]->setVisiable(true);
		//			pcardBtn[i]->setVisiable(true);
		//			itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record);
		//			pcard[i]->setImageName(record[iconid]);
		//		}
		//	}

		//	data->getParam(WCHDATA_JXJPrivatetimer,param);
		//	short *jiangkaTimer = (short *)param;
		//	*jiangkaTimer -= 1;
		//	times = *jiangkaTimer;
		//}
		//hour = times/3600;
		//t = times%3600;
		//minute = t/60;
		//s = t%60;
		//timer->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
		//data->excHandle(MAKEINT64(WCH_LockData,0));

		//crRole *mainRole = myPlayer->getMainRole();
		//crData *roleData = mainRole->getDataClass();
		//roleData->excHandle(MAKEINT64(WCH_LockData,1));
		//roleData->getParam(WCHDATA_BackPackMap,param);
		//CRNetApp::BackPackMap *backPackMap = (CRNetApp::BackPackMap *)param;
		//int jiangkacount = 0;
		//crItemChild *itemchild;
		//crInstanceItem *item;
		//crData *itemData;
		//unsigned char itemtype;
		//for( BackPackMap::iterator itr = backPackMap->begin();
		//	itr != backPackMap->end();
		//	++itr )
		//{
		//	if(itr->second!=0)
		//	{
		//		itemchild = mainRole->findChildItem(itr->second);
		//		if(itemchild)
		//		{
		//			item = itemchild->getInstanceItem();
		//			itemData = item->getDataClass();
		//			if(!itemData)
		//				continue;
		//			itemData->getParam(WCHDATA_JXJItemType,param);
		//			if(param)
		//			{
		//				itemtype = *(unsigned char *)param;
		//				if(itemtype == IT_Jiangka)
		//				{
		//					jiangkacount++;
		//				}
		//			}
		//		}
		//	}
		//}
		//roleData->excHandle(MAKEINT64(WCH_LockData,0));	
//	}
//}
///////////////////////////////////////////
////
////crJXJLevyTimerMethod
////
///////////////////////////////////////////
//crJXJLevyTimerMethod::crJXJLevyTimerMethod():
//	m_dt(0),
//	m_sec(0)
//{
//}
//crJXJLevyTimerMethod::crJXJLevyTimerMethod(const crJXJLevyTimerMethod& handle):
//	crMethod(handle),
//	m_dt(handle.m_dt),
//	m_sec(handle.m_sec)
//{
//}
//void crJXJLevyTimerMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((int*)(LOINT64(param64)));
//			m_sec = HIINT64(param64);
//		}
//		else
//		{
//			m_dt = 0;
//			m_sec = 0;
//		}
//		break;
//	}
//}
//void crJXJLevyTimerMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJLevyTimerMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		int playerid = m_this->getPlayerID();
//		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//		if(playerData.valid())
//		{
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			thisData->excHandle(MAKEINT64(WCH_LockData,1));
//			thisData->getParam(WCHDATA_JXJLevyTimer,param);
//			int *levyTimer = (int *)param;
//			*levyTimer-=m_dt;
//			if(*levyTimer<=0)
//			{
//				*levyTimer = m_sec;
//				//*levyTimer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyRefresh).c_str());
//				thisData->getParam(WCHDATA_JXJLevyCount,param);
//				char *levycount = (char *)param;
//				*levycount = (char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount).c_str()));
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(1);
//				stream->_writeChar(*levycount);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvLevyCount,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//			thisData->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJRecvZeroRefreshMethod
//
/////////////////////////////////////////
crJXJRecvZeroRefreshMethod::crJXJRecvZeroRefreshMethod():
	m_netType(GameClient_Game){}
crJXJRecvZeroRefreshMethod::crJXJRecvZeroRefreshMethod(const crJXJRecvZeroRefreshMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvZeroRefreshMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvZeroRefreshMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvZeroRefreshMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			unsigned char levycount = m_stream->_readUChar();
			unsigned char giftcount = m_stream->_readUChar();
			unsigned char junlingcount = m_stream->_readUChar();
			_crInt64 t = m_stream->_readInt64();
			unsigned char fubendeqsize = m_stream->_readUChar();
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_JXJLevyCount,&levycount);
			//在线时长清零
			data->inputParam(WCHDATA_JXJOnlineTimer,NULL);
			//每日死亡数清零
			data->inputParam(WCHDATA_JXJDayPlayerDeadCount,NULL);
			data->inputParam(WCHDATA_JXJDayKillPlayerCount,NULL);
			data->inputParam(WCHDATA_JXJDayKillNPCCount,NULL);
			data->inputParam(WCHDATA_JXJDayKillEachTroops,NULL);

			//data->inputParam(WCHDATA_JXJLuckyCardCopperCost,0);
			//data->inputParam(WCHDATA_JXJLuckyCardGoldCost,0);
			//data->inputParam(WCHDATA_JXJKnowLuckyCard,0);
			data->inputParam(WCHDATA_JXJOnlineRewardCount,&giftcount);
			data->inputParam(WCHDATA_JXJOnlineRewardTimer,&t);
			data->inputParam(WCHDATA_JXJBuyJunlingCount,&junlingcount);
			data->inputParam(WCHDATA_MarketBuyResourceCount,0);
			data->inputParam(WCHDATA_JXJBuyJunlingTimer, 0);
			data->inputParam(WCHDATA_JXJLingqufengluFlag, 0);
			bool hadwon = false;
			data->inputParam(WCHDATA_JXJHadWonJunTuanFBT,&hadwon);
			unsigned char spreftimes = 0;
			data->inputParam(WCHDATA_JXJSpecialtyRefreshTimes,&spreftimes);
			ref_ptr<crTableIO> olRewardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJOnlineRewardTab);
			if(giftcount>=1 && olRewardTab.valid())
			{
				crTableIO::StrVec record;
				time_t now = time(0);
				int olineRewardTimer = 0;
				int timerIndex = olRewardTab->getTitleIndex("timer");
				if(olRewardTab->queryOneRecord(0,crArgumentParser::appItoa(giftcount),record)>=0)
				{
					if(timerIndex>=0)
					{
						olineRewardTimer = atoi(record[timerIndex].c_str());
						if(olineRewardTimer>now-t)
						{
							int onlineRewardTime = olineRewardTimer+t-now;
							data->inputParam(WCHDATA_JXJPlayerOnlineRewardTimer,&onlineRewardTime);							
						}
					}
				}
			}
		
			
			//重置黄钻每日礼包
			data->getParam(WCHDATA_JXJYELLOWAWARDINFO,param);
			int yellowInfo = *(int*)param &0xffff;
			data->inputParam(WCHDATA_JXJYELLOWAWARDINFO,&yellowInfo);

			//重置每日市集购买次数
			unsigned char count = 1;
			data->inputParam(WCHDATA_JXJBuyResourceCount,&count);
			data->getParam(WCHDATA_JXJShijilv,param);
			unsigned char shijilv = *(unsigned char *)param;
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int freeLevel = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMarketFreeBuyLevel,viplv).c_str());
			if (shijilv >= freeLevel)
			{
				data->inputParam(WCHDATA_JXJFreeBuyInfo,0);
			}
			//重置国家建设次数
			char buildcountrytimes = (char)atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJVipBuildCountryTimes,viplv).c_str());
			data->inputParam(WCHDATA_JXJBuildCountryTimes,&buildcountrytimes);
			//重置元宝补兵次数
			data->inputParam(WCHDATA_JXJGoldRecruitCount,0);
			//重置节日活动窗口自动显示记录
			bool hadShowFestivalCanvas = false;
			data->inputParam(WCHDATA_JXJHadShowFestivalHuodongCanvas, &hadShowFestivalCanvas);

			data->getParam(WCHDATA_JXJFubenProgressMap,param);
			FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
			FubenProgressMap::iterator itr;
			for (int i = 0; i < fubendeqsize; i++)
			{
				itr = fubenProgress->find(m_stream->_readUShort());
				if (itr != fubenProgress->end())
				{
					itr->second->setComplete(1);
				}
			}
			unsigned char freeCount = m_stream->_readUChar();
			data->inputParam(WCHDATA_JXJFreeCounterinsurgencyCount,&freeCount);

			unsigned short seriesDays = m_stream->_readUShort();
			unsigned char rewardCount = m_stream->_readUChar();
			unsigned short loginDays = m_stream->_readUShort();
			data->inputParam(WCHDATA_JXJPlayerLoginDays,&loginDays);
			data->inputParam(WCHDATA_JXJSeriesLandDay,&seriesDays);
			data->inputParam(WCHDATA_JXJLandRewardGetCount, &rewardCount);
			int jifen = 0;
			data->inputParam(WCHDATA_JXJGuoZhanJiFen,&jifen);
			//活跃度重置
			if (m_this->getMainRole())
			{
				crData *mainroledata = m_this->getMainRole()->getDataClass();
				mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
				mainroledata->getParam(WCHDATA_JXJHuoyueduMap, param);
				HuoyueduMap *huoyuedumap = (HuoyueduMap *)param;
				mainroledata->getParam(WCHDATA_JXJHuoyueduRewardSet, param);
				HuoyueduRewardSet *huoyuedurewardset = (HuoyueduRewardSet *)param;
				huoyuedurewardset->clear();
				for (HuoyueduMap::iterator hyditr = huoyuedumap->begin();
					hyditr != huoyuedumap->end();
					++hyditr)
				{
					//if (hyditr->first != HYD_Vip)
					//{
						hyditr->second->setStep(0);
						hyditr->second->setComplete(false);
					//}
				}
				mainroledata->excHandle(MAKEINT64(WCH_LockData,0));
			}

			//日常任务和周常任务刷新
			bool isZhouRefrech = m_stream->_readBool();
			bool recommendSet = m_stream->_readBool();
			data->inputParam(WCHDATA_JXJCountryRecommendSet, &recommendSet);
			crRole *mainRole = m_this->getMainRole();
			if (mainRole)
			{
				crData *mainroledata = mainRole->getDataClass();
				mainroledata->inputParam(WCHDATA_JXJQiyuTaskID,NULL);
				crData *myMetierData = mainRole->getMetierDataClass();
				if (myMetierData)
				{
					myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
					myMetierData->getParam(WCHDATA_GameTaskMap,param);
					GameTaskMap *gameTaskMap = (GameTaskMap *)param;
					if (gameTaskMap)
					{
						ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
						int taskidindex = tasktitletab->getTitleIndex("taskid");
						crTableIO::StrVec record;
						for( GameTaskMap::iterator itr = gameTaskMap->begin();itr != gameTaskMap->end();++itr )
						{
							int renwutype = 0;
							if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(itr->second->getTaskID()),record) >= 0)
							{
								renwutype = atoi(record[0].c_str());
								if(renwutype == 4 || renwutype == 8)
									itr->second->resetTask();

								if(isZhouRefrech && renwutype == 5)
									itr->second->resetTask();
							}
						}
					}
					myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}

			//每日目标刷新
			unsigned char continuedayC = m_stream->_readUChar();
			bool check = true;
			data->inputParam(WCHDATA_JXJIsCheckHuoYueDuSign,&check);
			data->inputParam(WCHDATA_JXJFinishHuoYueDuDayCount,&continuedayC);

			//世界战场玩家领取活动奖励次数刷新
			unsigned char gettimes = 0;
			data->inputParam(WCHDATA_JXJAmHuoDongGetTimes,&gettimes);
			data->inputParam(WCHDATA_JXJAmHuoDongGetTimes+1,&gettimes);
			data->inputParam(WCHDATA_JXJAmHuoDongGetTimes+2,&gettimes);

			//征战商店每日购买上限刷新
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJBuyShangXianMap,param);
			std::map<int,unsigned char> *buyshangxianmap = (std::map<int,unsigned char>*)param;
			buyshangxianmap->clear();
			
			crVector3i foreignCard = m_stream->_readVec3i();
			data->inputParam(WCHDATA_JXJForeignCard, &foreignCard);

			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvMainroleZeroRefreshMethod
////
///////////////////////////////////////////
//crJXJRecvMainroleZeroRefreshMethod::crJXJRecvMainroleZeroRefreshMethod() :
//m_netType(GameClient_Game){}
//crJXJRecvMainroleZeroRefreshMethod::crJXJRecvMainroleZeroRefreshMethod(const crJXJRecvMainroleZeroRefreshMethod& handle) :
//crMethod(handle)
//{
//}
//void crJXJRecvMainroleZeroRefreshMethod::inputParam(int i, void *param)
//{
//	switch (i)
//	{
//	case 0:
//		if (param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if (param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvMainroleZeroRefreshMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvMainroleZeroRefreshMethod::operator()(crHandle &handle)
//{
//	if (m_this && m_stream.valid())
//	{
//		if (m_netType == GameClient_Game)
//		{
//			void *param;
//			//活跃度重置
//			if (m_this->getMainRole())
//			{
//				crData *mainroledata = m_this->getMainRole()->getDataClass();
//				mainroledata->getParam(WCHDATA_JXJHuoyueduMap, param);
//				HuoyueduMap *huoyuedumap = (HuoyueduMap *)param;
//				mainroledata->getParam(WCHDATA_JXJHuoyueduRewardSet, param);
//				HuoyueduRewardSet *huoyuedurewardset = (HuoyueduRewardSet *)param;
//				huoyuedurewardset->clear();
//				for (HuoyueduMap::iterator hyditr = huoyuedumap->begin();
//					hyditr != huoyuedumap->end();
//					++hyditr)
//				{
//					//if (hyditr->first != HYD_Vip)
//					//{
//						hyditr->second->setStep(0);
//						hyditr->second->setComplete(false);
//					//}
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJOnlineRewardTimerMethod
//
/////////////////////////////////////////
// crJXJOnlineRewardTimerMethod::crJXJOnlineRewardTimerMethod():
// 	m_dt(0)
// {
// }
// crJXJOnlineRewardTimerMethod::crJXJOnlineRewardTimerMethod(const crJXJOnlineRewardTimerMethod& handle):
// 	crMethod(handle),
// 	m_dt(handle.m_dt)
// {
// }
// void crJXJOnlineRewardTimerMethod::inputParam(int i, void *param)
// {
// 	switch(i) 
// 	{
// 	case 0:
// 		if(param == 0)
// 		{//释放
// 			m_this = NULL;
// 		}
// 		break;
// 	case 1:
// 		m_this = (crPlayerGameData*)param;
// 		break;
// 	case 2:
// 		if(param)
// 		{
// 			_crInt64 param64 = *(_crInt64*)param;
// 			m_dt = *((int*)(LOINT64(param64)));
// 		}
// 		else
// 		{
// 			m_dt = 0;
// 		}
// 		break;
// 	}
// }
// void crJXJOnlineRewardTimerMethod::addParam(int i, const std::string& str)
// {
// }
// void crJXJOnlineRewardTimerMethod::operator()(crHandle &handle)
// {
// 	if(m_this)
// 	{
// 		int playerid = m_this->getPlayerID();
// 		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
// 		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
// 		if(playerData.valid())
// 		{
// 			void *param;
// 			crData *thisData = m_this->getDataClass();
// 			thisData->excHandle(MAKEINT64(WCH_LockData,1));
// 			thisData->getParam(WCHDATA_JXJOnlineRewardTimer,param);
// 			_crInt64 *rewardTimer = (_crInt64 *)param;
// 			*rewardTimer-=m_dt;
// 			if(*rewardTimer<=0)
// 			{
// 				*rewardTimer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOnlineRewardRefresh).c_str());
// 				thisData->getParam(WCHDATA_JXJOnlineRewardCount,param);
// 				unsigned char *olcount = (unsigned char *)param;
// 				*olcount = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxOnlineRewardCount).c_str()));
// 				ref_ptr<crStreamBuf> stream = new crStreamBuf;
// 				stream->createBuf(1);
// 				stream->_writeUChar(*olcount);
// 				crPlayerDataEventPacket packet;
// 				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvOnlineRewardCount,stream.get());
// 				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
// 			}
// 			thisData->excHandle(MAKEINT64(WCH_LockData,0));
// 		}
// 	}
// }
/////////////////////////////////////////
//
//crJXJRecvOnlineRewardCountMethod
//
/////////////////////////////////////////
// crJXJRecvOnlineRewardCountMethod::crJXJRecvOnlineRewardCountMethod():
// 	m_netType(GameClient_Game){}
// crJXJRecvOnlineRewardCountMethod::crJXJRecvOnlineRewardCountMethod(const crJXJRecvOnlineRewardCountMethod& handle):
// 	crMethod(handle)
// {
// }
// void crJXJRecvOnlineRewardCountMethod::inputParam(int i, void *param)
// {
// 	switch(i) 
// 	{
// 	case 0:
// 		if(param == 0)
// 		{//释放
// 			m_this = NULL;
// 			m_stream = NULL;
// 		}
// 		break;
// 	case 1:
// 		m_this = (crPlayerGameData*)param;
// 		break;
// 	case 2:
// 		if(param)
// 		{
// 			_crInt64 param64 = *(_crInt64*)param;
// 			m_stream = (crStreamBuf *)(LOINT64(param64));
// 			m_netType = HIINT64(param64);
// 		}
// 		else
// 		{
// 			m_stream = NULL;
// 		}
// 		break;
// 	}
// }
// 
// void crJXJRecvOnlineRewardCountMethod::addParam(int i, const std::string& str)
// {
// }
// 
// void crJXJRecvOnlineRewardCountMethod::operator()(crHandle &handle)
// {
// 	if(m_this && m_stream.valid())
// 	{
// 		if(m_netType == GameClient_Game)
// 		{
// 			crData *thisData = m_this->getDataClass();
// 			unsigned char olcount = m_stream->_readUChar();
// 			//thisData->inputParam(WCHDATA_JXJOnlineRewardCount,&olcount);
// 		}
// 	}
// }
///////////////////////////////////////////
////
////crJXJBuyJunlingTimerMethod
////
///////////////////////////////////////////
//crJXJBuyJunlingTimerMethod::crJXJBuyJunlingTimerMethod():
//	m_dt(0),
//	m_sec(0)
//{
//}
//crJXJBuyJunlingTimerMethod::crJXJBuyJunlingTimerMethod(const crJXJBuyJunlingTimerMethod& handle):
//	crMethod(handle),
//	m_dt(handle.m_dt),
//	m_sec(handle.m_sec)
//{
//}
//void crJXJBuyJunlingTimerMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_dt = *((int*)(LOINT64(param64)));
//			m_sec = HIINT64(param64);
//		}
//		else
//		{
//			m_dt = 0;
//			m_sec = 0;
//		}
//		break;
//	}
//}
//void crJXJBuyJunlingTimerMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJBuyJunlingTimerMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		int playerid = m_this->getPlayerID();
//		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//		if(playerData.valid())
//		{
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			thisData->excHandle(MAKEINT64(WCH_LockData,1));
//			thisData->getParam(WCHDATA_JXJBuyJunlingTimer,param);
//			int *timer = (int *)param;
//			*timer-=m_dt;
//			if(*timer<=0)
//			{
//				*timer = m_sec;
//				//*timer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJunlingRefresh).c_str());
//				thisData->getParam(WCHDATA_JXJBuyJunlingCount,param);
//				unsigned char *count = (unsigned char *)param;
//				*count = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunlingBuyCount).c_str()));
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(1);
//				stream->_writeUChar(*count);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuyJunlingCount,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//			thisData->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvBuyJunlingCountMethod
////
///////////////////////////////////////////
//crJXJRecvBuyJunlingCountMethod::crJXJRecvBuyJunlingCountMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvBuyJunlingCountMethod::crJXJRecvBuyJunlingCountMethod(const crJXJRecvBuyJunlingCountMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvBuyJunlingCountMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvBuyJunlingCountMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvBuyJunlingCountMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameClient_Game)
//		{
//			crData *thisData = m_this->getDataClass();
//			unsigned char count = m_stream->_readUChar();
//			thisData->inputParam(WCHDATA_JXJBuyJunlingCount,&count);
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIRevenueUpdateMethod
//
/////////////////////////////////////////
crJXJUIRevenueUpdateMethod::crJXJUIRevenueUpdateMethod():
	m_this(NULL){}
crJXJUIRevenueUpdateMethod::crJXJUIRevenueUpdateMethod(const crJXJUIRevenueUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_mingjuCount(handle.m_mingjuCount),
	m_populations(handle.m_populations),
	m_coppercash(handle.m_coppercash),
	m_revenueCount(handle.m_revenueCount),
	m_levy(handle.m_levy),
	m_impress(handle.m_impress)
{
}
void crJXJUIRevenueUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIRevenueUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mingjuCount = str;
		break;
	case 1:
		m_populations = str;
		break;
	case 2:
		m_coppercash = str;
		break;
	case 3:
		m_revenueCount = str;
		break;
	case 4:
		m_levy = str;
		break;
	case 5:
		m_impress = str;
		break;
	}
}

void crJXJUIRevenueUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		crStaticTextWidgetNode *mingjuCount = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_mingjuCount));
		crStaticTextWidgetNode *populations = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_populations));
		crStaticTextWidgetNode *coppercash = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_coppercash));
		crStaticTextWidgetNode *revenueCount = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_revenueCount));
		crButtonWidgetNode *levy = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_levy));
		crButtonWidgetNode *impress = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_impress));
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMingjulv,param);
		_crInt64 mingjulv = *(_crInt64*)param;
		_crInt32 lo32 = LOINT64(mingjulv);
		_crInt32 hi32 = HIINT64(mingjulv);
		_crInt16 lo16 = LOINT32(lo32);
		_crInt16 hi16 = HIINT32(lo32);
		unsigned char mingju[8];
		mingju[0] = (unsigned char)LOINT16(lo16);
		mingju[1] = (unsigned char)HIINT16(lo16);
		mingju[2] = (unsigned char)LOINT16(hi16);
		mingju[3] = (unsigned char)HIINT16(hi16);
		lo16 = LOINT32(hi32);
		hi16 = HIINT32(hi32);
		mingju[4] = (unsigned char)LOINT16(lo16);
		mingju[5] = (unsigned char)HIINT16(lo16);
		mingju[6] = (unsigned char)LOINT16(hi16);
		mingju[7] = (unsigned char)HIINT16(hi16);
		int count = 0;
		int popcount = 0;
		ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
		int index = resbuildingTab->getTitleIndex("人口");
		crTableIO::StrVec record;
		for( int i = 0; i<8; i++)
		{
			if(mingju[i]>0)
			{
				count++;
				resbuildingTab->queryOneRecord(0,crArgumentParser::appItoa(mingju[i]),record);
				popcount += atoi(record[index].c_str());
			}
		}
		mingjuCount->setString(crArgumentParser::appItoa(count));
		populations->setString(crArgumentParser::appItoa(popcount));
		data->getParam(WCHDATA_JXJFuyalv,param);
		unsigned char fuyalv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		float param1 = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyParam1,viplv).c_str());
		float param2 = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyParam2,viplv).c_str());
		float cash = (float)popcount * param1 + /*(int)fuyalv * */param2;
		///////////////////////////////增加税收
		float increase = 0.0f;
		myPlayer->doEvent(WCH_JXJGetRevenueIncrease,MAKEINT64(&increase,NULL));
		cash = floor((float)cash * (1.0f + increase));

		coppercash->setString(crArgumentParser::appItoa((int)cash));
		data->getParam(WCHDATA_JXJLevyCount,param);
		unsigned char levyCount = *(unsigned char *)param;
		crVector2i maxlevycount;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount,viplv).c_str(),maxlevycount);
		if(levyCount <= maxlevycount[LevyType_Gold])
		{
			revenueCount->setString(crArgumentParser::appItoa(levyCount));
			levy->setVisiable(false);
			impress->setVisiable(true);
			if(levyCount == 0)
				impress->setEnable(false);
			else
				impress->setEnable(true);
		}
		else
		{
			revenueCount->setString(crArgumentParser::appItoa(levyCount - maxlevycount[LevyType_Gold]));
			levy->setVisiable(true);
			impress->setVisiable(false);
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));	
	}
}
/////////////////////////////////////////
//
//crJXJLevyMethod
//
/////////////////////////////////////////
crJXJLevyMethod::crJXJLevyMethod(){}
crJXJLevyMethod::crJXJLevyMethod(const crJXJLevyMethod& handle):
	crMethod(handle)
{
}
void crJXJLevyMethod::inputParam(int i, void *param)
{
}

void crJXJLevyMethod::addParam(int i, const std::string& str)
{
}

void crJXJLevyMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJLevyCount,param);
		unsigned char levyCount = *(unsigned char *)param;
		crVector2i maxlevycount;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount,viplv).c_str(),maxlevycount);
		if(levyCount > maxlevycount[LevyType_Gold])
		{
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvLevy,NULL);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvLevyMethod
//
/////////////////////////////////////////
crJXJRecvLevyMethod::crJXJRecvLevyMethod():
	m_netType(GameClient_Game){}
crJXJRecvLevyMethod::crJXJRecvLevyMethod(const crJXJRecvLevyMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvLevyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvLevyMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvLevyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			bool canlevy = false;
			bool needdeductgold = false;
			char done = 0;
			void *param;
			crData *data = m_this->getDataClass();
			//data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJLevyCount,param);
			unsigned char levyCount = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			crVector2i maxlevycount;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount,viplv).c_str(),maxlevycount);
//			int *coppercash;
			if (levyCount > 0)
			{
				if(levyCount > maxlevycount[LevyType_Gold])
				{
					canlevy = true;
				}
				else
				{
					int impress = maxlevycount[LevyType_Gold] - levyCount + 1;
					ref_ptr<crTableIO>impressTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressTab);
					crTableIO::StrVec record;
					if(impressTab->queryOneRecord(0,crArgumentParser::appItoa(impress),record)>=0)
					{
						int goldneed = atoi(record[1].c_str());
						MoneyChangeData moneydata(goldneed,"强征");
						m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&moneydata,&needdeductgold));
						if (moneydata.first == 0)
						{
							canlevy = true;
						}
					}
				}
			}
			if(canlevy)
			{
				levyCount-=1;
				data->inputParam(WCHDATA_JXJLevyCount,&levyCount);
				data->getParam(WCHDATA_JXJMingjulv,param);
				_crInt64 mingjulv = *(_crInt64*)param;
				_crInt32 lo32 = LOINT64(mingjulv);
				_crInt32 hi32 = HIINT64(mingjulv);
				_crInt16 lo16 = LOINT32(lo32);
				_crInt16 hi16 = HIINT32(lo32);
				unsigned char mingju[8];
				mingju[0] = (unsigned char)LOINT16(lo16);
				mingju[1] = (unsigned char)HIINT16(lo16);
				mingju[2] = (unsigned char)LOINT16(hi16);
				mingju[3] = (unsigned char)HIINT16(hi16);
				lo16 = LOINT32(hi32);
				hi16 = HIINT32(hi32);
				mingju[4] = (unsigned char)LOINT16(lo16);
				mingju[5] = (unsigned char)HIINT16(lo16);
				mingju[6] = (unsigned char)LOINT16(hi16);
				mingju[7] = (unsigned char)HIINT16(hi16);
				int popcount = 0;
				ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
				int index = resbuildingTab->getTitleIndex("人口");
				crTableIO::StrVec record;
				for( int i = 0; i<8; i++)
				{
					if(mingju[i]>0)
					{
						resbuildingTab->queryOneRecord(0,crArgumentParser::appItoa(mingju[i]),record);
						popcount += atoi(record[index].c_str());
					}
				}
				data->getParam(WCHDATA_JXJFuyalv,param);
				unsigned char fuyalv = *(unsigned char *)param;
				float param1 = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyParam1,viplv).c_str());
				float param2 = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyParam2,viplv).c_str());
				float cash = (float)popcount * param1 + /*(int)fuyalv * */param2;

				///////////////////////////////增加税收
				float increase = 0.0f;
				m_this->doEvent(WCH_JXJGetRevenueIncrease,MAKEINT64(&increase,NULL));
				int cash1 = -(floor((float)cash * (1.0f + increase)));

				int cash2 = (int)cash;
				/////////////////////////////// vip 暴击
				m_this->doEvent(MAKEINT64(WCH_JXJVIPExtend, WCH_JXJVIPRevenues), MAKEINT64(&cash1, &cash2));

				m_this->doEvent(WCH_JXJDeductCopperCash,MAKEINT64(&cash1, NULL));
				//data->getParam(WCHDATA_JXJCoppercash,param);
				//coppercash = (int *)param;
				//if(*coppercash<(MAXUINT)-cash)
				//	*coppercash += cash;
				//else
				//	*coppercash = MAXUINT;
				done = 1;
				if (needdeductgold)
				{
					crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
					ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
					if(playerData.valid())
					{
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
						callback->savePlayerData(playerData.get());
					}
				}
			}
			//返回信息
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(2);
				stream->_writeChar(done);
				if(done==1)
				{
					stream->_writeUChar(levyCount);
					//stream->_writeInt(*coppercash);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvLevy,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			//data->excHandle(MAKEINT64(WCH_LockData,0));		
			if (done == 1)
			{
				m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKEINT64(HYD_Levy, 1));
			}
			///游戏日志
			std::string logdata = "征税，（0免费或只扣礼金1扣元宝）：" + crArgumentParser::appItoa(needdeductgold);
			GameLogData gamelog(Log_Levy,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				void *param;
				unsigned char levycount = m_stream->_readUChar();
			//	int coppercash = m_stream->_readInt();
				crData *playerData = m_this->getDataClass();
			//	playerData->excHandle(MAKEINT64(WCH_LockData,1));
				playerData->inputParam(WCHDATA_JXJLevyCount, &levycount);

				crData *braindata = crBrain::getInstance()->getDataClass();
				CRCore::ScopedLock<crData> lock(*braindata);
				braindata->getParam(WCHDATA_JXJTotalLevyCount, param);
				int *totalexcount = (int *)param;
				(*totalexcount) += 1;
			//	playerData->getParam(WCHDATA_JXJCoppercash,param);
			//	int *cash = (int*)param;
			//	int dif = coppercash - *cash;//客户端需要提示dif
			//	*cash = coppercash;
			//	playerData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJImpressMethod
//
/////////////////////////////////////////
crJXJImpressMethod::crJXJImpressMethod():
m_this(NULL){}
crJXJImpressMethod::crJXJImpressMethod(const crJXJImpressMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_goldColor(handle.m_goldColor)
{
}
void crJXJImpressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJImpressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_goldColor);
		break;
	}
}

void crJXJImpressMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJLevyCount,param);
		unsigned char levyCount = *(unsigned char *)param;
		crVector2i maxlevycount;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount,viplv).c_str(),maxlevycount);
		if(levyCount>0 && levyCount <= maxlevycount[LevyType_Gold])
		{
			//检查元宝是否够
			int impress = maxlevycount[LevyType_Gold] - levyCount + 1;
			ref_ptr<crTableIO>impressTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressTab);
			crTableIO::StrVec record;
			if(impressTab->queryOneRecord(0,crArgumentParser::appItoa(impress),record)>=0)
			{
				int goldneed = atoi(record[1].c_str());

				ref_ptr<crCanvasNode> msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
				if(msgCanvas.valid())
				{
					crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
					crHypertextWidgetNode *msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
					crButtonWidgetNode *okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
					//title->setString(L"强征提示");

					data->getParam(WCHDATA_JXJGoldCostHintInt,param);
					unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_CompulsoryLevyHint;
					if (ifhint)
					{
						int hinttype = JXJGoldCostType_CompulsoryLevyHint;
						crData *braindata = crBrain::getInstance()->getDataClass();
						braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("Content");
						cfg_script.Push("Content");
						cfg_script.Add("Text","您确认要花费");
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content",2);
						v_i.clear();
						v_i.push_back(m_goldColor[0]);
						v_i.push_back(m_goldColor[1]);
						v_i.push_back(m_goldColor[2]);
						v_i.push_back(m_goldColor[3]);
						cfg_script.Add("Color",v_i);
						char tmpText[32];
						sprintf(tmpText,"%d礼金/元宝\0",goldneed);
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content",3);
						cfg_script.Add("Text","强征吗？");
						cfg_script.Pop();

						cfg_script.Pop();
						msg->setHypertext(cfg_script);
					}

					data->getParam(WCHDATA_JXJGoldingot,param);
					int goldingot = *(int *)param;
					data->getParam(WCHDATA_JXJGiftGold,param);
					int giftgold = *(int*)param;
					goldingot += giftgold;
					if(goldneed<=goldingot)
					{
						okBtn->setEnable(true);
					}
					else
					{
						okBtn->setEnable(false);
					}
					crData *dlgData = msgCanvas->getDataClass();
					int commandtype = CDP_Widget;
					dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
					dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
					if (ifhint)
					{
						crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
					}
					else
					{
						if (goldneed<=goldingot)
						{
							if(okBtn)okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
						}
						else
						{
							myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
						}
					}
				}
			}
			else
			{
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2029,NULL));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJImpress2Method
//
/////////////////////////////////////////
crJXJImpress2Method::crJXJImpress2Method()
{
}
crJXJImpress2Method::crJXJImpress2Method(const crJXJImpress2Method& handle):
	crMethod(handle)
{
}
void crJXJImpress2Method::inputParam(int i, void *param)
{
}
void crJXJImpress2Method::addParam(int i, const std::string& str)
{
}
void crJXJImpress2Method::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvLevy,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvImpressMethod
//
/////////////////////////////////////////
//crJXJRecvImpressMethod::crJXJRecvImpressMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvImpressMethod::crJXJRecvImpressMethod(const crJXJRecvImpressMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvImpressMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvImpressMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvImpressMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			char done = 0;
//			void *param;
//			crData *data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->getParam(WCHDATA_JXJLevyCount,param);
//			char* levyCount = (char *)param;
//			data->getParam(WCHDATA_JXJVipLv,param);
//			unsigned char viplv = *(unsigned char *)param;
//			char maxlevycount = (char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevyCount,viplv).c_str()));
//			int *coppercash;
//			//int* goldingot;
//			if(*levyCount>0 && *levyCount < maxlevycount)
//			{
//				int impress = maxlevycount - *levyCount;
//				ref_ptr<crTableIO>impressTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressTab);
//				crTableIO::StrVec record;
//				impressTab->queryOneRecord(0,crArgumentParser::appItoa(impress),record);
//				int goldneed = atoi(record[1].c_str());
//				//data->getParam(WCHDATA_JXJGoldingot,param);
//				//goldingot = (int *)param;
//				bool needdeductgold = false;
//				m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&goldneed,needdeductgold));
//				if(goldneed == 0)
//				{
//					//*goldingot -= goldneed;
//					(*levyCount)--;
//
//					data->getParam(WCHDATA_JXJMingjulv,param);
//					_crInt64 mingjulv = *(_crInt64*)param;
//					_crInt32 lo32 = LOINT64(mingjulv);
//					_crInt32 hi32 = HIINT64(mingjulv);
//					_crInt16 lo16 = LOINT32(lo32);
//					_crInt16 hi16 = HIINT32(lo32);
//					unsigned char mingju[8];
//					mingju[0] = (unsigned char)LOINT16(lo16);
//					mingju[1] = (unsigned char)HIINT16(lo16);
//					mingju[2] = (unsigned char)LOINT16(hi16);
//					mingju[3] = (unsigned char)HIINT16(hi16);
//					lo16 = LOINT32(hi32);
//					hi16 = HIINT32(hi32);
//					mingju[4] = (unsigned char)LOINT16(lo16);
//					mingju[5] = (unsigned char)HIINT16(lo16);
//					mingju[6] = (unsigned char)LOINT16(hi16);
//					mingju[7] = (unsigned char)HIINT16(hi16);
//					int popcount = 0;
//					ref_ptr<crTableIO>resbuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResBuildingTab);
//					int index = resbuildingTab->getTitleIndex("人口");
//					crTableIO::StrVec record;
//					for( int i = 0; i<8; i++)
//					{
//						if(mingju[i]>0)
//						{
//							resbuildingTab->queryOneRecord(0,crArgumentParser::appItoa(mingju[i]),record);
//							popcount += atoi(record[index].c_str());
//						}
//					}
//					data->getParam(WCHDATA_JXJFuyalv,param);
//					unsigned char fuyalv = *(unsigned char *)param;
//					int param1 = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyParam1,viplv).c_str());
//					int param2 = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLevyParam2,viplv).c_str());
//					int cash = popcount * param1 + (int)fuyalv * param2;
//					data->getParam(WCHDATA_JXJCoppercash,param);
//					coppercash = (int *)param;
//					if(*coppercash<(MAXUINT)-cash)
//						*coppercash += cash;
//					else
//						*coppercash = MAXUINT;
//					done = 1;
//					if (needdeductgold)
//					{
//						crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
//						if(playerData.valid())
//						{
//							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
//							callback->savePlayerData(playerData.get());
//						}
//					}
//				}
//			}
//			//返回信息
//			int playerid = m_this->getPlayerID();
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(6);
//				stream->_writeChar(done);
//				if(done==1)
//				{
//					stream->_writeChar(*levyCount);
//					//stream->_writeInt(*goldingot);
//					stream->_writeInt(*coppercash);
//				}
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvImpress,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			char returnCode = m_stream->_readChar();
//			if(returnCode == 1)
//			{
//				void *param;
//				char levycount = m_stream->_readChar();
//				//int goldingot = m_stream->_readInt();
//				int coppercash = m_stream->_readInt();
//				crData *playerData = m_this->getDataClass();
//				playerData->excHandle(MAKEINT64(WCH_LockData,1));
//				playerData->inputParam(WCHDATA_JXJLevyCount,&levycount);
//				//playerData->getParam(WCHDATA_JXJGoldingot,param);
//				//int *myGold = (int*)param;
//				//int golddif = goldingot - *myGold;//客户端需要提示golddif
//				//*myGold = goldingot;
//				playerData->getParam(WCHDATA_JXJCoppercash,param);
//				int *cash = (int*)param;
//				int dif = coppercash - *cash;//客户端需要提示dif
//				*cash = coppercash;
//				playerData->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJOnlineRewardMethod
////
///////////////////////////////////////////
//crJXJOnlineRewardMethod::crJXJOnlineRewardMethod(){}
//crJXJOnlineRewardMethod::crJXJOnlineRewardMethod(const crJXJOnlineRewardMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJOnlineRewardMethod::inputParam(int i, void *param)
//{
//}
//
//void crJXJOnlineRewardMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJOnlineRewardMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	if(myPlayer && netConductor)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		data->getParam(WCHDATA_JXJOnlineRewardCount,param);
//		unsigned char count = *(unsigned char *)param;
//		unsigned char maxcount = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxOnlineRewardCount).c_str()));
//		if(count>0 && count <= maxcount)
//		{
//			crPlayerDataEventPacket packet;
//			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOnlineReward,NULL);
//			netConductor->getNetManager()->sendPacket("all",packet);
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvOnlineRewardMethod
////
///////////////////////////////////////////
//crJXJRecvOnlineRewardMethod::crJXJRecvOnlineRewardMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvOnlineRewardMethod::crJXJRecvOnlineRewardMethod(const crJXJRecvOnlineRewardMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvOnlineRewardMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvOnlineRewardMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvOnlineRewardMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			char done = 0;
//			void *param;
//			crData *data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->getParam(WCHDATA_JXJOnlineRewardCount,param);
//			unsigned char* olRewardCount = (unsigned char*)param;
//			if(*olRewardCount>0)
//			{
//				//发放礼包
//				ref_ptr<crTableIO>olRewardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJOnlineRewardTab);
//				crTableIO::StrVec record;
//				if(olRewardTab->queryOneRecord(0,crArgumentParser::appItoa(*olRewardCount),record)>=0)
//				{
//					int index = olRewardTab->getTitleIndex("itemid");
//					crVector4i items;
//					crArgumentParser::appAtoVec(record[index],items);
//					//将items放入背包
//					//如果背包不够返回领取失败
//					done = 1;
//				}
//				if(done == 1)
//					(*olRewardCount)--;
//			}
//			//返回信息
//			int playerid = m_this->getPlayerID();
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(2);
//				stream->_writeChar(done);
//				stream->_writeUChar(*olRewardCount);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvOnlineReward,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			crData *data = m_this->getDataClass();
//			char done = m_stream->_readChar();
//			unsigned char olRewardCount = m_stream->_readUChar();
//			data->inputParam(WCHDATA_JXJOnlineRewardCount,&olRewardCount);
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJHallRefreshMethod
////
///////////////////////////////////////////
//crJXJHallRefreshMethod::crJXJHallRefreshMethod():
//	m_this(NULL){}
//crJXJHallRefreshMethod::crJXJHallRefreshMethod(const crJXJHallRefreshMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_msgbox(handle.m_msgbox),
//	m_title(handle.m_title),
//	m_msg(handle.m_msg),
//	m_ok(handle.m_ok),
//	m_copperColor(handle.m_copperColor)
//{
//}
//void crJXJHallRefreshMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//
//void crJXJHallRefreshMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_msgbox = str;
//		break;
//	case 1:
//		m_title = str;
//		break;
//	case 2:
//		m_msg = str;
//		break;
//	case 3:
//		m_ok = str;
//		break;
//	case 4:
//		crArgumentParser::appAtoVec(str,m_copperColor);
//		break;
//	}
//}
//
//void crJXJHallRefreshMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && myPlayer)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		data->getParam(WCHDATA_JXJJiusilv,param);
//		unsigned char jiushilv = *(unsigned char *)param;
//		ref_ptr<crTableIO>jiushiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJiushiTab);
//		crTableIO::StrVec record;
//		jiushiTab->queryOneRecord(0,crArgumentParser::appItoa((int)jiushilv),record);
//		int copperneed = atoi(record[1].c_str());
//
//		crCanvasNode *msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
//		crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
//		crHypertextWidgetNode *msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
//		crButtonWidgetNode *okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
//		//title->setString(L"大厅将卡刷新提示");
//
//		std::vector<float>v_i;
//		ItemMap itemMap;
//		rcfg::ConfigScript cfg_script(&itemMap);
//		cfg_script.Add("Hypertext");
//		cfg_script.Push("Hypertext");
//		cfg_script.Add("Content");
//		cfg_script.Push("Content");
//		cfg_script.Add("Text","您确认要花费");
//		cfg_script.Pop();
//
//		cfg_script.Add("Content");
//		cfg_script.Push("Content",2);
//		v_i.clear();
//		v_i.push_back(m_copperColor[0]);
//		v_i.push_back(m_copperColor[1]);
//		v_i.push_back(m_copperColor[2]);
//		v_i.push_back(m_copperColor[3]);
//		cfg_script.Add("Color",v_i);
//		char tmpText[32];
//		sprintf(tmpText,"%d铜钱\0",copperneed);
//		cfg_script.Add("Text",tmpText);
//		cfg_script.Pop();
//
//		cfg_script.Add("Content");
//		cfg_script.Push("Content",3);
//		cfg_script.Add("Text","来刷新将卡吗？");
//		cfg_script.Pop();
//
//		cfg_script.Pop();
//		msg->setHypertext(cfg_script);
//
//		data->getParam(WCHDATA_JXJCoppercash,param);
//		int mycopper = *(int *)param;
//		if(copperneed < mycopper)
//		{
//			okBtn->setEnable(true);
//		}
//		else
//		{
//			okBtn->setEnable(false);
//		}
//		crData *dlgData = msgCanvas->getDataClass();
//		dlgData->inputParam(WCHDATA_CommandDlgWidget,m_this);
//		crFilterRenderManager::getInstance()->doModal(msgCanvas);
//	}
//}
///////////////////////////////////////////
////
////crJXJHallRefresh2Method
////
///////////////////////////////////////////
//crJXJHallRefresh2Method::crJXJHallRefresh2Method()
//{
//}
//crJXJHallRefresh2Method::crJXJHallRefresh2Method(const crJXJHallRefresh2Method& handle):
//	crMethod(handle)
//{
//}
//void crJXJHallRefresh2Method::inputParam(int i, void *param)
//{
//}
//void crJXJHallRefresh2Method::addParam(int i, const std::string& str)
//{
//}
//void crJXJHallRefresh2Method::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	if(myPlayer && netConductor)
//	{
//		crPlayerDataEventPacket packet;
//		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvHallRefresh,NULL);
//		netConductor->getNetManager()->sendPacket("all",packet);
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvHallRefreshMethod
////
///////////////////////////////////////////
//crJXJRecvHallRefreshMethod::crJXJRecvHallRefreshMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvHallRefreshMethod::crJXJRecvHallRefreshMethod(const crJXJRecvHallRefreshMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvHallRefreshMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvHallRefreshMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvHallRefreshMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				crPlayerDataEventPacket packet;
//				char done = 0;
//				void *param;
//				crData *data = m_this->getDataClass();
//				data->excHandle(MAKEINT64(WCH_LockData,1));
//				data->getParam(WCHDATA_JXJJiusilv,param);
//				unsigned char jiushilv = *(unsigned char *)param;
//				ref_ptr<crTableIO>jiushiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJiushiTab);
//				crTableIO::StrVec record;
//				jiushiTab->queryOneRecord(0,crArgumentParser::appItoa((int)jiushilv),record);
//				int copperneed = atoi(record[1].c_str());
//				data->getParam(WCHDATA_JXJCoppercash,param);
//				int* mycopper = (int *)param;
//				if(copperneed < *mycopper)
//				{
//					*mycopper -= copperneed;
//					done = 1;
//					ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//					crTableIO::DataVec jiangkaRec;
//					int itemtype = itemTable->getTitleIndex("类型");
//					itemTable->queryRecords(itemtype,crArgumentParser::appItoa(IT_Jiangka),jiangkaRec);
//					int jiangkaCount = jiangkaRec.size();
//					data->getParam(WCHDATA_JXJHalltimer,param);
//					short *hallTimer = (short *)param;
//					*hallTimer = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJHallRefresh).c_str()));
//					stream->createBuf(22);
//					stream->_writeShort(*hallTimer);
//					//hall将卡刷新，并通知客户端
//					//将卡刷新规则未定
//					data->getParam(WCHDATA_JXJHallCard,param);
//					int *hallJiangka = (int *)param;
//					int rnd;
//					CRCore::rangei r(0,jiangkaCount);
//					for( int i = 0; i<5; ++i )
//					{
//						rnd = r.get_random();
//						*(hallJiangka+i) = atoi(jiangkaRec[rnd][0].c_str());
//						stream->_writeInt(*(hallJiangka+i));
//					}
//					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvHallJiangka,stream.get());
//					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				}
//				stream->createBuf(5);
//				stream->_writeChar(done);
//				if(done==1)
//				{
//					stream->_writeInt(*mycopper);
//				}
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvHallRefresh,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				data->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			char returnCode = m_stream->_readChar();
//			if(returnCode == 1)
//			{
//				void *param;
//				int coppercash = m_stream->_readInt();
//				crData *playerData = m_this->getDataClass();
//				playerData->excHandle(MAKEINT64(WCH_LockData,1));
//				playerData->getParam(WCHDATA_JXJCoppercash,param);
//				int *cash = (int*)param;
//				int dif = coppercash - *cash;//客户端需要提示dif
//				*cash = coppercash;
//				playerData->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJPrivateRefreshMethod
////
///////////////////////////////////////////
//crJXJPrivateRefreshMethod::crJXJPrivateRefreshMethod():
//	m_this(NULL){}
//crJXJPrivateRefreshMethod::crJXJPrivateRefreshMethod(const crJXJPrivateRefreshMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_msgbox(handle.m_msgbox),
//	m_title(handle.m_title),
//	m_msg(handle.m_msg),
//	m_ok(handle.m_ok),
//	m_goldColor(handle.m_goldColor)
//{
//}
//void crJXJPrivateRefreshMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//
//void crJXJPrivateRefreshMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_msgbox = str;
//		break;
//	case 1:
//		m_title = str;
//		break;
//	case 2:
//		m_msg = str;
//		break;
//	case 3:
//		m_ok = str;
//		break;
//	case 4:
//		crArgumentParser::appAtoVec(str,m_goldColor);
//		break;
//	}
//}
//
//void crJXJPrivateRefreshMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && myPlayer)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		data->getParam(WCHDATA_JXJJiusilv,param);
//		unsigned char jiushilv = *(unsigned char *)param;
//		ref_ptr<crTableIO>jiushiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJiushiTab);
//		crTableIO::StrVec record;
//		jiushiTab->queryOneRecord(0,crArgumentParser::appItoa((int)jiushilv),record);
//		int goldneed = atoi(record[2].c_str());
//
//		crCanvasNode *msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
//		crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
//		crHypertextWidgetNode *msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
//		crButtonWidgetNode *okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
//		//title->setString(L"雅间将卡刷新提示");
//
//		std::vector<float>v_i;
//		ItemMap itemMap;
//		rcfg::ConfigScript cfg_script(&itemMap);
//		cfg_script.Add("Hypertext");
//		cfg_script.Push("Hypertext");
//		cfg_script.Add("Content");
//		cfg_script.Push("Content");
//		cfg_script.Add("Text","您确认要花费");
//		cfg_script.Pop();
//
//		cfg_script.Add("Content");
//		cfg_script.Push("Content",2);
//		v_i.clear();
//		v_i.push_back(m_goldColor[0]);
//		v_i.push_back(m_goldColor[1]);
//		v_i.push_back(m_goldColor[2]);
//		v_i.push_back(m_goldColor[3]);
//		cfg_script.Add("Color",v_i);
//		char tmpText[32];
//		sprintf(tmpText,"%d元宝\0",goldneed);
//		cfg_script.Add("Text",tmpText);
//		cfg_script.Pop();
//
//		cfg_script.Add("Content");
//		cfg_script.Push("Content",3);
//		cfg_script.Add("Text","来刷新将卡吗？");
//		cfg_script.Pop();
//
//		cfg_script.Pop();
//		msg->setHypertext(cfg_script);
//
//		data->getParam(WCHDATA_JXJGoldingot,param);
//		int mygold = *(int *)param;
//		data->getParam(WCHDATA_JXJGiftGold,param);
//		int giftgold = *(int*)param;
//		mygold += giftgold;
//		if(goldneed < mygold)
//		{
//			okBtn->setEnable(true);
//		}
//		else
//		{
//			okBtn->setEnable(false);
//		}
//		crData *dlgData = msgCanvas->getDataClass();
//		dlgData->inputParam(WCHDATA_CommandDlgWidget,m_this);
//		crFilterRenderManager::getInstance()->doModal(msgCanvas);
//	}
//}
///////////////////////////////////////////
////
////crJXJPrivateRefresh2Method
////
///////////////////////////////////////////
//crJXJPrivateRefresh2Method::crJXJPrivateRefresh2Method()
//{
//}
//crJXJPrivateRefresh2Method::crJXJPrivateRefresh2Method(const crJXJPrivateRefresh2Method& handle):
//	crMethod(handle)
//{
//}
//void crJXJPrivateRefresh2Method::inputParam(int i, void *param)
//{
//}
//void crJXJPrivateRefresh2Method::addParam(int i, const std::string& str)
//{
//}
//void crJXJPrivateRefresh2Method::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	if(myPlayer && netConductor)
//	{
//		crPlayerDataEventPacket packet;
//		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPrivateRefresh,NULL);
//		netConductor->getNetManager()->sendPacket("all",packet);
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvPrivateRefreshMethod
////
///////////////////////////////////////////
//crJXJRecvPrivateRefreshMethod::crJXJRecvPrivateRefreshMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvPrivateRefreshMethod::crJXJRecvPrivateRefreshMethod(const crJXJRecvPrivateRefreshMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvPrivateRefreshMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvPrivateRefreshMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvPrivateRefreshMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				crPlayerDataEventPacket packet;
//				char done = 0;
//				void *param;
//				crData *data = m_this->getDataClass();
//				data->excHandle(MAKEINT64(WCH_LockData,1));
//				data->getParam(WCHDATA_JXJJiusilv,param);
//				unsigned char jiushilv = *(unsigned char *)param;
//				ref_ptr<crTableIO>jiushiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJiushiTab);
//				crTableIO::StrVec record;
//				jiushiTab->queryOneRecord(0,crArgumentParser::appItoa((int)jiushilv),record);
//				int goldneed = atoi(record[2].c_str());
//				//data->getParam(WCHDATA_JXJGoldingot,param);
//				//int* mygold = (int *)param;
//				m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&goldneed,NULL));
//				if(goldneed == 0)
//				{
//					//*mygold -= goldneed;
//					done = 1;
//					ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//					crTableIO::DataVec jiangkaRec;
//					int itemtype = itemTable->getTitleIndex("类型");
//					itemTable->queryRecords(itemtype,crArgumentParser::appItoa(IT_Jiangka),jiangkaRec);
//					int jiangkaCount = jiangkaRec.size();
//
//					data->getParam(WCHDATA_JXJPrivatetimer,param);
//					int *privateTimer = (int *)param;
//					*privateTimer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPrivateRefresh).c_str());
//					stream->createBuf(16);
//					stream->_writeInt(*privateTimer);
//					//private将卡刷新，并通知客户端
//					//将卡刷新规则未定
//					data->getParam(WCHDATA_JXJPrivateCard,param);
//					int *privateJiangka = (int *)param;
//					int rnd;
//					CRCore::rangei r(0,jiangkaCount);
//					for( int i = 0; i<3; ++i )
//					{
//						rnd = r.get_random();
//						*(privateJiangka+i) = atoi(jiangkaRec[rnd][0].c_str());
//						stream->_writeInt(*(privateJiangka+i));
//					}
//					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPrivateJiangka,stream.get());
//					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				}
//				stream->createBuf(1);
//				stream->_writeChar(done);
//				//if(done==1)
//				//{
//					//stream->_writeInt(*mygold);
//				//}
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPrivateRefresh,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				data->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			char returnCode = m_stream->_readChar();
//			if(returnCode == 1)
//			{
//				//void *param;
//				//int gold = m_stream->_readInt();
//				//crData *playerData = m_this->getDataClass();
//				//playerData->excHandle(MAKEINT64(WCH_LockData,1));
//				//playerData->getParam(WCHDATA_JXJGoldingot,param);
//				//int *mygold = (int*)param;
//				//int dif = gold - *mygold;//客户端需要提示dif
//				//*mygold = gold;
//				//playerData->excHandle(MAKEINT64(WCH_LockData,0));
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIGovPostOnShowMethod
//
/////////////////////////////////////////
crJXJUIGovPostOnShowMethod::crJXJUIGovPostOnShowMethod():
	m_this(NULL){}
crJXJUIGovPostOnShowMethod::crJXJUIGovPostOnShowMethod(const crJXJUIGovPostOnShowMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_posticon(handle.m_posticon),
	m_upgrade(handle.m_upgrade),
	m_curpost(handle.m_curpost),
	m_curarms(handle.m_curarms),
	m_exploit(handle.m_exploit),
	m_nextpost(handle.m_nextpost),
	m_nextarms(handle.m_nextarms),
	m_nextexploit(handle.m_nextexploit),
	m_lingqufenglubtn(handle.m_lingqufenglubtn)
{
}
void crJXJUIGovPostOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIGovPostOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_posticon = str;
		break;
	case 1:
		m_upgrade = str;
		break;
	case 2:
		m_curpost = str;
		break;
	case 3:
		m_curarms = str;
		break;
	case 4:
		m_exploit = str;
		break;
	case 5:
		m_nextpost = str;
		break;
	case 6:
		m_nextarms = str;
		break;
	case 7:
		m_nextexploit = str;
		break;
	case 8:
		m_lingqufenglubtn = str;
		break;
	}
}

void crJXJUIGovPostOnShowMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		ref_ptr<crImageBoxWidgetNode> posticon = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_posticon));
		ref_ptr<crButtonWidgetNode> upgrade = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_upgrade));
		ref_ptr<crStaticTextWidgetNode> curpost = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_curpost));
		ref_ptr<crStaticTextWidgetNode> curarms = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_curarms));
		ref_ptr<crStaticTextWidgetNode> exploit = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_exploit));
		ref_ptr<crStaticTextWidgetNode> nextpost = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nextpost));
		ref_ptr<crStaticTextWidgetNode> nextarms = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nextarms));
		ref_ptr<crStaticTextWidgetNode> nextexploit = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nextexploit));
		ref_ptr<crButtonWidgetNode> lingqufenglubtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_lingqufenglubtn));
		void *param;
		crRole *mainRole = myPlayer->getMainRole();
		crData *data = mainRole->getDataClass();
		data->getParam(WCHDATA_JXJGovPost,param);
		unsigned char post = *(unsigned char*)param;
		int npost = post+1;
		ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
		int rowcount = postTab->getRowCount();
		if(post == rowcount) 
		{
			npost = rowcount;
			upgrade->setEnable(false);
		}
		else
		{
			upgrade->setEnable(true);
		}
		int iconid = postTab->getTitleIndex("icon");
		int expid = postTab->getTitleIndex("功勋");
		crTableIO::StrVec record1,record2;
		postTab->queryOneRecord(0,crArgumentParser::appItoa(post),record1);
		postTab->queryOneRecord(0,crArgumentParser::appItoa(npost),record2);
		if (posticon.valid())posticon->setImageName(record1[iconid]);
		if (curpost.valid())curpost->setString(record1[1]);
		std::string str = "领导力+"+record1[2];
		if (curarms.valid())curarms->setString(str);
		data->getParam(WCHDATA_JXJExploit,param);
		int exp = *(int *)param;
		if (exploit.valid())exploit->setString(crArgumentParser::appItoa(exp));
		std::string upgradeRequireStr = "功勋:"+record2[expid];
		int nexp = atoi(record2[expid].c_str());
		//到最后5级还需要排名条件
		if (post != rowcount)
		{
			if (nextpost.valid())nextpost->setString(record2[1]);
			str = "领导力+"+record2[2];
			if (nextarms.valid())nextarms->setString(str);
			if (nextexploit.valid())
			{
				nextexploit->setString(upgradeRequireStr);
				if(nexp<=exp)
				{
					//upgrade->setEnable(true);
					nextexploit->setColor(crVector4(0.0f,0.0f,0.0f,1.0f));
				}
				else
				{
					upgrade->setEnable(false);
					nextexploit->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
				}
			}
		}
		else
		{
			if (nextpost.valid())nextpost->setString(std::string("主公您已位极人臣"));
			if (nextarms.valid())nextarms->setString(std::string("升无可升拉~"));
			if (nextexploit.valid())nextexploit->setString(std::string("无"));

		}
		crData *playerdata = myPlayer->getDataClass();
		if (lingqufenglubtn.valid())
		{
			playerdata->getParam(WCHDATA_JXJLingqufengluFlag, param);
			unsigned char lingqufenglu = *(unsigned char*)param;
			if (lingqufenglu > 0)
			{
				lingqufenglubtn->setEnable(false);
			}
			else
			{
				lingqufenglubtn->setEnable(true);
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJExploitRankingMethod
////
///////////////////////////////////////////
//crJXJExploitRankingMethod::crJXJExploitRankingMethod():
//	m_this(NULL){}
//crJXJExploitRankingMethod::crJXJExploitRankingMethod(const crJXJExploitRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJExploitRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJExploitRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJExploitRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJExpRankingWaitMap,param);
//		ExpRankingMap *expwaitmap = (ExpRankingMap *)param;
//		if(expwaitmap && !expwaitmap->empty())
//		{
//			int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
//			//ExpRankingMap *expRankingMap[JXJ_SHILICOUNT];
//			//int rankingMinExp[JXJ_SHILICOUNT];
//			//for( int i = 0; i<JXJ_SHILICOUNT; i++)
//			//{
//			//	data->getParam(WCHDATA_JXJExpRankingMap1+i,param);
//			//	expRankingMap[i] = (ExpRankingMap *)param;
//			//	if(expRankingMap[i]->size()<maxRankingNum)
//			//		rankingMinExp[i] = 0;
//			//	else
//			//	{
//			//		rankingMinExp[i] = expRankingMap[i]->rbegin()->first;
//			//	}
//			//}
//			ExpRankingMap *expRankingMap;
//			int rankingMinExp;
//			data->getParam(WCHDATA_JXJExpRankingMap,param);
//			expRankingMap = (ExpRankingMap *)param;
//			if(expRankingMap->size()<maxRankingNum)
//				rankingMinExp = 0;
//			else
//			{
//				rankingMinExp = expRankingMap->rbegin()->first;
//			}
//			
//			crPlayerRanking *ranking;
//			//unsigned char shilid;
//			//int startShili = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
//			int id = 0;
//			//std::vector<int>EraseVec;
//			for( ExpRankingMap::iterator itr = expwaitmap->begin();
//				 itr != expwaitmap->end();
//				 ++itr )
//			{
//				ranking = itr->second.get();
//				//shilid = ranking->getShiliID();
//				//id = shilid - c_startShiliID;
//				if(ranking->getExploit()>rankingMinExp)
//				{
//					//排行榜上删除已经存在的玩家
//					for( ExpRankingMap::iterator eitr = expRankingMap->begin();
//						 eitr != expRankingMap->end();
//						 ++eitr )
//					{
//						if(ranking->getPlayerID() == eitr->second->getPlayerID())
//						{
//							expRankingMap->erase(eitr);
//							break;
//						}
//					}
//					expRankingMap->insert(std::make_pair(ranking->getExploit(),ranking));
//					if(rankingMinExp == 0 && expRankingMap->size()==maxRankingNum)
//					{
//						rankingMinExp = expRankingMap->rbegin()->first;
//					}
//					else
//					{
//						while(expRankingMap->size()>maxRankingNum)
//						{
//							expRankingMap->erase(rankingMinExp);
//							rankingMinExp = expRankingMap->rbegin()->first;
//						}
//					}
//				}
//				else
//				{
//					break;
//				}
//				//else
//				//{//未上榜
//				//	//EraseVec.push_back(itr->first);
//				//	itr = expwaitmap->erase(itr);
//				//}
//			}
//			//for( std::vector<int>::iterator itr = EraseVec.begin();
//			//	 itr != EraseVec.end();
//			//	 ++itr )
//			//{
//			//	expwaitmap->erase(*itr);
//			//}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJSaveExploitRankingMethod
//
/////////////////////////////////////////
crJXJSaveExploitRankingMethod::crJXJSaveExploitRankingMethod():
	m_this(NULL){}
crJXJSaveExploitRankingMethod::crJXJSaveExploitRankingMethod(const crJXJSaveExploitRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_expRankingFile(handle.m_expRankingFile)
{
}
void crJXJSaveExploitRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveExploitRankingMethod::addParam(int i, const std::string& str)
{
	//m_expRankingFiles.push_back(str);
	switch(i) 
	{
	case 0:
		m_expRankingFile = str;
		break;
	}
}

void crJXJSaveExploitRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int expRankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		ExpRankingMap *expRankingMap;
		int j = 0;
		crPlayerRanking *exprank;
		ref_ptr<crTableIO> expRankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		//for( int i = 0; i<JXJ_SHILICOUNT; i++)
		//{//三个势力
			data->getParam(WCHDATA_JXJExpRankingMap,param);
			expRankingMap = (ExpRankingMap *)param;
			expRankingTab = new crTableIO;
			expRankingTab->setTitleVec(title);
			j = 0;
			for( ExpRankingMap::iterator itr = expRankingMap->begin();
				 j<expRankingCount && itr != expRankingMap->end();
				 ++itr,++j )
			{
				exprank = itr->second.get();
				record.clear();
				record.push_back(crArgumentParser::appItoa(exprank->getPlayerID()));
				record.push_back(crArgumentParser::appItoa(exprank->getExploit()));
				record.push_back(exprank->getName());
				record.push_back(crArgumentParser::appItoa((int)(exprank->getGovpost())));
				record.push_back(crArgumentParser::appItoa((int)(exprank->getShiliID())));
				record.push_back(crArgumentParser::appItoa((int)(exprank->getLevel())));
				record.push_back(crArgumentParser::appItoa((int)(exprank->getNobility())));
				record.push_back(crArgumentParser::appItoa((int)(exprank->getAccomplishPoint())));
				record.push_back(crArgumentParser::appItoa((int)(exprank->getTroops())));
				record.push_back(crArgumentParser::appItoa((int)(exprank->getManorlv())));
				record.push_back(crArgumentParser::appItoa(exprank->getCountrycontribute()));
				expRankingTab->addData(record);
			}

			CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
			CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
			CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
			std::string filepath = crArgumentParser::getFilePath(m_expRankingFile);
			std::string filename = crArgumentParser::getSimpleFileName(m_expRankingFile);
			std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

			expRankingTab->saveToFileStreamNoCook(relFileName ,SM_Record);
		//}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJLevelRankingMethod
////
///////////////////////////////////////////
//crJXJLevelRankingMethod::crJXJLevelRankingMethod():
//	m_this(NULL){}
//crJXJLevelRankingMethod::crJXJLevelRankingMethod(const crJXJLevelRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJLevelRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJLevelRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJLevelRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJLevelRankingWaitMap,param);
//		LevelRankingMap *rankwaitmap = (LevelRankingMap *)param;
//		if(rankwaitmap && !rankwaitmap->empty())
//		{
//			int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
//			LevelRankingMap *rankingMap;
//			unsigned char rankingMin;
//			data->getParam(WCHDATA_JXJLevelRankingMap,param);
//			rankingMap = (LevelRankingMap *)param;
//			if(rankingMap->size()<maxRankingNum)
//				rankingMin = 0;
//			else
//			{
//				rankingMin = rankingMap->rbegin()->first;
//			}
//
//			crPlayerRanking *ranking;
//			int id = 0;
//			for( LevelRankingMap::iterator itr = rankwaitmap->begin();
//				itr != rankwaitmap->end();
//				++itr )
//			{
//				ranking = itr->second.get();
//				if(ranking->getLevel()>rankingMin)
//				{
//					//排行榜上删除已经存在的玩家
//					for( LevelRankingMap::iterator eitr = rankingMap->begin();
//						eitr != rankingMap->end();
//						++eitr )
//					{
//						if(ranking->getPlayerID() == eitr->second->getPlayerID())
//						{
//							rankingMap->erase(eitr);
//							break;
//						}
//					}
//					rankingMap->insert(std::make_pair(ranking->getLevel(),ranking));
//					if(rankingMin == 0 && rankingMap->size()==maxRankingNum)
//					{
//						rankingMin = rankingMap->rbegin()->first;
//					}
//					else
//					{
//						while(rankingMap->size()>maxRankingNum)
//						{
//							rankingMap->erase(rankingMin);
//							rankingMin = rankingMap->rbegin()->first;
//						}
//					}
//				}
//				else
//				{
//					break;
//				}
//			}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJSaveLevelRankingMethod
//
/////////////////////////////////////////
crJXJSaveLevelRankingMethod::crJXJSaveLevelRankingMethod():
	m_this(NULL){}
crJXJSaveLevelRankingMethod::crJXJSaveLevelRankingMethod(const crJXJSaveLevelRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_rankingFile(handle.m_rankingFile)
{
}
void crJXJSaveLevelRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveLevelRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rankingFile = str;
		break;
	}
}

void crJXJSaveLevelRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int rankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		LevelRankingMap *rankingMap;
		int j = 0;
		crPlayerRanking *prank;
		ref_ptr<crTableIO> rankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		data->getParam(WCHDATA_JXJLevelRankingMap,param);
		rankingMap = (LevelRankingMap *)param;
		rankingTab = new crTableIO;
		rankingTab->setTitleVec(title);
		j = 0;
		for( LevelRankingMap::iterator itr = rankingMap->begin();
			j<rankingCount && itr != rankingMap->end();
			++itr,++j )
		{
			prank = itr->second.get();
			record.clear();
			record.push_back(crArgumentParser::appItoa(prank->getPlayerID()));
			record.push_back(crArgumentParser::appItoa(prank->getExploit()));
			record.push_back(prank->getName());
			record.push_back(crArgumentParser::appItoa((int)(prank->getGovpost())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getShiliID())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getLevel())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getNobility())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getAccomplishPoint())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getTroops())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getManorlv())));
			record.push_back(crArgumentParser::appItoa(prank->getCountrycontribute()));
			rankingTab->addData(record);
		}

		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_rankingFile);
		std::string filename = crArgumentParser::getSimpleFileName(m_rankingFile);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

		rankingTab->saveToFileStreamNoCook(relFileName,SM_Record);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJGovpostRankingMethod
////
///////////////////////////////////////////
//crJXJGovpostRankingMethod::crJXJGovpostRankingMethod():
//	m_this(NULL){}
//crJXJGovpostRankingMethod::crJXJGovpostRankingMethod(const crJXJGovpostRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJGovpostRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJGovpostRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJGovpostRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJGovpostRankingWaitMap,param);
//		GovpostRankingMap *rankwaitmap = (GovpostRankingMap *)param;
//		if(rankwaitmap && !rankwaitmap->empty())
//		{
//			int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
//			GovpostRankingMap *rankingMap;
//			unsigned char rankingMin;
//			data->getParam(WCHDATA_JXJGovpostRankingMap,param);
//			rankingMap = (GovpostRankingMap *)param;
//			if(rankingMap->size()<maxRankingNum)
//				rankingMin = 0;
//			else
//			{
//				rankingMin = rankingMap->rbegin()->first;
//			}
//
//			crPlayerRanking *ranking;
//			int id = 0;
//			for( GovpostRankingMap::iterator itr = rankwaitmap->begin();
//				itr != rankwaitmap->end();
//				++itr )
//			{
//				ranking = itr->second.get();
//				if(ranking->getGovpost()>rankingMin)
//				{
//					//排行榜上删除已经存在的玩家
//					for( GovpostRankingMap::iterator eitr = rankingMap->begin();
//						eitr != rankingMap->end();
//						++eitr )
//					{
//						if(ranking->getPlayerID() == eitr->second->getPlayerID())
//						{
//							rankingMap->erase(eitr);
//							break;
//						}
//					}
//					rankingMap->insert(std::make_pair(ranking->getGovpost(),ranking));
//					if(rankingMin == 0 && rankingMap->size()==maxRankingNum)
//					{
//						rankingMin = rankingMap->rbegin()->first;
//					}
//					else
//					{
//						while(rankingMap->size()>maxRankingNum)
//						{
//							rankingMap->erase(rankingMin);
//							rankingMin = rankingMap->rbegin()->first;
//						}
//					}
//				}
//				else
//				{
//					break;
//				}
//			}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJSaveGovpostRankingMethod
//
/////////////////////////////////////////
crJXJSaveGovpostRankingMethod::crJXJSaveGovpostRankingMethod():
	m_this(NULL){}
crJXJSaveGovpostRankingMethod::crJXJSaveGovpostRankingMethod(const crJXJSaveGovpostRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_rankingFile(handle.m_rankingFile)
{
}
void crJXJSaveGovpostRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveGovpostRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rankingFile = str;
		break;
	}
}

void crJXJSaveGovpostRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int rankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		GovpostRankingMap *rankingMap;
		int j = 0;
		crPlayerRanking *prank;
		ref_ptr<crTableIO> rankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		data->getParam(WCHDATA_JXJGovpostRankingMap,param);
		rankingMap = (GovpostRankingMap *)param;
		rankingTab = new crTableIO;
		rankingTab->setTitleVec(title);
		j = 0;
		for( GovpostRankingMap::iterator itr = rankingMap->begin();
			j<rankingCount && itr != rankingMap->end();
			++itr,++j )
		{
			prank = itr->second.get();
			record.clear();
			record.push_back(crArgumentParser::appItoa(prank->getPlayerID()));
			record.push_back(crArgumentParser::appItoa(prank->getExploit()));
			record.push_back(prank->getName());
			record.push_back(crArgumentParser::appItoa((int)(prank->getGovpost())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getShiliID())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getLevel())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getNobility())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getAccomplishPoint())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getTroops())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getManorlv())));
			record.push_back(crArgumentParser::appItoa(prank->getCountrycontribute()));
			rankingTab->addData(record);
		}

		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_rankingFile);
		std::string filename = crArgumentParser::getSimpleFileName(m_rankingFile);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

		rankingTab->saveToFileStreamNoCook(relFileName,SM_Record);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJAccomplishRankingMethod
////
///////////////////////////////////////////
//crJXJAccomplishRankingMethod::crJXJAccomplishRankingMethod():
//	m_this(NULL){}
//crJXJAccomplishRankingMethod::crJXJAccomplishRankingMethod(const crJXJAccomplishRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJAccomplishRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJAccomplishRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJAccomplishRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJAccomplishRankingWaitMap,param);
//		AccomplishRankingMap *rankwaitmap = (AccomplishRankingMap *)param;
//		if(rankwaitmap && !rankwaitmap->empty())
//		{
//			int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
//			AccomplishRankingMap *rankingMap;
//			unsigned short rankingMin;
//			data->getParam(WCHDATA_JXJAccomplishRankingMap,param);
//			rankingMap = (AccomplishRankingMap *)param;
//			if(rankingMap->size()<maxRankingNum)
//				rankingMin = 0;
//			else
//			{
//				rankingMin = rankingMap->rbegin()->first;
//			}
//
//			crPlayerRanking *ranking;
//			int id = 0;
//			for( AccomplishRankingMap::iterator itr = rankwaitmap->begin();
//				itr != rankwaitmap->end();
//				++itr )
//			{
//				ranking = itr->second.get();
//				if(ranking->getAccomplishPoint()>rankingMin)
//				{
//					//排行榜上删除已经存在的玩家
//					for( AccomplishRankingMap::iterator eitr = rankingMap->begin();
//						eitr != rankingMap->end();
//						++eitr )
//					{
//						if(ranking->getPlayerID() == eitr->second->getPlayerID())
//						{
//							rankingMap->erase(eitr);
//							break;
//						}
//					}
//					rankingMap->insert(std::make_pair(ranking->getAccomplishPoint(),ranking));
//					if(rankingMin == 0 && rankingMap->size()==maxRankingNum)
//					{
//						rankingMin = rankingMap->rbegin()->first;
//					}
//					else
//					{
//						while(rankingMap->size()>maxRankingNum)
//						{
//							rankingMap->erase(rankingMin);
//							rankingMin = rankingMap->rbegin()->first;
//						}
//					}
//				}
//				else
//				{
//					break;
//				}
//			}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJSaveAccomplishRankingMethod
//
/////////////////////////////////////////
crJXJSaveAccomplishRankingMethod::crJXJSaveAccomplishRankingMethod():
	m_this(NULL){}
crJXJSaveAccomplishRankingMethod::crJXJSaveAccomplishRankingMethod(const crJXJSaveAccomplishRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_rankingFile(handle.m_rankingFile)
{
}
void crJXJSaveAccomplishRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveAccomplishRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rankingFile = str;
		break;
	}
}

void crJXJSaveAccomplishRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int rankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		AccomplishRankingMap *rankingMap;
		int j = 0;
		crPlayerRanking *prank;
		ref_ptr<crTableIO> rankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		data->getParam(WCHDATA_JXJAccomplishRankingMap,param);
		rankingMap = (AccomplishRankingMap *)param;
		rankingTab = new crTableIO;
		rankingTab->setTitleVec(title);
		j = 0;
		for( AccomplishRankingMap::iterator itr = rankingMap->begin();
			j<rankingCount && itr != rankingMap->end();
			++itr,++j )
		{
			prank = itr->second.get();
			record.clear();
			record.push_back(crArgumentParser::appItoa(prank->getPlayerID()));
			record.push_back(crArgumentParser::appItoa(prank->getExploit()));
			record.push_back(prank->getName());
			record.push_back(crArgumentParser::appItoa((int)(prank->getGovpost())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getShiliID())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getLevel())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getNobility())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getAccomplishPoint())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getTroops())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getManorlv())));
			record.push_back(crArgumentParser::appItoa(prank->getCountrycontribute()));
			rankingTab->addData(record);
		}

		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_rankingFile);
		std::string filename = crArgumentParser::getSimpleFileName(m_rankingFile);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

		rankingTab->saveToFileStreamNoCook(relFileName ,SM_Record);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJTroopsRankingMethod
////
///////////////////////////////////////////
//crJXJTroopsRankingMethod::crJXJTroopsRankingMethod():
//	m_this(NULL){}
//crJXJTroopsRankingMethod::crJXJTroopsRankingMethod(const crJXJTroopsRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJTroopsRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJTroopsRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJTroopsRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJTroopsRankingWaitMap,param);
//		TroopsRankingMap *rankwaitmap = (TroopsRankingMap *)param;
//		data->getParam(WCHDATA_JXJTroopsRankingMap,param);
//		TroopsRankingMap *rankingMap = (TroopsRankingMap *)param;
//		rankingMap->swap(*rankwaitmap);
//		rankwaitmap->clear();
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJSaveTroopsRankingMethod
//
/////////////////////////////////////////
crJXJSaveTroopsRankingMethod::crJXJSaveTroopsRankingMethod():
	m_this(NULL){}
crJXJSaveTroopsRankingMethod::crJXJSaveTroopsRankingMethod(const crJXJSaveTroopsRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_rankingFile(handle.m_rankingFile)
{
}
void crJXJSaveTroopsRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveTroopsRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rankingFile = str;
		break;
	}
}

void crJXJSaveTroopsRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int rankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		TroopsRankingMap *rankingMap;
		int j = 0;
		crPlayerRanking *prank;
		ref_ptr<crTableIO> rankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		data->getParam(WCHDATA_JXJTroopsRankingMap,param);
		rankingMap = (TroopsRankingMap *)param;
		rankingTab = new crTableIO;
		rankingTab->setTitleVec(title);
		j = 0;
		for( TroopsRankingMap::iterator itr = rankingMap->begin();
			j<rankingCount && itr != rankingMap->end();
			++itr,++j )
		{
			prank = itr->second.get();
			record.clear();
			record.push_back(crArgumentParser::appItoa(prank->getPlayerID()));
			record.push_back(crArgumentParser::appItoa(prank->getExploit()));
			record.push_back(prank->getName());
			record.push_back(crArgumentParser::appItoa((int)(prank->getGovpost())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getShiliID())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getLevel())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getNobility())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getAccomplishPoint())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getTroops())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getManorlv())));
			record.push_back(crArgumentParser::appItoa(prank->getCountrycontribute()));
			rankingTab->addData(record);
		}

		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_rankingFile);
		std::string filename = crArgumentParser::getSimpleFileName(m_rankingFile);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

		rankingTab->saveToFileStreamNoCook(relFileName ,SM_Record);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJCountrycontributeRankingMethod
////
///////////////////////////////////////////
//crJXJCountrycontributeRankingMethod::crJXJCountrycontributeRankingMethod():
//	m_this(NULL){}
//crJXJCountrycontributeRankingMethod::crJXJCountrycontributeRankingMethod(const crJXJCountrycontributeRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJCountrycontributeRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJCountrycontributeRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJCountrycontributeRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJCountrycontributeRankingWaitMap,param);
//		CountrycontributeRankingMap *rankwaitmap = (CountrycontributeRankingMap *)param;
//		data->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
//		CountrycontributeRankingMap *rankingMap = (CountrycontributeRankingMap *)param;
//		rankingMap->swap(*rankwaitmap);
//		rankwaitmap->clear();
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//	//if(m_this)
//	//{
//	//	void *param;
//	//	crData *data = m_this->getDataClass();
//	//	data->excHandle(MAKEINT64(WCH_LockData,1));
//	//	data->getParam(WCHDATA_JXJCountrycontributeRankingWaitMap,param);
//	//	CountrycontributeRankingMap *rankwaitmap = (CountrycontributeRankingMap *)param;
//	//	if(rankwaitmap && !rankwaitmap->empty())
//	//	{
//	//		int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
//	//		CountrycontributeRankingMap *rankingMap;
//	//		int rankingMin;
//	//		data->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
//	//		rankingMap = (CountrycontributeRankingMap *)param;
//	//		if(rankingMap->size()<maxRankingNum)
//	//			rankingMin = 0;
//	//		else
//	//		{
//	//			rankingMin = rankingMap->rbegin()->first;
//	//		}
//
//	//		crPlayerRanking *ranking;
//	//		int id = 0;
//	//		for( CountrycontributeRankingMap::iterator itr = rankwaitmap->begin();
//	//			itr != rankwaitmap->end();
//	//			++itr )
//	//		{
//	//			ranking = itr->second.get();
//	//			if(ranking->getCountrycontribute()>rankingMin)
//	//			{
//	//				//排行榜上删除已经存在的玩家
//	//				for( CountrycontributeRankingMap::iterator eitr = rankingMap->begin();
//	//					eitr != rankingMap->end();
//	//					++eitr )
//	//				{
//	//					if(ranking->getPlayerID() == eitr->second->getPlayerID())
//	//					{
//	//						rankingMap->erase(eitr);
//	//						break;
//	//					}
//	//				}
//	//				rankingMap->insert(std::make_pair(ranking->getCountrycontribute(),ranking));
//	//				if(rankingMin == 0 && rankingMap->size()==maxRankingNum)
//	//				{
//	//					rankingMin = rankingMap->rbegin()->first;
//	//				}
//	//				else
//	//				{
//	//					while(rankingMap->size()>maxRankingNum)
//	//					{
//	//						rankingMap->erase(rankingMin);
//	//						rankingMin = rankingMap->rbegin()->first;
//	//					}
//	//				}
//	//			}
//	//			else
//	//			{
//	//				break;
//	//			}
//	//		}
//	//	}
//	//	data->excHandle(MAKEINT64(WCH_LockData,0));
//	//}
//}
/////////////////////////////////////////
//
//crJXJSaveCountrycontributeRankingMethod
//
/////////////////////////////////////////
crJXJSaveCountrycontributeRankingMethod::crJXJSaveCountrycontributeRankingMethod():
	m_this(NULL){}
crJXJSaveCountrycontributeRankingMethod::crJXJSaveCountrycontributeRankingMethod(const crJXJSaveCountrycontributeRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_rankingFile(handle.m_rankingFile)
{
}
void crJXJSaveCountrycontributeRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveCountrycontributeRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rankingFile = str;
		break;
	}
}

void crJXJSaveCountrycontributeRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int rankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		CountrycontributeRankingMap *rankingMap;
		int j = 0;
		crPlayerRanking *prank;
		ref_ptr<crTableIO> rankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		data->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
		rankingMap = (CountrycontributeRankingMap *)param;
		rankingTab = new crTableIO;
		rankingTab->setTitleVec(title);
		j = 0;
		for( CountrycontributeRankingMap::iterator itr = rankingMap->begin();
			j<rankingCount && itr != rankingMap->end();
			++itr,++j )
		{
			prank = itr->second.get();
			record.clear();
			record.push_back(crArgumentParser::appItoa(prank->getPlayerID()));
			record.push_back(crArgumentParser::appItoa(prank->getExploit()));
			record.push_back(prank->getName());
			record.push_back(crArgumentParser::appItoa((int)(prank->getGovpost())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getShiliID())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getLevel())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getNobility())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getAccomplishPoint())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getTroops())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getManorlv())));
			record.push_back(crArgumentParser::appItoa(prank->getCountrycontribute()));
			rankingTab->addData(record);
		}

		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_rankingFile);
		std::string filename = crArgumentParser::getSimpleFileName(m_rankingFile);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

		rankingTab->saveToFileStreamNoCook(relFileName ,SM_Record);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJManorlvRankingMethod
////
///////////////////////////////////////////
//crJXJManorlvRankingMethod::crJXJManorlvRankingMethod():
//	m_this(NULL){}
//crJXJManorlvRankingMethod::crJXJManorlvRankingMethod(const crJXJManorlvRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJManorlvRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJManorlvRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJManorlvRankingMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJManorlvRankingWaitMap,param);
//		ManorlvRankingMap *rankwaitmap = (ManorlvRankingMap *)param;
//		if(rankwaitmap && !rankwaitmap->empty())
//		{
//			int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
//			ManorlvRankingMap *rankingMap;
//			int rankingMin;
//			data->getParam(WCHDATA_JXJManorlvRankingMap,param);
//			rankingMap = (ManorlvRankingMap *)param;
//			if(rankingMap->size()<maxRankingNum)
//				rankingMin = 0;
//			else
//			{
//				rankingMin = rankingMap->rbegin()->first;
//			}
//
//			crPlayerRanking *ranking;
//			int id = 0;
//			for( ManorlvRankingMap::iterator itr = rankwaitmap->begin();
//				itr != rankwaitmap->end();
//				++itr )
//			{
//				ranking = itr->second.get();
//				if(ranking->getManorlv()>rankingMin)
//				{
//					//排行榜上删除已经存在的玩家
//					for( ManorlvRankingMap::iterator eitr = rankingMap->begin();
//						eitr != rankingMap->end();
//						++eitr )
//					{
//						if(ranking->getPlayerID() == eitr->second->getPlayerID())
//						{
//							rankingMap->erase(eitr);
//							break;
//						}
//					}
//					rankingMap->insert(std::make_pair(ranking->getManorlv(),ranking));
//					if(rankingMin == 0 && rankingMap->size()==maxRankingNum)
//					{
//						rankingMin = rankingMap->rbegin()->first;
//					}
//					else
//					{
//						while(rankingMap->size()>maxRankingNum)
//						{
//							rankingMap->erase(rankingMin);
//							rankingMin = rankingMap->rbegin()->first;
//						}
//					}
//				}
//				else
//				{
//					break;
//				}
//			}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJSaveManorlvRankingMethod
//
/////////////////////////////////////////
crJXJSaveManorlvRankingMethod::crJXJSaveManorlvRankingMethod():
	m_this(NULL){}
crJXJSaveManorlvRankingMethod::crJXJSaveManorlvRankingMethod(const crJXJSaveManorlvRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_rankingFile(handle.m_rankingFile)
{
}
void crJXJSaveManorlvRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveManorlvRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rankingFile = str;
		break;
	}
}

void crJXJSaveManorlvRankingMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		int rankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,0).c_str());
		ManorlvRankingMap *rankingMap;
		int j = 0;
		crPlayerRanking *prank;
		ref_ptr<crTableIO> rankingTab;
		crTableIO::StrVec record;
		crTableIO::StrVec title;
		title.push_back("playerid");
		title.push_back("功勋");
		title.push_back("name");
		title.push_back("官职");
		title.push_back("势力");
		title.push_back("等级");
		title.push_back("爵位");
		title.push_back("成就");
		title.push_back("兵力");
		title.push_back("领地");
		title.push_back("国家贡献");
		data->getParam(WCHDATA_JXJManorlvRankingMap,param);
		rankingMap = (ManorlvRankingMap *)param;
		rankingTab = new crTableIO;
		rankingTab->setTitleVec(title);
		j = 0;
		for( ManorlvRankingMap::iterator itr = rankingMap->begin();
			j<rankingCount && itr != rankingMap->end();
			++itr,++j )
		{
			prank = itr->second.get();
			record.clear();
			record.push_back(crArgumentParser::appItoa(prank->getPlayerID()));
			record.push_back(crArgumentParser::appItoa(prank->getExploit()));
			record.push_back(prank->getName());
			record.push_back(crArgumentParser::appItoa((int)(prank->getGovpost())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getShiliID())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getLevel())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getNobility())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getAccomplishPoint())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getTroops())));
			record.push_back(crArgumentParser::appItoa((int)(prank->getManorlv())));
			record.push_back(crArgumentParser::appItoa(prank->getCountrycontribute()));
			rankingTab->addData(record);
		}

		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_rankingFile);
		std::string filename = crArgumentParser::getSimpleFileName(m_rankingFile);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/"+ filename;

		rankingTab->saveToFileStreamNoCook(relFileName ,SM_Record);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJQueryGovPostRankingMethod
//
/////////////////////////////////////////
crJXJQueryGovPostRankingMethod::crJXJQueryGovPostRankingMethod()
//	m_queryInterval(86400)//24hour
//	m_queryCount(10)
{
}
crJXJQueryGovPostRankingMethod::crJXJQueryGovPostRankingMethod(const crJXJQueryGovPostRankingMethod& handle):
	crMethod(handle)
//	m_queryInterval(handle.m_queryInterval)
//	m_queryCount(handle.m_queryCount)
{
}
void crJXJQueryGovPostRankingMethod::inputParam(int i, void *param)
{
	//switch(i) 
	//{
	//case 0:
	//	if(param == 0)
	//	{//释放
	//		m_this = NULL;
	//	}
	//	break;
	//case 1:
	//	m_this = (crCanvasNode*)param;
	//	break;
	//}
}
void crJXJQueryGovPostRankingMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	////case 0:
	////	m_queryInterval = atoi(str.c_str());
	////	break;
	//case 0:
	//	m_queryCount = (unsigned char)(atoi(str.c_str()));
	//	break;
	//}
}
void crJXJQueryGovPostRankingMethod::operator()(crHandle &handle)
{
	//int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking).c_str());
	unsigned char querycount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,0).c_str());
	//bool cancelTask = false;
	//if(m_this)
	//{
		void *param;
	//	crData *data = m_this->getDataClass();
		//data->getParam(WCHDATA_JXJLastQueryTime,param);
		//_crInt64 *queryTime = (_crInt64 *)param;
		//bool query = false;
		//time_t t1 = time(0);
		//if(*queryTime == 0L)
		//{
		//	*queryTime = t1;
		//	query = true;
		//}
		//else
		//{
		//	int dt = t1 - *queryTime;
		//	if(dt>m_queryInterval)
		//	{
		//		*queryTime = t1;
		//		query = true;
		//	}
		//}
		//if(query)
		//{
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->getParam(WCHDATA_JXJRankingPageNum,param);
		int curpagenum = *(int *)param;
		unsigned short startline = (curpagenum - 1) * querycount;
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(myPlayer && netConductor)
		{
			crData *data = myPlayer->getDataClass();
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *(unsigned char *)param;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeUShort(startline);//start
			stream->_writeUChar(querycount);//count
			stream->_writeUChar(shiliid);//shili
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGovPostRanking,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			//cancelTask = true;
		}
		//}
//	}
	//handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJRecvExploitRankingMethod
//
/////////////////////////////////////////
crJXJRecvExploitRankingMethod::crJXJRecvExploitRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvExploitRankingMethod::crJXJRecvExploitRankingMethod(const crJXJRecvExploitRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_canvasName1(handle.m_canvasName1)
{
}
void crJXJRecvExploitRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvExploitRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_canvasName1 = str;
		break;
	}
}

void crJXJRecvExploitRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				//unsigned char querycount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking).c_str());
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJExpRankingMap,param);
				ExpRankingMap *expRankingMap = (ExpRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(expRankingMap->size()- start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( ExpRankingMap::iterator itr = expRankingMap->begin(); 
						itr != expRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;				
					for( ExpRankingMap::iterator itr = expRankingMap->begin(); 
						itr != expRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( ExpRankingMap::iterator itr = expRankingMap->begin(); 
						i < start + count && itr != expRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}
					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvExploitRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game && crStartHandler::getInstance()->isRunning())
		{
			void *param;
			crData *playerdata = m_this->getDataClass();
			playerdata->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			ref_ptr<crCanvasNode> canvas1 = crFilterRenderManager::getInstance()->findCanvas(m_canvasName1);
			if (canvas.valid() && canvas1.valid())
			{
				//crData *data = canvas->getDataClass();//府衙的官职排行
				crData *data1 = canvas1->getDataClass();
				//data->excHandle(MAKEINT64(WCH_LockData,1));
				//data->getParam(WCHDATA_JXJExpRankingMap,param);
				//ExpRankingMap *rankingMap = (ExpRankingMap *)param;
				data1->excHandle(MAKEINT64(WCH_LockData,1));
				data1->getParam(WCHDATA_JXJExpRankingMap,param);
				ExpRankingMap *rankingMap1 = (ExpRankingMap *)param;
				rankingMap1->clear();
				//rankingMap->clear();
				int count = (int)(m_stream->_readUChar());
				ref_ptr<crPlayerRanking> expRanking;
				for (int i = 0; i<count; i++)
				{
					expRanking = new crPlayerRanking;
					expRanking->setPlayerID(m_stream->_readInt());
					expRanking->setExploit(m_stream->_readInt());
					expRanking->setGovpost(m_stream->_readUChar());
					expRanking->setName(m_stream->_readString());
					expRanking->setShiliID(m_stream->_readUChar());
					expRanking->setLevel(m_stream->_readUChar());
					expRanking->setNobility(m_stream->_readUChar());
					expRanking->setAccomplishPoint(m_stream->_readUShort());
					expRanking->setTroops(m_stream->_readInt());
					expRanking->setManorlv(m_stream->_readUShort());
					expRanking->setPlayerRank(m_stream->_readInt());

					//rankingMap->insert(std::make_pair(expRanking->getExploit(),expRanking));
					rankingMap1->insert(std::make_pair(expRanking->getExploit(),expRanking));
				}
				data1->excHandle(MAKEINT64(WCH_LockData,0));
				unsigned short mapsize = m_stream->_readUShort();
				unsigned short myrank = m_stream->_readUShort();
				//data->excHandle(MAKEINT64(WCH_LockData,0));
				int totalPage = ceil((float)mapsize/(float)pageCount);
				if(totalPage == 0) totalPage = 1;
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
				data1->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
				//braindata->inputParam(WCHDATA_JXJMyRanking,&myrank);
				data1->inputParam(WCHDATA_JXJMyRanking,&myrank);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIExploitRankingMethod
//
/////////////////////////////////////////
crJXJUIExploitRankingMethod::crJXJUIExploitRankingMethod():
	m_this(NULL){}
crJXJUIExploitRankingMethod::crJXJUIExploitRankingMethod(const crJXJUIExploitRankingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_upgradeRequire(handle.m_upgradeRequire),
	m_upgrade(handle.m_upgrade),
	m_rankingList(handle.m_rankingList)
{
}
void crJXJUIExploitRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIExploitRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_upgradeRequire = str;
		break;
	case 1:
		m_upgrade = str;
		break;
	case 2:
		m_rankingList = str;
		break;
	}
}

void crJXJUIExploitRankingMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{	
		crStaticTextWidgetNode *upgradeRequire = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_upgradeRequire));
		crButtonWidgetNode *upgrade = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_upgrade));
		crTableWidgetNode *rankingList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_rankingList));
		void *param;
		crRole *mainRole = myPlayer->getMainRole();
		crData *data = mainRole->getDataClass();
		data->getParam(WCHDATA_JXJGovPost,param);
		unsigned char post = *(unsigned char*)param;
		int npost = post+1;
		ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
		int rowcount = postTab->getRowCount();
		if(npost>rowcount) 
		{
			npost = rowcount;
			upgrade->setEnable(false);
		}
		else
		{
			upgrade->setEnable(true);
		}
		int expid = postTab->getTitleIndex("功勋");
		crTableIO::StrVec record;
		postTab->queryOneRecord(0,crArgumentParser::appItoa(npost),record);
		data->getParam(WCHDATA_JXJExploit,param);
		int exp = *(int *)param;
		std::string upgradeRequireStr = "功勋:"+record[expid];
		upgradeRequire->setString(upgradeRequireStr);
		int nexp = atoi(record[expid].c_str());
		//到最后5级还需要排名条件
		if(nexp<=exp)
		{
			//upgrade->setEnable(true);
			upgradeRequire->setColor(crVector4(0.0f,0.0f,0.0f,1.0f));
		}
		else
		{
			upgrade->setEnable(false);
			upgradeRequire->setColor(crVector4(1.0f,0.0f,0.0f,1.0f));
		}

		//ref_ptr<crTableIO>govPostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
		//crData *rankingUI = m_this->getDataClass();
		//rankingUI->excHandle(MAKEINT64(WCH_LockData,1));
		//rankingUI->getParam(WCHDATA_JXJExpRankingMap,param);
		//ExpRankingMap *expRankingMap = (ExpRankingMap *)param;
		//if(rankingList)
		//{
		//	rankingList->clearData();
		//	int row = 0;
		//	crPlayerRanking *expRank;
		//	unsigned char postid;
		//	for( ExpRankingMap::iterator itr = expRankingMap->begin();
		//		itr != expRankingMap->end();
		//		++itr,row++ )
		//	{
		//		expRank = itr->second.get();
		//		rankingList->addData(0,row,crArgumentParser::appItoa(row+1));
		//		rankingList->addData(1,row,crArgumentParser::appItoa(itr->first));
		//		rankingList->addData(2,row,expRank->getName());
		//		postid = expRank->getGovpost();
		//		govPostTab->queryOneRecord(0,crArgumentParser::appItoa(postid),record);
		//		rankingList->addData(3,row,record[1]);
		//		rankingList->addData(4,row,record[2]);
		//	}
		//	//rankingList->selectRow(0);
		//}
		//rankingUI->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSaleCountValidCheckMethod
//
/////////////////////////////////////////
crJXJSaleCountValidCheckMethod::crJXJSaleCountValidCheckMethod():
	m_this(NULL),
	m_check(NULL)
{
}

crJXJSaleCountValidCheckMethod::crJXJSaleCountValidCheckMethod(const crJXJSaleCountValidCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_check(NULL)
{
}

void crJXJSaleCountValidCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_check = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_check = (SaleCountCheck *)(LOINT64(param64));
		}
		else
		{
			m_check = NULL;
		}
		break;
	}
}

void crJXJSaleCountValidCheckMethod::addParam(int i, const std::string& str)
{
}

void crJXJSaleCountValidCheckMethod::operator()(crHandle &handle)
{
	if(m_this && m_check)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		do 
		{
			int maxSaleNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxSaleNum,viplv).c_str());
			data->getParam(WCHDATA_JXJSaleList,param);
			SaleList *saleList = (SaleList *)param;
			int num = saleList->size();
			if(num>=maxSaleNum)
			{
				m_check->m_code = -1;
				break;
			}
			int salecount = 0;
			for( SaleList::iterator itr = saleList->begin();
				 itr != saleList->end();
				 ++itr )
			{
				salecount += (*itr)->getCount();
			}
			data->getParam(WCHDATA_JXJShijilv,param);
			unsigned char shijilv = *(unsigned char *)param;
			ref_ptr<crTableIO>shijiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShijiTab);
			crTableIO::StrVec record;
			shijiTab->queryOneRecord(0,crArgumentParser::appItoa((int)shijilv),record);
			int maxcount = atoi(record[1].c_str());
			int remaincount = maxcount - salecount;
			if(m_check->m_count>remaincount)
			{
				m_check->m_code = -2;
				break;
			}
			if(m_check->m_gtypeid == GT_Res)
			{
				data->getParam(m_check->m_goodsid,param);
				int mycount = *(int *)param;
				if(m_check->m_count>mycount)
				{
					m_check->m_code = -3;
					break;
				}
			}
			else if(m_check->m_gtypeid == GT_TroopsEquip)
			{
				data->getParam(WCHDATA_JXJTroopsEquipMap,param);
				TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
				TroopsEquipMap::iterator itr = equipMap->find((unsigned short)(m_check->m_goodsid));
				if(itr != equipMap->end())
				{
					if(m_check->m_count>itr->second)
					{
						m_check->m_code = -3;
						break;
					}
				}
				else
				{
					m_check->m_code = -3;
					break;
				}
			}
			else
			{
				m_check->m_code = -3;
				break;
			}
			m_check->m_code = 1;
		} while (0);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUISalePageUpdateMethod
//
/////////////////////////////////////////
crJXJUISalePageUpdateMethod::crJXJUISalePageUpdateMethod():
m_this(NULL)
{
}
crJXJUISalePageUpdateMethod::crJXJUISalePageUpdateMethod(const crJXJUISalePageUpdateMethod& handle):
crMethod(handle),
m_this(NULL),
m_foodInventory(handle.m_foodInventory),
m_woodInventory(handle.m_woodInventory),
m_ironInventory(handle.m_ironInventory),
m_horseInventory(handle.m_horseInventory),
m_foodCount(handle.m_foodCount),
m_woodCount(handle.m_woodCount),
m_ironCount(handle.m_ironCount),
m_horseCount(handle.m_horseCount),
m_foodPrice(handle.m_foodPrice),
m_woodPrice(handle.m_woodPrice),
m_ironPrice(handle.m_ironPrice),
m_horsePrice(handle.m_horsePrice),
m_foodTotal(handle.m_foodTotal),
m_woodTotal(handle.m_woodTotal),
m_ironTotal(handle.m_ironTotal),
m_horseTotal(handle.m_horseTotal),
m_remainCount(handle.m_remainCount),
m_nextlvCount(handle.m_nextlvCount),
m_foodBtn(handle.m_foodBtn),
m_woodBtn(handle.m_woodBtn),
m_ironBtn(handle.m_ironBtn),
m_horseBtn(handle.m_horseBtn)
{
}
void crJXJUISalePageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUISalePageUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foodInventory = str;
		break;
	case 1:
		m_woodInventory = str;
		break;
	case 2:
		m_ironInventory = str;
		break;
	case 3:
		m_horseInventory = str;
		break;
	case 4:
		m_foodCount = str;
		break;
	case 5:
		m_woodCount = str;
		break;
	case 6:
		m_ironCount = str;
		break;
	case 7:
		m_horseCount = str;
		break;
	case 8:
		m_foodPrice = str;
		break;
	case 9:
		m_woodPrice = str;
		break;
	case 10:
		m_ironPrice = str;
		break;
	case 11:
		m_horsePrice = str;
		break;
	case 12:
		m_foodTotal = str;
		break;
	case 13:
		m_woodTotal = str;
		break;
	case 14:
		m_ironTotal = str;
		break;
	case 15:
		m_horseTotal = str;
		break;
	case 16:
		m_remainCount = str;
		break;
	case 17:
		m_nextlvCount = str;
		break;
	case 18:
		m_foodBtn = str;
		break;
	case 19:
		m_woodBtn = str;
		break;
	case 20:
		m_ironBtn = str;
		break;
	case 21:
		m_horseBtn = str;
		break;
	case 22:
		m_foodCountControl = str;
		break;
	case 23:
		m_woodCountControl = str;
		break;
	case 24:
		m_ironCountControl = str;
		break;
	case 25:
		m_horseCountControl = str;
		break;
	case 26:
		m_foodPriceReduce = str;
		break;
	case 27:
		m_woodPriceReduce = str;
		break;
	case 28:
		m_ironPriceReduce = str;
		break;
	case 29:
		m_horsePriceReduce = str;
		break;
	case 30:
		m_foodPriceAdd = str;
		break;
	case 31:
		m_woodPriceAdd = str;
		break;
	case 32:
		m_ironPriceAdd = str;
		break;
	case 33:
		m_horsePriceAdd = str;
		break;
	}
}
void crJXJUISalePageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crStaticTextWidgetNode *foodInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodInventory));
		crStaticTextWidgetNode *woodInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodInventory));
		crStaticTextWidgetNode *ironInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironInventory));
		crStaticTextWidgetNode *horseInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseInventory));
		crEditWidgetNode *foodCount = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_foodCount));
		crEditWidgetNode *woodCount = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_woodCount));
		crEditWidgetNode *ironCount = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_ironCount));
		crEditWidgetNode *horseCount = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_horseCount));
		crEditWidgetNode *foodPrice = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_foodPrice));
		crEditWidgetNode *woodPrice = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_woodPrice));
		crEditWidgetNode *ironPrice = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_ironPrice));
		crEditWidgetNode *horsePrice = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_horsePrice));
		crStaticTextWidgetNode *foodTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodTotal));
		crStaticTextWidgetNode *woodTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodTotal));
		crStaticTextWidgetNode *ironTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironTotal));
		crStaticTextWidgetNode *horseTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseTotal));
		crStaticTextWidgetNode *remainCount = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_remainCount));
		crStaticTextWidgetNode *nextlvCount = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nextlvCount));
		crButtonWidgetNode *foodBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_foodBtn));
		crButtonWidgetNode *woodBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_woodBtn));
		crButtonWidgetNode *ironBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ironBtn));
		crButtonWidgetNode *horseBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_horseBtn));

		crScrollBarWidgetNode *foodControl = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_foodCountControl));
		crScrollBarWidgetNode *woodControl = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_woodCountControl));
		crScrollBarWidgetNode *ironControl = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_ironCountControl));
		crScrollBarWidgetNode *horseControl = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_horseCountControl));
		
		crButtonWidgetNode *foodAdd = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_foodPriceAdd));
		crButtonWidgetNode *foodReduce = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_foodPriceReduce));
		crButtonWidgetNode *woodAdd = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_woodPriceAdd));
		crButtonWidgetNode *woodReduce = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_woodPriceReduce));
		crButtonWidgetNode *ironAdd = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ironPriceAdd));
		crButtonWidgetNode *ironReduce = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_ironPriceReduce));
		crButtonWidgetNode *horseAdd = dynamic_cast<crButtonWidgetNode *>(m_this ->getWidget(m_horsePriceAdd));
		crButtonWidgetNode *horseReduce = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_horsePriceReduce));

		std::string str;
		ref_ptr<crTableIO>shijiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShijiTab);
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFood,param);
		int food = *(int *)param;
		str = crArgumentParser::appItoa(food);//"现有粮食："
		foodInventory->setString(str);
		
		data->getParam(WCHDATA_JXJWood,param);
		int wood = *(int *)param;
		str = crArgumentParser::appItoa(wood);//"现有木材："
		woodInventory->setString(str);
		
		data->getParam(WCHDATA_JXJIron,param);
		int iron = *(int *)param;
		str = crArgumentParser::appItoa(iron);//"现有铁矿："
		ironInventory->setString(str);

		data->getParam(WCHDATA_JXJHorse,param);
		int horse = *(int *)param;
		str = crArgumentParser::appItoa(horse);//"现有马匹："
		horseInventory->setString(str);

		data->getParam(WCHDATA_JXJShijilv,param);
		unsigned char shijilv = *(unsigned char *)param;
		int id = shijiTab->getRowByID((int)shijilv);
		int maxcount = atoi((*shijiTab)(id,1).c_str());
		

		data->getParam(WCHDATA_JXJSaleList,param);
		SaleList *saleList = (SaleList *)param;
		int salecount = 0;
		for( SaleList::iterator itr = saleList->begin();
			itr != saleList->end();
			++itr )
		{
			salecount += (*itr)->getCount();
		}
		int remaincount = maxcount - salecount;
		if (remaincount < 0)
		{
			remaincount = 0;
		}
		str = crArgumentParser::appItoa(remaincount);//剩余可售资源总量
		remainCount->setString(str);

		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		unsigned char maxbuildinglv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str()));
		if(shijilv<maxbuildinglv)
		{
			int nextcount = atoi((*shijiTab)(id+1,1).c_str());
			str = crArgumentParser::appItoa(nextcount);//下等级可售资源总量
			nextlvCount->setString(str);
			nextlvCount->setVisiable(true);
		}
		else
		{
			nextlvCount->setVisiable(false);
		}

		if(remaincount==0)
		{
			foodCount->setString(L"0");
			woodCount->setString(L"0");
			ironCount->setString(L"0");
			horseCount->setString(L"0");
			foodPrice->setString(L"0");
			woodPrice->setString(L"0");
			horsePrice->setString(L"0");
			ironPrice->setString(L"0");
			foodTotal->setString(L"0");
			woodTotal->setString(L"0");
			ironTotal->setString(L"0");
			horseTotal->setString(L"0");
			foodCount->setEnable(false);
			woodCount->setEnable(false);
			ironCount->setEnable(false);
			horseCount->setEnable(false);
			foodPrice->setEnable(false);
			woodPrice->setEnable(false);
			ironPrice->setEnable(false);
			horsePrice->setEnable(false);
			foodBtn->setEnable(false);
			woodBtn->setEnable(false);
			ironBtn->setEnable(false);
			horseBtn->setEnable(false);
			foodControl->setValue(0);
			foodControl->setEnable(false);
			woodControl->setValue(0);
			woodControl->setEnable(false);
			ironControl->setValue(0);
			ironControl->setEnable(false);
			horseControl->setValue(0);
			horseControl->setEnable(false);
			foodAdd->setEnable(false);
			woodAdd->setEnable(false);
			ironAdd->setEnable(false);
			horseAdd->setEnable(false);
			foodReduce->setEnable(false);
			woodReduce->setEnable(false);
			ironReduce->setEnable(false);
			horseReduce->setEnable(false);
		}
		else
		{
			int inputcount,price,controlmax;
			if(food>0)
			{
				inputcount = _wtoi(foodCount->getString().c_str());
				inputcount = CRCore::minimum(inputcount,remaincount);
				controlmax = CRCore::minimum(food,remaincount) / 1000 * 1000;
				foodControl->setRange(0.0f,(float)controlmax);
				foodControl->setLineValue(1000.0f);
				foodControl->setValue( inputcount/*/(float)controlmax*/);
				if(inputcount>food)
					inputcount = food;
				foodCount->setString(crArgumentParser::appItoa(inputcount));
				foodCount->setEnable(true);
				foodPrice->setEnable(true);
				foodControl->setEnable(true);
				foodAdd->setEnable(true);
				foodReduce->setEnable(true);
				price = _wtoi(foodPrice->getString().c_str());
				if (inputcount!=0)
				{
					if (price > (INT_MAX/inputcount))
					{
						price = INT_MAX/inputcount;
						foodPrice->setString(crArgumentParser::appItoa(price));
					}
				}
				foodTotal->setString(crArgumentParser::appItoa(inputcount * price));
				foodBtn->setEnable(inputcount * price>0);
			}
			else
			{
				foodCount->setString(L"0");
				foodPrice->setString(L"0");
				foodTotal->setString(L"0");
				foodCount->setEnable(false);
				foodPrice->setEnable(false);
				foodBtn->setEnable(false);
				foodControl->setValue(0);
				foodControl->setEnable(false);
				foodAdd->setEnable(false);
				foodReduce->setEnable(false);
			}
			if(wood>0)
			{
				inputcount = _wtoi(woodCount->getString().c_str());
				inputcount = CRCore::minimum(inputcount,remaincount);
				controlmax = CRCore::minimum(wood,remaincount) / 1000 * 1000;
				woodControl->setRange(0.0f,(float)controlmax);
				woodControl->setLineValue(1000.0f);
				woodControl->setValue( inputcount/*/(float)controlmax*/);
				if(inputcount>wood)
					inputcount = wood;
				woodCount->setString(crArgumentParser::appItoa(inputcount));
				woodCount->setEnable(true);
				woodPrice->setEnable(true);
				woodControl->setEnable(true);
				woodAdd->setEnable(true);
				woodReduce->setEnable(true);
				price = _wtoi(woodPrice->getString().c_str());
				if (inputcount!=0)
				{
					if (price > (INT_MAX/inputcount))
					{
						price = INT_MAX/inputcount;
						woodPrice->setString(crArgumentParser::appItoa(price));
					}
				}
				woodTotal->setString(crArgumentParser::appItoa(inputcount * price));
				woodBtn->setEnable(inputcount * price>0);
			}
			else
			{
				woodCount->setString(L"0");
				woodPrice->setString(L"0");
				woodTotal->setString(L"0");
				woodCount->setEnable(false);
				woodPrice->setEnable(false);
				woodBtn->setEnable(false);
				woodControl->setValue(0);
				woodControl->setEnable(false);
				woodAdd->setEnable(false);
				woodReduce->setEnable(false);
			}
			if(iron>0)
			{
				inputcount = _wtoi(ironCount->getString().c_str());
				inputcount = CRCore::minimum(inputcount,remaincount);
				controlmax = CRCore::minimum(iron,remaincount) / 1000 * 1000;
				ironControl->setRange(0.0f,(float)controlmax);
				ironControl->setLineValue(1000.0f);
				ironControl->setValue( inputcount/*/(float)controlmax*/);
				if(inputcount>iron)
					inputcount = iron;
				ironCount->setString(crArgumentParser::appItoa(inputcount));
				ironCount->setEnable(true);
				ironPrice->setEnable(true);
				ironPrice->setEnable(true);
				ironAdd->setEnable(true);
				ironReduce->setEnable(true);
				price = _wtoi(ironPrice->getString().c_str());
				if (inputcount!=0)
				{
					if (price > (INT_MAX/inputcount))
					{
						price = INT_MAX/inputcount;
						ironPrice->setString(crArgumentParser::appItoa(price));
					}
				}
				ironTotal->setString(crArgumentParser::appItoa(inputcount * price));
				ironBtn->setEnable(inputcount * price>0);
			}
			else
			{
				ironCount->setString(L"0");
				ironPrice->setString(L"0");
				ironTotal->setString(L"0");
				ironCount->setEnable(false);
				ironPrice->setEnable(false);
				ironBtn->setEnable(false);
				ironControl->setValue(0);
				ironControl->setEnable(false);
				ironAdd->setEnable(false);
				ironReduce->setEnable(false);
			}
			if(horse>0)
			{
				inputcount = _wtoi(horseCount->getString().c_str());
				inputcount = CRCore::minimum(inputcount,remaincount);
				controlmax = CRCore::minimum(horse,remaincount) / 1000 * 1000;
				horseControl->setRange(0.0f,(float)controlmax);
				horseControl->setLineValue(1000.0f);
				horseControl->setValue( inputcount/*/(float)controlmax*/);
				if(inputcount>horse)
					inputcount = horse;
				horseCount->setString(crArgumentParser::appItoa(inputcount));
				horseCount->setEnable(true);
				horsePrice->setEnable(true);
				horseControl->setEnable(true);
				horseAdd->setEnable(true);
				horseReduce->setEnable(true);
				price = _wtoi(horsePrice->getString().c_str());
				if (inputcount!=0)
				{
					if (price > (INT_MAX/inputcount))
					{
						price = INT_MAX/inputcount;
						horsePrice->setString(crArgumentParser::appItoa(price));
					}
				}
				horseTotal->setString(crArgumentParser::appItoa(inputcount * price));
				horseBtn->setEnable(inputcount * price>0);
			}
			else
			{
				horseCount->setString(L"0");
				horsePrice->setString(L"0");
				horseTotal->setString(L"0");
				horseCount->setEnable(false);
				horsePrice->setEnable(false);
				horseBtn->setEnable(false);
				horseControl->setValue(0);
				horseControl->setEnable(false);
				horseAdd->setEnable(false);
				horseReduce->setEnable(false);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUISaleMethod
//
/////////////////////////////////////////
crJXJUISaleMethod::crJXJUISaleMethod():
m_this(NULL)
{
}
crJXJUISaleMethod::crJXJUISaleMethod(const crJXJUISaleMethod& handle):
crMethod(handle),
m_this(NULL),
m_goodsType(handle.m_goodsType),
m_priceInput(handle.m_priceInput),
m_countInput(handle.m_countInput)
{
}
void crJXJUISaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISaleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_goodsType);
		break;
	case 1:
		m_priceInput = str;
		break;
	case 2:
		m_countInput = str;
		break;
	}
}
void crJXJUISaleMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crEditWidgetNode *priceInput = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_priceInput));
		crEditWidgetNode *countInput = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_countInput));
		int price = _wtoi(priceInput->getString().c_str());
		int count = _wtoi(countInput->getString().c_str());
		if(count>0 && price>0)
		{
			SaleCountCheck check;
			check.m_gtypeid = m_goodsType[0];
			check.m_goodsid = m_goodsType[1];
			check.m_count = count;
			myPlayer->doEvent(WCH_JXJSaleCountValidCheck,MAKEINT64(&check,NULL));
			if(check.m_code>0)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(16);
				stream->_writeInt(m_goodsType[0]);
				stream->_writeInt(m_goodsType[1]);
				stream->_writeInt(price);
				stream->_writeInt(count);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvSale,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSaleMethod
//
/////////////////////////////////////////
crJXJRecvSaleMethod::crJXJRecvSaleMethod():
	m_netType(GameClient_Game){}
crJXJRecvSaleMethod::crJXJRecvSaleMethod(const crJXJRecvSaleMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_foodinput(handle.m_foodinput),
	m_woodinput(handle.m_woodinput),
	m_ironinput(handle.m_ironinput),
	m_horseinput(handle.m_horseinput)
{
}
void crJXJRecvSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSaleMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_foodinput = str;
		break;
	case 2:
		m_woodinput = str;
		break;
	case 3:
		m_ironinput = str;
		break;
	case 4:
		m_horseinput = str;
		break;
	}
}
void crJXJRecvSaleMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int gtypeid = m_stream->_readInt();
				int gid = m_stream->_readInt();
				int price = m_stream->_readInt();
				int count = m_stream->_readInt();
				char id = -1;
				char done = 0;
				SaleCountCheck check;
				check.m_gtypeid = gtypeid;
				check.m_goodsid = gid;
				check.m_count = count;
				m_this->doEvent(WCH_JXJSaleCountValidCheck,MAKEINT64(&check,NULL));
				if(check.m_code>0)
				{
					void *param;
					crData *data = m_this->getDataClass();
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					data->getParam(WCHDATA_JXJSaleList,param);
					SaleList *saleList = (SaleList *)param;
					ref_ptr<crSale> sale = new crSale;
					GInitCharIDArray();
					for( SaleList::iterator itr = saleList->begin();
						itr != saleList->end();
						++itr )
					{
						GSetCharID((*itr)->getSaleListID());
					}
					id = GGainCharID();
					if(id>=0)
					{
						//扣除
						if(gtypeid == GT_Res)
						{
							data->getParam(gid,param);
							int* mycount = (int *)param;
							*mycount -= count;
						}
						else if(gtypeid == GT_TroopsEquip)
						{
							data->getParam(WCHDATA_JXJTroopsEquipMap,param);
							TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
							TroopsEquipMap::iterator itr = equipMap->find((unsigned short)gid);
							if(itr != equipMap->end())
							{
								itr->second -= count;
							}
						}
						//加入
						sale->setSaleListID(id);
						sale->setGoodsType(gtypeid);
						sale->setGoodsID(gid);
						sale->setPrice(price);
						sale->setCount(count);
						short t = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSaleDisposeOvertime,viplv).c_str()));
						sale->prepareTimer() = t;
						saleList->push_back(sale);
						data->excHandle(MAKEINT64(WCH_LockData,0));
						////加入到gameserver处理队列
						crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
						serverData->excHandle(MAKEINT64(WCH_LockData,1));
						serverData->getParam(WCHDATA_JXJSaleDisposeDeq,param);
						SaleDisposeDeq *saleDisposeDeq = (SaleDisposeDeq *)param;
						bool found = false;
						for( SaleDisposeDeq::iterator itr = saleDisposeDeq->begin();
							itr != saleDisposeDeq->end();
							++itr )
						{
							if(*itr == playerid)
							{
								found = true;
								break;
							}
						}
						if(!found)
						{
							saleDisposeDeq->push_back(playerid);
						}
						serverData->excHandle(MAKEINT64(WCH_LockData,0));
						done = 1;
					}
					else
					{
						data->excHandle(MAKEINT64(WCH_LockData,0));
					}
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				crPlayerDataEventPacket packet;
				stream->createBuf(18);
				stream->_writeChar(done);
				if(done==1)
				{
					stream->_writeChar(id);
					stream->_writeInt(gtypeid);
					stream->_writeInt(gid);
					stream->_writeInt(price);
					stream->_writeInt(count);
				}
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvSale,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = "市场寄售：" + crArgumentParser::appVectoa(crVector3i(gtypeid,gid,done));
				GameLogData gamelog(Log_MarketSale,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}				
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				char id = m_stream->_readChar();
				int gtypeid = m_stream->_readInt();
				int gid = m_stream->_readInt();
				int price = m_stream->_readInt();
				int count = m_stream->_readInt();

				
				ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if(canvas.valid())
				{
					crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodinput));
					crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodinput));
					crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironinput));
					crStaticTextWidgetNode *horse = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseinput));
					std::string str = "0";
					if (gid == WCHDATA_JXJFood)
					{
						if (food)
						{
							food->setString(str);
						}
					}
					if (gid == WCHDATA_JXJWood)
					{
						if (wood)
						{
							wood->setString(str);
						}
					}

					if (gid == WCHDATA_JXJIron)
					{
						if (iron)
						{
							iron->setString(str);
						}
					}

					if (gid == WCHDATA_JXJHorse)
					{
						if (horse)
						{
							horse->setString(str);
						}
					}
				}
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				//扣除
				if(gtypeid == GT_Res)
				{
					data->getParam(gid,param);
					int* mycount = (int *)param;
					*mycount -= count;
				}
				else if(gtypeid == GT_TroopsEquip)
				{
					data->getParam(WCHDATA_JXJTroopsEquipMap,param);
					TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
					TroopsEquipMap::iterator itr = equipMap->find((unsigned short)gid);
					if(itr != equipMap->end())
					{
						itr->second -= count;
					}
				}
				//加入
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJSaleList,param);
				SaleList *saleList = (SaleList *)param;
				ref_ptr<crSale> sale = new crSale;
				sale->setSaleListID(id);
				sale->setGoodsType(gtypeid);
				sale->setGoodsID(gid);
				sale->setPrice(price);
				sale->setCount(count);
				short t = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSaleDisposeOvertime,viplv).c_str()));
				sale->prepareTimer() = t;
				saleList->push_back(sale);
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSaleDisposeMethod
//
/////////////////////////////////////////
crJXJSaleDisposeMethod::crJXJSaleDisposeMethod():
m_this(NULL),
m_availableTime(0.02f){}
crJXJSaleDisposeMethod::crJXJSaleDisposeMethod(const crJXJSaleDisposeMethod& handle):
crMethod(handle),
m_this(NULL),
m_availableTime(handle.m_availableTime)
{
}
void crJXJSaleDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaleDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_availableTime = atof(str.c_str());
		break;
	}
}

void crJXJSaleDisposeMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJSaleDisposeDeq,param);
		SaleDisposeDeq *disposeDeq = (SaleDisposeDeq *)param;
		if(!disposeDeq->empty())
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			crPlayerGameData *playerGameData;
			crData *gameData;
			const CRCore::Timer& timer = *CRCore::Timer::instance();
			CRCore::Timer_t start_tick = timer.tick();
			float elapsedTime = 0.0f;

			int playerid;
			SaleList *saleList;
			SaleList::iterator sitr;
			ref_ptr<crSale>sale;

			ref_ptr<crInsertSale> insertSale = new crInsertSale;
			ref_ptr<crRemoveSale> removeSale = new crRemoveSale;
			ref_ptr<crMySaleStateQueryData> querySale = new crMySaleStateQueryData;
			crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
			ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
			int insertid;
			unsigned char salestate;
			crDBSavePacket packet;
			unsigned char viplv;
			unsigned char validTerm;
			int count;
			ref_ptr<crStreamBuf> cstream = new crStreamBuf;
			cstream->createBuf(5);
			crPlayerDataEventPacket cpacket;
			//while(elapsedTime<m_availableTime && !disposeDeq->empty())
			bool erased = false;
			for( SaleDisposeDeq::iterator itr = disposeDeq->begin();
				 itr != disposeDeq->end() && elapsedTime<m_availableTime;
				 )
			{
				erased = false;
				playerid = *itr;//disposeDeq->front();
				//disposeDeq->pop_front();
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid() && playerData->getSceneID()==0)
				{
					playerGameData = playerData->getPlayerGameData();
					if(playerGameData)
					{
						gameData = playerGameData->getDataClass();
						if(gameData)
						{
							gameData->excHandle(MAKEINT64(WCH_LockData,1));
							gameData->getParam(WCHDATA_JXJVipLv,param);
							viplv = *(unsigned char *)param;
							validTerm = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSaleValidterm,viplv).c_str()));
							gameData->getParam(WCHDATA_JXJSaleList,param);
							saleList = (SaleList *)param;
							for( sitr = saleList->begin();
								 sitr != saleList->end();
								 ++sitr )
							{
								sale = sitr->get();
								salestate = sale->getSaleState();
								count = sale->getCount();
								if(salestate == Sale_Cancel)
								{
									querySale->buildQuerySql(sale->getSaleID());
									dbSession->executeQuery(querySale.get());
									crDataBase::QueryResultVec &querySaleResultVec = dbSession->getQueryResult();
									if(!querySaleResultVec.empty())
									{
										querySale = dynamic_cast<crMySaleStateQueryData *>(querySaleResultVec[0].get());
										sale->setSaleState(querySale->getSaleState());
										sale->setGaincash(querySale->getGaincash());
									}
									dbSession->releaseQuery();
									if(sale->getSaleState() != Sale_Saled)
									{
										switch (sale->getGoodsType())
										{
										case GT_Res:
											{
												gameData->getParam(sale->getGoodsID(),param);
												int *resource = (int *)param;
												INTLIMITADD(*resource,count,INT_MAX);
											}
											break;
										case GT_TroopsEquip:
											{
												gameData->getParam(WCHDATA_JXJTroopsEquipMap,param);
												TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
												INTLIMITADD((*troopsEquipMap)[sale->getGoodsID()],count,INT_MAX);
											}
											break;
										}
										removeSale->buildUpdateSql(sale->getSaleID());
										crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,removeSale.get());
										dbConductor->getNetManager()->sendPacket("all",packet);
										//if(dbSession->executeUpdate(removeSale.get()))
										//{
										sale->setSaleState(Sale_Canceled);
										sale->saleTimer() = 0;
										cstream->seekBegin();
										cstream->_writeInt(sale->getSaleID());
										cstream->_writeUChar(Sale_Canceled);
										crPlayerDataEventPacket::buildReplyPacket(cpacket,playerid,WCH_JXJRecvSaleStateChange,cstream.get());
										gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),cpacket);
										//	dbSession->commit();
										//}
									}
								}
								else if(salestate == Sale_Prepare && sale->prepareTimer() > 1)
								{//往数据库里添加
									insertSale->buildUpdateSql(playerid,playerData->getCharacterName(),sale->getGoodsType(),sale->getGoodsID(),sale->getPrice(),sale->getCount(),validTerm,Sale_OnSale);
									//crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,insertSale.get());
									//dbConductor->getNetManager()->sendPacket("all",packet);
									if(dbSession->executeUpdate(insertSale.get()))
									{
										insertid = dbSession->getInsertID();
										sale->setSaleID(insertid);
										sale->setSaleState(Sale_OnSale);
										sale->saleTimer() = (int)validTerm * 86400;
										dbSession->commit();
										itr = disposeDeq->erase(itr);
										erased = true;
										cstream->seekBegin();
										cstream->_writeInt(sale->getSaleID());
										cstream->_writeUChar(Sale_OnSale);
										crPlayerDataEventPacket::buildReplyPacket(cpacket,playerid,WCH_JXJRecvSaleStateChange,cstream.get());
										gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),cpacket);
									}
								}
								else if(salestate == Sale_OnSale)
								{
									querySale->buildQuerySql(sale->getSaleID());
									dbSession->executeQuery(querySale.get());
									crDataBase::QueryResultVec &querySaleResultVec = dbSession->getQueryResult();
									if(!querySaleResultVec.empty())
									{
										querySale = dynamic_cast<crMySaleStateQueryData *>(querySaleResultVec[0].get());
										sale->setSaleState(querySale->getSaleState());
										sale->setGaincash(querySale->getGaincash());
									}
									dbSession->releaseQuery();
								}
								else if(salestate == Sale_Saled)
								{//东西已经卖出
									sale->setSaleState(Sale_Receive);
									sale->saleTimer() = 0;
									//cstream->_writeInt(sale->getSaleID());
									//cstream->_writeUChar(Sale_Receive);
									//crPlayerDataEventPacket::buildReplyPacket(cpacket,playerid,WCH_JXJRecvSaleStateChange,cstream.get());
									//gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),cpacket);
								}
								else if(salestate == Sale_Receive)
								{//收取铜钱
									playerGameData->doEvent(WCH_JXJRecvCoppercash,MAKEINT64(sale->getGaincash(),NULL));
									removeSale->buildUpdateSql(sale->getSaleID());
									crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,removeSale.get());
									dbConductor->getNetManager()->sendPacket("all",packet);

									sale->setSaleState(Sale_Received);
									sale->saleTimer() = 0;
									cstream->seekBegin();
									cstream->_writeInt(sale->getSaleID());
									cstream->_writeUChar(Sale_Received);
									crPlayerDataEventPacket::buildReplyPacket(cpacket,playerid,WCH_JXJRecvSaleStateChange,cstream.get());
									gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),cpacket);
								}
							}
							gameData->excHandle(MAKEINT64(WCH_LockData,0));
						}
					}
					if(!erased) ++itr;
				}
				else
				{
					itr = disposeDeq->erase(itr);
				}
				elapsedTime = timer.delta_s(start_tick,timer.tick());
			}
			gameglobaldb->endSession(dbSession.get());
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJOnMarketMySalePageMethod
//
/////////////////////////////////////////
crJXJOnMarketMySalePageMethod::crJXJOnMarketMySalePageMethod()
{
}
crJXJOnMarketMySalePageMethod::crJXJOnMarketMySalePageMethod(const crJXJOnMarketMySalePageMethod& handle):
	crMethod(handle)
{
}
void crJXJOnMarketMySalePageMethod::inputParam(int i, void *param)
{
}
void crJXJOnMarketMySalePageMethod::addParam(int i, const std::string& str)
{
}
void crJXJOnMarketMySalePageMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJSaleList,param);
		SaleList *saleList = (SaleList *)param;
		bool refresh = false;
		for( SaleList::iterator itr = saleList->begin();
			 itr != saleList->end();
			 ++itr )
		{
			if( (*itr)->getSaleState() != Sale_Canceled && (*itr)->getSaleState() != Sale_Received)
			{
				refresh = true;
				break;
			}
		}
		if(refresh)
		{
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOnMarketMySalePage,NULL);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvOnMarketMySalePageMethod
//
/////////////////////////////////////////
crJXJRecvOnMarketMySalePageMethod::crJXJRecvOnMarketMySalePageMethod():
	m_netType(GameClient_Game){}
crJXJRecvOnMarketMySalePageMethod::crJXJRecvOnMarketMySalePageMethod(const crJXJRecvOnMarketMySalePageMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvOnMarketMySalePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvOnMarketMySalePageMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvOnMarketMySalePageMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJSaleList,param);
				SaleList *saleList = (SaleList *)param;
				bool query = false;
				for( SaleList::iterator itr = saleList->begin();
					itr != saleList->end();
					++itr )
				{
					if( (*itr)->getSaleState() != Sale_Canceled && (*itr)->getSaleState() != Sale_Received )
					{
						query = true;
						break;
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				if(query)
				{
					////加入到gameserver处理队列
					crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
					serverData->excHandle(MAKEINT64(WCH_LockData,1));
					serverData->getParam(WCHDATA_JXJSaleDisposeDeq,param);
					SaleDisposeDeq *saleDisposeDeq = (SaleDisposeDeq *)param;
					bool found = false;
					for( SaleDisposeDeq::iterator itr = saleDisposeDeq->begin();
						itr != saleDisposeDeq->end();
						++itr )
					{
						if(*itr == playerid)
						{
							found = true;
							break;
						}
					}
					if(!found)
					{
						saleDisposeDeq->push_back(playerid);
					}
					serverData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJLeaveMarketMethod
//
/////////////////////////////////////////
crJXJLeaveMarketMethod::crJXJLeaveMarketMethod()
{
}
crJXJLeaveMarketMethod::crJXJLeaveMarketMethod(const crJXJLeaveMarketMethod& handle):
	crMethod(handle)
{
}
void crJXJLeaveMarketMethod::inputParam(int i, void *param)
{
}
void crJXJLeaveMarketMethod::addParam(int i, const std::string& str)
{
}
void crJXJLeaveMarketMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvLeaveMarket,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvLeaveMarketMethod
//
/////////////////////////////////////////
crJXJRecvLeaveMarketMethod::crJXJRecvLeaveMarketMethod():
	m_netType(GameClient_Game){}
crJXJRecvLeaveMarketMethod::crJXJRecvLeaveMarketMethod(const crJXJRecvLeaveMarketMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvLeaveMarketMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvLeaveMarketMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvLeaveMarketMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				////加入到gameserver处理队列
				void *param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJSaleDisposeDeq,param);
				SaleDisposeDeq *saleDisposeDeq = (SaleDisposeDeq *)param;
				for( SaleDisposeDeq::iterator itr = saleDisposeDeq->begin();
					itr != saleDisposeDeq->end();
					++itr )
				{
					if(*itr == playerid)
					{
						saleDisposeDeq->erase(itr);
						break;
					}
				}
				serverData->getParam(WCHDATA_JXJQuerySaleDeque,param);
				QuerySaleDeque *querySaleDeque = (QuerySaleDeque *)param;
				bool found = false;
				for( QuerySaleDeque::iterator itr = querySaleDeque->begin(); 
					itr != querySaleDeque->end();
					++itr)
				{
					if((*itr)->getPlayerID()==playerid)
					{
						querySaleDeque->erase(itr);
						break;
					}
				}
				serverData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIMySalePageUpdateMethod
//
/////////////////////////////////////////
crJXJUIMySalePageUpdateMethod::crJXJUIMySalePageUpdateMethod()
{
}
crJXJUIMySalePageUpdateMethod::crJXJUIMySalePageUpdateMethod(const crJXJUIMySalePageUpdateMethod& handle):
	crMethod(handle),
	m_mySaleList(handle.m_mySaleList),
	m_pagenum(handle.m_pagenum)
{
}
void crJXJUIMySalePageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIMySalePageUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mySaleList = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	}
}
void crJXJUIMySalePageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crData *data = playerData->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
		ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
		crTableIO::StrVec record;
		crTableWidgetNode *mySaleList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_mySaleList));
		crStaticTextWidgetNode *pageNum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
		int pagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJShowMysaleCount,viplv).c_str()));
		std::string number= "1/1";

		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->getParam(WCHDATA_JXJCurSalePageNum,param);
		int curpageNum = *(int *)param;
		int total;

		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJSaleList,param);
		SaleList *saleList = (SaleList *)param;
		int cursel = mySaleList->getSelect();
		mySaleList->clearData();
		mySaleList->setDefNull(-1);
		int row = -(curpageNum - 1)*pagecount;
		int gtypeid,goodsid,price,count;
		unsigned char saleState;
		crSale *sale;
		std::string str;
		int times,t;
		int hour,minute,s;
		int i = 1;
		for( SaleList::iterator itr = saleList->begin();
			 itr != saleList->end();
			 ++itr )
		{
			sale = itr->get();
			saleState = sale->getSaleState();
			if(saleState == Sale_Canceled)
				continue;
			if (row >= 0)
			{
				gtypeid = sale->getGoodsType();
				goodsid = sale->getGoodsID();
				if(gtypeid == GT_Res)
				{
					if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(gtypeid),1,crArgumentParser::appItoa(goodsid),record)>=0)
						mySaleList->addData(0,row,record[2]);
				}
				else if(gtypeid == GT_TroopsEquip)
				{
					if(troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(goodsid),record)>=0)
						mySaleList->addData(0,row,record[1]);
				}
				price = sale->getPrice();
				count = sale->getCount();
				mySaleList->addData(1,row,crArgumentParser::appItoa(count));
				mySaleList->addData(2,row,crArgumentParser::appItoa(price));
				mySaleList->addData(3,row,crArgumentParser::appItoa(price * count));
				if(saleState == Sale_Prepare)
				{
					times = sale->prepareTimer();
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					str = "准备上架";//"+crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s);
				}
				else if(saleState == Sale_PrepareOff)
				{
					str = "寄售超时";
				}
				else if(saleState == Sale_OnSale)
				{
					times = sale->saleTimer();
					//hour = times/3600;
					//t = times%3600;
					//minute = t/60;
					//s = t%60;
					str = "在售["+ showtime(times)+"]";//crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s);
				}
				else if(saleState == Sale_Saled)
				{
					str = "已售出";
				}
				else if(saleState == Sale_Off)
				{
					str = "已下架";
				}
				else if(saleState == Sale_Cancel)
				{
					str = "取消中";
				}
				else if(saleState == Sale_Canceled)
				{
					str = "已取消";
				}
				else if(saleState == Sale_Receive)
				{
					str = "领取中";
				}
				else if(saleState == Sale_Received)
				{
					str = "已领取";
				}
				mySaleList->addData(4,row,str);
				mySaleList->addData(row,sale->getSaleListID());
			}
			row++;
			i++;
		}
		total = i;
		int pagetotal = ceil((float)total/(float)pagecount);
		number = crArgumentParser::appItoa(curpageNum)+"/"+crArgumentParser::appItoa(pagetotal);
		brainData->inputParam(WCHDATA_JXJMySaleTotal,&pagetotal);
		if(pageNum)
		{
			pageNum->setString(number);
			pageNum->setAlignment(CRText::crText::CENTER_BASE_LINE);
		}
		mySaleList->selectRow(cursel);
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
std::string crJXJUIMySalePageUpdateMethod::showtime(int times)
{
	std::string str = "即将结束";
	if (times > 2 * 60 * 60)
	{
		str = "中";
	}
	else if (times > 6 * 60 * 60)
	{
		str = "很长";
	}
	return str;
}
/////////////////////////////////////////
//
//crJXJUICancelSaleMethod
//
/////////////////////////////////////////
crJXJUICancelSaleMethod::crJXJUICancelSaleMethod():
	m_this(NULL)
{
}
crJXJUICancelSaleMethod::crJXJUICancelSaleMethod(const crJXJUICancelSaleMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_mySaleList(handle.m_mySaleList)
{
}
void crJXJUICancelSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUICancelSaleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mySaleList = str;
		break;
	}
}
void crJXJUICancelSaleMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crTableWidgetNode *mySaleList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_mySaleList));
		int selectData = mySaleList->getSelectData();
		if(selectData>=0)
		{
			void *param;
			crData *data = myPlayer->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJSaleList,param);
			SaleList *saleList = (SaleList *)param;
			for( SaleList::iterator itr = saleList->begin();
				 itr != saleList->end();
				 ++itr )
			{
				if((*itr)->getSaleListID() == selectData)
				{
					unsigned char state = (*itr)->getSaleState();
					if(state == Sale_Prepare || state == Sale_PrepareOff || state == Sale_OnSale || state == Sale_Off)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(1);
						stream->_writeChar((*itr)->getSaleListID());
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCancelSale,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
						break;
					}
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCancelSaleMethod
//
/////////////////////////////////////////
crJXJRecvCancelSaleMethod::crJXJRecvCancelSaleMethod():
	m_netType(GameClient_Game){}
crJXJRecvCancelSaleMethod::crJXJRecvCancelSaleMethod(const crJXJRecvCancelSaleMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCancelSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCancelSaleMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCancelSaleMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				char done = 0;
				char selectid = m_stream->_readChar();
				void *param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJSaleList,param);
				SaleList *saleList = (SaleList *)param;
				unsigned char oldstate;
				for( SaleList::iterator itr = saleList->begin();
					 itr != saleList->end();
					 ++itr )
				{
					if((*itr)->getSaleListID() == selectid)
					{
						oldstate = (*itr)->getSaleState();
						switch (oldstate)
						{
						case Sale_Prepare:
						case Sale_PrepareOff:
							{//删除并回收
								int count = (*itr)->getCount();
								switch ((*itr)->getGoodsType())
								{
								case GT_Res:
									{
										data->getParam((*itr)->getGoodsID(),param);
										int *mycount = (int *)param;
										INTLIMITADD(*mycount,count,INT_MAX);
									}
									break;
								case GT_TroopsEquip:
									{
										data->getParam(WCHDATA_JXJTroopsEquipMap,param);
										TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
										INTLIMITADD((*troopsEquipMap)[(*itr)->getGoodsID()],count,INT_MAX);
									}
									break;
								}
								(*itr)->setSaleState(Sale_Canceled);
								done = 1;
							}
							break;
						case Sale_OnSale:
						case Sale_Off:
							{
								(*itr)->setSaleState(Sale_Cancel);
								//通知gameserverbrain
								////加入到gameserver处理队列
								serverData->getParam(WCHDATA_JXJSaleDisposeDeq,param);
								SaleDisposeDeq *saleDisposeDeq = (SaleDisposeDeq *)param;
								bool found = false;
								for( SaleDisposeDeq::iterator itr = saleDisposeDeq->begin();
									itr != saleDisposeDeq->end();
									++itr )
								{
									if(*itr == playerid)
									{
										found = true;
										break;
									}
								}
								if(!found)
								{
									saleDisposeDeq->push_back(playerid);
								}
								done = 2;
							}
							break;
						}
						break;
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				serverData->excHandle(MAKEINT64(WCH_LockData,0));
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				crPlayerDataEventPacket packet;
				stream->createBuf(3);
				stream->_writeChar(done);
				if(done>0)
				{
					stream->_writeChar(selectid);
					stream->_writeUChar(oldstate);
				}
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCancelSale,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode > 0)
			{
				char selectid = m_stream->_readChar();
				unsigned char oldstate = m_stream->_readUChar();
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJSaleList,param);
				SaleList *saleList = (SaleList *)param;
				for( SaleList::iterator itr = saleList->begin();
					itr != saleList->end();
					++itr )
				{
					if((*itr)->getSaleListID() == selectid)
					{
						switch (oldstate)
						{
						case Sale_Prepare:
						case Sale_PrepareOff:
							{//删除并回收
								int count = (*itr)->getCount();
								switch ((*itr)->getGoodsType())
								{
								case GT_Res:
									{
										data->getParam((*itr)->getGoodsID(),param);
										int *mycount = (int *)param;
										INTLIMITADD(*mycount,count,INT_MAX)
									}
									break;
								case GT_TroopsEquip:
									{
										data->getParam(WCHDATA_JXJTroopsEquipMap,param);
										TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
										INTLIMITADD((*troopsEquipMap)[(*itr)->getGoodsID()],count,INT_MAX)
									}
									break;
								}
								(*itr)->setSaleState(Sale_Canceled);
							}
							break;
						case Sale_OnSale:
						case Sale_Off:
							(*itr)->setSaleState(Sale_Cancel);
							break;
						}
						break;
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSaleListTimerMethod
//
/////////////////////////////////////////
crJXJSaleListTimerMethod::crJXJSaleListTimerMethod():
	m_dt(0)
{
}
crJXJSaleListTimerMethod::crJXJSaleListTimerMethod(const crJXJSaleListTimerMethod& handle):
	crMethod(handle),
	m_dt(handle.m_dt)
{
}
void crJXJSaleListTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = *((int*)(LOINT64(param64)));
		}
		else
		{
			m_dt = 0;
		}
		break;
	}
}
void crJXJSaleListTimerMethod::addParam(int i, const std::string& str)
{
}
void crJXJSaleListTimerMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_JXJSaleList,param);
			SaleList *saleList = (SaleList *)param;
			unsigned char count = saleList->size();
			if(count>0)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(count*6+1);
				stream->_writeUChar(count);
				for( SaleList::iterator itr = saleList->begin();
					itr != saleList->end();
					++itr )
				{
					if((*itr)->getSaleState() == Sale_Prepare)
					{
						if((*itr)->prepareTimer() > 0)
						{
							(*itr)->prepareTimer() -= m_dt;
						}
						if((*itr)->prepareTimer()<=0)
						{
							(*itr)->prepareTimer() = 0;
							(*itr)->setSaleState(Sale_PrepareOff);
						}
					}
					else if((*itr)->getSaleState() == Sale_OnSale)
					{
						if((*itr)->saleTimer() > 0)
						{
							(*itr)->saleTimer() -= m_dt;
							if((*itr)->saleTimer()<=0)
							{
								(*itr)->saleTimer() = 0;
								//(*itr)->setSaleState(Sale_Off);
							}
						}
					}
					stream->_writeChar((*itr)->getSaleListID());
					stream->_writeUChar((*itr)->getSaleState());
					if((*itr)->getSaleState() == Sale_Prepare)
						stream->_writeShort((*itr)->prepareTimer());
					else if((*itr)->getSaleState() == Sale_OnSale)
						stream->_writeInt((*itr)->saleTimer());
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvSaleListTimer,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSaleListTimerMethod
//
/////////////////////////////////////////
crJXJRecvSaleListTimerMethod::crJXJRecvSaleListTimerMethod():
	m_netType(GameClient_Game){}
crJXJRecvSaleListTimerMethod::crJXJRecvSaleListTimerMethod(const crJXJRecvSaleListTimerMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSaleListTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSaleListTimerMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSaleListTimerMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKEINT64(WCH_LockData,1));
			thisData->getParam(WCHDATA_JXJSaleList,param);
			SaleList *saleList = (SaleList *)param;
			int size = (int)(m_stream->_readUChar());
			std::map<char,crSale*> SaleMap;
			for( SaleList::iterator itr = saleList->begin();
				itr != saleList->end();
				++itr )
			{
				SaleMap[(*itr)->getSaleListID()] = itr->get();
			}
			char id;
			unsigned char state;
			std::map<char,crSale*>::iterator smitr;
			for(int i = 0; i<size; i++)
			{
				id = m_stream->_readChar();
				state = m_stream->_readUChar();
				smitr = SaleMap.find(id);
				if(smitr != SaleMap.end())
				{
					smitr->second->setSaleState(state);
					if(state == Sale_Prepare)
					{
						smitr->second->prepareTimer() = m_stream->_readShort();
					}
					else if(state == Sale_OnSale)
					{
						smitr->second->saleTimer() = m_stream->_readInt();
					}
				}
				else
				{
					if(state == Sale_Prepare)
					{
						m_stream->_readShort();
					}
					else if(state == Sale_OnSale)
					{
						m_stream->_readInt();
					}
				}
			}
			thisData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJOnMarketPlayerSalePageMethod
//
/////////////////////////////////////////
crJXJOnMarketPlayerSalePageMethod::crJXJOnMarketPlayerSalePageMethod():
m_this(NULL)
{
}
crJXJOnMarketPlayerSalePageMethod::crJXJOnMarketPlayerSalePageMethod(const crJXJOnMarketPlayerSalePageMethod& handle):
crMethod(handle),
m_this(NULL),
m_goodsTypeRadio(handle.m_goodsTypeRadio),
m_pagenum(handle.m_pagenum)
{
}
void crJXJOnMarketPlayerSalePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJOnMarketPlayerSalePageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_goodsTypeRadio = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	}
}
void crJXJOnMarketPlayerSalePageMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crRadioGroupWidgetNode *goodsTypeRadio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_goodsTypeRadio));
		crStaticTextWidgetNode *pageNum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
		int selType = goodsTypeRadio->getSelect();
		crData *goodsTypeData = goodsTypeRadio->getDataClass();
		goodsTypeData->getParam(WCHDATA_JXJGoodsVec,param);
		GoodsVec *goodsVec = (GoodsVec *)param;
		//int page = _wtoi(pageNum->getString().c_str());
		//int count = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQuerySaleCount).c_str());
		//int index = page * count;
		int firstpagenum = 1;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKEINT64(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJPlayerSaleRecordVec,param);
		PlayerSaleRecordVec *saleRecordVec = (PlayerSaleRecordVec *)param;
		saleRecordVec->clear();
		brainData->inputParam(WCHDATA_JXJCurSalePageNum,&firstpagenum);
		brainData->inputParam(WCHDATA_JXJSaleTotal,&firstpagenum);
		brainData->excHandle(MAKEINT64(WCH_LockData,0));
		//pageNum->setString(L"1/1");

		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(12);
		stream->_writeVec2i((*goodsVec)[selType]);
		stream->_writeInt(0);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOnMarketPlayerSalePage,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
///////////////////////////////////////////
////
////crJXJUIQueryPlayerSale2Method
////
///////////////////////////////////////////
//crJXJUIQueryPlayerSale2Method::crJXJUIQueryPlayerSale2Method():
//	m_this(NULL)
//{
//}
//crJXJUIQueryPlayerSale2Method::crJXJUIQueryPlayerSale2Method(const crJXJUIQueryPlayerSale2Method& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_goodsTypeRadio(handle.m_goodsTypeRadio)
//{
//}
//void crJXJUIQueryPlayerSale2Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJUIQueryPlayerSale2Method::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_goodsTypeRadio = str;
//		break;
//	}
//}
//void crJXJUIQueryPlayerSale2Method::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	if(myPlayer && netConductor)
//	{
//		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
//		void *param;
//		int start = 0;
//		int curpagenum;///////////////////////////当前页/总页数
//		crRadioGroupWidgetNode *goodsTypeRadio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_goodsTypeRadio));
//		//crStaticTextWidgetNode *pageNum = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_pagenum));
//		int selType = goodsTypeRadio->getSelect();
//		crData *goodsTypeData = goodsTypeRadio->getDataClass();
//		goodsTypeData->getParam(WCHDATA_JXJGoodsVec,param);
//		GoodsVec *goodsVec = (GoodsVec *)param;
//		//int page = _wtoi(pageNum->getString().c_str());
//		//int count = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQuerySaleCount).c_str());
//		//int index = page * count;
//
//		crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
//		crData *data = player->getDataClass();
//		crData *brainData = crBrain::getInstance()->getDataClass();
//		brainData->excHandle(MAKEINT64(WCH_LockData,1));
//		brainData->getParam(WCHDATA_JXJPlayerSaleRecordVec,param);
//		PlayerSaleRecordVec *saleRecordVec = (PlayerSaleRecordVec *)param;
//		saleRecordVec->clear();
//		brainData->getParam(WCHDATA_JXJCurSalePageNum,param);
//		curpagenum = *(int *)param;
//
//		data->getParam(WCHDATA_JXJVipLv,param);
//		unsigned char viplv = *(unsigned char *)param;
//		int offset = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQuerySaleCount,viplv).c_str());
//		start = (curpagenum - 1) * (offset / 2);
//		//brainData->inputParam(WCHDATA_JXJSaleTotal,0);
//		brainData->excHandle(MAKEINT64(WCH_LockData,0));
//
//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
//		stream->createBuf(12);
//		stream->_writeVec2i((*goodsVec)[selType]);
//		stream->_writeInt(start);
//		crPlayerDataEventPacket packet;
//		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryPlayerSale,stream.get());
//		netConductor->getNetManager()->sendPacket("all",packet);
//	}
//}
/////////////////////////////////////////
//
//crJXJRecvOnMarketPlayerSalePageMethod
//
/////////////////////////////////////////
crJXJRecvOnMarketPlayerSalePageMethod::crJXJRecvOnMarketPlayerSalePageMethod():
	m_netType(GameClient_Game){}
crJXJRecvOnMarketPlayerSalePageMethod::crJXJRecvOnMarketPlayerSalePageMethod(const crJXJRecvOnMarketPlayerSalePageMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvOnMarketPlayerSalePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvOnMarketPlayerSalePageMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvOnMarketPlayerSalePageMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				crVector2i goods = m_stream->_readVec2i();
				int start = m_stream->_readInt();
				void *param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJQuerySaleDeque,param);
				QuerySaleDeque *querySaleDeque = (QuerySaleDeque *)param;
				bool found = false;
				for( QuerySaleDeque::iterator itr = querySaleDeque->begin(); 
					 itr != querySaleDeque->end();
					 ++itr)
				{
					if((*itr)->getPlayerID()==playerid)
					{
						found = true;
						(*itr)->setGoods(goods);
						(*itr)->setStart(start);
						break;
					}
				}
				if(!found)
				{
					ref_ptr<crQuerySale> querySale = new crQuerySale(playerid);
					querySale->setGoods(goods);
					querySale->setStart(start);
					querySaleDeque->push_back(querySale.get());
				}
				serverData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQuerySaleDisposeMethod
//
/////////////////////////////////////////
crJXJQuerySaleDisposeMethod::crJXJQuerySaleDisposeMethod():
m_this(NULL),
m_availableTime(0.02f),
m_dt(NULL),
m_validterm(60){}
crJXJQuerySaleDisposeMethod::crJXJQuerySaleDisposeMethod(const crJXJQuerySaleDisposeMethod& handle):
crMethod(handle),
m_this(NULL),
m_availableTime(handle.m_availableTime),
m_dt(NULL),
m_validterm(handle.m_validterm)
{
}
void crJXJQuerySaleDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			if(lparam)
				m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJQuerySaleDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_availableTime = atof(str.c_str());
		break;
	case 1:
		m_validterm = atof(str.c_str());
		break;
	}
}

void crJXJQuerySaleDisposeMethod::operator()(crHandle &handle)
{
	crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
	if(m_this && gameglobaldb)
	{
		//GoodsCountMap Update;
		for( GoodsCountMap::iterator itr = m_goodsCountMap.begin();
			itr != m_goodsCountMap.end(); )
		{
			itr->second.second -= *m_dt;
			if(itr->second.second<0)
			{
				itr = m_goodsCountMap.erase(itr);
				continue;
			}
			++itr;
		}
		for( GoodsRecordMap::iterator itr = m_goodsRecordMap.begin();
			itr != m_goodsRecordMap.end(); )
		{
			itr->second.second -= *m_dt;
			if(itr->second.second<0)
			{
				itr = m_goodsRecordMap.erase(itr);
				continue;
			}
			++itr;
		}

		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJQuerySaleDeque,param);
		QuerySaleDeque *querySaleDeq = (QuerySaleDeque *)param;
		if(!querySaleDeq->empty())
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			crPlayerGameData *playerGameData;
			const CRCore::Timer& timer = *CRCore::Timer::instance();
			CRCore::Timer_t start_tick = timer.tick();
			float elapsedTime = 0.0f;

			ref_ptr<crCountPlayerSaleQueryData> countQuery = new crCountPlayerSaleQueryData;
			ref_ptr<crPlayerSaleQueryData> playerSaleQuery = new crPlayerSaleQueryData;
			ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
			ref_ptr<crQuerySale> querySale;
			crVector2i goods;
			crVector3i goodsR;
			GoodsCountMap::iterator goodsCountItr;
			GoodsRecordMap::iterator goodsRecordItr;
			int count,bufsize,playerid;
			crDataBase::QueryResultVec::iterator qritr;
			ref_ptr<crStreamBuf> stream;
			crPlayerDataEventPacket packet;
			crData* data = NULL;
			//while(elapsedTime<m_availableTime && !querySaleDeq->empty())
			//{
			//	querySale = querySaleDeq->front();
			//	querySaleDeq->pop_front();
			for( QuerySaleDeque::iterator itr = querySaleDeq->begin();
				 itr != querySaleDeq->end() && elapsedTime<m_availableTime;)
			{
				querySale = itr->get();
				playerid = querySale->getPlayerID();
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid() && playerData->getSceneID() == 0)
				{
					playerGameData = playerData->getPlayerGameData();
					if(playerGameData)
					{
						data = playerGameData->getDataClass();
						data->getParam(WCHDATA_JXJVipLv,param);
						unsigned char viplv = *(unsigned char *)param;
						int offset = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQuerySaleCount,viplv).c_str());
						goods = querySale->getGoods();
						//查询记录
						goodsR.set(goods[0],goods[1],querySale->getStart());
						goodsRecordItr = m_goodsRecordMap.find(goodsR);
						if(goodsRecordItr == m_goodsRecordMap.end())
						{
							playerSaleQuery->buildQuerySql(goods[0],goods[1],Sale_OnSale,querySale->getStart(),offset);
							dbSession->executeQuery(playerSaleQuery.get());
							crDataBase::QueryResultVec &playerSaleQueryResultVec = dbSession->getQueryResult();
							int size = playerSaleQueryResultVec.size();
							stream = new crStreamBuf;
							stream->createBuf(5+size*32);
							stream->_writeInt(0);
							stream->_writeUChar(size);
							for( qritr = playerSaleQueryResultVec.begin();
								qritr != playerSaleQueryResultVec.end();
								++qritr )
							{
								playerSaleQuery = dynamic_cast<crPlayerSaleQueryData *>(qritr->get());
								stream->_writeInt(playerSaleQuery->getID());
								stream->_writeString(playerSaleQuery->getPlayerName());
								stream->_writeInt(playerSaleQuery->getPrice());
								stream->_writeInt(playerSaleQuery->getSaleCount());
							}
							dbSession->releaseQuery();
							//stream->releaseUselessBuf();
							m_goodsRecordMap[goodsR] = std::make_pair(stream.get(),m_validterm);
						}
						else
						{
							stream = goodsRecordItr->second.first.get();
						}
						//查询记录条数
						goodsCountItr = m_goodsCountMap.find(goods);
						if(goodsCountItr != m_goodsCountMap.end())
						{
							count = goodsCountItr->second.first;
						}
						else
						{
							countQuery->buildQuerySql(goods[0],goods[1]);
							dbSession->executeQuery(countQuery.get());
							crDataBase::QueryResultVec &countQueryResultVec = dbSession->getQueryResult();
							if(!countQueryResultVec.empty())
							{
								countQuery = dynamic_cast<crCountPlayerSaleQueryData *>(countQueryResultVec[0].get());
								count = countQuery->getCount();
								m_goodsCountMap[goods] = std::make_pair(count,m_validterm);
							}
							dbSession->releaseQuery();
						}
						bufsize = stream->getBufSize();
						stream->seekBegin();
						stream->_writeInt(count);
						stream->setBufSize(bufsize);
						//向客户端发送数据
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPlayerSaleRecords,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
					++itr;
				}
				else
				{
					itr = querySaleDeq->erase(itr);
				}
				elapsedTime = timer.delta_s(start_tick,timer.tick());
			}
			gameglobaldb->endSession(dbSession.get());
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvPlayerSaleRecordsMethod
//
/////////////////////////////////////////
crJXJRecvPlayerSaleRecordsMethod::crJXJRecvPlayerSaleRecordsMethod():
	m_netType(GameClient_Game){}
crJXJRecvPlayerSaleRecordsMethod::crJXJRecvPlayerSaleRecordsMethod(const crJXJRecvPlayerSaleRecordsMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvPlayerSaleRecordsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPlayerSaleRecordsMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvPlayerSaleRecordsMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *brainData = crBrain::getInstance()->getDataClass();
			if(!brainData)return;
			brainData->excHandle(MAKEINT64(WCH_LockData,1));
			brainData->getParam(WCHDATA_JXJPlayerSaleRecordVec,param);
			PlayerSaleRecordVec *saleRecordVec = (PlayerSaleRecordVec *)param;
			int total = m_stream->_readInt();
			if (total<1)
			{
				total = 1;
			}
			brainData->inputParam(WCHDATA_JXJSaleTotal,&total);
			int size = (int)(m_stream->_readUChar());
			saleRecordVec->resize(size);
			ref_ptr<crPlayerSaleRecord> playerSaleRecord;
			for( int i = 0; i<size; i++)
			{
				playerSaleRecord = new crPlayerSaleRecord;
				playerSaleRecord->setSaleID(m_stream->_readInt());
				playerSaleRecord->setPlayerName(m_stream->_readString());
				playerSaleRecord->setPrice(m_stream->_readInt());
				playerSaleRecord->setCount(m_stream->_readInt());
				(*saleRecordVec)[i] = playerSaleRecord;
			}
			brainData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIPlayerSaleListUpdateMethod
//
/////////////////////////////////////////
crJXJUIPlayerSaleListUpdateMethod::crJXJUIPlayerSaleListUpdateMethod()
{
}
crJXJUIPlayerSaleListUpdateMethod::crJXJUIPlayerSaleListUpdateMethod(const crJXJUIPlayerSaleListUpdateMethod& handle):
	crMethod(handle),
	m_playerSaleList(handle.m_playerSaleList),
	m_pageNum(handle.m_pageNum),
	m_buycountmaxinput(handle.m_buycountmaxinput)
{
}
void crJXJUIPlayerSaleListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIPlayerSaleListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_playerSaleList = str;
		break;
	case 1:
		m_pageNum = str;
		break;
	case 2:
		m_buycountmaxinput = str;
		break;
	}
}
void crJXJUIPlayerSaleListUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if (playerGameData && playerGameData->getDataClass())
	{
		crData *data = playerGameData->getDataClass();
		void *param;
		crData *brainData = crBrain::getInstance()->getDataClass();

		crTableWidgetNode *playerSaleList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_playerSaleList));
		crStaticTextWidgetNode *pageNum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageNum));
		crStaticTextWidgetNode *buycountmaxinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_buycountmaxinput));
		brainData->getParam(WCHDATA_JXJCurSalePageNum,param);
		int curPageNum = *(int *)param;
		brainData->getParam(WCHDATA_JXJSaleTotal,param);
		int total = *(int *)param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int limitbuy = 0;
		playerGameData->doEvent(WCH_JXJCheckMarketLimitBuy,MAKEINT64(&limitbuy,NULL));
		if (buycountmaxinput)
		{
			buycountmaxinput->setString(crArgumentParser::appItoa(limitbuy));
		}
		int countPrePage = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQuerySaleCount,viplv).c_str());
		int pageCount = ceil((float)total/(float)countPrePage*2.0);
		char buf[32];
		sprintf(buf,"%d/%d\0",curPageNum,pageCount);
		pageNum->setString(std::string(buf));

		int cursel = playerSaleList->getSelect();
		playerSaleList->clearData();
		playerSaleList->setDefNull(NULL);

		int row = 0;
		int price,count;
		crPlayerSaleRecord *playerSaleRecord;
		brainData->excHandle(MAKEINT64(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJPlayerSaleRecordVec,param);
		PlayerSaleRecordVec *saleRecordVec = (PlayerSaleRecordVec *)param;
		if(saleRecordVec)
		{
			for( PlayerSaleRecordVec::iterator itr = saleRecordVec->begin();
				itr != saleRecordVec->end();
				++itr,row++ )
			{
				playerSaleRecord = itr->get();
				playerSaleList->addData(0,row,playerSaleRecord->getPlayerName());
				price = playerSaleRecord->getPrice();
				count = playerSaleRecord->getCount();
				playerSaleList->addData(1,row,crArgumentParser::appItoa(count));
				playerSaleList->addData(2,row,crArgumentParser::appItoa(price));
				playerSaleList->addData(3,row,crArgumentParser::appItoa(price * count));
				playerSaleList->addData(row,playerSaleRecord->getSaleID());
			}
		}
		brainData->excHandle(MAKEINT64(WCH_LockData,0));
		playerSaleList->selectRow(cursel);
	}
}
/////////////////////////////////////////
//
//crJXJUIPlayerSaleListSelectMethod
//
/////////////////////////////////////////
crJXJUIPlayerSaleListSelectMethod::crJXJUIPlayerSaleListSelectMethod()
{
}
crJXJUIPlayerSaleListSelectMethod::crJXJUIPlayerSaleListSelectMethod(const crJXJUIPlayerSaleListSelectMethod& handle):
	crMethod(handle),
	m_buyBtn(handle.m_buyBtn)
{
}
void crJXJUIPlayerSaleListSelectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crTableWidgetNode*)param;
		break;
	}
}
void crJXJUIPlayerSaleListSelectMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_buyBtn = str;
		break;
	}
}
void crJXJUIPlayerSaleListSelectMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crButtonWidgetNode *buyBtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_buyBtn));
		int saleid = m_this->getSelectData();
		if(saleid>0)
		{
			void *param;
			crData *data = playerGameData->getDataClass();
			//data->excHandle(MAKEINT64(WCH_LockData,1));
			//data->getParam(WCHDATA_JXJSaleList,param);
			//SaleList *saleList = (SaleList *)param;
			//bool canbuy = true;
			//for( SaleList::iterator itr = saleList->begin();
			//	itr != saleList->end();
			//	++itr )
			//{
			//	if((*itr)->getSaleID() == selectRecord->getSaleID())
			//	{//是否是自己的
			//		canbuy = false;
			//		break;
			//	}
			//}
			std::wstring selname;
			m_this->getData(0,m_this->getSelect(),selname);
			std::string name = CRIOManager::convertUTF16toUTF8(selname);
			bool canbuy = name!=crMyPlayerData::getInstance()->getCharacterName();
			if(canbuy)
			{//check 铜钱
				std::wstring selcopper;
				m_this->getData(3,m_this->getSelect(),selcopper);
				int copper = _wtoi(selcopper.c_str());
				data->getParam(WCHDATA_JXJCoppercash,param);
				int myCopper = *(int *)param;
				if(myCopper<copper)
					canbuy = false;
			}
			buyBtn->setEnable(canbuy);
			//data->excHandle(MAKEINT64(WCH_LockData,0));
		}
		else
		{
			buyBtn->setEnable(false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIMySaleListSelectMethod
//
/////////////////////////////////////////
crJXJUIMySaleListSelectMethod::crJXJUIMySaleListSelectMethod()
{
}
crJXJUIMySaleListSelectMethod::crJXJUIMySaleListSelectMethod(const crJXJUIMySaleListSelectMethod& handle):
	crMethod(handle),
	m_cancelBtn(handle.m_cancelBtn)
{
}
void crJXJUIMySaleListSelectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crTableWidgetNode*)param;
		break;
	}
}
void crJXJUIMySaleListSelectMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cancelBtn = str;
		break;
	}
}
void crJXJUIMySaleListSelectMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crButtonWidgetNode *cancelBtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_cancelBtn));
		int saleListID = m_this->getSelectData();
		if(saleListID>=0)
		{
			std::wstring statestr;
			m_this->getData(4,m_this->getSelect(),statestr);
			std::string str = CRIOManager::convertUTF16toUTF8(statestr);
			if( str.find("已售出")!=std::string::npos || 
				str.find("取消中")!=std::string::npos ||
				str.find("已取消")!=std::string::npos ||
				str.find("领取中")!=std::string::npos ||
				str.find("已领取")!=std::string::npos )
			{
				cancelBtn->setEnable(false);
			}
			else
			{
				cancelBtn->setEnable(true);
			}
		}
		else
		{
			cancelBtn->setEnable(false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBuyPlayerSaleMethod
//
/////////////////////////////////////////
crJXJUIBuyPlayerSaleMethod::crJXJUIBuyPlayerSaleMethod():
	m_this(NULL){}
crJXJUIBuyPlayerSaleMethod::crJXJUIBuyPlayerSaleMethod(const crJXJUIBuyPlayerSaleMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_copperColor(handle.m_copperColor),
	m_playerSaleList(handle.m_playerSaleList),
	m_goodsTypeRadio(handle.m_goodsTypeRadio)
{
}
void crJXJUIBuyPlayerSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIBuyPlayerSaleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_copperColor);
		break;
	case 5:
		m_playerSaleList = str;
		break;
	case 6:
		m_goodsTypeRadio = str;
		break;
	}
}

void crJXJUIBuyPlayerSaleMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crTableWidgetNode *playerSaleList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_playerSaleList));
		int saleid = playerSaleList->getSelectData();
		if(saleid>0)
		{
			crRadioGroupWidgetNode *goodsTypeRadio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_goodsTypeRadio));
			int selType = goodsTypeRadio->getSelect();
			void *param;
			crData *goodsTypeData = goodsTypeRadio->getDataClass();
			goodsTypeData->getParam(WCHDATA_JXJGoodsVec,param);
			GoodsVec *goodsVec = (GoodsVec *)param;
			crVector2i goods = (*goodsVec)[selType];
			crTableIO::StrVec record,shijirecord,viprecord;
			std::string goodsName;
			if(goods[0] == GT_Res)
			{
				ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
				if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(goods[0]),1,crArgumentParser::appItoa(goods[1]),record)>=0)
					goodsName = record[2];
			}
			else if(goods[0] == GT_TroopsEquip)
			{
				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
				if(troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(goods[1]),record)>=0)
					goodsName = record[1];
			}
			std::wstring selcount,selcopper;
			playerSaleList->getData(1,playerSaleList->getSelect(),selcount);
			playerSaleList->getData(3,playerSaleList->getSelect(),selcopper);
			int count = _wtoi(selcount.c_str());
			int copperneed = _wtoi(selcopper.c_str());
			ref_ptr<crCanvasNode> msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
			if(msgCanvas.valid())
			{
				crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
				crHypertextWidgetNode *msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
				crButtonWidgetNode *okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
				//title->setString(L"资源购买提示");

				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content");
				cfg_script.Add("Text","您确认要花费");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				v_i.clear();
				v_i.push_back(m_copperColor[0]);
				v_i.push_back(m_copperColor[1]);
				v_i.push_back(m_copperColor[2]);
				v_i.push_back(m_copperColor[3]);
				cfg_script.Add("Color",v_i);
				char tmpText[64];
				sprintf(tmpText,"%d铜钱\0",copperneed);
				cfg_script.Add("Text",tmpText);
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",3);
				cfg_script.Add("Text","来购买资源吗?\n\0");
				cfg_script.Pop();

				//资源超限警告
				bool canbuy = true;
				std::string str;
				crData *data = myPlayer->getDataClass();
				data->getParam(WCHDATA_JXJFukulv,param);
				unsigned char fukulv = *(unsigned char *)param;
				ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
				if(goods[0] == GT_Res)
				{
					data->getParam(goods[1],param);
					int mycount = *(int *)param;
					if(fukutab->queryOneRecord(0,crArgumentParser::appItoa((int)fukulv),record)>=0)
					{
						int limitbuycount = 0;
						myPlayer->doEvent(WCH_JXJCheckMarketLimitBuy,MAKEINT64(&limitbuycount,NULL));
						float fukulimitaddpercent = 0.0f;
						myPlayer->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
						int limit = atoi(record[goods[1]-(WCHDATA_JXJFood)+1].c_str()) * (1.0f + fukulimitaddpercent);
						if(mycount>limit-count)
						{
							canbuy = false;
							str = "资源达到库存上限，不能购买！";
						}
						if (count > limitbuycount)
						{
							canbuy = false;
							str = "今日可购资源量不足，不能购买！";
						}
						if(!canbuy)
						{
							int newcount = limit - mycount;
							if (newcount<0)
							{
								newcount = 0;
							}
							cfg_script.Add("Content");
							cfg_script.Push("Content",4);
							v_i.clear();
							v_i.push_back(255.0f);
							v_i.push_back(0.0f);
							v_i.push_back(0.0f);
							v_i.push_back(255.0f);
							cfg_script.Add("Color",v_i);
							//sprintf(tmpText,"您该资源已接近库存上限，如果购买成功将只能获得(%d)%s\0",newcount,goodsName.c_str());
							//cfg_script.Add("Text",tmpText);
							cfg_script.Add("Text",str);
							cfg_script.Pop();
						}
						else
						{
							cfg_script.Add("Content");
							cfg_script.Push("Content",4);
							sprintf(tmpText,"如果购买成功，您将获得(%d)%s\0",count,goodsName.c_str());
							cfg_script.Add("Text",tmpText);
							cfg_script.Pop();
						}
					}
				}
				//else if(goodstype == GT_TroopsEquip)
				//{
				//	data->getParam(WCHDATA_JXJTroopsEquipMap,param);
				//	equipMap = (TroopsEquipMap *)param;
				//	teitr = equipMap->find(goodsid);
				//	if(teitr != equipMap->end())
				//	{
				//		teitr->second += count;
				//	}
				//}
				cfg_script.Pop();
				msg->setHypertext(cfg_script);

				okBtn->setEnable(canbuy);
				crData *dlgData = msgCanvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
				crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBuyPlayerSale2Method
//
/////////////////////////////////////////
crJXJUIBuyPlayerSale2Method::crJXJUIBuyPlayerSale2Method():
	m_this(NULL)
{
}
crJXJUIBuyPlayerSale2Method::crJXJUIBuyPlayerSale2Method(const crJXJUIBuyPlayerSale2Method& handle):
	crMethod(handle),
	m_this(NULL),
	m_playerSaleList(handle.m_playerSaleList)
{
}
void crJXJUIBuyPlayerSale2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIBuyPlayerSale2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_playerSaleList = str;
		break;
	}
}
void crJXJUIBuyPlayerSale2Method::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crTableWidgetNode *playerSaleList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_playerSaleList));
		int saleid = playerSaleList->getSelectData();
		if(saleid>0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(saleid);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuyPlayerSale,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBuyPlayerSaleMethod
//
/////////////////////////////////////////
crJXJRecvBuyPlayerSaleMethod::crJXJRecvBuyPlayerSaleMethod():
	m_netType(GameClient_Game){}
crJXJRecvBuyPlayerSaleMethod::crJXJRecvBuyPlayerSaleMethod(const crJXJRecvBuyPlayerSaleMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvBuyPlayerSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBuyPlayerSaleMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvBuyPlayerSaleMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int saleid = m_stream->_readInt();
				void *param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKEINT64(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJBuySaleDeque,param);
				BuySaleDeque *buySaleDeque = (BuySaleDeque *)param;
				buySaleDeque->push_back(std::make_pair(saleid,playerid));
				serverData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool buysuccess = m_stream->_readBool();
			if(buysuccess)
			{
				int copper = m_stream->_readInt();
				int goodstype = m_stream->_readInt();
				int goodsid = m_stream->_readInt();
				int count = m_stream->_readInt();
				int resourcebuycount = m_stream->_readInt();
				void *param;
				crData *data = m_this->getDataClass();
				data->inputParam(WCHDATA_MarketBuyResourceCount,&resourcebuycount);
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJCoppercash,param);
				int *playerCopper = (int *)param;
				*playerCopper = copper;
				if(goodstype == GT_Res)
				{
					data->getParam(goodsid,param);
					int *mycount = (int *)param;
					*mycount += count;
				}
				else if(goodstype == GT_TroopsEquip)
				{
					data->getParam(WCHDATA_JXJTroopsEquipMap,param);
					TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
					TroopsEquipMap::iterator teitr = equipMap->find((unsigned short)goodsid);
					if(teitr != equipMap->end())
					{
						teitr->second += count;
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBuySaleDisposeMethod
//
/////////////////////////////////////////
crJXJBuySaleDisposeMethod::crJXJBuySaleDisposeMethod():
	m_this(NULL),
	m_availableTime(0.02f),
	m_validterm(60),
	m_dt(NULL){}
crJXJBuySaleDisposeMethod::crJXJBuySaleDisposeMethod(const crJXJBuySaleDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_availableTime(handle.m_availableTime),
	m_validterm(handle.m_validterm),
	m_dt(NULL)
{
}
void crJXJBuySaleDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			if(lparam)
				m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJBuySaleDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_availableTime = atof(str.c_str());
		break;
	case 1:
		m_validterm = atoi(str.c_str());
		break;
	}
}

void crJXJBuySaleDisposeMethod::operator()(crHandle &handle)
{
	crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
	if(gameglobaldb)
	{
		//SaledMap Update;
		SaledMap::iterator smitr;
		for( smitr = m_saledMap.begin();
			smitr != m_saledMap.end(); )
		{
			smitr->second -= *m_dt;
			if(smitr->second<0.0f)
			{
				smitr = m_saledMap.erase(smitr);
				continue;
			}
			++smitr;
		}

		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJBuySaleDeque,param);
		BuySaleDeque *buySaleDeq = (BuySaleDeque *)param;
		if(!buySaleDeq->empty())
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			crPlayerGameData *playerGameData;
			crData *gameData;
			const CRCore::Timer& timer = *CRCore::Timer::instance();
			CRCore::Timer_t start_tick = timer.tick();
			float elapsedTime = 0.0f;

			ref_ptr<crBuySaleQueryData> buySaleQuery = new crBuySaleQueryData;
			ref_ptr<crUpdateSale> updateSale = new crUpdateSale;
			ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
	
			crDataBase::QueryResultVec::iterator qritr;
			ref_ptr<crStreamBuf> stream;
			crPlayerDataEventPacket packet;
			int saleid,playerid,goodstype,goodsid,price,count,copperneed;
			bool buysuccess;
			int *playerCopper;
			int *mycount;
			unsigned char fukulv;
			int *buyresourcecount = 0,limitbuycount = 0;
			ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
			crTableIO::StrVec record;
			TroopsEquipMap *equipMap;
			TroopsEquipMap::iterator teitr;
			while(elapsedTime<m_availableTime && !buySaleDeq->empty())
			{
				saleid = buySaleDeq->front().first;
				playerid = buySaleDeq->front().second;
				buySaleDeq->pop_front();
				buysuccess = false;
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(saleid>0 && playerData.valid())
				{
					playerGameData = playerData->getPlayerGameData();
					if(playerGameData)
					{
						gameData = playerGameData->getDataClass();
						if(gameData)
						{
							smitr = m_saledMap.find(saleid);
							if(smitr == m_saledMap.end())
							{
								gameData->excHandle(MAKEINT64(WCH_LockData,1));
								buySaleQuery->buildQuerySql(saleid);
								dbSession->executeQuery(buySaleQuery.get());
								crDataBase::QueryResultVec &buySaleQueryResultVec = dbSession->getQueryResult();
								if(!buySaleQueryResultVec.empty())
								{
									buySaleQuery = dynamic_cast<crBuySaleQueryData *>(buySaleQueryResultVec[0].get());
									goodstype = buySaleQuery->getGoodsType();
									goodsid = buySaleQuery->getGoodsID();
									price = buySaleQuery->getPrice();
									count = buySaleQuery->getSaleCount();
									copperneed = price * count;

									playerGameData->doEvent(WCH_JXJCheckMarketLimitBuy,MAKEINT64(&limitbuycount,NULL));
									gameData->getParam(WCHDATA_MarketBuyResourceCount,param);
									buyresourcecount = (int *)param;
									if (limitbuycount>=count)
									{
										gameData->getParam(WCHDATA_JXJCoppercash,param);
										playerCopper = (int *)param;
										if(*playerCopper >= copperneed)
										{
											updateSale->buildUpdateSql(saleid,Sale_Saled,copperneed);
											if(dbSession->executeUpdate(updateSale.get()))
											{
												dbSession->commit();
												*playerCopper -= copperneed;
												//获得资源
												gameData->getParam(WCHDATA_JXJFukulv,param);
												fukulv = *(unsigned char *)param;
												if(goodstype == GT_Res)
												{
													gameData->getParam(goodsid,param);
													mycount = (int *)param;
													if (fukutab->queryOneRecord(0,crArgumentParser::appItoa((int)fukulv),record)>=0)
													{
														//float fukulimitaddpercent = 0.0f;
														//playerGameData->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
														//limit = atoi(record[goodsid-(WCHDATA_JXJFood)+1].c_str()) * (1.0f + fukulimitaddpercent);
														//if(*mycount>limit-count)
														//{
														//	count = limit - *mycount;
														//	*mycount = limit;
														//}
														//else
														//{
														INTLIMITADD(*mycount,count,INT_MAX);
														*buyresourcecount += count;
														//*mycount += count;
														//}
													}
												
												}
												else if(goodstype == GT_TroopsEquip)
												{
													data->getParam(WCHDATA_JXJTroopsEquipMap,param);
													equipMap = (TroopsEquipMap *)param;
													teitr = equipMap->find((unsigned short)goodsid);
													if(teitr != equipMap->end())
													{
														teitr->second += count;
													}
												}
												buysuccess = true;
												m_saledMap[saleid] = m_validterm;
											}
										}
									}
								}
								dbSession->releaseQuery();
								gameData->excHandle(MAKEINT64(WCH_LockData,0));
							}
							stream = new crStreamBuf;
							stream->createBuf(21);
							stream->_writeBool(buysuccess);
							if(buysuccess)
							{
								stream->_writeInt(*playerCopper);
								stream->_writeInt(goodstype);
								stream->_writeInt(goodsid);
								stream->_writeInt(count);
								stream->_writeInt(*buyresourcecount);
							}
							//向客户端发送数据
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuyPlayerSale,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
				}
				elapsedTime = timer.delta_s(start_tick,timer.tick());
			}
			gameglobaldb->endSession(dbSession.get());
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIGoldingotBuyStepCountMethod
//
/////////////////////////////////////////
crJXJUIGoldingotBuyStepCountMethod::crJXJUIGoldingotBuyStepCountMethod():
	m_step(-1)
{
}
crJXJUIGoldingotBuyStepCountMethod::crJXJUIGoldingotBuyStepCountMethod(const crJXJUIGoldingotBuyStepCountMethod& handle):
	crMethod(handle),
	m_step(handle.m_step),
	m_goods(handle.m_goods),
	m_input(handle.m_input)
{
}
void crJXJUIGoldingotBuyStepCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIGoldingotBuyStepCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_goods);
		break;
	case 2:
		m_input = str;
		break;
	}
}
void crJXJUIGoldingotBuyStepCountMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	void *param;
	crData *data = canvas->getDataClass();
	crEditWidgetNode *input = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input));
	if(data)
	{
		data->getParam(WCHDATA_JXJGoldBuySteps,param);
		GoodsStepMap *goodsStepMap = (GoodsStepMap *)param;
		if(goodsStepMap)
		{
			GoodsStepMap::iterator itr = goodsStepMap->find(m_goods);
			if(itr == goodsStepMap->end())
			{
				goodsStepMap->insert(std::make_pair(m_goods,m_step>0?m_step:0));
			}
			else
			{
				if(m_step == 0)
				{
					if (input)
					{
						std::string str = input -> getUTF8String();
						int inputnum = atoi(str.c_str());
						itr->second = inputnum;
					}
				}
				else
				{
					itr->second += m_step;
					if(itr->second<0)
						itr->second = 0;
					if (input)
					{
						input->setString(crArgumentParser::appItoa(itr->second));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGoldingotBuyUpdateMethod
//
/////////////////////////////////////////
crJXJUIGoldingotBuyUpdateMethod::crJXJUIGoldingotBuyUpdateMethod()
{
}
crJXJUIGoldingotBuyUpdateMethod::crJXJUIGoldingotBuyUpdateMethod(const crJXJUIGoldingotBuyUpdateMethod& handle):
	crMethod(handle),
	m_foodPrice(handle.m_foodPrice),
	m_woodPrice(handle.m_woodPrice),
	m_ironPrice(handle.m_ironPrice),
	m_horsePrice(handle.m_horsePrice),
	m_foodCount(handle.m_foodCount),
	m_woodCount(handle.m_woodCount),
	m_ironCount(handle.m_ironCount),
	m_horseCount(handle.m_horseCount),
	m_foodTotal(handle.m_foodTotal),
	m_woodTotal(handle.m_woodTotal),
	m_ironTotal(handle.m_ironTotal),
	m_horseTotal(handle.m_horseTotal),
	m_allTotal(handle.m_allTotal),
	m_buyBtn(handle.m_buyBtn),
	m_goodsVec(handle.m_goodsVec),
	m_buyMaxInput(handle.m_buyMaxInput)
{
}
void crJXJUIGoldingotBuyUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIGoldingotBuyUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foodPrice = str;
		break;
	case 1:
		m_woodPrice = str;
		break;
	case 2:
		m_ironPrice = str;
		break;
	case 3:
		m_horsePrice = str;
		break;
	case 4:
		m_foodCount = str;
		break;
	case 5:
		m_woodCount = str;
		break;
	case 6:
		m_ironCount = str;
		break;
	case 7:
		m_horseCount = str;
		break;
	case 8:
		m_foodTotal = str;
		break;
	case 9:
		m_woodTotal = str;
		break;
	case 10:
		m_ironTotal = str;
		break;
	case 11:
		m_horseTotal = str;
		break;
	case 12:
		m_allTotal = str;
		break;
	case 13:
		m_buyBtn = str;
		break;
	case 14:
		m_buyMaxInput = str;
		break;
	default:
		{
			crVector2i vec;
			crArgumentParser::appAtoVec(str,vec);
			m_goodsVec.push_back(vec);
		}
		break;
	}
}
void crJXJUIGoldingotBuyUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = m_this->getDataClass();
	if(data && playerGameData)
	{
		void *param;
		data->getParam(WCHDATA_JXJGoldBuySteps,param);
		GoodsStepMap *goodsStepMap = (GoodsStepMap *)param;

		crStaticTextWidgetNode *goodsPrice[4];
		goodsPrice[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodPrice));
		goodsPrice[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodPrice));
		goodsPrice[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironPrice));
		goodsPrice[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horsePrice));
		crEditWidgetNode *goodsCount[4];
		goodsCount[0] = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_foodCount));
		goodsCount[1] = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_woodCount));
		goodsCount[2] = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_ironCount));
		goodsCount[3] = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_horseCount));
		crStaticTextWidgetNode *goodsTotal[4];
		goodsTotal[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodTotal));
		goodsTotal[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodTotal));
		goodsTotal[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironTotal));
		goodsTotal[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseTotal));
		crStaticTextWidgetNode *allTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_allTotal));
		crButtonWidgetNode *buyBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_buyBtn));
		crStaticTextWidgetNode *buyMaxInput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_buyMaxInput));

		ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
		int goldid = goodsTab->getTitleIndex("系统售价");
		crTableIO::StrVec record,fukuRec,shijirecord,viprecord;
		int count;
		int gold;
		int goldsum = 0;
		std::string str;
		int iprice;
		GoodsStepMap::iterator stepItr;
		int step;
		crData *myData = playerGameData->getDataClass();
		myData->getParam(WCHDATA_JXJGoldingot,param);
		int mygold = *(int *)param;
		myData->getParam(WCHDATA_JXJGiftGold,param);
		int giftgold = *(int*)param;
		mygold += giftgold;
		myData->getParam(WCHDATA_JXJFukulv,param);
		int fukulv = (int)(*(unsigned char *)param);
		ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
		fukutab->queryOneRecord(0,crArgumentParser::appItoa(fukulv),fukuRec);
		int mycount,limit;
		int limitbuy = 0;
		playerGameData->doEvent(WCH_JXJCheckMarketLimitBuy,MAKEINT64(&limitbuy,NULL));
		if (buyMaxInput)
		{
			buyMaxInput->setString(crArgumentParser::appItoa(limitbuy));
		}
		for( int i = 0; i<4; i++)
		{
			std::string input = goodsCount[i]->getUTF8String();
			int inputcount = atoi(input.c_str());
			stepItr = goodsStepMap->find(m_goodsVec[i]);
			if(stepItr==goodsStepMap->end())
			{
				goodsStepMap->insert(std::make_pair(m_goodsVec[i],0));
				step = 0;
			}
			else
			{
				step = stepItr->second;
			}

			if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(m_goodsVec[i][0]),1,crArgumentParser::appItoa(m_goodsVec[i][1]),record)>=0)
			{
				iprice = atoi(record[goldid].c_str());
				str = "1:"+record[goldid];
				goodsPrice[i]->setString(str);
				if(step>0)
				{
					//price = 1.0f/(float)iprice;
					count = iprice * step;
					gold = inputcount;
					//count修正
					if(gold+goldsum>mygold)
					{
						gold = mygold - goldsum;
						count = iprice * gold;
					}
					//超限修正
					myData->getParam(m_goodsVec[i][1],param);
					mycount = *(int *)param;
					float fukulimitaddpercent = 0.0f;
					playerGameData->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
					limit = atoi(fukuRec[m_goodsVec[i][1]-(WCHDATA_JXJFood)+1].c_str()) * (1.0f + fukulimitaddpercent);
					if (limitbuy <= 0)
					{
						gold = 0;
						count = 0;
					}
					else if (limitbuy-count<0)
					{
						gold = limitbuy/iprice + 1;
						count = gold * iprice;
					}
					if (limit-mycount>0)
					{
						if(mycount>limit-count)
						{
							gold = (limit - mycount)/iprice + 1;
							count = limit - mycount;
						}
						goodsTotal[i]->setColor(COLOR_WHITE);
						goodsTotal[i]->setString(crArgumentParser::appItoa(count));
					}
					else
					{
						gold = 0;
						goodsTotal[i]->setColor(COLOR_RED/255.0f);
						goodsTotal[i]->setString(std::string("府库超限"));
					}
					count = gold * iprice;
					stepItr->second = gold;

					goodsCount[i]->setString(crArgumentParser::appItoa(gold));
					goldsum += gold;
				}
				else
				{
					goodsCount[i]->setString(L"0");
					goodsTotal[i]->setString(L"0");
				}
			}
		}
		allTotal->setString(crArgumentParser::appItoa(goldsum));
		buyBtn->setEnable(goldsum>0);
	}
}
/////////////////////////////////////////
//
//crJXJUICopperSaleStepCountMethod
//
/////////////////////////////////////////
crJXJUICopperSaleStepCountMethod::crJXJUICopperSaleStepCountMethod():
	m_step(-1)
{
}
crJXJUICopperSaleStepCountMethod::crJXJUICopperSaleStepCountMethod(const crJXJUICopperSaleStepCountMethod& handle):
	crMethod(handle),
	m_step(handle.m_step),
	m_goods(handle.m_goods),
	m_input(handle.m_input)
{
}
void crJXJUICopperSaleStepCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUICopperSaleStepCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_goods);
		break;
	case 2:
		m_input = str;
		break;
	}
}
void crJXJUICopperSaleStepCountMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	void *param;
	crData *data = canvas->getDataClass();
	crEditWidgetNode *input = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input));
	if(data)
	{
		data->getParam(WCHDATA_JXJCopperSaleSteps,param);
		GoodsStepMap *goodsStepMap = (GoodsStepMap *)param;
		if(goodsStepMap)
		{
			GoodsStepMap::iterator itr = goodsStepMap->find(m_goods);
			if(itr == goodsStepMap->end())
			{
				goodsStepMap->insert(std::make_pair(m_goods,m_step>0?m_step:0));
			}
			else
			{
				if(m_step == 0)
				{
					if (input)
					{
						std::string str = input -> getUTF8String();
						int inputnum = atoi(str.c_str());
						itr->second = inputnum;
					}
				}
				else
				{
					itr->second += m_step;
					if(itr->second<0)
						itr->second = 0;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICopperSalePageUpdateMethod
//
/////////////////////////////////////////
crJXJUICopperSalePageUpdateMethod::crJXJUICopperSalePageUpdateMethod()
{
}
crJXJUICopperSalePageUpdateMethod::crJXJUICopperSalePageUpdateMethod(const crJXJUICopperSalePageUpdateMethod& handle):
	crMethod(handle),
	m_foodPrice(handle.m_foodPrice),
	m_woodPrice(handle.m_woodPrice),
	m_ironPrice(handle.m_ironPrice),
	m_horsePrice(handle.m_horsePrice),
	m_foodCount(handle.m_foodCount),
	m_woodCount(handle.m_woodCount),
	m_ironCount(handle.m_ironCount),
	m_horseCount(handle.m_horseCount),
	m_foodTotal(handle.m_foodTotal),
	m_woodTotal(handle.m_woodTotal),
	m_ironTotal(handle.m_ironTotal),
	m_horseTotal(handle.m_horseTotal),
	m_allTotal(handle.m_allTotal),
	m_buyBtn(handle.m_buyBtn),
	m_goodsVec(handle.m_goodsVec),
	m_foodInventory(handle.m_foodInventory),
	m_woodInventory(handle.m_woodInventory),
	m_ironInventory(handle.m_ironInventory),
	m_horseInventory(handle.m_horseInventory)
{
}
void crJXJUICopperSalePageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUICopperSalePageUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foodPrice = str;
		break;
	case 1:
		m_woodPrice = str;
		break;
	case 2:
		m_ironPrice = str;
		break;
	case 3:
		m_horsePrice = str;
		break;
	case 4:
		m_foodCount = str;
		break;
	case 5:
		m_woodCount = str;
		break;
	case 6:
		m_ironCount = str;
		break;
	case 7:
		m_horseCount = str;
		break;
	case 8:
		m_foodTotal = str;
		break;
	case 9:
		m_woodTotal = str;
		break;
	case 10:
		m_ironTotal = str;
		break;
	case 11:
		m_horseTotal = str;
		break;
	case 12:
		m_allTotal = str;
		break;
	case 13:
		m_buyBtn = str;
		break;
	case 14:
		m_foodInventory = str;
		break;
	case 15:
		m_woodInventory = str;
		break;
	case 16:
		m_ironInventory = str;
		break;
	case 17:
		m_horseInventory = str;
		break;
	default:
		{
			crVector2i vec;
			crArgumentParser::appAtoVec(str,vec);
			m_goodsVec.push_back(vec);
		}
		break;
	}
}
void crJXJUICopperSalePageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = m_this->getDataClass();
	if(data && playerGameData)
	{
		void *param;
		data->getParam(WCHDATA_JXJCopperSaleSteps,param);
		GoodsStepMap *goodsStepMap = (GoodsStepMap *)param;

		crStaticTextWidgetNode *goodsPrice[4];
		goodsPrice[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodPrice));
		goodsPrice[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodPrice));
		goodsPrice[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironPrice));
		goodsPrice[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horsePrice));
		crStaticTextWidgetNode *goodsCount[4];
		goodsCount[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodCount));
		goodsCount[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodCount));
		goodsCount[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironCount));
		goodsCount[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseCount));
		crStaticTextWidgetNode *goodsTotal[4];
		goodsTotal[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodTotal));
		goodsTotal[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodTotal));
		goodsTotal[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironTotal));
		goodsTotal[3] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseTotal));
		crStaticTextWidgetNode *foodInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_foodInventory));
		crStaticTextWidgetNode *woodInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_woodInventory));
		crStaticTextWidgetNode *ironInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_ironInventory));
		crStaticTextWidgetNode *horseInventory = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_horseInventory));
		crStaticTextWidgetNode *allTotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_allTotal));
		crButtonWidgetNode *buyBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_buyBtn));
		ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
		std::string str;
		crData *data = playerGameData->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFood,param);
		int food = *(int *)param;
		str = crArgumentParser::appItoa(food);//"现有粮食："
		if(foodInventory)foodInventory->setString(str);

		data->getParam(WCHDATA_JXJWood,param);
		int wood = *(int *)param;
		str = crArgumentParser::appItoa(wood);//"现有木材："
		if(woodInventory)woodInventory->setString(str);

		data->getParam(WCHDATA_JXJIron,param);
		int iron = *(int *)param;
		str = crArgumentParser::appItoa(iron);//"现有铁矿："
		if(ironInventory)ironInventory->setString(str);

		data->getParam(WCHDATA_JXJHorse,param);
		int horse = *(int *)param;
		str = crArgumentParser::appItoa(horse);//"现有马匹："
		if(horseInventory)horseInventory->setString(str);
		data->excHandle(MAKEINT64(WCH_LockData,0));

		int copperid = goodsTab->getTitleIndex("回收价格");
		crTableIO::StrVec record;
		int count;
		int copper;
		int coppersum = 0;
		int iprice;
		GoodsStepMap::iterator stepItr;
		int step,mycount,index;
		index = sizeof(goodsCount) / sizeof(goodsCount[0]);
		crData *myData = playerGameData->getDataClass();
		for( int i = 0; i<index; i++)
		{
			std::string input = goodsCount[i]->getUTF8String();
			int inputcount = atoi(input.c_str());

			stepItr = goodsStepMap->find(m_goodsVec[i]);
			if(stepItr==goodsStepMap->end())
			{
				goodsStepMap->insert(std::make_pair(m_goodsVec[i],0));
				step = 0;
			}
			else
			{
				step = stepItr->second;
			}
			if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(m_goodsVec[i][0]),1,crArgumentParser::appItoa(m_goodsVec[i][1]),record)>=0)
			{
				iprice = atoi(record[copperid].c_str());
				str = "1:"+record[copperid];
				goodsPrice[i]->setString(str);
				if (step > 0)
				{
					count = iprice * step;
					copper = step;
					//count修正
					myData->getParam(m_goodsVec[i][1],param);
					mycount = *(int*)param;
					if(count>mycount)
					{
						count = mycount;
						copper = count / iprice;
						stepItr->second = copper;
						count = iprice * copper;
					}
					goodsTotal[i]->setString(crArgumentParser::appItoa(count));
					stepItr->second = copper;
					goodsCount[i]->setString(crArgumentParser::appItoa(copper));
					coppersum += copper;
				}
				else
				{
					goodsCount[i]->setString(L"0");
					goodsTotal[i]->setString(L"0");
				}
			}
		}
		allTotal->setString(crArgumentParser::appItoa(coppersum));
	}
}
/////////////////////////////////////////
//
//crJXJUIGoldBuyMethod
//
/////////////////////////////////////////
crJXJUIGoldBuyMethod::crJXJUIGoldBuyMethod():
	m_this(NULL){}
crJXJUIGoldBuyMethod::crJXJUIGoldBuyMethod(const crJXJUIGoldBuyMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_goldColor(handle.m_goldColor),
	m_foodCount(handle.m_foodCount),
	m_woodCount(handle.m_woodCount),
	m_ironCount(handle.m_ironCount),
	m_horseCount(handle.m_horseCount),
	m_total(handle.m_total),
	m_goodsVec(handle.m_goodsVec)
{
}
void crJXJUIGoldBuyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIGoldBuyMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_goldColor);
		break;
	case 5:
		m_foodCount = str;
		break;
	case 6:
		m_woodCount = str;
		break;
	case 7:
		m_ironCount = str;
		break;
	case 8:
		m_horseCount = str;
		break;
	case 9:
		m_total = str;
		break;
	default:
		{
			crVector2i vec;
			crArgumentParser::appAtoVec(str,vec);
			m_goodsVec.push_back(vec);
		}
		break;
	}
}

void crJXJUIGoldBuyMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crStaticTextWidgetNode *goodsCount[4];
		goodsCount[0] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodCount));
		goodsCount[1] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodCount));
		goodsCount[2] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironCount));
		goodsCount[3] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseCount));
		crStaticTextWidgetNode *total = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_total));
		ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
		crTableIO::StrVec record;
		int buycount[4];
		std::string goodsNames[4];
		for( int i = 0; i<4; i++)
		{
			buycount[i] = _wtoi(goodsCount[i]->getString().c_str());
			if(buycount[i]>0)
			{
				if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(m_goodsVec[i][0]),1,crArgumentParser::appItoa(m_goodsVec[i][1]),record)>=0)
				{
					goodsNames[i] = record[2];
				}
			}
		}
		int totalgold = _wtoi(total->getString().c_str());
		if(totalgold>0)
		{
			ref_ptr<crCanvasNode> msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
			if(msgCanvas.valid())
			{
				crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
				crHypertextWidgetNode *msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
				crButtonWidgetNode *okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
				//title->setString(L"元宝购买资源提示");

				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				int nContent = 1;
				cfg_script.Add("Content");
				cfg_script.Push("Content",nContent++);
				cfg_script.Add("Text","您确认要花费");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",nContent++);
				v_i.clear();
				v_i.push_back(/*m_goldColor[0]*/140.0);
				v_i.push_back(/*m_goldColor[1]*/40.0);
				v_i.push_back(/*m_goldColor[2]*/40.0);
				v_i.push_back(/*m_goldColor[3]*/255.0);
				cfg_script.Add("Color",v_i);
				char tmpText[32];
				sprintf(tmpText,"%d礼金/元宝\0",totalgold);
				cfg_script.Add("Text",tmpText);
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",nContent++);
				cfg_script.Add("Text","来购买资源吗?\n\0");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",nContent++);
				cfg_script.Add("Text","您将获得\0");
				cfg_script.Pop();
				for(int i = 0; i<4; i++)
				{
					if(buycount[i]>0)
					{
						sprintf(tmpText,"(%d)%s\0",buycount[i],goodsNames[i].c_str());
						cfg_script.Add("Content");
						cfg_script.Push("Content",nContent++);
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
					}
				}
				cfg_script.Add("Content");
				cfg_script.Push("Content",nContent++);
				cfg_script.Add("Text","实际以服务器计算为准。\0");
				cfg_script.Pop();
				cfg_script.Pop();
				msg->setHypertext(cfg_script);

				okBtn->setEnable(true);
				crData *dlgData = msgCanvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
				crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGoldBuy2Method
//
/////////////////////////////////////////
crJXJUIGoldBuy2Method::crJXJUIGoldBuy2Method():
	m_this(NULL)
{
}
crJXJUIGoldBuy2Method::crJXJUIGoldBuy2Method(const crJXJUIGoldBuy2Method& handle):
	crMethod(handle),
	m_this(NULL),
	m_foodCount(handle.m_foodCount),
	m_woodCount(handle.m_woodCount),
	m_ironCount(handle.m_ironCount),
	m_horseCount(handle.m_horseCount),
	m_goodsVec(handle.m_goodsVec)
{
}
void crJXJUIGoldBuy2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIGoldBuy2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foodCount = str;
		break;
	case 1:
		m_woodCount = str;
		break;
	case 2:
		m_ironCount = str;
		break;
	case 3:
		m_horseCount = str;
		break;
	default:
		{
			crVector2i vec;
			crArgumentParser::appAtoVec(str,vec);
			m_goodsVec.push_back(vec);
		}
		break;
	}
}
void crJXJUIGoldBuy2Method::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crStaticTextWidgetNode *goodsCount[4];
		goodsCount[0] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodCount));
		goodsCount[1] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodCount));
		goodsCount[2] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironCount));
		goodsCount[3] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseCount));
		int buycount[4];
		char size = 0;
		for( int i = 0; i<4; i++)
		{
			buycount[i] = _wtoi(goodsCount[i]->getString().c_str());
			if(buycount[i]>0)
			{
				size++;
			}
		}
		if(size>0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(size * 12 + 1);
			stream->_writeChar(size);
			for( int i = 0; i<4; i++)
			{
				if(buycount[i]>0)
				{
					stream->_writeVec2i(m_goodsVec[i]);
					stream->_writeInt(buycount[i]);
				}
			}
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGoldBuy,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGoldBuyMethod
//
/////////////////////////////////////////
crJXJRecvGoldBuyMethod::crJXJRecvGoldBuyMethod():
	m_netType(GameClient_Game){}
crJXJRecvGoldBuyMethod::crJXJRecvGoldBuyMethod(const crJXJRecvGoldBuyMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_foodinput(handle.m_foodinput),
	m_woodinput(handle.m_woodinput),
	m_ironinput(handle.m_ironinput),
	m_horseinput(handle.m_horseinput)
{
}
void crJXJRecvGoldBuyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvGoldBuyMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_foodinput = str;
		break;
	case 2:
		m_woodinput = str;
		break;
	case 3:
		m_ironinput = str;
		break;
	case 4:
		m_horseinput = str;
		break;
	}
}

void crJXJRecvGoldBuyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int size = (int)(m_stream->_readChar());
				if(size<0)
					return;
				ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
				int goldid = goodsTab->getTitleIndex("系统售价");
				crTableIO::StrVec record,fukuRec;
				ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
				void *param;
				crData *data = m_this->getDataClass();
				bool needdeductgold = false;
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJFukulv,param);
				int fukulv = (int)(*(unsigned char *)param);
				data->getParam(WCHDATA_JXJShijilv,param);
				int shijilv = (int)(*(unsigned char *)param);
				data->getParam(WCHDATA_JXJVipLv,param);
				int viplv = (int)(*(unsigned char *)param);
				fukutab->queryOneRecord(0,crArgumentParser::appItoa(fukulv),fukuRec);
				int *mycount;
				int limit;
				crVector2i goods;
				int buycount,iprice;
				float price,relcount;
				int goldneed;
				data->getParam(WCHDATA_JXJGoldingot,param);
				int curgold = *(int *)param;
				data->getParam(WCHDATA_JXJGiftGold,param);
				int giftgold = *(int*)param;
				data->getParam(WCHDATA_MarketBuyResourceCount,param);
				int *MarketBuyResourceCount = (int*)param;
				curgold += giftgold;
				
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(size * 13 + 5);
				stream->_writeChar(size);
				for( int i = 0; i<size; ++i)
				{
					goods = m_stream->_readVec2i();
					buycount = m_stream->_readInt();

					do
					{
						int limitbuycount = 0;
						m_this->doEvent(WCH_JXJCheckMarketLimitBuy,MAKEINT64(&limitbuycount,NULL));
						if(buycount > limitbuycount)
						{
							buycount = limitbuycount;
						}
						if(curgold>0 && goodsTab->queryOneRecord(0,crArgumentParser::appItoa(goods[0]),1,crArgumentParser::appItoa(goods[1]),record)>=0)
						{
							float fukulimitaddpercent = 0.0f;
							m_this->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
							iprice = atoi(record[goldid].c_str());
							price = 1.0f/(float)iprice;
							data->getParam(goods[1],param);
							mycount = (int *)param;
							limit = atoi(fukuRec[goods[1]-(WCHDATA_JXJFood)+1].c_str()) * (1.0f + fukulimitaddpercent);
							if(*mycount>limit-buycount)
							{
								relcount = limit - *mycount;
								if(relcount<0) relcount = 0;
							}
							else
							{
								relcount = buycount;
							}
							if(relcount>0)
							{
								goldneed = ceil(price * relcount);
								if(goldneed>curgold)
								{
									goldneed = curgold;
								}
								if(goldneed>0)
								{
									relcount = goldneed * iprice;
									*MarketBuyResourceCount += relcount;
									*mycount += relcount;
									//*mygold -= goldneed;
									MoneyChangeData moneydata(goldneed,"市集购买资源");
									m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&moneydata,&needdeductgold));
									stream->_writeBool(true);
									stream->_writeVec2i(goods);
									stream->_writeInt(*mycount);
									break;
								}
							}
						}
						stream->_writeBool(false);
					} while (0);
				}
				stream->_writeInt(*MarketBuyResourceCount);
				//stream->_writeInt(*mygold);
				data->excHandle(MAKEINT64(WCH_LockData,0));
				if (needdeductgold)
				{
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					callback->savePlayerData(playerData.get());
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvGoldBuy,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = "元宝购买资源（id，type，count）：" + crArgumentParser::appVectoa(crVector3i(goods[0],goods[1],relcount));
				GameLogData gamelog(Log_MarketGoldBuy,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			int size = (int)(m_stream->_readChar());
			bool success;
			crVector2i goods;
			int serverCount;
			int *myCount;
			void *param;
			int gainCount;

			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			for( int i = 0; i<size; ++i)
			{
				success = m_stream->_readBool();
				if(success && canvas.valid())
				{
					crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodinput));
					crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodinput));
					crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironinput));
					crStaticTextWidgetNode *horse = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseinput));
					std::string str = "0";
					goods = m_stream->_readVec2i();
					serverCount = m_stream->_readInt();
					data->getParam(goods[1],param);
					myCount = (int *)param;
					gainCount = serverCount - *myCount;//客户端提示
					*myCount = serverCount;
					if (goods[1] == WCHDATA_JXJFood)
					{
						if (food)
						{
							food->setString(str);
							crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Food,gainCount));
						}
					}
					if (goods[1] == WCHDATA_JXJWood)
					{
						if (wood)
						{
							wood->setString(str);
							crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Wood,gainCount));
						}
					}
					if (goods[1] == WCHDATA_JXJIron)
					{
						if (iron)
						{
							iron->setString(str);
							crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Iron,gainCount));
						}
					}
					if (goods[1] == WCHDATA_JXJHorse)
					{
						if (horse)
						{
							horse->setString(str);
							crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Horse,gainCount));
						}
					}
					crData *data2 = canvas->getDataClass();
					if(data2)
					{
						data2->getParam(WCHDATA_JXJGoldBuySteps,param);
						GoodsStepMap *goodsStepMap = (GoodsStepMap *)param;
						if(goodsStepMap)
						{
							GoodsStepMap::iterator itr = goodsStepMap->find(goods);
							itr->second = 0;
							data2->inputParam(WCHDATA_JXJGoldBuySteps,goodsStepMap);
						}
					}
					
				}
			}
			int marketbuyresourcecount = m_stream->_readInt();
			data -> inputParam(WCHDATA_MarketBuyResourceCount,&marketbuyresourcecount);
			canvas->doEvent(WCH_UI_UpdateData);
			//serverCount = m_stream->_readInt();
			//data->getParam(WCHDATA_JXJGoldingot,param);
			//myCount = (int *)param;
			//gainCount = serverCount - *myCount;//客户端提示
			//*myCount = serverCount;
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJMarketPageCheckMethod
//
/////////////////////////////////////////
crJXJMarketPageCheckMethod::crJXJMarketPageCheckMethod():
m_page(0){}
crJXJMarketPageCheckMethod::crJXJMarketPageCheckMethod(const crJXJMarketPageCheckMethod& handle):
crMethod(handle),
m_marketCanvas(handle.m_marketCanvas),
m_pageRadio(handle.m_pageRadio),
m_page(handle.m_page)
{
}
void crJXJMarketPageCheckMethod::inputParam(int i, void *param)
{
}
void crJXJMarketPageCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_marketCanvas = str;
		break;
	case 1:
		m_pageRadio = str;
		break;
	case 2:
		m_page = atoi(str.c_str());
		break;
	}
}
void crJXJMarketPageCheckMethod::operator()(crHandle &handle)
{
	bool success = false;
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_marketCanvas);
	if(canvas.valid())
	{
		crRadioGroupWidgetNode *pageRadio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_pageRadio));
		if(pageRadio)
		{
			int sel = pageRadio->getSelect();
			success = (sel == m_page);
		}
	}
	handle.outputParam(0,&success);
}
/////////////////////////////////////////
//
//crJXJUICopperSaleMethod
//
/////////////////////////////////////////
crJXJUICopperSaleMethod::crJXJUICopperSaleMethod():
	m_this(NULL){}
crJXJUICopperSaleMethod::crJXJUICopperSaleMethod(const crJXJUICopperSaleMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_goldColor(handle.m_goldColor),
	m_foodCount(handle.m_foodCount),
	m_woodCount(handle.m_woodCount),
	m_ironCount(handle.m_ironCount),
	m_horseCount(handle.m_horseCount),
	m_total(handle.m_total),
	m_goodsVec(handle.m_goodsVec)
{
}
void crJXJUICopperSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUICopperSaleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_goldColor);
		break;
	case 5:
		m_foodCount = str;
		break;
	case 6:
		m_woodCount = str;
		break;
	case 7:
		m_ironCount = str;
		break;
	case 8:
		m_horseCount = str;
		break;
	case 9:
		m_total = str;
		break;
	default:
		{
			crVector2i vec;
			crArgumentParser::appAtoVec(str,vec);
			m_goodsVec.push_back(vec);
		}
		break;
	}
}
void crJXJUICopperSaleMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crStaticTextWidgetNode *goodsCount[4];
		goodsCount[0] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodCount));
		goodsCount[1] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodCount));
		goodsCount[2] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironCount));
		goodsCount[3] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseCount));
		crStaticTextWidgetNode *total = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_total));
		ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
		crTableIO::StrVec record;
		int salecount[4];
		std::string goodsNames[4];
		for( int i = 0; i<4; i++)
		{
			salecount[i] = _wtoi(goodsCount[i]->getString().c_str());
			if(salecount[i]>0)
			{
				if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(m_goodsVec[i][0]),1,crArgumentParser::appItoa(m_goodsVec[i][1]),record)>=0)
				{
					goodsNames[i] = record[2];
				}
			}
		}
		ref_ptr<crCanvasNode> msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
		int totalgold = _wtoi(total->getString().c_str());
		if(totalgold>0 && msgCanvas.valid())
		{
			crStaticTextWidgetNode *title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
			crHypertextWidgetNode *msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
			crButtonWidgetNode *okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
			//title->setString(L"元宝购买资源提示");

			std::vector<float>v_i;
			ItemMap itemMap;
			rcfg::ConfigScript cfg_script(&itemMap);
			cfg_script.Add("Hypertext");
			cfg_script.Push("Hypertext");
			cfg_script.Add("Content");
			cfg_script.Push("Content");
			cfg_script.Add("Text","您确认要卖出");
			cfg_script.Pop();

			char tmpText[32];
			int id = 2;
			for(int i = 0; i<4; i++)
			{
				if(salecount[i]>0)
				{
					sprintf(tmpText,"(%d)%s\0",salecount[i],goodsNames[i].c_str());
					cfg_script.Add("Content");
					cfg_script.Push("Content",id++);
					cfg_script.Add("Text",tmpText);
					cfg_script.Pop();
				}
			}
			cfg_script.Add("Content");
			cfg_script.Push("Content",id++);
			cfg_script.Add("Text","吗\n\0");
			cfg_script.Pop();

			cfg_script.Add("Content");
			cfg_script.Push("Content",id++);
			v_i.clear();
			v_i.push_back(m_goldColor[0]);
			v_i.push_back(m_goldColor[1]);
			v_i.push_back(m_goldColor[2]);
			v_i.push_back(m_goldColor[3]);
			cfg_script.Add("Color",v_i);
			sprintf(tmpText,"您将获得%d铜钱\0",totalgold);
			cfg_script.Add("Text",tmpText);
			cfg_script.Pop();

			cfg_script.Pop();
			msg->setHypertext(cfg_script);

			okBtn->setEnable(true);
			crData *dlgData = msgCanvas->getDataClass();
			int commandtype = CDP_Widget;
			dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
			dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
			crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICopperSale2Method
//
/////////////////////////////////////////
crJXJUICopperSale2Method::crJXJUICopperSale2Method():
	m_this(NULL)
{
}
crJXJUICopperSale2Method::crJXJUICopperSale2Method(const crJXJUICopperSale2Method& handle):
	crMethod(handle),
	m_this(NULL),
	m_foodCount(handle.m_foodCount),
	m_woodCount(handle.m_woodCount),
	m_ironCount(handle.m_ironCount),
	m_horseCount(handle.m_horseCount),
	m_goodsVec(handle.m_goodsVec)
{
}
void crJXJUICopperSale2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUICopperSale2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foodCount = str;
		break;
	case 1:
		m_woodCount = str;
		break;
	case 2:
		m_ironCount = str;
		break;
	case 3:
		m_horseCount = str;
		break;
	default:
		{
			crVector2i vec;
			crArgumentParser::appAtoVec(str,vec);
			m_goodsVec.push_back(vec);
		}
		break;
	}
}
void crJXJUICopperSale2Method::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crStaticTextWidgetNode *goodsCount[4];
		goodsCount[0] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodCount));
		goodsCount[1] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodCount));
		goodsCount[2] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironCount));
		goodsCount[3] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseCount));
		int salecount[4];
		char size = 0;
		for( int i = 0; i<4; i++)
		{
			salecount[i] = _wtoi(goodsCount[i]->getString().c_str());
			if(salecount[i]>0)
			{
				size++;
			}
		}
		if(size>0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(size * 12 + 1);
			stream->_writeChar(size);
			for( int i = 0; i<4; i++)
			{
				if(salecount[i]>0)
				{
					stream->_writeVec2i(m_goodsVec[i]);
					stream->_writeInt(salecount[i]);
				}
			}
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCopperSale,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCopperSaleMethod
//
/////////////////////////////////////////
crJXJRecvCopperSaleMethod::crJXJRecvCopperSaleMethod():
	m_netType(GameClient_Game){}
crJXJRecvCopperSaleMethod::crJXJRecvCopperSaleMethod(const crJXJRecvCopperSaleMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_foodinput(handle.m_foodinput),
	m_woodinput(handle.m_woodinput),
	m_ironinput(handle.m_ironinput),
	m_horseinput(handle.m_horseinput)
{
}
void crJXJRecvCopperSaleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCopperSaleMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_foodinput = str;
		break;
	case 2:
		m_woodinput = str;
		break;
	case 3:
		m_ironinput = str;
		break;
	case 4:
		m_horseinput = str;
		break;
	}
}

void crJXJRecvCopperSaleMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int size = (int)(m_stream->_readChar());
				if(size<=0||size>4)
					return;
				ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
				int copperid = goodsTab->getTitleIndex("回收价格");
				crTableIO::StrVec record;
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				int *mycount;
				crVector2i goods;
				int salecount,iprice;
				float price,relcount,copperneed;
				data->getParam(WCHDATA_JXJCoppercash,param);
				int *myCopper = (int *)param;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(size * 13 + 5);
				stream->_writeChar(size);
				for( int i = 0; i<size; ++i)
				{
					goods = m_stream->_readVec2i();
					salecount = m_stream->_readInt();

					if(goodsTab->queryOneRecord(0,crArgumentParser::appItoa(goods[0]),1,crArgumentParser::appItoa(goods[1]),record)>=0)
					{
						iprice = atoi(record[copperid].c_str());
						price = 1.0f/(float)iprice;
						data->getParam(goods[1],param);
						mycount = (int *)param;
						if(*mycount<salecount)
						{
							relcount = *mycount;
							if(relcount<0) relcount = 0;
						}
						else
						{
							relcount = salecount;
						}

						copperneed = floor(price * relcount);
						relcount = copperneed * iprice;
						*mycount -= relcount;
						*myCopper += copperneed;
						stream->_writeBool(true);
						stream->_writeVec2i(goods);
						stream->_writeInt(*mycount);
					}
					else
					{
						stream->_writeBool(false);
					}
				}
				stream->_writeInt(*myCopper);
				data->excHandle(MAKEINT64(WCH_LockData,0));
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCopperSale,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if(m_netType == GameClient_Game)
		{
			int size = (int)(m_stream->_readChar());
			bool success;
			crVector2i goods;
			int serverCount;
			int *myCount;
			void *param;
			int gainCount;
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			for( int i = 0; i<size; ++i)
			{
				success = m_stream->_readBool();
				if(success && canvas.valid())
				{
					crStaticTextWidgetNode *food = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_foodinput));
					crStaticTextWidgetNode *wood = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_woodinput));
					crStaticTextWidgetNode *iron = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_ironinput));
					crStaticTextWidgetNode *horse = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_horseinput));
					std::string str = "0";
					goods = m_stream->_readVec2i();
					serverCount = m_stream->_readInt();
					data->getParam(goods[1],param);
					myCount = (int *)param;
					gainCount = serverCount - *myCount;//客户端提示
					*myCount = serverCount;
					if (goods[1] == WCHDATA_JXJFood)
					{
						if (food)
						{
							food->setString(str);
						}
					}
					if (goods[1] == WCHDATA_JXJWood)
					{
						if (wood)
						{
							wood->setString(str);
						}
					}
					if (goods[1] == WCHDATA_JXJIron)
					{
						if (iron)
						{
							iron->setString(str);
						}
					}
					if (goods[1] == WCHDATA_JXJHorse)
					{
						if (horse)
						{
							horse->setString(str);
						}
					}
					crData *data2 = canvas->getDataClass();
					if(data2)
					{
						data2->getParam(WCHDATA_JXJCopperSaleSteps,param);
						GoodsStepMap *goodsStepMap = (GoodsStepMap *)param;
						if(goodsStepMap)
						{
							GoodsStepMap::iterator itr = goodsStepMap->find(goods);
							itr->second = 0;
							data2->inputParam(WCHDATA_JXJCopperSaleSteps,goodsStepMap);
						}
					}
				}
			}
			serverCount = m_stream->_readInt();
			data->getParam(WCHDATA_JXJCoppercash,param);
			myCount = (int *)param;
			gainCount = serverCount - *myCount;//客户端提示
			*myCount = serverCount;
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUITroopsEquipUpdateMethod
//
/////////////////////////////////////////
crJXJUITroopsEquipUpdateMethod::crJXJUITroopsEquipUpdateMethod()
{
}
crJXJUITroopsEquipUpdateMethod::crJXJUITroopsEquipUpdateMethod(const crJXJUITroopsEquipUpdateMethod& handle):
	crMethod(handle),
	m_armyRadio(handle.m_armyRadio)
{
}
void crJXJUITroopsEquipUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crJXJUITroopsEquipUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_armyRadio = str;
		break;
	}
}
void crJXJUITroopsEquipUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		crRadioGroupWidgetNode *armyRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_armyRadio));
		crRadioGroupWidgetNode::RadioGroup &radioGroup = armyRadioGroup->getRadioGroup();
		int armType;
		if (armyRadioGroup)
		{
			armType = armyRadioGroup->getSelect();
		}
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		int equiptitleid = troopsTab->getTitleIndex("装备ID");
		crTableIO::DataVec recordVec;
		crTableIO::StrVec record;
		troopsTab->queryRecords(2,crArgumentParser::appItoa(armType),recordVec);
		std::set<int>EquipSet;
		int equipid;
		for( crTableIO::DataVec::iterator itr = recordVec.begin();
			itr != recordVec.end();
			++itr )
		{
			equipid = atoi((*itr)[equiptitleid].c_str());
			if(equipid>0)
				EquipSet.insert(equipid);
		}
		ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
		int iconid = troopsEquipTab->getTitleIndex("icon");
		m_this->setListNodeCount(EquipSet.size());
		crListControlWidgetNode::ListNodeVec& listNodeVec = m_this->getListNodeVec();
		std::string iconfile;
		ref_ptr<crListControlNode> listNode;
		int i = 0;
		for( std::set<int>::iterator itr = EquipSet.begin();
			 itr != EquipSet.end();
			 ++itr,++i )
		{
			troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(*itr),record);
			iconfile = record[iconid];
			listNodeVec[i]->setData(*itr);
			listNodeVec[i]->setImageName(iconfile);
			listNodeVec[i]->setVisiable(true);
		}
		m_this->select(0);
	}
}
/////////////////////////////////////////
//
//crJXJUITroopsEquipSelInfoUpdateMethod
//
/////////////////////////////////////////
crJXJUITroopsEquipSelInfoUpdateMethod::crJXJUITroopsEquipSelInfoUpdateMethod()
{
}
crJXJUITroopsEquipSelInfoUpdateMethod::crJXJUITroopsEquipSelInfoUpdateMethod(const crJXJUITroopsEquipSelInfoUpdateMethod& handle):
	crMethod(handle),
	m_equipList(handle.m_equipList),
	m_makeCount(handle.m_makeCount),
	m_makeBtn(handle.m_makeBtn),
	m_info(handle.m_info)
{
	for (int i = 0; i<4; i++)
	{
		m_needCount[i] = handle.m_needCount[i];
		m_needTotal[i] = handle.m_needTotal[i];
	}
}
void crJXJUITroopsEquipSelInfoUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUITroopsEquipSelInfoUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipList = str;
		break;
	case 1:
		m_makeCount = str;
		break;
	case 2:
		m_needCount[0] = str;
		break;
	case 3:
		m_needCount[1] = str;
		break;
	case 4:
		m_needCount[2] = str;
		break;
	case 5:
		m_needCount[3] = str;
		break;
	case 6:
		m_needTotal[0] = str;
		break;
	case 7:
		m_needTotal[1] = str;
		break;
	case 8:
		m_needTotal[2] = str;
		break;
	case 9:
		m_needTotal[3] = str;
		break;
	case 10:
		m_makeBtn = str;
		break;
	case 11:
		m_info = str;
		break;
	}
}
void crJXJUITroopsEquipSelInfoUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		void *param;
		crRadioGroupWidgetNode *equipList = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_equipList));
		crEditWidgetNode *makeCount = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_makeCount));
		crButtonWidgetNode *makeBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_makeBtn));
		crHypertextWidgetNode *info = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_info));
		crStaticTextWidgetNode *needCount[4];
		crStaticTextWidgetNode *needTotal[4];
		if (equipList)
		{
			for(int i = 0; i<4; i++)
			{
				std::string str;
				needCount[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_needCount[i]));
				needTotal[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_needTotal[i]));
				switch (i)
				{
				case 0:
					str = "铜钱";
					if(needCount[i])needCount[i]->setString(str);
					break;
				case 1:
					str = "木材";
					if(needCount[i])needCount[i]->setString(str);
					break;
				case 2:
					str = "铁矿";
					if(needCount[i])needCount[i]->setString(str);
					break;
				case 3:
					str = "马匹";
					if(needCount[i])needCount[i]->setString(str);
					break;
				}
			}
			//crListControlNode *selectNode = equipList->getSelectNode();
			unsigned short equipid = 0;
			crData *canvasdata = m_this->getDataClass();
			if (canvasdata)
			{
				canvasdata->getParam(WCHDATA_JXJCurSelForgeTroopsEquipID,param);
				equipid = *(unsigned short *)param;
			}
			if(equipid > 0)
			{
				int makecount = 0;
				if (makeCount)
				{
					makecount = _wtoi(makeCount->getString().c_str());
				}
			//	int equipid = selectNode->getData();
				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
				std::vector< std::pair<int,int> >ResCountVec;
				int startIndex = troopsEquipTab->getTitleIndex("铜钱");
				int indexCount = troopsEquipTab->getColumnCount();
				int infoindex = troopsEquipTab->getTitleIndex("条件");
				std::string file;
				crTableIO::StrVec record;
				if (troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record)<0)
				{
					return;
				}
				int count;
				if(info)
				{
					file = record[infoindex];
					if(!file.empty())
					{
						file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						info->setHypertext(file);
					}
					else
					{
						info->clearText();
					}
				}
				for(int i = startIndex; i<indexCount; i++)
				{
					count = atoi(record[i].c_str());
					if(count>=0)       //等于0时也读入数据
					{
						ResCountVec.push_back(std::make_pair(i,count));
					}
				}
				int i = 0;
				std::string name;
				ref_ptr<crTableIO>resnameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResNameTab);
				void *param;
				crData *data = playerData->getDataClass();
				int resid,mycount,total;
				bool canmake = true;
				int maxmakecount;
				for( std::vector< std::pair<int,int> >::iterator itr = ResCountVec.begin();
					itr != ResCountVec.end() && i<4;
					++itr,++i )
				{
					name = troopsEquipTab->getTitle(itr->first);
					//needCount[i]->setString(crArgumentParser::appItoa(itr->second));
					int need = itr->second;
					if (0 == need)
					{
						maxmakecount = INT_MAX;
					}
					else
					{
						maxmakecount = INT_MAX/need; //整型最大值
					}
					if (makecount<=maxmakecount)
					{
						total = itr->second * makecount;
					}
					else
					{
						total = INT_MAX;
						needTotal[i]->setColor(crVector4(1,0,0,1));
					}
					needTotal[i]->setString(crArgumentParser::appItoa(total));

					//数量检测
					resnameTab->queryOneRecord(1,name,record);
					resid = atoi(record[0].c_str());
					data->getParam(resid,param);
					mycount = *(int *)param;
					if(mycount<total)
					{
						needTotal[i]->setColor(crVector4(1,0,0,1));
						canmake = false;
					}
					else
					{
						needTotal[i]->setColor(crVector4(0,0,0,1));
					}
				}
				for( ; i<4; i++)
				{
					//needCount[i]->clearString();
					needTotal[i]->clearString();
				}
				if(makecount>0)
				{
					if(makeBtn)makeBtn->setEnable(canmake);
				}
				else
				{
					if(makeBtn)makeBtn->setEnable(false);
				}
			}
			else
			{
				makeCount->clearString();
				for( int i = 0; i<4; i++)
				{
					//needCount[i]->clearString();
					needTotal[i]->clearString();
				}
				if(makeBtn)makeBtn->setEnable(false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIMakeTroopsEquipMethod
//
/////////////////////////////////////////
crJXJUIMakeTroopsEquipMethod::crJXJUIMakeTroopsEquipMethod():
	m_this(NULL)
{
}
crJXJUIMakeTroopsEquipMethod::crJXJUIMakeTroopsEquipMethod(const crJXJUIMakeTroopsEquipMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_equipList(handle.m_equipList),
	m_makeCount(handle.m_makeCount)
{
}
void crJXJUIMakeTroopsEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIMakeTroopsEquipMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipList = str;
		break;
	case 1:
		m_makeCount = str;
		break;
	}
}
void crJXJUIMakeTroopsEquipMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
		void *param;
		crTableIO::StrVec record;
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		//crListControlWidgetNode *equipList = dynamic_cast<crListControlWidgetNode *>(canvas->getWidget(m_equipList));
		crEditWidgetNode *makeCount = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_makeCount));
		//crListControlNode *selectNode = equipList->getSelectNode();
		//if(selectNode)
		crData *canvasdata = canvas->getDataClass();
		unsigned short equipid = 0;
		if (canvasdata)
		{
			canvasdata->getParam(WCHDATA_JXJCurSelForgeTroopsEquipID,param);
			equipid = *(unsigned short *)param;
		}
		if(equipid>0 && troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record)>=0)
		{
			int makecount = _wtoi(makeCount->getString().c_str());
			if(makecount>0 && makecount < INT_MAX)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(6);
				stream->_writeUShort(equipid);
				stream->_writeInt(makecount);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvMakeTroopsEquip,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		else
		{
			myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2052,NULL));//装备出错
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvMakeTroopsEquipMethod
//
/////////////////////////////////////////
crJXJRecvMakeTroopsEquipMethod::crJXJRecvMakeTroopsEquipMethod():
	m_netType(GameClient_Game){}
crJXJRecvMakeTroopsEquipMethod::crJXJRecvMakeTroopsEquipMethod(const crJXJRecvMakeTroopsEquipMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input)
{
}
void crJXJRecvMakeTroopsEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvMakeTroopsEquipMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	}
}

void crJXJRecvMakeTroopsEquipMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short equipid = m_stream->_readUShort();
				int makecount = m_stream->_readInt();

				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
				std::vector< std::pair<int,int> >ResCountVec;
				int startIndex = troopsEquipTab->getTitleIndex("铜钱");
				int indexCount = troopsEquipTab->getColumnCount();
				crTableIO::StrVec record;
				bool canmake = false;
				std::vector< std::pair<int,int> >ResNeedVec;
				std::vector< std::pair<int,int> >ResRemainVec;
				if(troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record)>=0)
				{
					int count;
					for(int i = startIndex; i<indexCount; i++)
					{
						count = atoi(record[i].c_str());
						if(count>0)
						{
							ResCountVec.push_back(std::make_pair(i,count));
						}
					}
					int i = 0;
					std::string name;
					ref_ptr<crTableIO>resnameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResNameTab);
					void *param;
					crData *data = m_this->getDataClass();
					data->excHandle(MAKEINT64(WCH_LockData,1));
					int *mycount;
					int resid,total;
					canmake = true;
					for( std::vector< std::pair<int,int> >::iterator itr = ResCountVec.begin();
						itr != ResCountVec.end() && i<4;
						++itr,++i )
					{
						name = troopsEquipTab->getTitle(itr->first);
						total = itr->second * makecount;
						//数量检测
						resnameTab->queryOneRecord(1,name,record);
						resid = atoi(record[0].c_str());
						data->getParam(resid,param);
						mycount = (int *)param;
						if(*mycount<total || total < 0)
						{
							canmake = false;
						}
						ResNeedVec.push_back(std::make_pair(resid,total));
					}
					if(canmake)
					{
						for( std::vector< std::pair<int,int> >::iterator itr = ResNeedVec.begin();
							itr != ResNeedVec.end();
							++itr )
						{
							data->getParam(itr->first,param);
							mycount = (int *)param;
							*mycount -= itr->second;
							ResRemainVec.push_back(std::make_pair(itr->first,*mycount));
						}
						data->getParam(WCHDATA_JXJTroopsEquipMap,param);
						TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
						TroopsEquipMap::iterator itr = troopsEquipMap->find(equipid);
						if(itr == troopsEquipMap->end())
						{
							(*troopsEquipMap)[equipid] = makecount;
						}
						else
						{
							itr->second += makecount;
						}
						////////////////////////////////////////////////////
					}
					data->excHandle(MAKEINT64(WCH_LockData,0));
				}

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(8+ResNeedVec.size()*8);
				stream->_writeBool(canmake);
				if(canmake)
				{
					stream->_writeUShort(equipid);
					stream->_writeInt(makecount);
					stream->_writeUChar(ResRemainVec.size());
					for( std::vector< std::pair<int,int> >::iterator itr = ResRemainVec.begin();
						itr != ResRemainVec.end();
						++itr )
					{
						stream->_writeInt(itr->first);
						stream->_writeInt(itr->second);
					}
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvMakeTroopsEquip,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = "打造部队装备（id，count）：" + crArgumentParser::appVectoa(crVector2i(equipid,makecount));
				GameLogData gamelog(Log_MakeArmyEquip,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool success = m_stream->_readBool();
			if(success)
			{
				ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (canvas.valid())
				{
					crStaticTextWidgetNode *input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
					std::string str = "0";
					if (input)
					{
						input->setString(str);
					}
					unsigned short equipid = m_stream->_readUShort();
					int makecount = m_stream->_readInt();
					int size = (int)(m_stream->_readUChar());
					void *param;
					crData *data = m_this->getDataClass();
					data->excHandle(MAKEINT64(WCH_LockData,1));
					int *mycount;
					int resid,remaincount;
					for( int i = 0; i<size; i++)
					{
						resid = m_stream->_readInt();
						remaincount = m_stream->_readInt();
						data->getParam(resid,param);
						mycount = (int *)param;
						*mycount = remaincount;
					}
					data->getParam(WCHDATA_JXJTroopsEquipMap,param);
					TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
					TroopsEquipMap::iterator itr = troopsEquipMap->find(equipid);
					if(itr == troopsEquipMap->end())
					{
						(*troopsEquipMap)[equipid] = makecount;
					}
					else
					{
						itr->second += makecount;
					}
					data->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUITroopsEquipTipInfoMethod
//
/////////////////////////////////////////
crJXJUITroopsEquipTipInfoMethod::crJXJUITroopsEquipTipInfoMethod():
	m_ea(NULL),
	m_this(NULL)
{
}
crJXJUITroopsEquipTipInfoMethod::crJXJUITroopsEquipTipInfoMethod(const crJXJUITroopsEquipTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_ea(NULL),
	m_this(NULL)
{
}
void crJXJUITroopsEquipTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOINT64(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUITroopsEquipTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_name = str;
		break;
	case 2:
		m_info1 = str;
		break;
	case 3:
		m_info2 = str;
		break;
	}
}
void crJXJUITroopsEquipTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	if(tipsCanvas.valid())
	{
		crStaticTextWidgetNode *name = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_name));
		crHypertextWidgetNode *info1 = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_info1));
		crHypertextWidgetNode *info2 = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_info2));
		crListControlNode *selectNode = m_this->getSelectNode();
		if(selectNode)
		{
			int equipid = selectNode->getData();
			if(equipid>0)
			{
				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
				int info1id = troopsEquipTab->getTitleIndex("来源");
				int info2id = troopsEquipTab->getTitleIndex("功能");
				crTableIO::StrVec record;
				troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record);
				if(name)
				{
					name->setString(record[1]);
				}
				std::string file;
				if(info1)
				{
					file = record[info1id];
					if(!file.empty())
					{
						file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						info1->setHypertext(file);
					}
					else
					{
						info1->clearText();
					}
				}
				if(info2)
				{
					file = record[info2id];
					if(!file.empty())
					{
						file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						info2->setHypertext(file);
					}
					else
					{
						info2->clearText();
					}
				}
				crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
				tipsCanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
				tipsCanvas->setCanFocus(false);
				crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIBuildBattlegroundListMethod
//
/////////////////////////////////////////
crJXJUIBuildBattlegroundListMethod::crJXJUIBuildBattlegroundListMethod():
	m_this(NULL),
	m_alpha(0.5f),
	m_bigmapimg("T_BigMap.img")
{
	m_roadimage[0] = "UI_Line_Blue.img";
	m_roadimage[1] = "UI_Line_Green.img";
	m_roadimage[2] = "UI_Line_Red.img";
	m_roadimage[3] = "UI_Line_none.img";
	
	m_border[0] = "UI_Border_Wei.img";
	m_border[1] = "UI_Border_Shu.img";
	m_border[2] = "UI_Border_Wu.img";

	m_colormask[0] = "UI_BigMap_Zhezhao_Wei.img";
	m_colormask[1] = "UI_BigMap_Zhezhao_Shu.img";
	m_colormask[2] = "UI_BigMap_Zhezhao_Wu.img";
}
crJXJUIBuildBattlegroundListMethod::crJXJUIBuildBattlegroundListMethod(const crJXJUIBuildBattlegroundListMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_battleList(handle.m_battleList),
	m_battleList2(handle.m_battleList2),
	m_mapcanvas(handle.m_mapcanvas),
	m_play(handle.m_play),
	m_alpha(handle.m_alpha),
	m_bigmapimg(handle.m_bigmapimg)
{
	for (int i = 0;i < 7;i++)
	{
		if (i < 4)
		{
			m_roadimage[i] = handle.m_roadimage[i];
			if (i < 3)
			{
				m_border[i] = handle.m_border[i];
				m_colormask[i] = handle.m_colormask[i];
			}
		}
		m_enterbtn[i] = handle.m_enterbtn[i];
		m_jiaobtn[i] = handle.m_jiaobtn[i];
		m_paibtn[i] =  handle.m_paibtn[i];
	}
}
void crJXJUIBuildBattlegroundListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIBuildBattlegroundListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_battleList = str;
		break;
	case 1:
		m_battleList2 = str;
		break;
	case 2:
		m_mapcanvas = str;
		break;
	case 3:
		m_play = str;
		break;
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
		m_enterbtn[i - 4] = str;
		break;
	case 11:
		m_alpha = atof(str.c_str());
		break;
	case 12:
	case 13:
	case 14:
	case 15:
		m_roadimage[i - 12] = str;
		break;
	case 16:
	case 17:
	case 18:
		m_border[i - 16] = str;
		break;
	case 19:
		m_bigmapimg = str;
		break;
	case 20:
		m_backboard = str;
		break;
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
	case 26:
	case 27:
		m_jiaobtn[i - 21] = str;
		break;
	case 28:
	case 29:
	case 30:
	case 31:
	case 32:
	case 33:
	case 34:
		m_paibtn[i - 28] = str;
		break;
	}
}
void crJXJUIBuildBattlegroundListMethod::operator()(crHandle &handle)
{
	// entity
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode> mapcanvas = crFilterRenderManager::getInstance()->findCanvas(m_mapcanvas);
	crRole* pMainRole = player->getMainRole();
	if(!player || !mapcanvas || !pMainRole) return;
	crData *player_data = player->getDataClass();
	crData *canvas_data = m_this->getDataClass();
	crData *myMetierData = pMainRole->getMetierDataClass();
	if(!player_data || !canvas_data || !myMetierData) return;
	void *param;
	int taskID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCityBattleTaskID,0).c_str());
	myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
	myMetierData->getParam(WCHDATA_GameTaskMap,param);
	GameTaskMap *gameTaskMap = (GameTaskMap *)param;
	GameTaskMap::iterator it = gameTaskMap->find(taskID);
	bool bBattleCopy = false;
	if (it!= gameTaskMap->end() && it->second->getActivation())
	{
		bBattleCopy = true;
	}
	myMetierData->excHandle(MAKEINT64(WCH_LockData,0));

	crWidgetNode *backboard = dynamic_cast<crWidgetNode *>(mapcanvas->getWidget(m_backboard));
	if (backboard)
	{
		//backboard->setImageName(m_bigmapimg);
		backboard->setCanCaptureMouse(false);
		backboard->setCanFocus(false);
	}
	//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
	// get select type
	
	canvas_data->excHandle(MAKEINT64(WCH_LockData,1));
	//canvas_data->getParam(WCHDATA_JXJBattleUIType, param);
	//int select = *((int *)param);
	canvas_data->getParam(WCHDATA_JXJBattleCitiesSet, param);
	std::set<unsigned short> *battlecityset = ((std::set<unsigned short> *)param);
	canvas_data->getParam(WCHDATA_JXJMyBattleCitiesSet, param);
	std::set<unsigned short> *my_cities = ((std::set<unsigned short> *)param);
	canvas_data->getParam(WCHDATA_JXJCityInBattleSet, param);
	std::set<unsigned short> *cityinbattleset = ((std::set<unsigned short> *)param);
	my_cities->clear();
	battlecityset->clear();
	// tables
	ref_ptr<crTableIO>tab_city = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	ref_ptr<crTableIO>tab_side = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
	ref_ptr<crTableIO>roadtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengchiRoadTab);
	crTableIO::StrVec record;
	crTableIO::StrVec recordcolor;
	crTableIO::StrVec recordneighbour;

	int roadcity[4];
	roadcity[0] = roadtab->getTitleIndex("城池1");
	roadcity[1] = roadtab->getTitleIndex("城池2");
	roadcity[2] = roadtab->getTitleIndex("城池3");
	roadcity[3] = roadtab->getTitleIndex("城池4");
	int colorswindex = tab_city->getTitleIndex("colorsw");
	int maskindex = tab_city->getTitleIndex("城池mask");
	int bordernameindex = tab_city->getTitleIndex("bordername");
	int colormaskindex = tab_city->getTitleIndex("colormask");
	// extract info
	player_data->excHandle(MAKEINT64(WCH_LockData,1));
	player_data->getParam(WCHDATA_JXJShiliID,param);
	unsigned char side_id = *(unsigned char *)param;
	tab_side->queryOneRecord(0,crArgumentParser::appItoa((int)side_id),record);
	std::string side_str = record[1];
	player_data->getParam(WCHDATA_JXJChengChiMap,param);
	ChengchiMap *map_city = (ChengchiMap *)param;
	std::set<unsigned short> shilicities[3];
	 crMultiSwitch *colorsw = NULL;
	 crMultiSwitch *chengchinode = NULL;
	 crImageBoxWidgetNode *border = NULL;
	 crImageBoxWidgetNode *colormask = NULL;
	 crVector4f maskcolor;
	 bool enablealphashadow = crDisplaySettings::instance()->getEnableAlphaShadow();
	// filter my side city
	unsigned char chengzhu;
	for( ChengchiMap::iterator itr = map_city->begin(); itr != map_city->end(); ++itr)
	{
		chengzhu = itr->second->getChengzhuShili();
		if (tab_city->queryOneRecord(0,crArgumentParser::appItoa((int)itr->first),recordcolor)>=0)
		{
			//if(itr->first == 20009)
			//{
			//	int jjj=0;
			//}
			if (chengzhu>=c_startShiliID)
			{
				shilicities[chengzhu - c_startShiliID].insert(itr->first);
			}
			colorsw = dynamic_cast<crMultiSwitch *>(mapcanvas->getChildNode(recordcolor[colorswindex]));
			chengchinode = dynamic_cast<crMultiSwitch *>(mapcanvas->getChildNode(recordcolor[maskindex]));
			border = dynamic_cast<crImageBoxWidgetNode *>(mapcanvas->getWidget(recordcolor[bordernameindex]));
			colormask = dynamic_cast<crImageBoxWidgetNode *>(mapcanvas->getWidget(recordcolor[colormaskindex]));
			//chengchinode = dynamic_cast<crObject *>(mapcanvas->getChildNode(recordcolor[maskindex]));
			maskcolor = crVector4f(1.0f,1.0f,1.0f,0.0f);
			if (border)
			{
				border->setCanCaptureMouse(false);
				border->setCanFocus(false);
				border->setVisiable(false);
			}
			if (colormask)
			{
				colormask->setCanCaptureMouse(false);
				colormask->setCanFocus(false);
				colormask->setVisiable(false);
			}
			
			if (chengzhu>=c_startShiliID)
			{
				if (colorsw)colorsw->setActiveSwitchSet(chengzhu - c_startShiliID);
				if (chengchinode)
				{
					chengchinode->setActiveSwitchSet(1);
				}
				if (enablealphashadow && border)
				{
					border->setVisiable(true);
					border->setImageName(m_border[chengzhu - c_startShiliID]);
				}
				if (enablealphashadow && colormask)
				{
					colormask->setVisiable(true);
					colormask->setImageName(m_colormask[chengzhu - c_startShiliID]);
				}
				//switch (itr->second.first - c_startShiliID)
				//{
				//case 0:
				//	maskcolor = crVector4f(16.0f/255.0f,78.0f/255.0f,213.0f/255.0f,m_alpha);
				//	break;
				//case 1:
				//	maskcolor = crVector4f(0.0f,160.0f/255.0f,27.0f/255.0f,m_alpha);
				//	break;
				//case 2:
				//	maskcolor = crVector4f(213.0f/255.0f,12.0f/255.0f,0.0f,m_alpha);
				//	break;
				//default:
				//	break;
				//}
			}
			else
			{
				if (colorsw)colorsw->setActiveSwitchSet(3);
			}
			//if (chengchinode)
			//{
			//	//chengchinode->getDrawable(0)->setColor(maskcolor);
			//}
		}
		if(chengzhu == side_id)
		{
			my_cities->insert(itr->first);
			//shilicities[0].insert(itr->first);
		}
	}
	//int citycount = 1;
	//for (int i = 0; i<3; i++)
	//{
	//	if ((startShiliID + i) != side_id)
	//	{
	//		for( ChengchiMap::iterator itr = map_city->begin(); itr != map_city->end(); ++itr)
	//		{
	//			if(itr->second == (startShiliID + i))
	//				shilicities[citycount].insert(itr->first);
	//		}
	//		citycount ++;
	//	}
	//}
	// city info pre
	int ngb_ids[4];
	ngb_ids[0] = tab_city->getTitleIndex("接壤1");
	ngb_ids[1] = tab_city->getTitleIndex("接壤2");
	ngb_ids[2] = tab_city->getTitleIndex("接壤3");
	ngb_ids[3] = tab_city->getTitleIndex("接壤4");
	int city_type_index = tab_city->getTitleIndex("类型");
	int nameinputid = tab_city->getTitleIndex("cityname");
	int buttonnameid = tab_city->getTitleIndex("buttonname");
	unsigned short ngbs[4];

	ref_ptr<crButtonWidgetNode> enterbutton[7] = {NULL};
	ref_ptr<crButtonWidgetNode> jiaobutton[7] = {NULL};
	ref_ptr<crButtonWidgetNode> paibutton[7] = {NULL};
	for (int i = 0; i < 7; i++)
	{
		enterbutton[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enterbtn[i]));
		if(enterbutton[i].valid())
		{
			enterbutton[i]->setEnable(false);
		}
		jiaobutton[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_jiaobtn[i]));
		if(jiaobutton[i].valid())
		{
			jiaobutton[i]->setEnable(false);
		}
		paibutton[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_paibtn[i]));
		if(paibutton[i].valid())
		{
			paibutton[i]->setEnable(false);
		}
	}
	// 城战或者关隘站列表
	crTableWidgetNode *field_list = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_battleList));
	field_list->clearData();

	crWidgetNode *playfire =dynamic_cast<crWidgetNode *> (mapcanvas->getWidget(m_play));
	//if(select == BT_CityBattle)
	// 城战
	int city_type = 0;
	std::map< unsigned short,std::string > nbr_city;
	std::set<unsigned short> nbr_set;
	std::multimap<unsigned char,unsigned short> nbr_map;
	std::multimap<unsigned char,unsigned short> nbr_inbattlemap;
	ChengchiMap::iterator mapitr;
	// find next cities
	player_data->getParam(WCHDATA_JXJOpenBattle,param);
	bool openBattle = *(bool *)param;

	ref_ptr<crTableIO> playershilitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
	//bool no_country = true;
	if(!openBattle)
	{//
		if(playershilitab.valid())
		{
			crTableIO::StrVec record;
			int guoduIndex = playershilitab->getTitleIndex("国都");
			if(playershilitab->queryOneRecord(0,crArgumentParser::appItoa(side_id),record)>=0 && guoduIndex>=0)
			{
				unsigned short guoduid = (unsigned short)(atoi(record[guoduIndex].c_str()));
				unsigned short guodu = (*map_city)[guoduid]->getChengzhuShili();
				if (guodu == 2)
				{
					//no_country = false;
					openBattle = true;
				}
			}
		}
	}

	bool connect = false;
	for( std::set<unsigned short>::iterator itr = my_cities->begin(); itr != my_cities->end(); ++itr )
	{
		if(tab_city->queryOneRecord(0, crArgumentParser::appItoa((int)(*itr)), record)<0)
			continue;
		//判断该城与我当前驻地是否连通
		if(*itr<TestChengchiID)
		{//>30000的是测试城
			player->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(*itr,&connect));
			if(!connect)
				continue;
		}
		for(int i = 0; i < 4; i++)
		{
			// check neighbor
			ngbs[i] = (unsigned short)(atoi(record[ngb_ids[i]].c_str()));
			if(ngbs[i]>0 && my_cities->find(ngbs[i]) == my_cities->end())
			{//不是自己势力
				mapitr = map_city->find(ngbs[i]);
				if (mapitr != map_city->end() && mapitr->second->getChengzhuChengfang() > 0 && tab_city->queryOneRecord(0, crArgumentParser::appItoa((int)ngbs[i]), recordneighbour) >= 0)
				{//与敌人接壤，去除城防值为0的城池
					// 去除未开始的城战和关隘
					city_type = atoi(recordneighbour[city_type_index].c_str());
					if(city_type == 1)
					{//城战判断城战是否开启，关隘战全天候开启
						if(!openBattle && cityinbattleset->find(ngbs[i])==cityinbattleset->end())
						{//非城站时间并且该战场没有战斗
							continue;
						}
					}
					//player_data->getParam(WCHDATA_JXJOpenPass,param);
					//bool openPass = *(bool *)param;
					//if(city_type == 0 && !openPass)
					//{
					//	continue;//关隘战尚未开始
					//}
					nbr_city[*itr] = record[1];
					nbr_set.insert(ngbs[i]);

					if(cityinbattleset->find(ngbs[i]) != cityinbattleset->end())
					{
						std::multimap<unsigned char,unsigned short>::iterator itr = nbr_inbattlemap.begin();
						for(; itr != nbr_inbattlemap.end(); ++itr)
						{
							if(itr->second == ngbs[i])
								break;
						}
						if(itr == nbr_inbattlemap.end())
							nbr_inbattlemap.insert(std::make_pair(mapitr->second->getChengzhuShili(),ngbs[i]));
					}
					else
					{
						std::multimap<unsigned char,unsigned short>::iterator itr = nbr_map.begin();
						for(; itr != nbr_map.end(); ++itr)
						{
							if(itr->second == ngbs[i])
								break;
						}
						if(itr == nbr_map.end())
							nbr_map.insert(std::make_pair(mapitr->second->getChengzhuShili(),ngbs[i]));
					}
				}
				else
				{
					continue;
				}
			}
		}
	}

	int row = 0;
	//for(std::map< unsigned short,std::string >::iterator itr = nbr_city.begin(); itr != nbr_city.end(); ++itr, row++)
	//{
	//tab_city->queryOneRecord(0, crArgumentParser::appItoa(itr->first), record);
	//battlecityset->insert((unsigned short)itr->first);
	//field_list->addData(0,row, itr->second);
	//field_list->addData(1,row, side_str);
	//field_list->addData(2,row,"守");
	//field_list->addData(row, (int)(itr->first));
	//}
	row = 0;
	crTableWidgetNode *field_list2 = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_battleList2));
	field_list2->clearData();
	crTableIO::StrVec temp_rec;

	if (bBattleCopy)
	{
		int copyID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJTrainingCopyID,0).c_str());
		ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		std::string strCity;
		std::string strShili;
		if(textTab->queryOneRecord(0,crArgumentParser::appItoa(9186),record)>=0)
		{
			strCity = record[1];
		}
		if(textTab->queryOneRecord(0,crArgumentParser::appItoa(9187),record)>=0)
		{
			strShili = record[1];
		}

		field_list2->addData(0,row,strCity);
		field_list2->addData(1,row,strShili);
		field_list2->addData(2,row,"攻");
		field_list2->addData(row,copyID);
		row++;
	}
	
	for(std::multimap<unsigned char,unsigned short>::iterator itr = nbr_inbattlemap.begin(); itr != nbr_inbattlemap.end(); ++itr,row++ )
	{
		battlecityset->insert((unsigned short)(itr->second));
		if(tab_side->queryOneRecord(0,crArgumentParser::appItoa((*map_city)[itr->second]->getChengzhuShili()),temp_rec)>=0)
		{
			tab_city->queryOneRecord(0, crArgumentParser::appItoa((int)(itr->second)), record);
			field_list2->addData(0,row,record[1]);
			field_list2->addData(1,row,temp_rec[1]);
			field_list2->addData(2,row,"攻");
			field_list2->addData(row,(int)(itr->second));
		}
	}

	for(std::multimap<unsigned char,unsigned short>::iterator itr = nbr_map.begin(); itr != nbr_map.end(); ++itr,row++ )
	{
		battlecityset->insert((unsigned short)(itr->second));
		if(tab_side->queryOneRecord(0,crArgumentParser::appItoa((*map_city)[itr->second]->getChengzhuShili()),temp_rec)>=0)
		{
			tab_city->queryOneRecord(0, crArgumentParser::appItoa((int)(itr->second)), record);
			field_list2->addData(0,row,record[1]);
			field_list2->addData(1,row,temp_rec[1]);
			field_list2->addData(2,row,"攻");
			field_list2->addData(row,(int)(itr->second));
		}
	}
	for (int ii = 0; ii<row && ii<7; ii++)
	{
		if(enterbutton[ii].valid())
			enterbutton[ii]->setEnable(true);
		if(jiaobutton[ii].valid())
			jiaobutton[ii]->setEnable(true);
		if(paibutton[ii].valid())
			paibutton[ii]->setEnable(true);
	}
	//////////城池之间连通的路
	crImageBoxWidgetNode *road = NULL;
	for (int i = 0; i < roadtab->getRowCount(); i++)
	{
		road = dynamic_cast<crImageBoxWidgetNode *>(mapcanvas->getChildNode(roadtab->getData(i,0)));
		if (road)
		{
			road->setVisiable(false);
			road->setCanCaptureMouse(false);
			road->setCanFocus(false);
			//road->setImageName(m_roadimage[3]);
		}
	}

	unsigned short croad[4] = {0};
	char roadtype = 0;
	int j = 0;
	std::set<unsigned short>::iterator itrfind;
	std::set<unsigned short>::iterator itrnb;
	for (int i = 0; i < 3; i++)
	{
		for (int ii = 0; ii < roadtab->getRowCount(); ii++)
		{
			roadtype = 0;
			j = 4;
			for (int iii = 0; iii < 4; ++iii)
			{
				if (roadcity[iii] > 0)
				{
					croad[iii] = (unsigned short)atoi(roadtab->getData(ii,roadcity[iii]).c_str());
					if (croad[iii] > 0)
					{
						itrfind = shilicities[i].find(croad[iii]);
						if (itrfind==shilicities[i].end())
						{
							itrnb = nbr_set.find(croad[iii]);
							if (itrnb == nbr_set.end())
							{
								--j;
							}
							roadtype = -1;
						}
					} 
				}
			}
			if (roadtype == -1)
			{
				if (j == 4)
				{
					roadtype = 1;
				}
			} 
			//road = dynamic_cast<crImageBoxWidgetNode *>(mapcanvas->getWidget(roadtab->getData(ii,0)));
			//if (road)
			//{
			//	if (roadtype == 0)
			//	{
			//		road->setVisiable(true);
			//		road->setImageName(m_roadimage[i]);
			//	}
			//	else if(roadtype == 1)
			//	{
			//		road->setVisiable(true);
			//		road->setImageName(m_roadimage[3]);
			//	}
			//}
		}
	}

	//else
	//{// 关隘战
	//	// 获取城池毗邻关隘
	//	std::set<unsigned short> nbg_pass;
	//	for(ChengchiMap::iterator itr = map_city->begin(); itr != map_city->end(); itr++)
	//	{
	//		tab_city->queryOneRecord(0, crArgumentParser::appItoa(itr->first),record);
	//		int city_type = atoi(record[city_type_index].c_str());
	//		if(city_type != 0) continue;

	//		for(int i = 0; i < 4; i++)
	//		{
	//			// check neighbor
	//			ngbs[i] = (unsigned short)(atoi(record[ngb_ids[i]].c_str()));
	//			if(ngbs[i] <= 0) continue;
	//			search_itr = my_cities->find(ngbs[i]);

	//			// 与我方城池毗邻
	//			if(search_itr != my_cities->end())
	//			{
	//				nbg_pass.insert(itr->first);
	//			}
	//		}
	//	}

	//	// 插入信息
	//	int row = 0;
	//	for(std::set<unsigned short>::iterator itr = nbg_pass.begin(); itr != nbg_pass.end(); itr++)
	//	{
	//		ChengchiMap::iterator find_itr = map_city->find(*itr);
	//		if(find_itr == map_city->end()) continue;
	//		tab_city->queryOneRecord(0,crArgumentParser::appItoa((*itr)),record);
	//	
	//		// 除去 我方并且无毗邻敌方 关隘
	//		if(find_itr->second.first == side_id)
	//		{
	//			bool is_atb = false;
	//			for(int i = 0; i < 4; i++)
	//			{
	//				// check neighbor
	//				ngbs[i] = (unsigned short)(atoi(record[ngb_ids[i]].c_str()));
	//				if(ngbs[i] <= 0) continue;

	//				ChengchiMap::iterator temp_itr = map_city->find(ngbs[i]);
	//				if(temp_itr != map_city->end() && temp_itr->second.first != side_id)
	//				{
	//					is_atb = true;
	//				}
	//			}

	//			if(!is_atb)
	//			{
	//				continue;
	//			}
	//		}

	//		crTableIO::StrVec temp_rec;
	//		tab_side->queryOneRecord(0,crArgumentParser::appItoa((int)find_itr->second.first),temp_rec);
	//		field_list->addData(0, row, record[1]);
	//		field_list->addData(1, row, temp_rec[1]);
	//		field_list->addData(2, row, find_itr->second.first == side_id ? "守" : "攻");
	//		field_list->addData(row, (int)(find_itr->first));
	//		row++;
	//	}
	//}

	field_list->selectRow(0);
	player_data->excHandle(MAKEINT64(WCH_LockData,0));
	canvas_data->excHandle(MAKEINT64(WCH_LockData,0));
}


/////////////////////////////////////////
//
//crJXJUIBattlegroundUpdateMethod
//
/////////////////////////////////////////
crJXJUIBattlegroundUpdateMethod::crJXJUIBattlegroundUpdateMethod():
	m_this(NULL),
	m_mintime(1200)
{
}
crJXJUIBattlegroundUpdateMethod::crJXJUIBattlegroundUpdateMethod(const crJXJUIBattlegroundUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_battleTimer(handle.m_battleTimer),
	m_battleList(handle.m_battleList),
	m_chengchiName(handle.m_chengchiName),
	m_shou(handle.m_shou),
	m_enterBtn(handle.m_enterBtn),
	m_mintime(handle.m_mintime),
	m_scrollbarA(handle.m_scrollbarA),
	m_scrollbarD(handle.m_scrollbarD),
	m_canvastime(handle.m_canvastime),
	m_canvasmap(handle.m_canvasmap),
	m_playfire(handle.m_playfire),
	m_battlelistD(handle.m_battlelistD)
{
	for( int i = 0; i<3; i++)
	{
		m_gong[i] = handle.m_gong[i];
	}
	for( int i = 0; i<7; i++)
	{
		m_shilisw[i] = handle.m_shilisw[i];
		m_enterbtn[i] = handle.m_enterbtn[i];
		m_attacksw[i] = handle.m_attacksw[i];
	}
}
void crJXJUIBattlegroundUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIBattlegroundUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_battleTimer = str;
		break;
	case 1:
		m_battleList = str;
		break;
	case 2:
		m_chengchiName = str;
		break;
	case 3:
		m_gong[0] = str;
		break;
	case 4:
		m_gong[1] = str;
		break;
	case 5:
		m_gong[2] = str;
		break;
	case 6:
		m_shou = str;
		break;
	case 7:
		m_enterBtn = str;
		break;
	case 8:
		m_mintime = atoi(str.c_str());
		break;
	case 9:
		m_select = str;
		break;
	case 10:
		m_show_text = str;
		break;
	case 11:
		m_scrollbarA = str;
		break;
	case 12:
		m_scrollbarD = str;
		break;
	case 13:
		m_shilisw[0] = str;
		break;
	case 14:
		m_shilisw[1] = str;
		break;
	case 15:
		m_shilisw[2] = str;
		break;
	case 16:
		m_shilisw[3] = str;
		break;
	case 17:
		m_shilisw[4] = str;
		break;
	case 18:
		m_shilisw[5] = str;
		break;
	case 19:
		m_shilisw[6] = str;
		break;
	case 20:
		m_canvastime = str;
		break;
	case 21:
		m_canvasmap = str;
		break;
	case 22:
		m_playfire = str;
		break;
	case 23:
		m_battlelistD = str;
		break;
	case 24:
		m_enterbtn[0] = str;
		break;
	case 25:
		m_enterbtn[1] = str;
		break;
	case 26:
		m_enterbtn[2] = str;
		break;
	case 27:
		m_enterbtn[3] = str;
		break;
	case 28:
		m_enterbtn[4] = str;
		break;
	case 29:
		m_enterbtn[5] = str;
		break;
	case 30:
		m_enterbtn[6] = str;
		break;
	case 31:
		m_chengzhanCanvas = str;
		break;
	case 32:
		m_chengzhanSwitch = str;
		break;
	case 33:
	case 34:
	case 35:
	case 36:
	case 37:
	case 38:
	case 39:
		m_attacksw[i - 33] = str;
		break;
	case 40:
		m_qiehuan = str;
		break;
	default:
		break;
	}
}
void crJXJUIBattlegroundUpdateMethod::operator()(crHandle &handle)
{
	// get select type
	if (!m_this)
	{
		return;
	}
	crData *canvas_data = m_this->getDataClass();
	ref_ptr<crCanvasNode> canvastime = crFilterRenderManager::getInstance()->findCanvas(m_canvastime);
	if (!canvas_data || !canvastime)
	{
		return;
	}

	bool isopened = false;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!playerData) return;
	crData *data = playerData->getDataClass();
	void *param;
	data->getParam(WCHDATA_JXJOpenBattle,param);
	isopened = *(bool *)param;

	// 开启显示城战，未开启显示关隘战
	{
		crMultiSwitch *select_sw = dynamic_cast<crMultiSwitch *>(canvastime->getChildNode(m_select));
		if(select_sw)
		{
			if (isopened)
				select_sw->setActiveSwitchSet(0);
			else
				select_sw->setActiveSwitchSet(1);
		}
	}
	{
		ref_ptr<crCanvasNode> this_canvas = crFilterRenderManager::getInstance()->findCanvas(m_chengzhanCanvas);
		if (this_canvas.valid())
		{
			crMultiSwitch* select_sw = dynamic_cast<crMultiSwitch *>(this_canvas->getChildNode(m_chengzhanSwitch));
			if (select_sw)
			{
				if (isopened)
					select_sw->setActiveSwitchSet(0);
				else
					select_sw->setActiveSwitchSet(1);
			}
		}
	}

	crButtonWidgetNode *enterbutton[7] = {NULL};
	for (int i = 0; i < 7; i++)
	{
		enterbutton[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enterbtn[i]));
		if(enterbutton[i])
		{
			enterbutton[i]->setEnable(false);
		}
	}

	ref_ptr<crMultiSwitch> qieyesw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_qiehuan));
	if(qieyesw.valid()) qieyesw->setVisiable(false);

	crStaticTextWidgetNode *battleTimer = dynamic_cast<crStaticTextWidgetNode *>(canvastime->getWidget(m_battleTimer));
	crTableWidgetNode *battleList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_battleList));
	crTableWidgetNode *battleListD = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_battlelistD));
	crStaticTextWidgetNode *chengchiName = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_chengchiName));
	//crStaticTextWidgetNode *gong[3];
	crStaticTextWidgetNode *shou = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_shou));
	//crButtonWidgetNode *enterBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enterBtn));
	crScrollBarWidgetNode *scrollbarA = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbarA));
	crScrollBarWidgetNode *scrollbarD = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbarD));
	crMultiSwitch *PlayFireSw = NULL; 
	crMultiSwitch *shilisw[7];
	ref_ptr<crMultiSwitch> attacksw[7];
	//	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!playerData) return;
	//	crData *data = playerData->getDataClass();
	for (int i = 0; i < 7;i++)
	{
		shilisw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_shilisw[i]));
		if (shilisw[i])
		{
			shilisw[i]->setVisiable(false);
		}
		attacksw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_attacksw[i]));
		if (attacksw[i].valid())
		{
			attacksw[i]->setActiveSwitchSet(0);
		}
	}
	////////////////////////////战火
	std::set<unsigned short> cityhavedequeset;
	ref_ptr<crTableIO>tab_city = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	crTableIO::StrVec recordbatt,recordbatt2,cityrecord;
	int buttonnameid = tab_city->getTitleIndex("buttonname");
	int citynameindex = tab_city->getTitleIndex("名字");
	int citytypeindex = tab_city->getTitleIndex("类型");
	std::set<unsigned short> cityinbattle;
	ref_ptr<crCanvasNode> canvasmap = crFilterRenderManager::getInstance()->findCanvas(m_canvasmap);
	if (canvasmap.get())
	{
		crWidgetNode *playfire =dynamic_cast<crWidgetNode *> (canvasmap->getWidget(m_playfire));
		canvas_data->excHandle(MAKEINT64(WCH_LockData,1));
		canvas_data->getParam(WCHDATA_JXJBattleCitiesSet, param);
		std::set<unsigned short> *battlecityset = ((std::set<unsigned short> *)param);
		canvas_data->getParam(WCHDATA_JXJMyBattleCitiesSet, param);
		std::set<unsigned short> *my_cities = ((std::set<unsigned short> *)param);
		canvas_data->getParam(WCHDATA_JXJCityInBattleSet, param);
		std::set<unsigned short> *cityinbattleset = ((std::set<unsigned short> *)param);
		canvas_data->getParam(WCHDATA_JXJChengchiPlayFireMap, param);
		ChengchiPlayFireMap *playfiremap = (ChengchiPlayFireMap *)param;
		canvas_data->getParam(WCHDATA_JXJCityHaveDeque, param);
		cityhavedequeset = *((std::set<unsigned short> *)param);

		cityinbattle = *cityinbattleset;

		for (ChengchiPlayFireMap::iterator fireitr = playfiremap->begin();fireitr!=playfiremap->end();++fireitr)
		{
			fireitr->second->setVisiable(false);
		}

		//攻
		if (playfire)
		{
			playfire->setVisiable(false);
		}
		//for (std::set<unsigned short>::iterator battitr = battlecityset->begin();battitr!=battlecityset->end();++battitr)
		{
			//std::set<unsigned short>::iterator finditr = cityinbattleset->find((*battitr));
			//if (finditr!=cityinbattleset->end())
			for (std::set<unsigned short>::iterator battitr = cityinbattleset->begin();battitr!=cityinbattleset->end();++battitr)
			{
				if (tab_city->queryOneRecord(0,crArgumentParser::appItoa(*battitr),recordbatt)>=0)
				{
					ChengchiPlayFireMap::iterator findfireitr = playfiremap->find((*battitr));
					if (findfireitr!=playfiremap->end())
					{
						findfireitr->second->setVisiable(true);
						PlayFireSw = dynamic_cast<crMultiSwitch *>(findfireitr->second->getChild(0));
						if (PlayFireSw)
						{
							PlayFireSw->setActiveSwitchSet(0);
						}
					}
					else if (playfire)
					{
						if(!recordbatt[buttonnameid].empty())
						{
							crWidgetNode *playfire2 = dynamic_cast<crWidgetNode *>(playfire->clone(crCopyOp::DEEP_COPY_NODES));
							playfire2->setName("Fire"+crArgumentParser::appItoa(* battitr));
							crRadioWidgetNode *buttonname = dynamic_cast<crRadioWidgetNode *>(canvasmap->getWidget(recordbatt[buttonnameid]));
							if(buttonname&&playfire2)
							{
								playfire2->setEnableMatrix(true);
								playfire2->setCanFocus(false);
								//canvasmap->addChild(playfire2);
								crLoadManager::getInstance()->requestAddNode(canvasmap.get(),playfire2,false);
								playfire2->setParentCanvas(canvasmap.get());
								//canvasmap->initWindow();
								crVector3 centerCoord = buttonname->getBound().center();
								//crMatrix mat = canvasmap->getMatrix();
								playfire2->setPosition(centerCoord);
								/////JXJUIAttachUpdate
								//ref_ptr<crData> data = crDataManager::getInstance()->getData("UI");
								//ref_ptr<crHandle> driver = crHandleManager::getInstance()->getHandle("OneSlot");
								//ref_ptr<crHandle> method = crHandleManager::getInstance()->getHandle("JXJUIAttachUpdate");
								//crVector3 offset;
								//method->inputParam(3,buttonname);
								//driver->inputHandle(0,method.get());
								//data->insertHandle(WCH_UPDATEVISITOR,driver.get());
								//playfire2->setDataClass(data.get());
								///////////////////////////
								playfire2->setVisiable(true);
								playfiremap->insert(std::make_pair((*battitr),playfire2));
								///切换动画
								PlayFireSw = dynamic_cast<crMultiSwitch *>(playfire2->getChild(0));
								if (PlayFireSw)
								{
									PlayFireSw->setActiveSwitchSet(1);
								}
							}
							//buttonname->setVisiable(true);
						}
					}
				}
			}
		}
		//守
		float scrollDvalue;
		if (scrollbarD)
		{
			scrollDvalue = scrollbarD->getValue();
		}
		battleListD->clearData();
		int row=0;
		bool connect = false;
		for (std::set<unsigned short>::iterator battitr = my_cities->begin();battitr!=my_cities->end();++battitr)
		{
			std::set<unsigned short>::iterator finditr = cityinbattleset->find((*battitr));
			if (finditr!=cityinbattleset->end())
			{
				if (tab_city->queryOneRecord(0,crArgumentParser::appItoa(*battitr),recordbatt2)>=0)
				{
					battleListD->addData(0,row, recordbatt2[citynameindex]);
					battleListD->addData(1,row, "势力");
					battleListD->addData(2,row,"守");
					battleListD->addData(row, (int)((*battitr)));
					row++;
					ChengchiPlayFireMap::iterator findfireitr = playfiremap->find((*battitr));
					if (findfireitr!=playfiremap->end())
					{
						findfireitr->second->setVisiable(true);
						PlayFireSw = dynamic_cast<crMultiSwitch *>(findfireitr->second->getChild(0));
						if (PlayFireSw)
						{
							PlayFireSw->setActiveSwitchSet(1);
						}
					}
					else if (playfire)
					{
						if(!recordbatt2[buttonnameid].empty())
						{
							crWidgetNode *playfire2 = dynamic_cast<crWidgetNode *>(playfire->clone(crCopyOp::DEEP_COPY_NODES));
							playfire2->setName("Fire"+crArgumentParser::appItoa(*battitr));
							crRadioWidgetNode *buttonname = dynamic_cast<crRadioWidgetNode *>(canvasmap->getWidget(recordbatt2[buttonnameid]));
							if(buttonname&&playfire2)
							{
								playfire2->setEnableMatrix(true);
								playfire2->setCanFocus(false);
								//canvasmap->addChild(playfire2);
								crLoadManager::getInstance()->requestAddNode(canvasmap.get(),playfire2,false);
								playfire2->setParentCanvas(canvasmap.get());
								//canvasmap->initWindow();
								crVector3 centerCoord = buttonname->getBound().center();
								//crMatrix mat = canvasmap->getMatrix();
								playfire2->setPosition(centerCoord);
								playfire2->setVisiable(true);
								playfiremap->insert(std::make_pair((*battitr),playfire2));
								///切换动画
								PlayFireSw = dynamic_cast<crMultiSwitch *>(playfire2->getChild(0));
								if (PlayFireSw)
								{
									PlayFireSw->setActiveSwitchSet(0);
								}
							}
							//buttonname->setVisiable(true);
						}
					}
					//判断该城与我当前驻地是否连通
					if(*battitr<TestChengchiID)
					{//>5000的是测试城
						playerData->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(*battitr,&connect));
						if(!connect)
							cityinbattleset->erase(finditr);
					}					

				}
			}
		}
		if (scrollbarD)
		{
			scrollbarD->setValue(scrollDvalue);
		}
		for (int ii = 0; ii<row && ii<7; ii++)
		{
			enterbutton[ii]->setEnable(true);
		}
		canvas_data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	/////////////////////////////////////////////
	float dt = 0.5;
	if (scrollbarA)
	{
		int indexA = int(scrollbarA->getValue()/scrollbarA->getLineValue() + dt);
		if (indexA >=0)
		{
			canvas_data->inputParam(WCHDATA_JXJCityListstartindexA, &indexA);
			if (battleList)
			{
				for (int i = 0; i < 7; i++)
				{
					int chengchiid = battleList->getData(indexA + i);
					data->getParam(WCHDATA_JXJChengChiMap,param);
					ChengchiMap *mapcity = (ChengchiMap *)param;
					if (mapcity->size() > 0 && chengchiid > 0)
					{
						unsigned char shiliid = 0;
						// filter my side city
						for( ChengchiMap::iterator itr = mapcity->begin(); itr != mapcity->end(); ++itr)
						{
							if(itr->first == chengchiid)
							{
								shiliid = itr->second->getChengzhuShili();
								break;
							}
						}
						if (shilisw[i])
						{
							shilisw[i]->setVisiable(true);
						}

						//城池还是关隘显示切换
						int guanai = 0;
						if (tab_city->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),cityrecord)>=0)
						{
							if(atoi(cityrecord[citytypeindex].c_str()) == 0)
								guanai = 4;
							else
								guanai = 0;
						}
						//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
						if(shiliid >= c_startShiliID)
						{
							if (shilisw[i])
							{
								shilisw[i]->setActiveSwitchSet((int)shiliid - c_startShiliID + guanai);
							}
						}
						else
						{
							if (shilisw[i])
							{
								shilisw[i]->setActiveSwitchSet(3 + guanai);
							}
						}
						//处于排队中的城池
						if (cityhavedequeset.find(chengchiid) != cityhavedequeset.end())
						{
							if(attacksw[i].valid())
								attacksw[i]->setActiveSwitchSet(2);
						}
						else
						{
							if(attacksw[i].valid())
								attacksw[i]->setActiveSwitchSet(0);
						}
						//处于交战中的城池
						if (cityinbattle.find(chengchiid) != cityinbattle.end())
						{
							if(attacksw[i].valid())
								attacksw[i]->setActiveSwitchSet(1);
						}
						else
						{
							if(attacksw[i].valid())
								attacksw[i]->setActiveSwitchSet(0);
						}
					}
					//if(chengchiid == 20009)
					//shilisw[i]->setVisiable(false);
				}
			}
		}

	}
	if (scrollbarD)
	{
		int indexD = (scrollbarD->getValue() + dt)/scrollbarD->getLineValue();
		if (indexD >=0)
		{
			canvas_data->inputParam(WCHDATA_JXJCityListstartindexD, &indexD);
		}
	}
	//gong[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gong[0]));
	//gong[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gong[1]));
	//gong[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gong[2]));

	//ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	//int buttonnameid = chengchiTab->getTitleIndex("buttonname");
	//crTableIO::StrVec btnrecord;
	//int rowcount = battleList->getRowCount();
	//for (int i = 0;i<rowcount;i++)
	//{
	//	unsigned short cityid2 = battleList->getData(i);
	//	chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(cityid2),btnrecord);
	//	if (btnrecord.size())
	//	{
	//		std::string btnname = btnrecord[buttonnameid];
	//		crButtonWidgetNode *cityBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(btnname));
	//		if (cityBtn)
	//		{
	//			crMultiSwitch *btnswi = dynamic_cast<crMultiSwitch *>(cityBtn->getChild(0));
	//			if (btnswi)
	//			{
	//				btnswi->setActiveSwitchSet(0);
	//			}
	//		}
	//	}
	//}
	//unsigned short cityid = battleList->getSelectData();
	//chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(cityid),btnrecord);
	//if (btnrecord.size())
	//{
	//	std::string btnname = btnrecord[buttonnameid];
	//	crButtonWidgetNode *cityBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(btnname));
	//	if (cityBtn)
	//	{
	//		crMultiSwitch *btnswi = dynamic_cast<crMultiSwitch *>(cityBtn->getChild(0));
	//		if (btnswi)
	//		{
	//			btnswi->setActiveSwitchSet(1);
	//		}
	//	}
	//}

	//if(select == BT_CityBattle)
	//{
	//	data->getParam(WCHDATA_JXJOpenBattle,param);
	//	is_opened = *(bool *)param;
	//	data->getParam(WCHDATA_JXJBattleTimer,param);
	//	time = *(short *)param;
	//}
	//else if(select == BT_GateBattle)
	//{
	//	data->getParam(WCHDATA_JXJOpenPass,param);
	//	is_opened = *(bool *)param;
	//	data->getParam(WCHDATA_JXJPassTimer,param);
	//	time = *(short *)param;
	//}
	//
	//// shows
	//// show time
	//if(is_opened)
	//{
	//	int t;
	//	int hour,minute,s;
	//	hour = time/3600;
	//	t = time%3600;
	//	minute = t/60;
	//	s = t%60;
	//	if(time<=m_mintime)
	//	{
	//		if(battleTimer)battleTimer->setColor(crVector4(1,0,0,1));
	//		//if (enterBtn)
	//		//{
	//		//	enterBtn->setEnable(false);
	//		//}
	//	}
	//	else
	//	{
	//		if(battleTimer)battleTimer->setColor(crVector4(0,0,0,1));
	//		//if (enterBtn)
	//		//{
	//		//	enterBtn->setEnable(true);
	//		//}
	//	}
	//	if (battleTimer)battleTimer->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
	//}
	//else
	//{
	//	if(battleTimer)battleTimer->setColor(crVector4(0,0,0,1));
	//	if(battleTimer)battleTimer->setString(L"00:00:00");
	//	//enterBtn->setEnable(false);
	//	//gong[0]->clearString();
	//	//gong[1]->clearString();
	//	//gong[2]->clearString();
	//}

}

/////////////////////////////////////////
//
//crJXJUIBattlegroundUpdate1Method
//
/////////////////////////////////////////
crJXJUIBattlegroundUpdate1Method::crJXJUIBattlegroundUpdate1Method():
	m_this(NULL),
	m_mintime(1200)
{
}
crJXJUIBattlegroundUpdate1Method::crJXJUIBattlegroundUpdate1Method(const crJXJUIBattlegroundUpdate1Method& handle):
	crMethod(handle),
	m_this(NULL),
	m_battleTimer(handle.m_battleTimer),
	m_battleList(handle.m_battleList),
	m_chengchiName(handle.m_chengchiName),
	m_shou(handle.m_shou),
	m_enterBtn(handle.m_enterBtn),
	m_mintime(handle.m_mintime),
	m_scrollbarA(handle.m_scrollbarA),
	m_scrollbarD(handle.m_scrollbarD),
	m_canvastime(handle.m_canvastime),
	m_canvasmap(handle.m_canvasmap),
	m_playfire(handle.m_playfire),
	m_battlelistD(handle.m_battlelistD),
	m_qiehuanshilisw(handle.m_qiehuanshilisw),
	m_radiowei(handle.m_radiowei),
	m_radioshu(handle.m_radioshu),
	m_radiowu(handle.m_radiowu)
{
	for( int i = 0; i<3; i++)
	{
		m_gong[i] = handle.m_gong[i];
	}
	for( int i = 0; i<7; i++)
	{
		m_shilisw[i] = handle.m_shilisw[i];
		m_enterbtn[i] = handle.m_enterbtn[i];
		m_attacksw[i] = handle.m_attacksw[i];
	}
}
void crJXJUIBattlegroundUpdate1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIBattlegroundUpdate1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_battleTimer = str;
		break;
	case 1:
		m_battleList = str;
		break;
	case 2:
		m_chengchiName = str;
		break;
	case 3:
		m_gong[0] = str;
		break;
	case 4:
		m_gong[1] = str;
		break;
	case 5:
		m_gong[2] = str;
		break;
	case 6:
		m_shou = str;
		break;
	case 7:
		m_enterBtn = str;
		break;
	case 8:
		m_mintime = atoi(str.c_str());
		break;
	case 9:
		m_select = str;
		break;
	case 10:
		m_show_text = str;
		break;
	case 11:
		m_scrollbarA = str;
		break;
	case 12:
		m_scrollbarD = str;
		break;
	case 13:
		m_shilisw[0] = str;
		break;
	case 14:
		m_shilisw[1] = str;
		break;
	case 15:
		m_shilisw[2] = str;
		break;
	case 16:
		m_shilisw[3] = str;
		break;
	case 17:
		m_shilisw[4] = str;
		break;
	case 18:
		m_shilisw[5] = str;
		break;
	case 19:
		m_shilisw[6] = str;
		break;
	case 20:
		m_canvastime = str;
		break;
	case 21:
		m_canvasmap = str;
		break;
	case 22:
		m_playfire = str;
		break;
	case 23:
		m_battlelistD = str;
		break;
	case 24:
		m_enterbtn[0] = str;
		break;
	case 25:
		m_enterbtn[1] = str;
		break;
	case 26:
		m_enterbtn[2] = str;
		break;
	case 27:
		m_enterbtn[3] = str;
		break;
	case 28:
		m_enterbtn[4] = str;
		break;
	case 29:
		m_enterbtn[5] = str;
		break;
	case 30:
		m_enterbtn[6] = str;
		break;
	case 31:
		m_chengzhanCanvas = str;
		break;
	case 32:
		m_chengzhanSwitch = str;
		break;
	case 33:
	case 34:
	case 35:
	case 36:
	case 37:
	case 38:
	case 39:
		m_attacksw[i - 33] = str;
		break;
	default:
		break;
	}
}
void crJXJUIBattlegroundUpdate1Method::operator()(crHandle &handle)
{
	// get select type
	if (!m_this)
	{
		return;
	}
	crData *canvas_data = m_this->getDataClass();
	ref_ptr<crCanvasNode> canvastime = crFilterRenderManager::getInstance()->findCanvas(m_canvastime);
	if (!canvas_data || !canvastime)
	{
		return;
	}

	bool isopened = false;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!playerData) return;
	crData *data = playerData->getDataClass();
	void *param;
	data->getParam(WCHDATA_JXJOpenBattle,param);
	isopened = *(bool *)param;

	// 开启显示城战，未开启显示关隘战
	{
		crMultiSwitch *select_sw = dynamic_cast<crMultiSwitch *>(canvastime->getChildNode(m_select));
		if(select_sw)
		{
			if (isopened)
				select_sw->setActiveSwitchSet(0);
			else
				select_sw->setActiveSwitchSet(1);
		}
	}
	{
		ref_ptr<crCanvasNode> this_canvas = crFilterRenderManager::getInstance()->findCanvas(m_chengzhanCanvas);
		if (this_canvas.valid())
		{
			crMultiSwitch* select_sw = dynamic_cast<crMultiSwitch *>(this_canvas->getChildNode(m_chengzhanSwitch));
			if (select_sw)
			{
				if (isopened)
					select_sw->setActiveSwitchSet(0);
				else
					select_sw->setActiveSwitchSet(1);
			}
		}
	}

	crButtonWidgetNode *enterbutton[7] = {NULL};
	for (int i = 0; i < 7; i++)
	{
		enterbutton[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enterbtn[i]));
		if(enterbutton[i])
		{
			enterbutton[i]->setEnable(false);
		}
	}

	unsigned char attackcountry = 13;
	std::set<unsigned short> cityinbattle;
	std::set<unsigned short> cityhavedequeset;
	crStaticTextWidgetNode *battleTimer = dynamic_cast<crStaticTextWidgetNode *>(canvastime->getWidget(m_battleTimer));
	crTableWidgetNode *battleList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_battleList));
	crTableWidgetNode *battleListD = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_battlelistD));
	crStaticTextWidgetNode *chengchiName = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_chengchiName));
	//crStaticTextWidgetNode *gong[3];
	crStaticTextWidgetNode *shou = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_shou));
	//crButtonWidgetNode *enterBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enterBtn));
	crScrollBarWidgetNode *scrollbarA = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbarA));
	crScrollBarWidgetNode *scrollbarD = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbarD));
	crMultiSwitch *PlayFireSw = NULL; 
	crMultiSwitch *citytypesw[7];
	crMultiSwitch *attacksw[7];

	/*ref_ptr<crMultiSwitch> shilisw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_qiehuanshilisw));
	ref_ptr<crRadioGroupWidgetNode> radiowei = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radiowei));
	ref_ptr<crRadioGroupWidgetNode> radioshu = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radioshu));
	ref_ptr<crRadioGroupWidgetNode> radiowu = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radiowu));
	if (shilisw.valid())
	{
	data->getParam(WCHDATA_JXJShiliID,param);
	unsigned char myshiliid =  *(unsigned char *)param;
	if (myshiliid == 10)
	{
	shilisw->setActiveSwitchSet(0);
	if (radiowei.valid())
	{
	if(radiowei->getSelect() == 0)
	attackcountry = 11;
	else if(radiowei->getSelect() == 1)
	attackcountry = 12;
	else
	attackcountry = 2;
	}
	}
	else if(myshiliid == 11)
	{
	shilisw->setActiveSwitchSet(1);
	if (radioshu.valid())
	{
	if(radioshu->getSelect() == 0)
	attackcountry = 12;
	else if(radioshu->getSelect() == 1)
	attackcountry = 10;
	else
	attackcountry = 2;
	}

	}
	else
	{
	shilisw->setActiveSwitchSet(2);
	if (radiowu.valid())
	{
	if(radiowu->getSelect() == 0)
	attackcountry = 10;
	else if(radiowu->getSelect() == 1)
	attackcountry = 11;
	else
	attackcountry = 2;
	}
	}
	}*/
	//	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!playerData) return;
	//	crData *data = playerData->getDataClass();
	for (int i = 0; i < 7;i++)
	{
		citytypesw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_shilisw[i]));
		if (citytypesw[i])
		{
			citytypesw[i]->setVisiable(false);
		}
		attacksw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_attacksw[i]));
		if (attacksw[i])
		{
			attacksw[i]->setActiveSwitchSet(0);
		}
	}

	/*crButtonWidgetNode *enterbuttonA[7] = {NULL};
	for (int i = 0; i < 7; i++)
	{
	enterbuttonA[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enterbtnA[i]));
	if(enterbuttonA[i])
	{
	enterbuttonA[i]->setEnable(false);
	}
	}*/
	////////////////////////////战火
	ref_ptr<crTableIO>tab_city = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	crTableIO::StrVec recordbatt,recordbatt2,cityrecord;
	int buttonnameid = tab_city->getTitleIndex("buttonname");
	int citynameindex = tab_city->getTitleIndex("名字");
	int citytypeindex = tab_city->getTitleIndex("类型");
	ref_ptr<crCanvasNode> canvasmap = crFilterRenderManager::getInstance()->findCanvas(m_canvasmap);
	if (canvasmap.get())
	{
		crWidgetNode *playfire =dynamic_cast<crWidgetNode *> (canvasmap->getWidget(m_playfire));
		canvas_data->excHandle(MAKEINT64(WCH_LockData,1));
		canvas_data->getParam(WCHDATA_JXJBattleCitiesSet, param);
		std::set<unsigned short> *battlecityset = ((std::set<unsigned short> *)param);
		canvas_data->getParam(WCHDATA_JXJMyBattleCitiesSet, param);
		std::set<unsigned short> *my_cities = ((std::set<unsigned short> *)param);
		canvas_data->getParam(WCHDATA_JXJCityInBattleSet, param);
		std::set<unsigned short> *cityinbattleset = ((std::set<unsigned short> *)param);
		canvas_data->getParam(WCHDATA_JXJChengchiPlayFireMap, param);
		ChengchiPlayFireMap *playfiremap = (ChengchiPlayFireMap *)param;
		canvas_data->getParam(WCHDATA_JXJCityHaveDeque, param);
		cityhavedequeset = *((std::set<unsigned short> *)param);

		cityinbattle = *cityinbattleset;

		for (ChengchiPlayFireMap::iterator fireitr = playfiremap->begin();fireitr!=playfiremap->end();++fireitr)
		{
			fireitr->second->setVisiable(false);
		}

		//攻
		if (playfire)
		{
			playfire->setVisiable(false);
		}
		//for (std::set<unsigned short>::iterator battitr = battlecityset->begin();battitr!=battlecityset->end();++battitr)
		{
			//std::set<unsigned short>::iterator finditr = cityinbattleset->find((*battitr));
			//if (finditr!=cityinbattleset->end())
			for (std::set<unsigned short>::iterator battitr = cityinbattleset->begin();battitr!=cityinbattleset->end();++battitr)
			{
				if (tab_city->queryOneRecord(0,crArgumentParser::appItoa(*battitr),recordbatt)>=0)
				{
					ChengchiPlayFireMap::iterator findfireitr = playfiremap->find((*battitr));
					if (findfireitr!=playfiremap->end())
					{
						findfireitr->second->setVisiable(true);
						PlayFireSw = dynamic_cast<crMultiSwitch *>(findfireitr->second->getChild(0));
						if (PlayFireSw)
						{
							PlayFireSw->setActiveSwitchSet(0);
						}
					}
					else if (playfire)
					{
						if(!recordbatt[buttonnameid].empty())
						{
							crWidgetNode *playfire2 = dynamic_cast<crWidgetNode *>(playfire->clone(crCopyOp::DEEP_COPY_NODES));
							playfire2->setName("Fire"+crArgumentParser::appItoa(* battitr));
							crRadioWidgetNode *buttonname = dynamic_cast<crRadioWidgetNode *>(canvasmap->getWidget(recordbatt[buttonnameid]));
							if(buttonname&&playfire2)
							{
								playfire2->setEnableMatrix(true);
								playfire2->setCanFocus(false);
								//canvasmap->addChild(playfire2);
								crLoadManager::getInstance()->requestAddNode(canvasmap.get(),playfire2,false);
								playfire2->setParentCanvas(canvasmap.get());
								//canvasmap->initWindow();
								crVector3 centerCoord = buttonname->getBound().center();
								//crMatrix mat = canvasmap->getMatrix();
								playfire2->setPosition(centerCoord);
								/////JXJUIAttachUpdate
								//ref_ptr<crData> data = crDataManager::getInstance()->getData("UI");
								//ref_ptr<crHandle> driver = crHandleManager::getInstance()->getHandle("OneSlot");
								//ref_ptr<crHandle> method = crHandleManager::getInstance()->getHandle("JXJUIAttachUpdate");
								//crVector3 offset;
								//method->inputParam(3,buttonname);
								//driver->inputHandle(0,method.get());
								//data->insertHandle(WCH_UPDATEVISITOR,driver.get());
								//playfire2->setDataClass(data.get());
								///////////////////////////
								playfire2->setVisiable(true);
								playfiremap->insert(std::make_pair((*battitr),playfire2));
								///切换动画
								PlayFireSw = dynamic_cast<crMultiSwitch *>(playfire2->getChild(0));
								if (PlayFireSw)
								{
									PlayFireSw->setActiveSwitchSet(1);
								}
							}
							//buttonname->setVisiable(true);
						}
					}
				}
			}
		}
		//守
		float scrollDvalue;
		if (scrollbarD)
		{
			scrollDvalue = scrollbarD->getValue();
		}
		battleListD->clearData();
		int row=0;
		bool connect = false;
		for (std::set<unsigned short>::iterator battitr = my_cities->begin();battitr!=my_cities->end();++battitr)
		{
			std::set<unsigned short>::iterator finditr = cityinbattleset->find((*battitr));
			if (finditr!=cityinbattleset->end())
			{
				if (tab_city->queryOneRecord(0,crArgumentParser::appItoa(*battitr),recordbatt2)>=0)
				{
					battleListD->addData(0,row, recordbatt2[citynameindex]);
					battleListD->addData(1,row, "势力");
					battleListD->addData(2,row,"守");
					battleListD->addData(row, (int)((*battitr)));
					row++;
					ChengchiPlayFireMap::iterator findfireitr = playfiremap->find((*battitr));
					if (findfireitr!=playfiremap->end())
					{
						findfireitr->second->setVisiable(true);
						PlayFireSw = dynamic_cast<crMultiSwitch *>(findfireitr->second->getChild(0));
						if (PlayFireSw)
						{
							PlayFireSw->setActiveSwitchSet(1);
						}
					}
					else if (playfire)
					{
						if(!recordbatt2[buttonnameid].empty())
						{
							crWidgetNode *playfire2 = dynamic_cast<crWidgetNode *>(playfire->clone(crCopyOp::DEEP_COPY_NODES));
							playfire2->setName("Fire"+crArgumentParser::appItoa(*battitr));
							crRadioWidgetNode *buttonname = dynamic_cast<crRadioWidgetNode *>(canvasmap->getWidget(recordbatt2[buttonnameid]));
							if(buttonname&&playfire2)
							{
								playfire2->setEnableMatrix(true);
								playfire2->setCanFocus(false);
								//canvasmap->addChild(playfire2);
								crLoadManager::getInstance()->requestAddNode(canvasmap.get(),playfire2,false);
								playfire2->setParentCanvas(canvasmap.get());
								//canvasmap->initWindow();
								crVector3 centerCoord = buttonname->getBound().center();
								//crMatrix mat = canvasmap->getMatrix();
								playfire2->setPosition(centerCoord);
								playfire2->setVisiable(true);
								playfiremap->insert(std::make_pair((*battitr),playfire2));
								///切换动画
								PlayFireSw = dynamic_cast<crMultiSwitch *>(playfire2->getChild(0));
								if (PlayFireSw)
								{
									PlayFireSw->setActiveSwitchSet(0);
								}
							}
							//buttonname->setVisiable(true);
						}
					}
					//判断该城与我当前驻地是否连通
					if(*battitr<TestChengchiID)
					{//>5000的是测试城
						playerData->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(*battitr,&connect));
						if(!connect)
							cityinbattleset->erase(finditr);
					}					

				}
			}
		}
		if (scrollbarD)
		{
			scrollbarD->setValue(scrollDvalue);
		}
		for (int ii = 0; ii<row && ii<7; ii++)
		{
			enterbutton[ii]->setEnable(true);
		}
		canvas_data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	/////////////////////////////////////////////
	float dt = 0.5;
	if (scrollbarA)
	{
		int indexA = int(scrollbarA->getValue()/scrollbarA->getLineValue() + dt);
		if (indexA >=0)
		{
			canvas_data->inputParam(WCHDATA_JXJCityListstartindexA, &indexA);
			if (battleList)
			{
				for (int i = 0; i < 7; i++)
				{
					int chengchiid = battleList->getData(indexA + i);
					data->getParam(WCHDATA_JXJChengChiMap,param);
					ChengchiMap *mapcity = (ChengchiMap *)param;
					if (mapcity->size() > 0 && chengchiid > 0)
					{
						unsigned char shiliid = 0;
						// filter my side city
						for( ChengchiMap::iterator itr = mapcity->begin(); itr != mapcity->end(); ++itr)
						{
							if(itr->first == chengchiid)
							{
								shiliid = itr->second->getChengzhuShili();
								break;
							}
						}
						if (citytypesw[i])
						{
							citytypesw[i]->setVisiable(true);
						}

						//城池还是关隘显示切换
						int guanai = 0;
						if (tab_city->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),cityrecord)>=0)
						{
							if(atoi(cityrecord[citytypeindex].c_str()) == 0)
								guanai = 4;
							else
								guanai = 0;
						}

						if(shiliid >= c_startShiliID)
						{
							if (citytypesw[i])
							{
								citytypesw[i]->setActiveSwitchSet(((int)shiliid - c_startShiliID)+guanai);
							}
						}
						else
						{
							if (citytypesw[i])
							{
								citytypesw[i]->setActiveSwitchSet(3+guanai);
							}
						}

						//处于排队中的城池
						if (cityhavedequeset.find(chengchiid) != cityhavedequeset.end())
						{
							attacksw[i]->setActiveSwitchSet(2);
						}
						else
						{
							attacksw[i]->setActiveSwitchSet(0);
						}
						//处于交战中的城池
						if (cityinbattle.find(chengchiid) != cityinbattle.end())
						{
							attacksw[i]->setActiveSwitchSet(1);
						}
						else
						{
							attacksw[i]->setActiveSwitchSet(0);
						}
					}
				}
			}
		}	
	}
	if (scrollbarD)
	{
		int indexD = (scrollbarD->getValue() + dt)/scrollbarD->getLineValue();
		if (indexD >=0)
		{
			canvas_data->inputParam(WCHDATA_JXJCityListstartindexD, &indexD);
		}
	}
	//gong[0] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gong[0]));
	//gong[1] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gong[1]));
	//gong[2] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gong[2]));

	//ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	//int buttonnameid = chengchiTab->getTitleIndex("buttonname");
	//crTableIO::StrVec btnrecord;
	//int rowcount = battleList->getRowCount();
	//for (int i = 0;i<rowcount;i++)
	//{
	//	unsigned short cityid2 = battleList->getData(i);
	//	chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(cityid2),btnrecord);
	//	if (btnrecord.size())
	//	{
	//		std::string btnname = btnrecord[buttonnameid];
	//		crButtonWidgetNode *cityBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(btnname));
	//		if (cityBtn)
	//		{
	//			crMultiSwitch *btnswi = dynamic_cast<crMultiSwitch *>(cityBtn->getChild(0));
	//			if (btnswi)
	//			{
	//				btnswi->setActiveSwitchSet(0);
	//			}
	//		}
	//	}
	//}
	//unsigned short cityid = battleList->getSelectData();
	//chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(cityid),btnrecord);
	//if (btnrecord.size())
	//{
	//	std::string btnname = btnrecord[buttonnameid];
	//	crButtonWidgetNode *cityBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(btnname));
	//	if (cityBtn)
	//	{
	//		crMultiSwitch *btnswi = dynamic_cast<crMultiSwitch *>(cityBtn->getChild(0));
	//		if (btnswi)
	//		{
	//			btnswi->setActiveSwitchSet(1);
	//		}
	//	}
	//}

	//if(select == BT_CityBattle)
	//{
	//	data->getParam(WCHDATA_JXJOpenBattle,param);
	//	is_opened = *(bool *)param;
	//	data->getParam(WCHDATA_JXJBattleTimer,param);
	//	time = *(short *)param;
	//}
	//else if(select == BT_GateBattle)
	//{
	//	data->getParam(WCHDATA_JXJOpenPass,param);
	//	is_opened = *(bool *)param;
	//	data->getParam(WCHDATA_JXJPassTimer,param);
	//	time = *(short *)param;
	//}
	//
	//// shows
	//// show time
	//if(is_opened)
	//{
	//	int t;
	//	int hour,minute,s;
	//	hour = time/3600;
	//	t = time%3600;
	//	minute = t/60;
	//	s = t%60;
	//	if(time<=m_mintime)
	//	{
	//		if(battleTimer)battleTimer->setColor(crVector4(1,0,0,1));
	//		//if (enterBtn)
	//		//{
	//		//	enterBtn->setEnable(false);
	//		//}
	//	}
	//	else
	//	{
	//		if(battleTimer)battleTimer->setColor(crVector4(0,0,0,1));
	//		//if (enterBtn)
	//		//{
	//		//	enterBtn->setEnable(true);
	//		//}
	//	}
	//	if (battleTimer)battleTimer->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
	//}
	//else
	//{
	//	if(battleTimer)battleTimer->setColor(crVector4(0,0,0,1));
	//	if(battleTimer)battleTimer->setString(L"00:00:00");
	//	//enterBtn->setEnable(false);
	//	//gong[0]->clearString();
	//	//gong[1]->clearString();
	//	//gong[2]->clearString();
	//}

}

/////////////////////////////////////////
//
//crJXJOpenBattleTimerMethod
//
/////////////////////////////////////////
crJXJOpenBattleTimerMethod::crJXJOpenBattleTimerMethod():
	m_timer(0L)
{
}
crJXJOpenBattleTimerMethod::crJXJOpenBattleTimerMethod(const crJXJOpenBattleTimerMethod& handle):
	crMethod(handle),
	m_timer(0L)
{
}
void crJXJOpenBattleTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJOpenBattleTimerMethod::addParam(int i, const std::string& str)
{
}
void crJXJOpenBattleTimerMethod::operator()(crHandle &handle)
{
	time_t t = time(0);
	if(m_timer == 0)
	{
		m_timer = t;
		return;
	}
	int dt = t - m_timer;
	if(dt>0)
	{
		m_timer = t;
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));

		char code = 0;
		data->getParam(WCHDATA_JXJOpenBattle,param);
		bool *openBattle = (bool *)param;
		if(!(*openBattle))
		{
			std::string opentime = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOpenBattleTime_1,0);
			std::string endtime = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJEndBattleTime_1,0);
			std::string opentime_2 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOpenBattleTime_2,0);
			std::string endtime_2 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJEndBattleTime_2,0);
			std::string opentime_3 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOpenBattleTime_3,0);
			std::string endtime_3 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJEndBattleTime_3,0);
			char tmp[20];
			strftime( tmp, sizeof(tmp), "%H:%M:%S\0", localtime(&t) );
			crVector3i opentm,endtm,curtm;
			crVector3i opentm_2,endtm_2,opentm_3,endtm_3;
			crArgumentParser::appTimetoVec(opentime,opentm);
			crArgumentParser::appTimetoVec(endtime,endtm);
			crArgumentParser::appTimetoVec(opentime_2,opentm_2);
			crArgumentParser::appTimetoVec(endtime_2,endtm_2);
			crArgumentParser::appTimetoVec(opentime_3,opentm_3);
			crArgumentParser::appTimetoVec(endtime_3,endtm_3);
			crArgumentParser::appTimetoVec(tmp,curtm);

			//国战前5、4、3、2、1分钟发公告
			/*if (curtm > opentm)
			{
			int term = (curtm[0]-opentm[0])*3600 + (curtm[1]-opentm[1])*60 + curtm[2]-opentm[2];
			if (term==300 || term==240 || term==180 || term==120 || term==60 || term==3)
			{
			m_this->doEvent(WCH_JXJBattleOpenCenterNoticeCreate,MAKEINT64(term,NULL));
			}
			}*/
			if (curtm < opentm_2)
			{
				int term = (opentm_2[0] - curtm[0])*3600 + (opentm_2[1] - curtm[1])*60 + opentm_2[2] - curtm[2];
				if (term==300 || term==240 || term==180 || term==120 || term==60 || term==3)
				{
					m_this->doEvent(WCH_JXJBattleOpenCenterNoticeCreate,MAKEINT64(term,NULL));
				}
			}
			if (curtm < opentm_3)
			{
				int term = (opentm_3[0] - curtm[0])*3600 + (opentm_3[1] - curtm[1])*60 + opentm_3[2] - curtm[2];
				if (term==300 || term==240 || term==180 || term==120 || term==60 || term==3)
				{
					m_this->doEvent(WCH_JXJBattleOpenCenterNoticeCreate,MAKEINT64(term,NULL));
				}
			}
			//国战开启时客户端谈提示框
			if (curtm==opentm_2 || curtm==opentm_3)
			{
				int term = 0;
				m_this->doEvent(WCH_JXJBattleOpenCenterNoticeCreate,MAKEINT64(term,NULL));
			}

			if(opentm<curtm && curtm<endtm)
			{
				int term = (endtm[0]-curtm[0])*3600+(endtm[1]-curtm[1])*60+endtm[2]-curtm[2];//atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleTerm).c_str());
				*openBattle = true;
				data->inputParam(WCHDATA_JXJBattleTimer,&term);
				code = 1;
			}
			if(opentm_2<curtm && curtm<endtm_2)
			{
				int term = (endtm_2[0]-curtm[0])*3600+(endtm_2[1]-curtm[1])*60+endtm_2[2]-curtm[2];//atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleTerm).c_str());
				*openBattle = true;
				data->inputParam(WCHDATA_JXJBattleTimer,&term);
				code = 1;
				opentm = opentm_2;
				endtm = endtm_2;
			}
			if(opentm_3<curtm && curtm<endtm_3)
			{
				int term = (endtm_3[0]-curtm[0])*3600+(endtm_3[1]-curtm[1])*60+endtm_3[2]-curtm[2];//atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleTerm).c_str());
				*openBattle = true;
				data->inputParam(WCHDATA_JXJBattleTimer,&term);
				code = 1;
				opentm = opentm_3;
				endtm = endtm_3;
			}
			if(*openBattle)
			{//国战开启时，国战积分排行榜数据清空
				bool resetranking = true;
				data->getParam(WCHDATA_JXJBattleRankingSaveTime,param);
				time_t savetime = *(time_t *)param;
				if(savetime>0)
				{
					strftime( tmp, sizeof(tmp), "%Y|%m|%d\0", localtime(&t) );
					crVector3i nowdate;
					crArgumentParser::appTimetoVec(tmp,nowdate,'|');
					strftime( tmp, sizeof(tmp), "%Y|%m|%d\0", localtime(&savetime) );
					crVector3i savedata;
					crArgumentParser::appTimetoVec(tmp,savedata,'|');

					strftime( tmp, sizeof(tmp), "%H:%M:%S\0", localtime(&savetime) );
					crVector3i savetm;
					crArgumentParser::appTimetoVec(tmp,savetm);
					if(nowdate == savedata && opentm<curtm && curtm<endtm)
					{//上次存储属于国战期间内，不重置
						resetranking = false;
					}
				}
				if(resetranking)
				{
					data->getParam(WCHDATA_JXJBattleRankingMapWei,param);
					BattleRankingMap *rankingMapWei = (BattleRankingMap *)param;
					rankingMapWei->clear();
					data->getParam(WCHDATA_JXJBattleRankingMapShu,param);
					BattleRankingMap *rankingMapShu = (BattleRankingMap *)param;
					rankingMapShu->clear();
					data->getParam(WCHDATA_JXJBattleRankingMapWu,param);
					BattleRankingMap *rankingMapWu = (BattleRankingMap *)param;
					rankingMapWu->clear();
					data->inputParam(WCHDATA_JXJBattleRankingVerWei,NULL);
					data->inputParam(WCHDATA_JXJBattleRankingVerShu,NULL);
					data->inputParam(WCHDATA_JXJBattleRankingVerWu,NULL);
				}
			}
		}
		else
		{
			data->getParam(WCHDATA_JXJBattleTimer,param);
			int *battleTimer = (int *)param;
			*battleTimer -= dt;
			if(*battleTimer<=0)
			{
				*battleTimer = 0;
				*openBattle = false;
				code = 1;
				//m_settleTime = 300;
			}
		}
		//data->getParam(WCHDATA_JXJOpenPass,param);
		//bool *openPass = (bool *)param;
		//if(!(*openPass))
		//{
		//	std::string opentime = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPassTimeStart);
		//	std::string opentime1 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPassTimeEnd);
		//	char tmp[20];
		//	strftime( tmp, sizeof(tmp), "%H:%M:%S\0", localtime(&t) );
		//	crVector3i opentm,opentm1,curtm;
		//	crArgumentParser::appTimetoVec(opentime,opentm);
		//	crArgumentParser::appTimetoVec(opentime1,opentm1);
		//	crArgumentParser::appTimetoVec(tmp,curtm);
		//	if(opentm<curtm && curtm<opentm1)
		//	{
		//		short term = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPassTimeLast).c_str()));
		//		*openPass = true;
		//		data->inputParam(WCHDATA_JXJPassTimer,&term);
		//		code = 1;
		//	}
		//}
		//else
		//{
		//	data->getParam(WCHDATA_JXJPassTimer,param);
		//	short *passTimer = (short *)param;
		//	*passTimer -= dt;
		//	if(*passTimer<0)
		//	{
		//		*passTimer = 0;
		//		*openPass = false;
		//		//code = 2;
		//		//m_settleTime = 300;
		//	}
		//}
		if(code == 1)
		{
			//通知所有玩家
			crBattleOpenPacket packet;
			crBattleOpenPacket::buildReplyPacket(packet,0,*openBattle);
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetDataManager *netDataManager = netConductor->getNetDataManager();
			netDataManager->sendPacketToAllPlayer(packet);
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSaveChengchiMapMethod
//
/////////////////////////////////////////
crJXJSaveChengchiMapMethod::crJXJSaveChengchiMapMethod()
{
}
crJXJSaveChengchiMapMethod::crJXJSaveChengchiMapMethod(const crJXJSaveChengchiMapMethod& handle):
	crMethod(handle)/*,
					m_chengchi2TabFile(handle.m_chengchi2TabFile)*/
{
}
void crJXJSaveChengchiMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJSaveChengchiMapMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	m_chengchi2TabFile = str;
	//	break;
	//}
}
void crJXJSaveChengchiMapMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJChengchiModifySet,param);
		ChengchiModifySet *chengchiModifySet = (ChengchiModifySet *)param;
		if(!chengchiModifySet->empty())
		{
			data->getParam(WCHDATA_JXJChengChiMap,param);
			ChengchiMap *chengchiMap = (ChengchiMap *)param;
			crDBSavePacket packet;
			ref_ptr<crUpdateChengchi2> updateChengchi2 = new crUpdateChengchi2;
			unsigned short chengchiid;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(12);
			for( ChengchiModifySet::iterator itr = chengchiModifySet->begin();
				itr != chengchiModifySet->end();
				++itr )
			{
				chengchiid = *itr;
				stream->seekBegin();
				(*chengchiMap)[chengchiid]->buildStream(stream);
				updateChengchi2->buildUpdateSql(chengchiid,stream.get());
				crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,updateChengchi2.get());
				dbConductor->getNetManager()->sendPacket("all",packet);
			}
			chengchiModifySet->clear();
			////保存城池
			//ChengchiMap *chengchiMap;
			//ref_ptr<crTableIO> chengchi2Tab;
			//crTableIO::StrVec record;
			//crTableIO::StrVec title;
			//title.push_back("id");
			//title.push_back("当前势力");
			//title.push_back("城防值");

			//data->getParam(WCHDATA_JXJChengChiMap,param);
			//chengchiMap = (ChengchiMap *)param;
			//chengchi2Tab = new crTableIO;
			//chengchi2Tab->setTitleVec(title);
			//record.resize(3);
			//for( ChengchiMap::iterator itr = chengchiMap->begin();
			//	itr != chengchiMap->end();
			//	++itr )
			//{
			//	record[0] = crArgumentParser::appItoa((int)(itr->first));
			//	record[1] = crArgumentParser::appItoa((int)(itr->second.first));
			//	record[2] = crArgumentParser::appItoa((int)(itr->second.second));
			//	chengchi2Tab->addData(record);
			//}
			//chengchi2Tab->saveToFile(m_chengchi2TabFile,SM_Record);
			//*modified = false;
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
///////////////////////////////////////////
////
////crJXJSaveChengchiMapMethod
////
///////////////////////////////////////////
//crJXJImmediatelySaveMethod::crJXJImmediatelySaveMethod()
//{
//}
//crJXJImmediatelySaveMethod::crJXJImmediatelySaveMethod(const crJXJImmediatelySaveMethod& handle):
//	crMethod(handle)/*,
//	m_chengchi2TabFile(handle.m_chengchi2TabFile)*/
//{
//}
//void crJXJImmediatelySaveMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//void crJXJImmediatelySaveMethod::addParam(int i, const std::string& str)
//{
//	//switch(i) 
//	//{
//	//case 0:
//	//	m_chengchi2TabFile = str;
//	//	break;
//	//}
//}
//void crJXJImmediatelySaveMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crData *data = m_this->getDataClass();
//	data->excHandle(MAKEINT64(WCH_LockData,1));
//	data->getParam(WCHDATA_JXJImmediatelySavePlayerSet,param);
//	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
//	ImmediatelySavePlayerSet *playerset = (ImmediatelySavePlayerSet *)param;
//	ref_ptr<crGameServerPlayerData> playerData;
//	for( ImmediatelySavePlayerSet::iterator itr = playerset->begin();
//		 itr != playerset->end();
//		 ++itr )
//	{
//		playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(*itr));
//		if(playerData.valid()) callback->savePlayerData(playerData.get());
//	}
//	playerset->clear();
//	data->excHandle(MAKEINT64(WCH_LockData,0));
//}
/////////////////////////////////////////
//
//crJXJSaveConsortiaMethod
//
/////////////////////////////////////////
crJXJSaveConsortiaMethod::crJXJSaveConsortiaMethod():
	m_saveCount(10)
{
}
crJXJSaveConsortiaMethod::crJXJSaveConsortiaMethod(const crJXJSaveConsortiaMethod& handle):
	crMethod(handle),
	m_saveCount(handle.m_saveCount)
{
}
void crJXJSaveConsortiaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJSaveConsortiaMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_saveCount = atoi(str.c_str());
		break;
	}
}
void crJXJSaveConsortiaMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJConsortiaMap,param);
		ConsortiaMap *consortiaMap = (ConsortiaMap *)param;
		ref_ptr<crJXJConsortia> consortia;
		crData *consortiaData;
		bool modify;
		int count = 0;
		crDBSavePacket packet;
		ref_ptr<crUpdateConsortia> updateConsortia = new crUpdateConsortia;
		ref_ptr<CRCore::crStreamBuf> dataStream;
		for( ConsortiaMap::iterator itr = consortiaMap->begin();
			itr != consortiaMap->end() && count<m_saveCount;
			++itr )
		{
			consortia = itr->second.get();
			consortiaData = consortia->getDataClass();
			consortiaData->getParam(WCHDATA_JXJConsortiaModify,param);
			modify = *(bool *)param;
			if(modify)
			{
				dataStream = new crStreamBuf;
				consortiaData->excHandle(MAKEINT64(WCH_BuildSaveStream,dataStream.get()));
				//consortiaData->getParam(WCHDATA_DataStream,param);
				//if(param)
				//{
				//dataStream = *((ref_ptr<crStreamBuf>*)param);
				//往数据库里添加
				updateConsortia->buildUpdateSql(consortia->getID(),/*consortia->getLevel(),consortia->getAffiche(),*/dataStream.get());
				crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,updateConsortia.get());
				dbConductor->getNetManager()->sendPacket("all",packet);
				count++;
				//}
				consortiaData->inputParam(WCHDATA_JXJConsortiaModify,NULL);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSaveShiliMethod
//
/////////////////////////////////////////
crJXJSaveShiliMethod::crJXJSaveShiliMethod()
{
}
crJXJSaveShiliMethod::crJXJSaveShiliMethod(const crJXJSaveShiliMethod& handle):
	crMethod(handle)
{
}
void crJXJSaveShiliMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJSaveShiliMethod::addParam(int i, const std::string& str)
{
}
void crJXJSaveShiliMethod::saveShili(crJXJShili *shili,CRNet::crNetConductor *dbConductor)
{
	if(shili && shili->getDataClass())
	{
		crData *shiliData = shili->getDataClass();
		shiliData->excHandle(MAKEINT64(WCH_LockData,1));
		crDBSavePacket packet;
		ref_ptr<crUpdateShili> updateShili = new crUpdateShili;
		ref_ptr<CRCore::crStreamBuf> dataStream;
		void *param;
		shiliData->getParam(WCHDATA_JXJShiliModify,param);
		bool modify = *(bool *)param;
		if(modify)
		{
			dataStream = new crStreamBuf;
			shiliData->excHandle(MAKEINT64(WCH_BuildSaveStream,dataStream.get()));
			//shiliData->getParam(WCHDATA_DataStream,param);
			//if(param)
			//{
			//dataStream = *((ref_ptr<crStreamBuf>*)param);
			//往数据库里添加
			updateShili->buildUpdateSql(shili->getID(),dataStream.get());
			crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,updateShili.get());
			dbConductor->getNetManager()->sendPacket("all",packet);
			//}
			shiliData->inputParam(WCHDATA_JXJShiliModify,NULL);
		}
		shiliData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
void crJXJSaveShiliMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJShiliWei,param);
		crJXJShili *shili = (crJXJShili *)param;
		saveShili(shili,dbConductor);

		data->getParam(WCHDATA_JXJShiliShu,param);
		shili = (crJXJShili *)param;
		saveShili(shili,dbConductor);

		data->getParam(WCHDATA_JXJShiliWu,param);
		shili = (crJXJShili *)param;
		saveShili(shili,dbConductor);

		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJIsBattleOpenedMethod
//
/////////////////////////////////////////
crJXJIsBattleOpenedMethod::crJXJIsBattleOpenedMethod(){}
crJXJIsBattleOpenedMethod::crJXJIsBattleOpenedMethod(const crJXJIsBattleOpenedMethod& handle):
	crMethod(handle)
{
}
void crJXJIsBattleOpenedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJIsBattleOpenedMethod::addParam(int i, const std::string& str)
{
}
void crJXJIsBattleOpenedMethod::operator()(crHandle &handle)
{
	bool openbattle = false;
	crPlayerGameData *myData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myData)
	{
		void *param;
		//crData *canvas_data = m_this->getDataClass();
		//canvas_data->getParam(WCHDATA_JXJBattleUIType, param);
		//if (canvas_data)
		//{
			//int select = *((int *)param);
			//if (select == BT_CityBattle)
			//{
				crData *data = myData->getDataClass();
				data->getParam(WCHDATA_JXJOpenBattle,param);
				openbattle = *(bool *)param;
			//}
			//else if(select == BT_GateBattle)
			//{
			//	crData *data = myData->getDataClass();
			//	data->getParam(WCHDATA_JXJOpenPass,param);
			//	openbattle = *(bool *)param;
			//}
		//}
	}
	handle.outputParam(0,&openbattle);
}


/////////////////////////////////////////
//
//crJXJUIQueryBattleTimerMethod
//
/////////////////////////////////////////
crJXJUIQueryBattleTimerMethod::crJXJUIQueryBattleTimerMethod(){}
crJXJUIQueryBattleTimerMethod::crJXJUIQueryBattleTimerMethod(const crJXJUIQueryBattleTimerMethod& handle):
	crMethod(handle)
{
}
void crJXJUIQueryBattleTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRCore::crCanvasNode * )param;
		break;
	}
}
void crJXJUIQueryBattleTimerMethod::addParam(int i, const std::string& str)
{
}
void crJXJUIQueryBattleTimerMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		//void *param;
		//crData *canvas_data = m_this->getDataClass();
		//canvas_data->getParam(WCHDATA_JXJBattleUIType, param);
		//if (canvas_data)
		//{
			//int select = *((int *)param);
			//if (select == BT_CityBattle)
			//{
				crQueryBattleTimerPacket packet;
				//crQueryBattleTimerPacket::buildRequestPacket(packet/*,unsigned char(BT_CityBattle)*/);
				netConductor->getNetManager()->sendPacket("all",packet);
			//}
			//else if(select == BT_GateBattle)
			//{
			//	crQueryBattleTimerPacket packet;
			//	crQueryBattleTimerPacket::buildRequestPacket(packet,unsigned char(BT_GateBattle));
			//	netConductor->getNetManager()->sendPacket("all",packet);
			//}
		//}
	}
}


/////////////////////////////////////////
//
//crJXJUIBuildFrientListMethod
//
/////////////////////////////////////////
crJXJUIBuildFrientListMethod::crJXJUIBuildFrientListMethod():
	m_this(NULL)
{
}
crJXJUIBuildFrientListMethod::crJXJUIBuildFrientListMethod(const crJXJUIBuildFrientListMethod& handle):
	crMethod(handle),
	m_this(NULL)/*,
	m_friendlist(handle.m_friendlist)*/
{
}
void crJXJUIBuildFrientListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIBuildFrientListMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	m_friendlist = str;
	//	break;
	//}
}
void crJXJUIBuildFrientListMethod::operator()(crHandle &handle)
{
	//ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		//int onepagenum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOneInvitePageNum).c_str()));
		crData *data = crBrain::getInstance()->getDataClass();
		if (data)
		{
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJCurInvitePageNum,param);
			int *curpagenum = (int *)param;
			*curpagenum = 1;
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			//if (m_this)
			//{
			//	crTableWidgetNode *friendlist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_friendlist));
			//}
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIInviteUpdateMethod
//
/////////////////////////////////////////
crJXJUIInviteUpdateMethod::crJXJUIInviteUpdateMethod():
	m_this(NULL)
{
}
crJXJUIInviteUpdateMethod::crJXJUIInviteUpdateMethod(const crJXJUIInviteUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_inviteBtn(handle.m_inviteBtn),
	m_friendlist(handle.m_friendlist),
	m_selectInfo(handle.m_selectInfo),
	m_pagenuminpue(handle.m_pagenuminpue)
{
	for( int i = 0; i<5; i++)
	{
		m_invitebtn[i] = handle.m_invitebtn[i];
	}
}
void crJXJUIInviteUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIInviteUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_inviteBtn = str;
		break;
	case 1:
		m_friendlist = str;
		break;
	case 2:
		m_selectInfo = str;
		break;
	case 3:
		m_invitebtn[0] = str;
		break;
	case 4:
		m_invitebtn[1] = str;
		break;
	case 5:
		m_invitebtn[2] = str;
		break;
	case 6:
		m_invitebtn[3] = str;
		break;
	case 7:
		m_invitebtn[4] = str;
		break;
	case 8:
		m_pagenuminpue = str;
		break;
	}
}
void crJXJUIInviteUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		crData *data = myPlayer->getDataClass();
		//crButtonWidgetNode *inviteBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_inviteBtn));
		crTableWidgetNode *friendlist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_friendlist));
		//crStaticTextWidgetNode *selectInfo = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_selectInfo));
		crStaticTextWidgetNode *pagenuminput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenuminpue));
		//crFriend *selectFriend = (crFriend *)(friendlist->getSelectData());
		if(friendlist)
		{
			void *param;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int onepagenum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOneInvitePageNum,viplv).c_str()));
			crData *braindata = crBrain::getInstance()->getDataClass();
			if (braindata)
			{
				braindata->getParam(WCHDATA_JXJCurInvitePageNum,param);
				int curpagenum = *(int *)param;
				crButtonWidgetNode *invitebtn[5]={NULL};
				for (int i =0; i<5;i++)
				{
					invitebtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_invitebtn[i]));
					if (invitebtn[i])
					{
						invitebtn[i]->setVisiable(false);
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJFriendList,param);
				FriendVec *friendVec = (FriendVec *)param;
				if (friendVec->size()>0)
				{
					friendlist->clearData();
					if (curpagenum>0 && onepagenum>0)
					{
						int row = -((curpagenum - 1) * onepagenum);
						std::string str;
						for( FriendVec::iterator itr = friendVec->begin();
							itr != friendVec->end();
							++itr)
						{
							if (row>=5)
							{
								break;
							}
							if (row>=0)
							{
								if (!(*itr)->getOnline())
								{
									continue;
								}
								str = (*itr)->getName();
								friendlist->addData(0,row,str);
								str = "Lv:"+crArgumentParser::appItoa((*itr)->getLevel());
								friendlist->addData(1,row,str);
								friendlist->addData(row,(int)(itr->get()));
								invitebtn[row]->setVisiable(true);
							}
							row++;
						}
						//friendlist->selectRow(0);
					}
					int totalpagenum = ceil((float)friendVec->size()/(float)onepagenum);
					braindata->inputParam(WCHDATA_JXJTotalInvitePageNum,&totalpagenum);
					if(pagenuminput)pagenuminput->setString(crArgumentParser::appItoa(curpagenum) + "/" + crArgumentParser::appItoa(totalpagenum));
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				//if(inviteBtn)inviteBtn->setEnable(true);
				//std::string str = selectFriend->getName() + "Lv:"+crArgumentParser::appItoa(selectFriend->getLevel());
				//if(selectInfo)selectInfo->setString(str);
			}
			else
			{
				//if(inviteBtn)inviteBtn->setEnable(false);
				//if(selectInfo)selectInfo->clearString();
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBattlegroundInviteMethod
//
/////////////////////////////////////////
crJXJUIBattlegroundInviteMethod::crJXJUIBattlegroundInviteMethod():
	m_this(NULL),
	m_inviteindex(0)
{
}
crJXJUIBattlegroundInviteMethod::crJXJUIBattlegroundInviteMethod(const crJXJUIBattlegroundInviteMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_friendlist(handle.m_friendlist),
	m_inviteindex(handle.m_inviteindex)
{
}
void crJXJUIBattlegroundInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIBattlegroundInviteMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_friendlist = str;
		break;
	case 1:
		m_inviteindex = atoi(str.c_str());
		break;
	}
}
void crJXJUIBattlegroundInviteMethod::operator()(crHandle &handle)
{
	void *param;
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	crPlayerGameData *myplayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if (canvas.valid() && myplayer)
	{
		crData *myData = myplayer->getDataClass();
		myData->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		myData->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short id = *(unsigned short *)param;
		if(type>0 && id>0)
		{
			crTableWidgetNode *friendlist = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_friendlist));
			//crFriend *selectFriend = (crFriend *)(friendlist->getSelectData());
			myData->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int onepagenum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOneInvitePageNum,viplv).c_str()));
			crData *data = crBrain::getInstance()->getDataClass();
			int curpagenum = 0;
			if (data)
			{
				data->getParam(WCHDATA_JXJCurInvitePageNum,param);
				curpagenum = *(int *)param;
				//data->getParam(WCHDATA_JXJCurInviteType,param);
				//unsigned char minvitetype = *(unsigned char *)param;
				if (m_inviteindex>=0 && curpagenum>0 && onepagenum>0)
				{
					m_inviteindex += (curpagenum-1) * onepagenum;
				}
				crFriend *selectFriend = (crFriend *)(friendlist->getData(m_inviteindex));
				if(selectFriend)
				{
					//unsigned char invitetype;
					//switch (minvitetype)
					//{
					//case 0:
					//	invitetype = Invite_Battleground;
					//	break;
					//case 1:
					//	invitetype = Invite_Fuben;
					//	break;
					//}
					//crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameClient_Game);
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					if(netConductor)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4);
						//stream->_writeUChar(invitetype);
						stream->_writeInt(selectFriend->getPlayerID());
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvInvite,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvInviteMethod
//
/////////////////////////////////////////
crJXJRecvInviteMethod::crJXJRecvInviteMethod():
	m_netType(GameClient_Game){}
crJXJRecvInviteMethod::crJXJRecvInviteMethod(const crJXJRecvInviteMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvInviteMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvInviteMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			char code = 0;//-1:对方不在线，-2对方在组队里，-3对方在战场里，-4对方在排队，-5提前退出惩罚时间内,-6对方等级不足,-7副本ID错误,-8对方已经完成该副本
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				crData *myData = m_this->getDataClass();
				myData->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				myData->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short id = *(unsigned short *)param;
				if(type>0 && id>0)
				{
					int invitePlayerID = m_stream->_readInt();
					do 
					{
						ref_ptr<crGameServerPlayerData> invitePlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(invitePlayerID));
						if(invitePlayerData.valid() && invitePlayerData->getPlayerGameData() && invitePlayerData->getPlayerGameData()->getDataClass() && invitePlayerData->getPlayerGameData()->getMainRole())
						{
							//if(itype == Invite_Battleground || itype == Invite_Fuben)
							//{//检查是否是同势力的
							myData->getParam(WCHDATA_JXJShiliID,param);
							unsigned char myShili = *(unsigned char *)param;
							crData *inviteData = invitePlayerData->getPlayerGameData()->getDataClass();
							crData *inviteRoleData = invitePlayerData->getPlayerGameData()->getMainRole()->getDataClass();
							inviteData->getParam(WCHDATA_JXJShiliID,param);
							unsigned char inviteShili = *(unsigned char *)param;
							if(myShili == inviteShili)
							{
								inviteData->getParam(WCHDATA_JXJTeamLeaderID,param);
								int leaderid = *(int *)param;
								if(leaderid != 0 && leaderid != playerid)
								{
									code = -2;//对方在组队里
									break;
								}
								if(invitePlayerData->getSceneID() != 0)
								{
									code = -3;//对方在战场里
									break;
								}
								inviteData->getParam(WCHDATA_JXJFubenOrChengchiType,param);
								unsigned char _type = *(unsigned char *)param;
								if(_type == FT_Chengchi)
								{
									code = -4;//该玩家正在战场排队
									break;
								}
								if(type == FT_Chengchi)
								{
									crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
									gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
									gsBrainData->getParam(WCHDATA_JXJBattleDropPlayerMap,param);
									BattleDropPlayerMap *battleDropPlayerMap = (BattleDropPlayerMap *)param;
									BattleDropPlayerMap::iterator bitr = battleDropPlayerMap->find(invitePlayerID);
									if( bitr != battleDropPlayerMap->end() )
									{
										code = -5;//提前退出惩罚时间内
										gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
										break;
									}
									gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
								}
								inviteRoleData->getParam(WCHDATA_Level,param);
								unsigned char invitelv = *(unsigned char *)param;
								if(type == FT_Chengchi)
								{
									inviteData->getParam(WCHDATA_JXJTreasonPunishTimer,param);
									int punishtime = *(int *)param; 
									if(punishtime != 0) 
									{
										code = -9;//对方在叛国惩罚期内
										break;
									}

									inviteData->getParam(WCHDATA_JXJVipLv,param);
									unsigned char inviteviplv = *(unsigned char *)param;
									unsigned char openlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevel,inviteviplv).c_str());
									int maxBattlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenMaxLimitLevel,inviteviplv).c_str());
									int IncreaseDate = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevelIncreaseDate,inviteviplv).c_str());

									int tianshu = 0;
									if (crGlobalHandle::isClient())
									{
										crGlobalHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
									}
									else
									{
										crServerBrainHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
									}
									if (tianshu >= 0 && tianshu < IncreaseDate)
									{
										if (invitelv < openlv)
										{
											code = -6;//对方等级不足
											break;

										}
									}
									else if (tianshu >= IncreaseDate && tianshu < maxBattlelv-IncreaseDate)
									{
										int battlelv_1 = openlv + tianshu - IncreaseDate + 1;
										if (invitelv < battlelv_1)
										{
											code = -6;//对方等级不足
											break;
										}
									}
									else
									{
										if (invitelv < maxBattlelv)
										{
											code = -6;//对方等级不足
											break;
										}
									}

									//if (invitelv < openlv)
									//{
									//	code = -6;//对方等级不足
									//	break;
									//}
								}
								else
								{
									ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
									crTableIO::StrVec fubenrecord;
									int needlvindex = fubentab->getTitleIndex("需求等级");
									if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(id),fubenrecord)>=0)
									{
										if(invitelv < atoi(fubenrecord[needlvindex].c_str()))
										{
											code = -6;//对方等级不足
											break;
										}
										inviteData->excHandle(MAKEINT64(WCH_LockData,1));
										inviteData->getParam(WCHDATA_JXJFubenProgressMap,param);
										FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
										FubenProgressMap::iterator itr = fubenProgressMap->find(id);
										if(itr != fubenProgressMap->end())
										{
											if(itr->second->getComplete()>1)
											{
												code = -8;//对方已经完成该副本
											}
										}
										inviteData->excHandle(MAKEINT64(WCH_LockData,0));
										if(code<0)
											break;
									}
									else
									{
										code = -7;//副本ID错误
										break;
									}

								}

								ref_ptr<crStreamBuf> stream = new crStreamBuf;
								stream->createBuf(11+playerData->getCharacterName().length());
								stream->_writeUChar(type);
								stream->_writeUShort(id);
								stream->_writeInt(playerid);
								stream->_writeString(playerData->getCharacterName());
								crPlayerDataEventPacket packet;
								crPlayerDataEventPacket::buildReplyPacket(packet,invitePlayerID,WCH_JXJClientRecvInvite,stream.get());
								gameServer->getNetManager()->sendPacket(invitePlayerData->getPlayerConnectServerAddress(),packet);
							}
							else
							{
								code = -1;//-1:对方已经下线
								break;
							}
							//}
						}
					} while (0);
					if(code<0)
					{
						crPlayerDataEventPacket packet;
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(1);
						stream->_writeChar(code);
						crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvInvite,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char code = m_stream->_readChar();
			switch (code)
			{
			case -1://对方已经下线，不能被邀请
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1062,NULL));
				break;
			case -2://对方在组队里，不能被邀请
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1063,NULL));
				break;
			case -3://对方在战场里，不能被邀请
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1064,NULL));
				break;
			case -4://对方正在战场排队，不能被邀请
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1065,NULL));
				break;
			case -5://提前退出惩罚时间内
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1066,NULL));
				break;
			case -6://对方等级不足
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(2076,NULL));
				break;
			case -7://副本ID错误
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(2077,NULL));
				break;
			case -8://对方已经完成该副本
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1070,NULL));
				break;
			case -9://对方在叛国惩罚期内
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(9161,NULL));
				break;
			default://对方不能被邀请
				crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1067,NULL));
				break;
			}
		}
	}
}

////////////////////////////////
//
//crJXJSetInviteMethod
//
///////////////////////////////////
crJXJSetInviteMethod::crJXJSetInviteMethod():
	m_netType(GameClient_Game){}
crJXJSetInviteMethod::crJXJSetInviteMethod(const crJXJSetInviteMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_canvasFrame(handle.m_canvasFrame),
	m_playername(handle.m_playername),
	m_placername(handle.m_placername),
	m_inviteyouenter(handle.m_inviteyouenter),
	m_myteam(handle.m_myteam),
	m_invitecanvas(handle.m_invitecanvas),
	m_invitename(handle.m_invitename)
{
}
void crJXJSetInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJSetInviteMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_canvasFrame = str;
		break;
	case 2:
		m_playername = str;
		break;
	case 3:
		m_placername = str;
		break;
	case 4:
		m_inviteyouenter = str;
		break;
	case 5:
		m_myteam = str;
		break;
	case 6:
		m_invitecanvas = str;
		break;
	case 7:
		m_invitename = str;
		break;
	}
}
void crJXJSetInviteMethod::operator()(crHandle &handle)
{
	unsigned char invitetype = m_stream->_readUChar();
	unsigned short id = m_stream->_readUShort();//副本或者城池ID
	int playerid = m_stream->_readInt();
	std::string playname = m_stream->_readString();
	if(invitetype>0 && id>0)
	{
		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
		if(canvas.valid())
		{
			crStaticTextWidgetNode *frame = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_canvasFrame));
			crStaticTextWidgetNode *playername = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_playername));
			crStaticTextWidgetNode *placername = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_placername));
			crStaticTextWidgetNode *inviteyouenter = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_inviteyouenter));
			crStaticTextWidgetNode *myteam = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_myteam));
			//crHypertextWidgetNode *text = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_text));
			ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
			ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			crTableIO::StrVec record;
			std::string str = "邀请您加入",str2,name;
			int nameid = 0;
			crData *data = m_this->getDataClass();
			switch (invitetype)
			{
			case FT_Chengchi:
				//frame->setString(L"城战邀请");
				str2 = "城战队伍";
				if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
				{
					nameid = chengchiTab->getTitleIndex("名字");
					name = record[nameid].c_str();
				}
				break;
			case FT_Fuben:  
				//frame->setString(L"副本邀请");
				str2 = "副本队伍";
				if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
				{
					nameid = fubentab->getTitleIndex("name");
					name = record[nameid].c_str();
				}
				break;
			}
			data->inputParam(WCHDATA_JXJInviteType,&invitetype);
			data->inputParam(WCHDATA_JXJInviteID,&playerid);
			data->inputParam(WCHDATA_JXJInviteChengChiID,&id);
			if(playername)
			{
				playername->setColor(crVector4f(0.0f,255.0f,255.0f,255.0f));
				playername->setString(playname);
			}
			if(placername)
			{
				placername->setColor(crVector4f(50.0f,170.0f,255.0f,255.0f));
				placername->setString(name);
			}
			if(inviteyouenter)
			{
				inviteyouenter->setString(str);
			}
			if(myteam)
			{
				myteam->setString(str2);
			}
			ref_ptr<crCanvasNode> invitecanvas = crFilterRenderManager::getInstance()->findCanvas(m_invitecanvas);
			if (invitecanvas.get())
			{
				crStaticTextWidgetNode *invitename = dynamic_cast<crStaticTextWidgetNode *>(invitecanvas->getWidget(m_invitename));
				if (invitename)
				{
					invitename->setString(name);
				}
			}
			crData *dlgData = canvas->getDataClass();
			int commandtype = CDP_PlayerGameData;
			dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
			dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
			crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		}
	}
}


////////////////////////////////
//
//crJXJAcceptInviteMethod
//
///////////////////////////////////
crJXJAcceptInviteMethod::crJXJAcceptInviteMethod(){}
crJXJAcceptInviteMethod::crJXJAcceptInviteMethod(const crJXJAcceptInviteMethod& handle):
	crMethod(handle),
	m_punishcanvas(handle.m_punishcanvas)
{
}
void crJXJAcceptInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJAcceptInviteMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_punishcanvas = str;
		break;
	default:
		break;
	}
}
void crJXJAcceptInviteMethod::operator()(crHandle &handle)
{
	if(m_this->getMainRole())
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_JXJInviteType,param);
		unsigned char inviteType = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJInviteChengChiID,param);
		unsigned short chengchiID = *(unsigned short *)param;
		data->getParam(WCHDATA_JXJInviteID,param);
		int inviteID = *(int *)param;
		int texid = 0;
		crData *roledata = m_this->getMainRole()->getDataClass();
		roledata->getParam(WCHDATA_Level,param);
		unsigned char mylv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char myviplv = *(unsigned char *)param;
		do 
		{
			if(inviteID<=0 || inviteType==FT_None)
			{
				texid = 1074;//接受邀请失败！
				break;
			}
			else if(inviteType == FT_Chengchi)
			{
				ref_ptr<crCanvasNode> punishcanvas = crFilterRenderManager::getInstance()->findCanvas(m_punishcanvas);
				if (punishcanvas.get() && punishcanvas->getVisiable())
				{
					texid = 1033;//提前退出惩罚时间内
					break;
				}
				int battlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevel,myviplv).c_str());
				int maxBattlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenMaxLimitLevel,myviplv).c_str());
				int IncreaseDate = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevelIncreaseDate,myviplv).c_str());
				int tianshu = 0;
				if (crGlobalHandle::isClient())
				{
					crGlobalHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
				}
				else
				{
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKEINT64(&tianshu, NULL));
				}
				if (tianshu >= 0 && tianshu < IncreaseDate)
				{
					if (mylv < battlelv)
					{
						texid = 1075;//等级不足，接受邀请失败！
						break;
					}
				}
				else if (tianshu >= IncreaseDate && tianshu < maxBattlelv-IncreaseDate)
				{
					int battlelv_1 = battlelv + tianshu - IncreaseDate + 1;
					if (mylv < battlelv_1)
					{
						texid = 1075;//等级不足，接受邀请失败！
						break;
					}
				}
				else
				{
					if (mylv < maxBattlelv)
					{
						texid = 1075;//等级不足，接受邀请失败！
						break;
					}
				}

				//if(mylv<battlelv)
				//{
				//	texid = 1075;//等级不足，接受邀请失败！
				//	break;
				//}

				//判断该城与我当前驻地是否连通
				if(chengchiID<TestChengchiID)
				{//>5000的是测试城
					bool connect = false;
					m_this->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(chengchiID,&connect));
					if(!connect)
					{
						texid = 1073;//军队无法到达该城！
						break;
					}
				}
			}
			else if(chengchiID>0)
			{
				ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
				crTableIO::StrVec fubenrecord;
				int needlvindex = fubentab->getTitleIndex("需求等级");
				if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(chengchiID),fubenrecord)<0)
				{
					texid = 1074;//接受邀请失败！
					break;
				}
				if(mylv < atoi(fubenrecord[needlvindex].c_str()))
				{
					texid = 1075;//副本进度不满足，接受邀请失败！
					break;
				}
				bool fubencheck = false;
				data->getParam(WCHDATA_JXJFubenProgressMap,param);
				FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
				FubenProgressMap::iterator itr = fubenProgressMap->find(chengchiID);
				FubenProgressMap::iterator itr_front = fubenProgressMap->find(chengchiID-1);

				if(itr_front!=fubenProgressMap->end() && itr_front->second->getComplete()>=1)
				{
					fubencheck = true;
				}
				if(itr != fubenProgressMap->end() && itr->second->getComplete()>=1)
				{
					fubencheck = true;
				}
				if(itr == fubenProgressMap->end() && itr_front==fubenProgressMap->end() && fubentab->queryOneRecord(0,crArgumentParser::appItoa(chengchiID-1),fubenrecord)<0)
					fubencheck = true;

				if(!fubencheck)
				{
					texid = 3008;//副本未至此关
					break;
				}
			}
		} while (0);
		if(texid == 0)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(7);
				stream->_writeInt(inviteID);
				stream->_writeUChar(inviteType);
				stream->_writeUShort(chengchiID);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvJoinTeam,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		else if(texid>0)
		{
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
			int mode = 1;
			noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
			crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
		}
	}
}


////////////////////////////////
//
//crJXJRefuseInviteMethod
//
///////////////////////////////////
crJXJRefuseInviteMethod::crJXJRefuseInviteMethod(){}
crJXJRefuseInviteMethod::crJXJRefuseInviteMethod(const crJXJRefuseInviteMethod& handle):
	crMethod(handle)
{
}
void crJXJRefuseInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJRefuseInviteMethod::addParam(int i, const std::string& str)
{
}
void crJXJRefuseInviteMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJInviteType,param);
	unsigned char inviteType = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJInviteID,param);
	int inviteID = *(int *)param;
	if(inviteType>0 && inviteID>0)
	{//拒绝
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(inviteID);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRefuseInvite,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvAcceptInviteMethod
////
///////////////////////////////////////////
//crJXJRecvAcceptInviteMethod::crJXJRecvAcceptInviteMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvAcceptInviteMethod::crJXJRecvAcceptInviteMethod(const crJXJRecvAcceptInviteMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvAcceptInviteMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJRecvAcceptInviteMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJRecvAcceptInviteMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				unsigned char itype = m_stream->_readUChar();
//				int invitePlayerID = m_stream->_readInt();
//				ref_ptr<crGameServerPlayerData> invitePlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(invitePlayerID));
//				if(invitePlayerData.valid() && invitePlayerData->getPlayerGameData() && invitePlayerData->getPlayerGameData()->getDataClass())
//				{
//					if(itype == Invite_Battleground)
//					{//返回信息通知我进入等待队列
//						void *param;
//						unsigned char lv;
//						crData *data = m_this->getDataClass();
//						crData *RoleData = playerData->getPlayerGameData()->getMainRole()->getDataClass();
//						RoleData->getParam(WCHDATA_Level,param);
//						lv = *(unsigned char *)param;
//						data->excHandle(MAKEINT64(WCH_LockData,1));
//						data->getParam(WCHDATA_JXJMyTeam,param);
//						TeamMemberVec *teamVec = (TeamMemberVec *)param;
//						if (teamVec->size()<5)
//						{
//							ref_ptr<crTeamMember> newmember = new crTeamMember;
//							newmember->setPlayerID(playerid);
//							newmember->setName(m_this->getCharacterName());
//							newmember->setLevel(lv);
//							teamVec->push_back(newmember);
//						}
//						ref_ptr<crStreamBuf> stream = new crStreamBuf;
//						stream->createBuf(9+m_this->getCharacterName().length());
//						stream->_writeUChar(Invite_Battleground);
//						stream->_writeInt(playerid);
//						stream->_writeString(m_this->getCharacterName());
//						crPlayerDataEventPacket packet;
//						for (TeamMemberVec::iterator itr = teamVec->begin();
//							itr!= teamVec->end();
//							++itr)
//						{
//						}
//						crPlayerDataEventPacket::buildReplyPacket(packet,invitePlayerID,WCH_JXJClientRecvInvite,stream.get());
//						gameServer->getNetManager()->sendPacket(invitePlayerData->getPlayerConnectServerAddress(),packet);
//						data->excHandle(MAKEINT64(WCH_LockData,0));
//					}
//				}
//				else
//				{//对方下线
//					if(itype == Invite_Battleground)
//					{//检查是否是同势力的
//						ref_ptr<crStreamBuf> stream = new crStreamBuf;
//						stream->createBuf(1);
//						stream->_writeUChar(Invite_Battleground);
//						crPlayerDataEventPacket packet;
//						crPlayerDataEventPacket::buildReplyPacket(packet,invitePlayerID,WCH_JXJInvalidRequest,stream.get());
//						gameServer->getNetManager()->sendPacket(invitePlayerData->getPlayerConnectServerAddress(),packet);
//					}
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJRecvRefuseInviteMethod
//
/////////////////////////////////////////
crJXJRecvRefuseInviteMethod::crJXJRecvRefuseInviteMethod():
	m_netType(GameClient_Game){}
crJXJRecvRefuseInviteMethod::crJXJRecvRefuseInviteMethod(const crJXJRecvRefuseInviteMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRefuseInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvRefuseInviteMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvRefuseInviteMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				//unsigned char itype = m_stream->_readUChar();
				int invitePlayerID = m_stream->_readInt();
				ref_ptr<crGameServerPlayerData> invitePlayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(invitePlayerID));
				if(invitePlayerData.valid() && invitePlayerData->getPlayerGameData() && invitePlayerData->getPlayerGameData()->getDataClass())
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4+playerData->getCharacterName().length());
					//stream->_writeInt(playerid);
					stream->_writeString(playerData->getCharacterName());
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,invitePlayerID,WCH_JXJClientRecvRefuseInvite,stream.get());
					gameServer->getNetManager()->sendPacket(invitePlayerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
	}
}
//////////////////////////////////
////
////crJXJSetInvalidRequestMethod
////
/////////////////////////////////////
//crJXJSetInvalidRequestMethod::crJXJSetInvalidRequestMethod():
//	m_netType(GameClient_Game){}
//crJXJSetInvalidRequestMethod::crJXJSetInvalidRequestMethod(const crJXJSetInvalidRequestMethod& handle):
//	crMethod(handle),
//	m_canvasName(handle.m_canvasName),
//	m_canvasFrame(handle.m_canvasFrame),
//	m_text(handle.m_text)
//{
//}
//void crJXJSetInvalidRequestMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJSetInvalidRequestMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_canvasName = str;
//		break;
//	case 1:
//		m_canvasFrame = str;
//		break;
//	case 2:
//		m_text = str;
//		break;
//	}
//}
//void crJXJSetInvalidRequestMethod::operator()(crHandle &handle)
//{
//	unsigned char invitetype = m_stream->_readUChar();
//	if(invitetype>Invite_None)
//	{
//		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
//		crStaticTextWidgetNode *frame = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_canvasFrame));
//		crHypertextWidgetNode *text = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_text));
//		if(invitetype == Invite_Battleground)
//		{
//			frame->setString(L"城战邀请");
//			crData *data = m_this->getDataClass();
//			data->inputParam(WCHDATA_JXJInviteType,NULL);
//			data->inputParam(WCHDATA_JXJInviteID,NULL);
//			std::vector<float>v_i;
//			ItemMap itemMap;
//			rcfg::ConfigScript cfg_script(&itemMap);
//			cfg_script.Add("Hypertext");
//			cfg_script.Push("Hypertext");
//
//			cfg_script.Add("Content");
//			cfg_script.Push("Content");
//			cfg_script.Add("Text","无法加入城站房间，申请无效");
//			cfg_script.Pop();
//
//			cfg_script.Pop();
//			text->setHypertext(cfg_script);
//			crFilterRenderManager::getInstance()->doModal(canvas);
//		}
//	}
//}
////////////////////////////////
//
//crJXJSetRefuseInviteMethod
//
///////////////////////////////////
crJXJSetRefuseInviteMethod::crJXJSetRefuseInviteMethod():
	m_netType(GameClient_Game){}
crJXJSetRefuseInviteMethod::crJXJSetRefuseInviteMethod(const crJXJSetRefuseInviteMethod& handle):
	crMethod(handle)
{
}
void crJXJSetRefuseInviteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJSetRefuseInviteMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetRefuseInviteMethod::operator()(crHandle &handle)
{
	std::string name = m_stream->_readString();
	crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
	int texid = 1027;
	noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
	int mode = 1;
	noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
	noticeHandle->inputParam(WCHDATA_NoticeParam1,&name);
	crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
	//ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	//if (canvas) 
	//{
	//	crStaticTextWidgetNode *frame = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_canvasFrame));
	//	crHypertextWidgetNode *text = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_text));
	//	//int playerid = m_stream->_readInt();
	//	//crData *data = m_this->getDataClass();
	//	//data->inputParam(WCHDATA_JXJInviteType,&invitetype);
	//	//data->inputParam(WCHDATA_JXJInviteID,&playerid);

	//	std::string name = m_stream->_readString();
	//	std::vector<float>v_i;
	//	ItemMap itemMap;
	//	rcfg::ConfigScript cfg_script(&itemMap);
	//	cfg_script.Add("Hypertext");
	//	cfg_script.Push("Hypertext");

	//	cfg_script.Add("Content");
	//	cfg_script.Push("Content");
	//	char tmpText[32];
	//	sprintf(tmpText,"玩家%s拒绝了您的邀请\0",name.c_str());
	//	cfg_script.Add("Text",tmpText);
	//	cfg_script.Pop();

	//	cfg_script.Pop();
	//	if(text)
	//	{
	//		text->setHypertext(cfg_script);
	//	}
	//	else
	//	{
	//		crStaticTextWidgetNode *text2 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_text));
	//		if (text2)
	//		{
	//			text2->setString("玩家"+name+"拒绝了您的邀请");
	//		}
	//	}
	//	crFilterRenderManager::getInstance()->doModal(canvas);
	//}
}
////////////////////////////////
//
//crJXJSetAcceptInviteMethod
//
///////////////////////////////////
//crJXJSetAcceptInviteMethod::crJXJSetAcceptInviteMethod():
//	m_netType(GameClient_Game){}
//crJXJSetAcceptInviteMethod::crJXJSetAcceptInviteMethod(const crJXJSetAcceptInviteMethod& handle):
//	crMethod(handle),
//	m_canvasName(handle.m_canvasName),
//	m_canvasFrame(handle.m_canvasFrame),
//	m_text(handle.m_text)
//{
//}
//void crJXJSetAcceptInviteMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJSetAcceptInviteMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_canvasName = str;
//		break;
//	case 1:
//		m_canvasFrame = str;
//		break;
//	case 2:
//		m_text = str;
//		break;
//	}
//}
//void crJXJSetAcceptInviteMethod::operator()(crHandle &handle)
//{
//	unsigned char invitetype = m_stream->_readUChar();
//	if(invitetype>Invite_None)
//	{
//		ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
//		crStaticTextWidgetNode *frame = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_canvasFrame));
//		crHypertextWidgetNode *text = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_text));
//		switch (invitetype)
//		{
//		case Invite_Battleground:
//			frame->setString(L"城战邀请");
//			break;
//		}
//		int playerid = m_stream->_readInt();
//		crData *data = m_this->getDataClass();
//		data->inputParam(WCHDATA_JXJInviteType,&invitetype);
//		data->inputParam(WCHDATA_JXJInviteID,&playerid);
//
//		std::string name = m_stream->_readString();
//		std::vector<float>v_i;
//		ItemMap itemMap;
//		rcfg::ConfigScript cfg_script(&itemMap);
//		cfg_script.Add("Hypertext");
//		cfg_script.Push("Hypertext");
//
//		cfg_script.Add("Content");
//		cfg_script.Push("Content");
//		char tmpText[32];
//		sprintf(tmpText,"玩家%s加入了房间！\0",name.c_str());
//		cfg_script.Add("Text",tmpText);
//		cfg_script.Pop();
//
//		cfg_script.Pop();
//		text->setHypertext(cfg_script);
//		crFilterRenderManager::getInstance()->doModal(canvas);
//	}
//}
/////////////////////////////////////////
//
//crJXJPlayerLoginGameMethod
//
/////////////////////////////////////////
crJXJPlayerLoginGameMethod::crJXJPlayerLoginGameMethod()
{
}
crJXJPlayerLoginGameMethod::crJXJPlayerLoginGameMethod(const crJXJPlayerLoginGameMethod& handle):
	crMethod(handle)
{
}
void crJXJPlayerLoginGameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crGameServerPlayerData*)(LOINT64(param64));
		}
		else
		{
			m_player = NULL;
		}
		break;
	}
}
void crJXJPlayerLoginGameMethod::addParam(int i, const std::string& str)
{
}
void crJXJPlayerLoginGameMethod::operator()(crHandle &handle)
{
	if(m_this && m_player)
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		crData *gsBrainData = m_this->getDataClass();

		crPlayerGameData *playerGameData = m_player->getPlayerGameData();
		if(playerGameData && playerGameData->getDataClass())
		{
			crData *playerData = playerGameData->getDataClass();
			if(playerData)
			{
				void *param;
				playerData->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shili = *(unsigned char *)param;

				stream->createBuf(1);
				stream->_writeUChar(shili);
				stream->seekBegin();
				gsBrainData->excHandle(MAKEINT64(WCH_BuildPlayerLoginStream,stream.get()));
				int playerid = m_player->getPlayerID();
				crJXJPlayerLoginGamePacket packet;
				crJXJPlayerLoginGamePacket::buildReplyPacket(packet,playerid,stream.get());
				crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
				//netConductor->getNetDataManager()->sendPacketToAllPlayer(packet);test
				netConductor->getNetManager()->sendPacket(m_player->getPlayerConnectServerAddress(),packet);

				//if(shili>=c_startShiliID)
				//{
				//	gsBrainData->getParam(WCHDATA_JXJShiliWei+shili-c_startShiliID,param);
				//	crJXJShili *jxjshili = (crJXJShili *)param;
				//	if(jxjshili && jxjshili->getDataClass())
				//	{
				//		crData *shiliData = jxjshili->getDataClass();
				//		shiliData->excHandle(MAKEINT64(WCH_LockData,1));
				//		shiliData->getParam(WCHDATA_JXJPeopleMap,param);
				//		PeopleMap *peopleMap = (PeopleMap *)param;
				//		PeopleMap::iterator itr = peopleMap->find(m_player->getPlayerID());
				//		if(itr == peopleMap->end())
				//		{
				//			CRCore::ref_ptr<PeopleInfo> item = new PeopleInfo(m_player->getPlayerID(),m_player->getCharacterName());							
				//			//peopleMap->insert(std::make_pair(m_player->getPlayerID(),0));
				//			peopleMap->insert(PeopleMap::value_type(item->m_id,item));
				//			bool isModify = true;
				//			shiliData->inputParam(WCHDATA_JXJShiliModify,&isModify);
				//		}
				//		shiliData->excHandle(MAKEINT64(WCH_LockData,0));
				//	}
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerLoginSceneMethod
//
/////////////////////////////////////////
crJXJPlayerLoginSceneMethod::crJXJPlayerLoginSceneMethod()
{
}
crJXJPlayerLoginSceneMethod::crJXJPlayerLoginSceneMethod(const crJXJPlayerLoginSceneMethod& handle):
	crMethod(handle)
{
}
void crJXJPlayerLoginSceneMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crSceneServerPlayerData*)(LOINT64(param64));
		}
		else
		{
			m_player = NULL;
		}
		break;
	}
}
void crJXJPlayerLoginSceneMethod::addParam(int i, const std::string& str)
{
}
void crJXJPlayerLoginSceneMethod::operator()(crHandle &handle)
{
	if(m_player)
	{
		///游戏日志
		std::string logdata = "进入战场：" + crArgumentParser::appItoa(m_player->getSceneID());
		GameLogData gamelog(Log_EnterSceneServer,logdata);
		crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_player->getPlayerID(),&gamelog));
	}
}
/////////////////////////////////////////
//
//crJXJUISetBattlegroundGroupMethod
//
/////////////////////////////////////////
crJXJUISetBattlegroundGroupMethod::crJXJUISetBattlegroundGroupMethod():
	m_this(NULL)
{
}
crJXJUISetBattlegroundGroupMethod::crJXJUISetBattlegroundGroupMethod(const crJXJUISetBattlegroundGroupMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_inviteBtn(handle.m_inviteBtn),
	m_frame(handle.m_frame),
	m_btStart(handle.m_btStart)
{
	for( int i = 0; i<5; i++)
	{
		m_players[i] = handle.m_players[i];
		m_playericon[i] = handle.m_playericon[i];
	}
}
void crJXJUISetBattlegroundGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUISetBattlegroundGroupMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_inviteBtn = str;
		break;
	case 1:
		m_frame = str;
		break;
	case 2:
		m_players[0] = str;
		break;
	case 3:
		m_players[1] = str;
		break;
	case 4:
		m_players[2] = str;
		break;
	case 5:
		m_players[3] = str;
		break;
	case 6:
		m_players[4] = str;
		break;
	case 7:
		m_btStart = str;
		break;
	case 8:
		m_playericon[0] = str;
		break;
	case 9:
		m_playericon[1] = str;
		break;
	case 10:
		m_playericon[2] = str;
		break;
	case 11:
		m_playericon[3] = str;
		break;
	case 12:
		m_playericon[4] = str;
		break;
	}
}
void crJXJUISetBattlegroundGroupMethod::operator()(crHandle &handle)
{
	crButtonWidgetNode *inviteBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_inviteBtn));
	crStaticTextWidgetNode *frame = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_frame));
	crStaticTextWidgetNode *players[5];
	crImageBoxWidgetNode *playericon[5];
	for(int i = 0; i<5; i++)
	{
		players[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_players[i]));
		playericon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_playericon[i]));
		if (players[i])
		{
			players[i]->clearString();
		}
		if (playericon[i])
		{
			playericon[i]->setVisiable(false);
		}
	}
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		//if(frame)frame->setString(L"组队进入");
		void *param;
		crData *data = playerData->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJMyTeam,param);
		TeamMemberVec *teamVec = (TeamMemberVec *)param;
		data->getParam(WCHDATA_JXJTeamLeaderID,param);
		int leaderid = *(int *)param;
		int myid = playerData->getPlayerID();
		crButtonWidgetNode *btStart = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_btStart));
		if(teamVec->empty())
		{
			if(btStart)btStart->setEnable(false);
			if(inviteBtn)inviteBtn->setEnable(false);
			//crFilterRenderManager::getInstance()->closeCanvas(m_this);
		}
		else
		{
			if(leaderid!=myid)
			{
				if(btStart)btStart->setEnable(false);
				if(inviteBtn)inviteBtn->setEnable(false);
			}
			else
			{
				if(btStart)btStart->setEnable(true);
				if(inviteBtn)inviteBtn->setEnable(true);
			}
			crTableIO::StrVec record;
			ref_ptr<crTableIO>playerIconTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
			int i = 0;
			for( TeamMemberVec::iterator itr = teamVec->begin();
				itr != teamVec->end() && i<5;
				++itr,i++ )
			{
				playerIconTable->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getIconID()),record);
				if(playericon[i])
				{
					playericon[i]->setVisiable(true);
					playericon[i]->setImageName(record[1]);
				}
				if(players[i])players[i]->setString((*itr)->getName()+"Lv"+crArgumentParser::appItoa((*itr)->getLevel()));
			}
			for( ; i<5; i++)
			{
				if(players[i])players[i]->clearString();
				if(playericon[i])playericon[i]->setVisiable(false);
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIShowBattlegroundBackboardMethod
//
/////////////////////////////////////////
crJXJUIShowBattlegroundBackboardMethod::crJXJUIShowBattlegroundBackboardMethod():
	m_show(false)
{
}
crJXJUIShowBattlegroundBackboardMethod::crJXJUIShowBattlegroundBackboardMethod(const crJXJUIShowBattlegroundBackboardMethod& handle):
	crMethod(handle),
	m_show(handle.m_show),
	m_canvas(handle.m_canvas),
	m_nodeName(handle.m_nodeName),
	m_widgetName(handle.m_widgetName),
	m_canvas2(handle.m_canvas2),
	m_button(handle.m_button),
	m_jianguo(handle.m_jianguo)
{
}
void crJXJUIShowBattlegroundBackboardMethod::inputParam(int i, void *param)
{
}
void crJXJUIShowBattlegroundBackboardMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_show = atoi(str.c_str());
		break;
	case 1:
		m_canvas = str;
		break;
	case 2:
		m_nodeName = str;
		break;
	case 3:
		m_widgetName = str;
		break;
	case 4:
		m_canvas2 = str;
		break;
	case 5:
		m_button = str;
		break;
	case 6:
		m_DataCanvas = str;
		break;
	case 7:
		m_GuanAi = str;
		break;
	case 8:
		m_jianguo = str;
		break;
	}
}
void crJXJUIShowBattlegroundBackboardMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	ref_ptr<crCanvasNode> canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas2);

	//ref_ptr<crCanvasNode> DataCanvas = crFilterRenderManager::getInstance()->findCanvas(m_DataCanvas);
	//void *param;
	//canvas_data->getParam(WCHDATA_JXJBattleUIType, param);
	//int select = *((int *)param);
	//std::string button;
	//button = (select == BT_GateBattle)?m_GuanAi:m_button;
	//crNode *node = canvas->getChildNode(m_nodeName);
	if(canvas2.valid() && canvas.valid())
	{
		//crData *canvas_data = DataCanvas->getDataClass();
		crStaticTextWidgetNode *input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getChildNode(m_nodeName));
		crButtonWidgetNode *btn = dynamic_cast<crButtonWidgetNode *>(canvas2->getWidget(m_button));
		crButtonWidgetNode *jianguoBtn = dynamic_cast<crButtonWidgetNode *>(canvas2->getWidget(m_jianguo));
		std::string str1 = "你已经在队列中,请耐心等待！";
		//node->setVisiable(m_show);
		input->clearString();
		input->setString(str1);
		//crWidgetNode *widget = canvas->getWidget(m_widgetName);
		//widget->setVisiable(m_show);

		if (jianguoBtn && jianguoBtn->getVisiable())
		{
			const crBoundingBox &bbox2 = canvas->getBoundBox();
			const crBoundingBox &bbox = jianguoBtn->getBoundBox();
			float posx = (bbox.m_max[0]-bbox.m_min[0])*0.5 + bbox.m_min[0]/* - (bbox2.m_max[0]-bbox2.m_min[0])*0.5*/;
			float posy = bbox.m_max[1] - (bbox2.m_max[1]-bbox2.m_min[1]);
			canvas->setMatrix(crMatrix::translate(posx,posy,0.0f));
			crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		}
		else if (btn && btn->getVisiable())
		{
			const crBoundingBox &bbox2 = canvas->getBoundBox();
			const crBoundingBox &bbox = btn->getBoundBox();
			float posx = (bbox.m_max[0]-bbox.m_min[0]) + bbox.m_min[0]*0.85 - 0.01/* - (bbox2.m_max[0]-bbox2.m_min[0])*0.5*/;
			float posy = bbox.m_max[1] + bbox2.yLength()*0.5 + 0.05;
			canvas->setMatrix(crMatrix::translate(posx,posy,0.0f));
			crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		}
	}
}


/////////////////////////////////////////
//
//crJXJUISetBattlegroundNameMethod
//
/////////////////////////////////////////
crJXJUISetBattlegroundNameMethod::crJXJUISetBattlegroundNameMethod():
	m_this(NULL),
	m_index(0)
{
}
crJXJUISetBattlegroundNameMethod::crJXJUISetBattlegroundNameMethod(const crJXJUISetBattlegroundNameMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_battlelist(handle.m_battlelist),
	m_canvas(handle.m_canvas),
	m_battlename(handle.m_battlename),
	m_index(handle.m_index)
{
}
void crJXJUISetBattlegroundNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISetBattlegroundNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_battlelist = str;
		break;
	case 1:
		m_canvas = str;
		break;
	case 2:
		m_battlename = str;
		break;
	case 3:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJUISetBattlegroundNameMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		//ref_ptr<crTableIO>codeTextTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		crData *data = myPlayer->getDataClass();
		ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crTableWidgetNode *battlelist = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_battlelist));
			ref_ptr<crCanvasNode> canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas2.valid())
			{
				unsigned short selectID = 0;
				crStaticTextWidgetNode *battlename = dynamic_cast<crStaticTextWidgetNode *>(canvas2->getWidget(m_battlename));
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					int startindex = 0;
					if (m_index < 7)
					{
						canvasdata->getParam(WCHDATA_JXJCityListstartindexA,param);
						startindex = *(int *)param; 
					}
					else
					{
						canvasdata->getParam(WCHDATA_JXJCityListstartindexD,param);
						startindex = *(int *)param; 
						m_index = m_index - 7;
					}
					if (battlelist)
					{
						selectID = battlelist->getData(startindex + m_index);
					}
				}
				unsigned char type = 0;
				unsigned short id = 0;
				if(selectID>0)
				{
					ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
					if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(selectID),record)>=0)
					{
						if(battlename)battlename->setString(record[1]);
					}
					id = selectID;
					type = FT_Chengchi;
				}
				else
				{
					if(battlename)battlename->clearString();
					//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
					//if(noticeText)
					//{
					//	if(codeTextTab->queryOneRecord(0,crArgumentParser::appItoa(1),record)>=0)
					//	{
					//		std::string str = record[1];
					//		noticeText->setText(CRIOManager::convertUTF8toUTF16(str).c_str());
					//		noticeText->setVisiable(true);
					//	}
					//}
				}
				data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
				data->inputParam(WCHDATA_JXJFubenOrChengchiID,&id);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUpdateGovPosMethod
//
/////////////////////////////////////////
crJXJUpdateGovPosMethod::crJXJUpdateGovPosMethod()
{
}
crJXJUpdateGovPosMethod::crJXJUpdateGovPosMethod(const crJXJUpdateGovPosMethod& handle):
	crMethod(handle)
{
}
void crJXJUpdateGovPosMethod::inputParam(int i, void *param)
{
}
void crJXJUpdateGovPosMethod::addParam(int i, const std::string& str)
{
}
void crJXJUpdateGovPosMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
		crData *data = myPlayer->getMainRole()->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJGovPost,param);
		unsigned char post = *(unsigned char*)param;
		data->getParam(WCHDATA_JXJExploit,param);
		int govpostgot = *(int *)param;
		int npost = post+1;
		crTableIO::StrVec record1;
		if(postTab->queryOneRecord(0,crArgumentParser::appItoa(npost),record1)>=0)
		{
			int rowcount = postTab->getRowCount();
			if(npost>rowcount) 
			{
				npost = rowcount;
			}
			else
			{
				int govpostneed = atoi(record1[4].c_str());
				if(govpostneed<=govpostgot)
				{
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUpdateGovPos,NULL);
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else
				{//提示功勋不够

				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}


/////////////////////////////////////////
//
//crJXJRecvUpdateGovPosMethod
//
/////////////////////////////////////////
crJXJRecvUpdateGovPosMethod::crJXJRecvUpdateGovPosMethod():
	m_netType(GameClient_Game){}
crJXJRecvUpdateGovPosMethod::crJXJRecvUpdateGovPosMethod(const crJXJRecvUpdateGovPosMethod& handle):
	crMethod(handle),
	m_donghua(handle.m_donghua),
	m_sequence(handle.m_sequence)
{
}
void crJXJRecvUpdateGovPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvUpdateGovPosMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_donghua = str;
		break;
	case 1:
		m_sequence = str;
		break;
	default:
		break;
	}
}
void crJXJRecvUpdateGovPosMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			if(m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				crTableIO::StrVec record1,record2;
				int gongxunindex = postTab->getTitleIndex("功勋");
				//计算所需功勋
				char done = 0;
				int getvipexp = 0;
				void *param;
				crData *data = m_this->getDataClass();
				crData *mainroledata = m_this->getMainRole()->getDataClass();
				mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char*)param;
				mainroledata->getParam(WCHDATA_JXJGovPost,param);
				unsigned char* post = (unsigned char*)param;
				mainroledata->getParam(WCHDATA_JXJExploit,param);
				int govpostgot = *(int *)param;
				int npost = *post+1;
				if(postTab->queryOneRecord(0,crArgumentParser::appItoa(npost),record1)>=0 && gongxunindex > 0)
				{
					int rowcount = postTab->getRowCount();
					if(npost>rowcount) 
					{
						npost = rowcount;
					}
					else
					{
						int govpostneed = atoi(record1[gongxunindex].c_str());
						if(param)
						{
							if(govpostneed<1) govpostneed = 1;
							if(govpostgot<govpostneed)
							{
								done = -1;//功勋不够
							}
							else
							{
								if(postTab->queryOneRecord(0,crArgumentParser::appItoa(*post),record2)>=0)
								{
									//int govToVipExpFactor = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGovpostToVipExpFactor,viplv).c_str());
									//getvipexp = (govpostneed - atoi(record2[gongxunindex].c_str())) * govToVipExpFactor;
									///if (getvipexp < 0)
									//{
									//	getvipexp = 0;
									//}
								}
								*post += 1;
								done = 1;
								//data->inputParam(WCHDATA_JXJGovPost,post);
								//m_this->doEvent(WCH_JXJCheckResBuildingLevel);
							}
						}
					}
				}
				mainroledata->excHandle(MAKEINT64(WCH_LockData,0));
				//返回信息
				int playerid = m_this->getPlayerID();
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(2);
					stream->_writeChar(done);
					if(done==1)
					{
						stream->_writeUChar(*post);
                        m_this->doEvent(WCH_JXJCheck7Day);
						//if(getvipexp>0)
						//	m_this->doEvent(WCH_JXJAddVipExp,MAKEINT64(getvipexp,NULL));
					}
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUpdateGovPos,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				///游戏日志
				std::string logdata = "升级官职（success，当前官职）" + crArgumentParser::appVectoa(crVector2i(done,*post));
				GameLogData gamelog(Log_UpgradeGovPost,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}

		}
		else if(m_netType == GameClient_Game)
		{
			char returnCode = m_stream->_readChar();
			if(returnCode == 1)
			{
				unsigned char post = m_stream->_readUChar();
				crData *data = m_this->getMainRole()->getDataClass();
				data->inputParam(WCHDATA_JXJGovPost,&post);
				//m_this->doEvent(WCH_JXJCheckResBuildingLevel);
				ref_ptr<crCanvasNode>donghuaCanvas = crFilterRenderManager::getInstance()->findCanvas(m_donghua);
				if (donghuaCanvas.valid())
				{
					crFilterRenderManager::getInstance()->showCanvas(donghuaCanvas.get(),true);
					ref_ptr<crSequence> donghuasequence = dynamic_cast<crSequence*>(donghuaCanvas->getChildNode(m_sequence));
					if(donghuasequence.valid())
					{
						donghuasequence->setMode(crSequence::START);
						donghuasequence->setVanishWhenStop(true);
					}
				}
			}
			else if(returnCode == -1)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2078,NULL));//功勋不足
			}
		}
	}
} 


/////////////////////////////////////////
//
//crJXJUIUpdateGovPosMethod
//
/////////////////////////////////////////
crJXJUIUpdateGovPosMethod::crJXJUIUpdateGovPosMethod():
	m_this(NULL){}
crJXJUIUpdateGovPosMethod::crJXJUIUpdateGovPosMethod(const crJXJUIUpdateGovPosMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_canvasName(handle.m_canvasName),
	m_curpost(handle.m_curpost),
	m_curarms(handle.m_curarms),
	m_exploit(handle.m_exploit),
	m_nextpost(handle.m_nextpost),
	m_nextarms(handle.m_nextarms),
	m_nextexploit(handle.m_nextexploit),
	m_updateButton(handle.m_updateButton),
	m_govpostpic(handle.m_govpostpic)
{
}
void crJXJUIUpdateGovPosMethod::inputParam(int i, void *param)
{
}
void crJXJUIUpdateGovPosMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
	case 1:
		m_curpost = str;
		break;
	case 2:
		m_curarms = str;
		break;
	case 3:
		m_exploit = str;
		break;
	case 4:
		m_nextpost = str;
		break;
	case 5:
		m_nextarms = str;
		break;
	case 6:
		m_nextexploit = str;
		break;
	case 7:
		m_updateButton = str;
		break;
	case 8:
		m_govpostpic = str;
		break;
	}
}
void crJXJUIUpdateGovPosMethod::operator()(crHandle &handle)
{
	std::string curpoststr,ccurarmsstr,exploitstr,nextpoststr,nextarmsstr,nextexploitstr;
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && canvas.valid())
	{
		ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
		crStaticTextWidgetNode *curpost = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_curpost));		 //当前官职
		crStaticTextWidgetNode *curarms = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_curarms));		 //当前带兵量
		crStaticTextWidgetNode *exploit = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_exploit));		 //当前功勋
		crStaticTextWidgetNode *nextpost = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextpost));	 //下一级官职
		crStaticTextWidgetNode *nextarms = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextarms));	 //下一级带兵量
		crStaticTextWidgetNode *nextexploit = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nextexploit));//升级所需功勋
		crButtonWidgetNode *updateBtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_updateButton));
		crImageBoxWidgetNode *govpostpic = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_govpostpic));
		//计算所需功勋
		void *param;
		int iconindex = postTab->getTitleIndex("icon");
		crData *data = myPlayer->getMainRole()->getDataClass();
		data->getParam(WCHDATA_JXJGovPost,param);
		unsigned char post = *(unsigned char*)param;
		data->getParam(WCHDATA_JXJExploit,param);
		int govpostgot = *(int *)param;
		int npost = post+1;
		int rowcount = postTab->getRowCount();
		if(post == rowcount) 
		{
			npost = rowcount;
			updateBtn->setEnable(false);
		}
		crTableIO::StrVec record1,record2;
		postTab->queryOneRecord(0,crArgumentParser::appItoa(post),record1);
		postTab->queryOneRecord(0,crArgumentParser::appItoa(npost),record2);
		int govpostneed = atoi(record2[4].c_str());
		if(govpostneed<1) govpostneed = 1;
		curpoststr = record1[1].c_str();
		ccurarmsstr = record1[2].c_str();
		exploitstr = crArgumentParser::appItoa(govpostgot);
		nextpoststr = record2[1].c_str();
		nextarmsstr = record2[2].c_str();
		nextexploitstr = crArgumentParser::appItoa(govpostneed);
		if(curpost)
			curpost->setString(curpoststr);
		if(curarms)
			curarms->setString(ccurarmsstr);
		if(exploit)
			exploit->setString(exploitstr);
		if(nextpost)
			nextpost->setString(nextpoststr);
		if(nextarms)
			nextarms->setString(nextarmsstr);
		if(nextexploit)
			nextexploit->setString(nextexploitstr);
		if(govpostpic)
			govpostpic->setImageName(record1[iconindex]);
	}
}


/////////////////////////////////////////
//
//crJXJEnterBattleDequeMethod
//
/////////////////////////////////////////
crJXJEnterBattleDequeMethod::crJXJEnterBattleDequeMethod():
	m_this(NULL),
	m_shiliid(0)
{
}
crJXJEnterBattleDequeMethod::crJXJEnterBattleDequeMethod(const crJXJEnterBattleDequeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_shiliid(0)
{
}
void crJXJEnterBattleDequeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJEnterBattleDequeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_shiliid = atoi(str.c_str());
		break;
	}
}
void crJXJEnterBattleDequeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short chengchiid = *(unsigned short *)param;
		if(type == FT_Chengchi && chengchiid>0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(3);
			stream->_writeUShort(chengchiid);
			stream->_writeUChar(m_shiliid);//要防守的势力
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvEnterBattleDeque,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}


/////////////////////////////////////////
//
//crJXJRecvEnterBattleDequeMethod
//
/////////////////////////////////////////
crJXJRecvEnterBattleDequeMethod::crJXJRecvEnterBattleDequeMethod():
	m_netType(GameClient_Game){}
crJXJRecvEnterBattleDequeMethod::crJXJRecvEnterBattleDequeMethod(const crJXJRecvEnterBattleDequeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvEnterBattleDequeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvEnterBattleDequeMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvEnterBattleDequeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			int leaderid;
			if(playerData.valid())
			{
				char code = 0;
				do
				{
					if(playerData->getSceneID() != 0)
					{
						code = -1;//未离开副本
						break;
					}
					void *param;
					data->getParam(WCHDATA_JXJTeamLeaderID,param);
					leaderid = *(int *)param;
					if(leaderid != 0 && leaderid != playerid)
					{
						code = -2;//在组队里
						break;
					}
					data->getParam(WCHDATA_JXJBattleRoomID,param);
					_crInt64 battleroomid = *(_crInt64 *)param;
					if(battleroomid != 0)
					{
						code = -3;//已经在战场了
						break;
					}
					unsigned short chengchiid = m_stream->_readUShort();
					data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
					unsigned char _type = *(unsigned char *)param;
					data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
					unsigned short _changchiid = *(unsigned short *)param;
					if(_type==FT_Chengchi)
					{
						if(leaderid == playerid)
						{//我是队长
							if(_changchiid != chengchiid)
							{
								code = -5;//组队的战场ID和要排的战场ID不同
								break;
							}
						}
						else if(_changchiid != 0)
						{
							code = -4;//已经在排队了
							break;
						}
					}
					ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
					int typeindex = chengchiTab->getTitleIndex("类型");
					crTableIO::StrVec record;
					if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)<0)
					{
						code = -6;//无效城池
						break;
					}
					//判断该城与我当前驻地是否连通
					bool connect = false;
					if(chengchiid<TestChengchiID)
					{//>5000的是测试城
						m_this->doEvent(WCH_JXJConnectWithStationCheck,MAKEINT64(chengchiid,&connect));
						if(!connect)
						{
							code = -10;//军队无法到达该城！
							break;
						}
					}
					//int battletype = atoi(record[typeindex].c_str());
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					//gsBrainData->getParam(WCHDATA_JXJOpenBattle,param);
					//bool openBattle = *(bool *)param;
					//if(battletype == 1 && !openBattle)
					//{
					//	code = -7;//城战尚未开始
					//	break;
					//}
					//gsBrainData->getParam(WCHDATA_JXJOpenPass,param);
					//bool openPass = *(bool *)param;
					//if(battletype == 0 && !openPass)
					//{
					//	code = -8;//关隘战尚未开始
					//	break;
					//}
					gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
					gsBrainData->getParam(WCHDATA_JXJBattleDropPlayerMap,param);
					BattleDropPlayerMap *battleDropPlayerMap = (BattleDropPlayerMap *)param;
					BattleDropPlayerMap::iterator bitr = battleDropPlayerMap->find(playerid);
					if( bitr != battleDropPlayerMap->end() )
					{
						code = -9;//提前退出惩罚时间内
						gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
						break;
					}
					data->getParam(WCHDATA_JXJShiliID,param);
					unsigned char myShili = *(unsigned char *)param;
					if (myShili >= c_startShiliID)
					{
						gsBrainData->getParam(WCHDATA_JXJShiliWei + myShili - c_startShiliID,param);
						crJXJShili *shili = (crJXJShili *)param;
						if (shili && shili->getDataClass())
						{
							crData *shiliData = shili->getDataClass();
							shiliData->getParam(WCHDATA_JXJPeopleMap,param);
							PeopleMap *peopleMap = (PeopleMap *)param;
							PeopleMap::iterator itr = peopleMap->find(playerid);
							if(itr != peopleMap->end())
							{
								if (itr->second->getSmallAcc())
								{
									code = -11;// 标记为小号
									gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
									break;
								}
							}
						}
					}
					bool foundchengchi = false;
					gsBrainData->getParam(WCHDATA_JXJChengChiMap,param);
					ChengchiMap *chengchiMap = (ChengchiMap *)param;
					ChengchiMap::iterator itr = chengchiMap->find(chengchiid);
					unsigned char chengzhu = 0;
					unsigned short chengfang = 0;
					if(itr != chengchiMap->end())
					{//城防值>0
						chengzhu = itr->second->getChengzhuShili();
						chengfang = itr->second->getChengzhuChengfang();
						if(chengfang>0)
							foundchengchi = true;
					}
					gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));

					bool found = false;
					if(foundchengchi)
					{
						unsigned char _type = FT_Chengchi;						
						data->inputParam(WCHDATA_JXJFubenOrChengchiType,&_type);
						data->inputParam(WCHDATA_JXJFubenOrChengchiID,&chengchiid);
						if(chengzhu == myShili)
						{//我是守方
							unsigned char attackShili = m_stream->_readUChar();
							if(attackShili == myShili)
								attackShili = 0;
							gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
							gsBrainData->getParam(WCHDATA_JXJDefendDequeMap,param);
							DefendDequeMap *defendDequeMap = (DefendDequeMap *)param;
							_crInt32 battleid = MAKEINT32(MAKEINT16(attackShili,myShili),chengchiid);
							DefendDequeMap::iterator ditr = defendDequeMap->find(battleid);
							if(ditr != defendDequeMap->end())
							{
								for( BattleDeque::iterator bitr = ditr->second.begin();
									bitr != ditr->second.end();
									++bitr )
								{
									if(*bitr == playerid)
									{
										found = true;
										break;
									}
								}
								if(!found)
									ditr->second.push_back(playerid);
							}
							else
								(*defendDequeMap)[battleid].push_back(playerid);
							gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
						}
						else
						{//我是攻方
							gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
							gsBrainData->getParam(WCHDATA_JXJAttackDequeMap,param);
							AttackDequeMap *attackDequeMap = (AttackDequeMap *)param;
							_crInt32 battleid = MAKEINT32(MAKEINT16(myShili,chengzhu),chengchiid);
							AttackDequeMap::iterator aitr = attackDequeMap->find(battleid);
							if(aitr != attackDequeMap->end())
							{
								for( BattleDeque::iterator bitr = aitr->second.begin();
									bitr != aitr->second.end();
									++bitr )
								{
									if(*bitr == playerid)
									{
										found = true;
										break;
									}
								}
								if(!found)
								{
									aitr->second.push_back(playerid);
									if(aitr->second.size() == 5)
										crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerBattDequeUpdata,MAKEINT64(MAKEINT32(chengchiid,0),MAKEINT32(MAKEINT16(myShili,chengzhu),NULL)));
								}
							}
							else
							{
								(*attackDequeMap)[battleid].push_back(playerid);
								crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerBattDequeUpdata,MAKEINT64(MAKEINT32(chengchiid,1),MAKEINT32(MAKEINT16(myShili,chengzhu),NULL)));
							}
							gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
						}
					}
					else
					{
						code = -12;//城池已被攻陷
					}
				} while (0);
				if(code<0)
				{
					//void *param;
					//data->getParam(WCHDATA_JXJMyTeam,param);
					//TeamMemberVec *myTeam = (TeamMemberVec *)param;
					//for(TeamMemberVec::iterator itr = myTeam->begin(); itr!=myTeam->end();++itr)
					//{
					//	if((*itr)->getPlayerID()!=leaderid)
					//	{
					//		ref_ptr<crGameServerPlayerData> playerData2 = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
					//		crPlayerDataEventPacket packet2;
					//		ref_ptr<crStreamBuf> stream2 = new crStreamBuf;
					//		stream2->createBuf(1);
					//		stream2->_writeChar(code);
					//		crPlayerDataEventPacket::buildReplyPacket(packet2,(*itr)->getPlayerID(),WCH_JXJRecvShowBattleGround,stream2.get());
					//		gameServer->getNetManager()->sendPacket(playerData2->getPlayerConnectServerAddress(),packet2);
					//	}
					//}
					crPlayerDataEventPacket packet;
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeChar(code);
					crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvEnterBattleDeque,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				///游戏日志
				std::string logdata = "进入战场排队（-2在组队-6无效城池-7城战未开-9惩罚时间内）：" + crArgumentParser::appItoa(code);
				GameLogData gamelog(Log_EnterBattleDeq,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char code = m_stream->_readChar();
			//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
			//if(noticeText)
			//{
				switch (code)
				{
				case -1:
					//noticeText->setText(L"未离开副本");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1011,NULL));
					break;
				case -2:
					//noticeText->setText(L"在组队里，由队长排队");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1012,NULL));
					break;
				case -3:
					//noticeText->setText(L"已经在战场了,请等待战场结束");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1013,NULL));
					break;
				case -4:
					//noticeText->setText(L"已经在排队了");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1009,NULL));
					break;
				case -5:
					//noticeText->setText(L"组队的战场ID和要排的战场ID不同");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1014,NULL));
					break;
				case -6:
					//noticeText->setText(L"无效城池");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1015,NULL));
					break;
				case -7:
					//noticeText->setText(L"城战尚未开始");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1016,NULL));
					break;
				case -8:
					//noticeText->setText(L"关隘战尚未开始");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1017,NULL));
					break;
				case -9:
					//noticeText->setText(L"提前退出惩罚时间内");
					//noticeText->setVisiable(true);
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1018,NULL));
					break;
				case -10://军队无法到达该城！
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1073,NULL));
					break;
				case -11: // 标记为小号
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(4072,NULL));
					break;
				case -12: // 该城池已经被攻陷了
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1082,NULL));
					break;
				}

				crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
				if (playerData)
				{
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiType, NULL);
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiID, NULL);
				}
			//}
		}
	}
}


/////////////////////////////////////////
//
//crJXJBattleDequeDisposeMethod
//
/////////////////////////////////////////
crJXJBattleDequeDisposeMethod::crJXJBattleDequeDisposeMethod():
	m_this(NULL),
	m_dt(NULL),
    m_removeDelay(0.0f){}
crJXJBattleDequeDisposeMethod::crJXJBattleDequeDisposeMethod(const crJXJBattleDequeDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL),
	m_removeDelay(handle.m_removeDelay)
{
}
void crJXJBattleDequeDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			if(lparam)
				m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crJXJBattleDequeDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_removeDelay = atof(str.c_str());
		break;
	}
}
bool crJXJBattleDequeDisposeMethod::isBattleClosed(int roomid, int battleid)
{
	//void *param;
	//_crInt64 battleroomid = MAKEINT64(battleid, roomid);
	//unsigned char ashili = (unsigned char)(LOINT16(LOINT32(battleid)));
	//
	//crData * gsbrainData = m_this->getDataClass();
	//if (gsbrainData)
	//{
	//	gsbrainData->excHandle(MAKEINT64(WCH_LockData, 1));

	//	gsbrainData->getParam(WCHDATA_JXJCloseBattleSet, param);
	//	ClosedBattleSet *closeBattleSet = (ClosedBattleSet *)param;

	//	if (closeBattleSet->find(battleroomid) != closeBattleSet->end())
	//	{
	//		gsbrainData->excHandle(MAKEINT64(WCH_LockData, 0));
	//		return true;
	//	}
	//	gsbrainData->excHandle(MAKEINT64(WCH_LockData, 0));
	//}
	return false;
}
void crJXJBattleDequeDisposeMethod::playerEnterBattle(crNetConductor *gameServer,crGameServerPlayerData *playerData,int sceneid,int roomid,int battleid,int playerid)
{
	//void *param;
	_crInt64 battleroomid = MAKEINT64(battleid, roomid);
	crPlayerGameData *playerGameData = playerData->getPlayerGameData();
	crData *data = playerGameData->getDataClass();	
		
	crPlayerDataEventPacket packet;
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	
	data->inputParam(WCHDATA_JXJBattleRoomID, &battleroomid);
	stream->createBuf(12);
	stream->_writeInt(sceneid);
	stream->_writeInt64(battleroomid);
	crPlayerDataEventPacket::buildReplyPacket(packet, playerid, WCH_JXJRecvEnterBattle, stream.get());
	gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet);
// 	else
// 	{
// 		//告诉玩家战场处于关闭状态
// 		crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBattleDisable,NULL);
// 		gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
// 	}
	
}
void crJXJBattleDequeDisposeMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	ref_ptr<crTableIO> playershilitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
	crTableIO::StrVec record;
	int timeid = chengchiTab->getTitleIndex("时间");
	int playercountid = chengchiTab->getTitleIndex("玩家数量");
	int opencountid = chengchiTab->getTitleIndex("开启人数");
	int time2id = chengchiTab->getTitleIndex("进场时间");
	int sceneindex = chengchiTab->getTitleIndex("sceneid");
	int battletypeindex = chengchiTab->getTitleIndex("类型");
	//unsigned char startShiliID = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str()));
	unsigned char shiliidcount = c_startShiliID+c_startShiliID+c_startShiliID+3;
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	ref_ptr<crGameServerPlayerData> playerData,playerData2;
	crPlayerGameData *playerGameData;
	crData *gameData/*,*gameData2*/;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	//data->getParam(WCHDATA_JXJBattleTimer,param);
	//int battleTimer = *(int *)param;
	//int passTimer = battleTimer;
	//data->getParam(WCHDATA_JXJPassTimer,param);
	//short passTimer = *(short *)param;
	data->getParam(WCHDATA_JXJOpenBattle,param);
	bool openBattle = *(bool *)param;
	data->getParam(WCHDATA_JXJChengChiMap,param);
	ChengchiMap *chengchiMap = (ChengchiMap *)param;
	data->getParam(WCHDATA_JXJOpenBattleMap,param);
	OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
	data->getParam(WCHDATA_JXJAttackDequeMap,param);
	AttackDequeMap *attackDequeMap = (AttackDequeMap *)param;
	data->getParam(WCHDATA_JXJDefendDequeMap,param);
	DefendDequeMap *defendDequeMap = (DefendDequeMap *)param;
	data->getParam(WCHDATA_JXJCreateBattleDeque,param);
	CreateBattleDeque *createBattleDeque = (CreateBattleDeque *)param;
	data->getParam(WCHDATA_JXJBattleDropPlayerMap,param);
	BattleDropPlayerMap *battleDropPlayerMap = (BattleDropPlayerMap *)param;
	unsigned short chengchiid;
	OpenBattleMap::iterator openItr;
	int playercount,opencount; 
	float time,time2;
	int playerid,playerid2;
	int sceneid,battleid,battletype;
	unsigned char defendshili,attackshili,chengzhu;
	_crInt64 battleroomid;
	TeamMemberVec *teamVec;
	int halfplayercount;
	/////OpenBattleMap tick
	crPlayerDataEventPacket packet;
	crPlayerDataEventPacket::buildReplyPacket(packet,0,WCH_JXJClientRecvBattleRemoved,NULL);
	ref_ptr<crStreamBuf> packetStream = packet.getStreamBuf();
	int bufsize = packetStream->getBufSize();
	TeamMemberVec *myTeam;
	crNetManager *netManager = gameServer->getNetManager();
	crNetDataManager *netDataManager = gameServer->getNetDataManager();
	for( OpenBattleMap::iterator itr = openBattleMap->begin();
		itr != openBattleMap->end(); )
	{//进入创建通道的房间如果10s(2倍m_removeDelay)内为完成创建则创建失败
		//if(itr->second.second.first != 0)
		//{
			itr->second.second.second -= *m_dt;
			if(itr->second.second.second < -m_removeDelay)
			{//删除
				//通知玩家战场结束
				for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
					pitr != itr->second.first.first.end();
					++pitr )
				{
					playerid = *pitr;
					playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
					if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
					{
						playerGameData = playerData->getPlayerGameData();
						gameData = playerGameData->getDataClass();
						gameData->excHandle(MAKEINT64(WCH_LockData,1));

						gameData->inputParam(WCHDATA_JXJBattleRoomID,NULL);
						gameData->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
						gameData->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
						//解散组队
						gameData->inputParam(WCHDATA_JXJTeamLeaderID,NULL);
						gameData->getParam(WCHDATA_JXJMyTeam,param);
						myTeam = (TeamMemberVec *)param;
						myTeam->clear();
						gameData->excHandle(MAKEINT64(WCH_LockData,0));
						packetStream->seekBegin();
						packetStream->_writeInt(playerid);
						packetStream->setBufSize(bufsize);
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
				for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
					pitr != itr->second.first.second.end();
					++pitr )
				{
					playerid = *pitr;
					playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
					if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
					{
						playerGameData = playerData->getPlayerGameData();
						gameData = playerGameData->getDataClass();
						gameData->excHandle(MAKEINT64(WCH_LockData,1));
						gameData->inputParam(WCHDATA_JXJBattleRoomID,NULL);
						gameData->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
						gameData->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
						//解散组队
						gameData->inputParam(WCHDATA_JXJTeamLeaderID,NULL);
						gameData->getParam(WCHDATA_JXJMyTeam,param);
						myTeam = (TeamMemberVec *)param;
						myTeam->clear();
						gameData->excHandle(MAKEINT64(WCH_LockData,0));
						packetStream->seekBegin();
						packetStream->_writeInt(playerid);
						packetStream->setBufSize(bufsize);
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
				itr = openBattleMap->erase(itr);
				continue;
			}
		//}
		++itr;
	}
	crPlayerDataEventPacket punishpacket;
	ref_ptr<crStreamBuf> punishstream = new crStreamBuf;
	punishstream->createBuf(2);
	for( BattleDropPlayerMap::iterator itr = battleDropPlayerMap->begin();
		 itr != battleDropPlayerMap->end(); )
	{
		itr->second.second -= *m_dt;
		playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(itr->first));
		if(itr->second.second<0.0f)
		{
			if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
			{
				gameData = playerData->getPlayerGameData()->getDataClass();
				gameData->inputParam(WCHDATA_JXJBattleRoomID,NULL);
				gameData->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
				gameData->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
			}
			itr = battleDropPlayerMap->erase(itr);
		}
		else
		{
			if(playerData.valid()/* && playerData->getSceneID() == 0*/)
			{
				punishstream->seekBegin();
				punishstream->_writeShort((short)(itr->second.second+0.5f));
				crPlayerDataEventPacket::buildReplyPacket(punishpacket,itr->first,WCH_JXJRecvBattlePunish,punishstream.get());
				netManager->sendPacket(playerData->getPlayerConnectServerAddress(),punishpacket);
			}
			++itr;
		}
	}
	crPlayerDataEventPacket battleClosePacket;
	unsigned char canopenCount;
	bool battlecreating = false;
	for( AttackDequeMap::iterator aitr = attackDequeMap->begin();
		 aitr != attackDequeMap->end();)
	{
		if(!aitr->second.empty())
		{
			battleid = aitr->first;
			chengchiid = HIINT32(battleid);
			canopenCount = (*chengchiMap)[chengchiid]->getChengzhuChengfang() / 100;
			defendshili = HIINT16(LOINT32(battleid));
			attackshili = LOINT16(LOINT32(battleid));
			chengzhu = (*chengchiMap)[chengchiid]->getChengzhuShili();
			if(canopenCount == 0 || defendshili!=chengzhu || attackshili==chengzhu)
			{//已经被攻陷
				for( BattleDeque::iterator bitr = aitr->second.begin();
					bitr != aitr->second.end();
					++bitr )
				{
					playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
					if(playerData.valid()/* && playerData->getSceneID() == 0*/)
					{
						crPlayerDataEventPacket::buildReplyPacket(battleClosePacket,*bitr,WCH_JXJRecvBattleCaptured,NULL);
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),battleClosePacket);
					}
				}
				aitr->second.clear();
				++aitr;
				continue;
			}
			battleroomid = MAKEINT64(battleid,0);
			if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
			{
				//ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//stream->createBuf(2);
				//stream->_writeUShort(chengchiid);
				time = atof(record[timeid].c_str());
				playercount = atoi(record[playercountid].c_str());
				opencount = atoi(record[opencountid].c_str());
				time2 = atof(record[time2id].c_str());
				time2 = time - time2;
				battletype = atoi(record[battletypeindex].c_str());
				//if((battletype == 1 && battleTimer < time2) /*|| (battletype == 0 && passTimer < time2)*/)
				//{//城站即将结束，该战场不能进了
				//	for( BattleDeque::iterator bitr = aitr->second.begin();
				//		 bitr != aitr->second.end();
				//		 ++bitr )
				//	{
				//		playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
				//		if(playerData.valid()/* && playerData->getSceneID() == 0*/)
				//		{
				//			crPlayerDataEventPacket::buildReplyPacket(battleClosePacket,*bitr,WCH_JXJRecvBattleClose,NULL);
				//			netManager->sendPacket(playerData->getPlayerConnectServerAddress(),battleClosePacket);
				//		}
				//	}
				//	aitr->second.clear();
				//	++aitr;
				//	continue;
				//}
				sceneid = atoi(record[sceneindex].c_str());
				halfplayercount = playercount/2;
				//查找已经开启的战场
				battlecreating = false;
				for( openItr = openBattleMap->find(battleid);
					openItr != openBattleMap->end() && openItr->first == battleid && !aitr->second.empty();
					++openItr )
				{
					if (openItr->second.second.second > time2 && \
						!isBattleClosed(openItr->second.second.first, battleid))
					{
						if(openItr->second.first.first.size()<halfplayercount)
						{//允许进入
							if(openItr->second.second.first == 0)
							{//
								battlecreating = true;
								break;
							}
							else
							{
								for( BattleDeque::iterator bitr = aitr->second.begin();
									bitr != aitr->second.end() && openItr->second.first.first.size()<halfplayercount;)
								{
									playerid = *bitr;
									playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
									if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass()/* && playerData->getSceneID() == 0*/)
									{
										playerGameData = playerData->getPlayerGameData();
										gameData = playerGameData->getDataClass();
										gameData->excHandle(MAKEINT64(WCH_LockData,1));
										gameData->getParam(WCHDATA_JXJMyTeam,param);
										teamVec = (TeamMemberVec *)param;
										if(!teamVec->empty())
										{//组队进入
											if(openItr->second.first.first.size()+teamVec->size()<=halfplayercount)
											{
												for( TeamMemberVec::iterator titr = teamVec->begin();
													titr != teamVec->end(); )
												{
													playerid2 = (*titr)->getPlayerID();
													if(playerid == playerid2)
													{
														openItr->second.first.first.push_back(playerid2);
														//if(openItr->second.second.first != 0)
														//{//roomid = 0
														//通知玩家进入战场
														playerEnterBattle(gameServer,playerData.get(),sceneid,openItr->second.second.first,battleid,playerid2);
														//}
														//else
														//{//为什么要在这里设置上？针对掉线玩家？
														//	gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
														//}
													}
													else
													{
														playerData2 = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid2));
														if(playerData2.valid() && playerData2->getPlayerGameData() && playerData2->getPlayerGameData()->getDataClass() && playerData2->getSceneID() == 0)
														{
															openItr->second.first.first.push_back(playerid2);
															//if(openItr->second.second.first != 0)
															//{
															//通知玩家进入战场
															playerEnterBattle(gameServer,playerData2.get(),sceneid,openItr->second.second.first,battleid,playerid2);
															//}
															//else
															//{//为什么要在这里设置上？针对掉线玩家？
															//	gameData2 = playerData2->getPlayerGameData()->getDataClass();
															//	gameData2->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
															//}
														}
														else
														{//该队友已经离开组队
															titr = teamVec->erase(titr);
															continue;
														}
													}
													++titr;
												}
												bitr = aitr->second.erase(bitr);
											}
											else
											{
												++bitr;
											}
										}
										else
										{//单人进入
											openItr->second.first.first.push_back(playerid);
											bitr = aitr->second.erase(bitr);
											//if(openItr->second.second.first != 0)
											//{
											//通知玩家进入战场
											playerEnterBattle(gameServer,playerData.get(),sceneid,openItr->second.second.first,battleid,playerid);
											//}
											//else
											//{//为什么要在这里设置上？针对掉线玩家？
											//	gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
											//}
										}
										gameData->excHandle(MAKEINT64(WCH_LockData,0));
									}
									else
									{
										bitr = aitr->second.erase(bitr);
									}
								}
							}
						}
					}
				}
				bool no_country = true; //未建国时，建国之路城池全天开启。建国后，随城战时间开启。
				//crJXJShili * shili;
				//crData * shiliData;
				//data->getParam(WCHDATA_JXJShiliWei + attackshili - 10, param);
				//shili = (crJXJShili *)param;
				//shiliData = shili->getDataClass();
				//shiliData->excHandle(MAKEINT64(WCH_LockData,1));
				////shiliData->getParam(WCHDATA_JXJShiliFoundCountryWinCity,param);
				////unsigned char winCity = *(unsigned char *)param;
				//shiliData->excHandle(MAKEINT64(WCH_LockData,0));
				if(playershilitab.valid())
				{
					crTableIO::StrVec record;
					int guoduIndex = playershilitab->getTitleIndex("国都");
					if(playershilitab->queryOneRecord(0,crArgumentParser::appItoa(attackshili),record)>=0 && guoduIndex>=0)
					{
						unsigned short guoduid = (unsigned short)(atoi(record[guoduIndex].c_str()));
						unsigned short guodu = (*chengchiMap)[guoduid]->getChengzhuShili();
						if (guodu != 2)
						{
							no_country = false;
						}
					}
				}
				bool canopen = false; 
				if(!battlecreating && ((battletype == 1 && openBattle/*battleTimer > time*/) || (battletype == 1 && no_country) || battletype == 0 /*&& passTimer > time)*/))
				{//判断时间是否满足城站开启条件
					//根据城防值判断可开启房间数量是否已经达到上限
					unsigned short openedCount = 0;
					unsigned short ashiliid = LOINT32(battleid);
					unsigned char gshiliid = LOINT16(ashiliid);
					unsigned char dshiliid = HIINT16(ashiliid);
					int battleid2;

					if(dshiliid < c_startShiliID)
					{//npc城
						battleid2 = MAKEINT32(MAKEINT16(c_startShiliID,dshiliid),chengchiid);
						for( openItr = openBattleMap->find(battleid2);
							openItr != openBattleMap->end() && openItr->first == battleid2;
							++openItr )
						{
							openedCount++;
						}
						if(openedCount<canopenCount)
						{
							battleid2 = MAKEINT32(MAKEINT16(c_startShiliID+1,dshiliid),chengchiid);
							for( openItr = openBattleMap->find(battleid2);
								openItr != openBattleMap->end() && openItr->first == battleid2;
								++openItr )
							{
								openedCount++;
							}
						}
						if(openedCount<canopenCount)
						{
							battleid2 = MAKEINT32(MAKEINT16(c_startShiliID+2,dshiliid),chengchiid);
							for( openItr = openBattleMap->find(battleid2);
								openItr != openBattleMap->end() && openItr->first == battleid2;
								++openItr )
							{
								openedCount++;
							}
						}
						if(openedCount<canopenCount)
						{
							canopen = true;
						}
					}
					else
					{
						for( openItr = openBattleMap->find(battleid);
							openItr != openBattleMap->end() && openItr->first == battleid;
							++openItr )
						{
							openedCount++;
						}
						if(openedCount<canopenCount)
						{///////////在NPC城，势力判断有问题
							unsigned char oshiliid = shiliidcount-gshiliid-dshiliid;////
							int battleid2 = MAKEINT32(MAKEINT16(oshiliid,dshiliid),chengchiid);
							for( openItr = openBattleMap->find(battleid2);
								openItr != openBattleMap->end() && openItr->first == battleid2;
								++openItr )
							{
								openedCount++;
							}
							if(openedCount<canopenCount)
							{
								canopen = true;
							}
						}
					}	
				}
				if(canopen)
				{
					BattlePlayer playerVec,playerVec2;
					BattlePlayer removeVec;
					for( BattleDeque::iterator bitr = aitr->second.begin();
						 bitr != aitr->second.end();)
					{//剩余玩家数量>城站开启人数
						playerid = *bitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass()/* && playerData->getSceneID() == 0*/)
						{
							playerGameData = playerData->getPlayerGameData();
							gameData = playerGameData->getDataClass();
							gameData->excHandle(MAKEINT64(WCH_LockData,1));
							gameData->getParam(WCHDATA_JXJMyTeam,param);
							teamVec = (TeamMemberVec *)param;
							if(!teamVec->empty())
							{
								if(playerVec.size()+teamVec->size()<=halfplayercount)
								{
									for( TeamMemberVec::iterator titr = teamVec->begin();
										titr != teamVec->end(); )
									{
										playerid2 = (*titr)->getPlayerID();
										if(playerid == playerid2)
										{
											playerVec.push_back(playerid);
											removeVec.push_back(playerid);
										}
										else
										{
											playerData2 = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid2));
											if(playerData2.valid() && playerData2->getPlayerGameData() && playerData2->getPlayerGameData()->getDataClass() && playerData2->getSceneID() == 0)
											{
												playerVec.push_back(playerid2);
											}
											else
											{
												titr = teamVec->erase(titr);
												continue;
											}
										}
										++titr;
									}
								}
							}
							else
							{
								playerVec.push_back(playerid);
								removeVec.push_back(playerid);
							}
							gameData->excHandle(MAKEINT64(WCH_LockData,0));
							if(playerVec.size()>=opencount ||  JXJGMPermission_manager == crGlobalHandle::gData()->getGMAuthority(playerid))
							{
								openBattleMap->insert(std::make_pair(aitr->first,std::make_pair(BattlePlayerPair(playerVec,playerVec2),std::make_pair(0,m_removeDelay))));
								//通知玩家
								//playerEnterBattle(gameServer,playerid);
								//通知sceneserver创建room并返回roomid
								//当返回roomid后通知玩家进入战场
								//createBattle(gameServer,sceneid,aitr->first);
								createBattleDeque->push_back(MAKEINT64(sceneid,aitr->first));
								for( BattlePlayer::iterator ritr = removeVec.begin();
									ritr != removeVec.end();
									++ritr )
								{
									for( BattleDeque::iterator birt2 = aitr->second.begin();
										birt2 != aitr->second.end();
										++birt2 )
									{
										if(*ritr == *birt2)
										{
											aitr->second.erase(birt2);
											break;
										}
									}
								}
								//for( BattlePlayer::iterator pitr = playerVec.begin();
								//	pitr != playerVec.end();
								//	++pitr )
								//{
								//	playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
								//	if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass()/* && playerData->getSceneID() == 0*/)
								//	{
								//		playerGameData = playerData->getPlayerGameData();
								//		gameData = playerGameData->getDataClass();
								//		gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
								//	}
								//}
								break;
							}
							++bitr;
						}
						else
						{
							bitr = aitr->second.erase(bitr);
						}
					}
				}
				//else if(!battlecreating)
				//{//已有战场已经不能进了,不能开辟新战场了,请退出
				//	for( BattleDeque::iterator bitr = aitr->second.begin();
				//		bitr != aitr->second.end();
				//		++bitr )
				//	{
				//		playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
				//		if(playerData.valid()/* && playerData->getSceneID() == 0*/)
				//		{
				//			crPlayerDataEventPacket::buildReplyPacket(battleClosePacket,*bitr,WCH_JXJRecvBattleCannotCreate,NULL);
				//			netManager->sendPacket(playerData->getPlayerConnectServerAddress(),battleClosePacket);
				//		}
				//	}
				//	aitr->second.clear();
				//	++aitr;
				//	continue;
				//}
				++aitr;
			}
			else
			{//无效的chengchiid
				CRCore::notify(CRCore::ALWAYS)<<"crJXJBattleDequeDisposeMethod 无效的城池ID"<<chengchiid<<std::endl;
				//sprintf(gDebugInfo->buf(),"crJXJBattleDequeDisposeMethod 无效的城池ID=%d\n\0",chengchiid);
				//gDebugInfo->debugInfo(CRCore::ALWAYS);
				aitr = attackDequeMap->erase(aitr);
			}
		}
		else
		{
			++aitr;
		}
	}
	for( DefendDequeMap::iterator ditr = defendDequeMap->begin();
		ditr != defendDequeMap->end();)
	{
		if(!ditr->second.empty())
		{
			battleid = ditr->first;
			chengchiid = HIINT32(battleid);
			canopenCount = (*chengchiMap)[chengchiid]->getChengzhuChengfang() / 100;
			defendshili = HIINT16(LOINT32(battleid));
			attackshili = LOINT16(LOINT32(battleid));
			chengzhu = (*chengchiMap)[chengchiid]->getChengzhuShili();
			if(canopenCount == 0 || defendshili!=chengzhu)
			{//已经被攻陷
				for( BattleDeque::iterator bitr = ditr->second.begin();
					bitr != ditr->second.end();
					++bitr )
				{
					playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
					if(playerData.valid()/* && playerData->getSceneID() == 0*/)
					{
						crPlayerDataEventPacket::buildReplyPacket(battleClosePacket,*bitr,WCH_JXJRecvBattleCaptured,NULL);
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),battleClosePacket);
					}
				}
				ditr->second.clear();
				++ditr;
				continue;
			}
			if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
			{
				time = atof(record[timeid].c_str());
				playercount = atoi(record[playercountid].c_str());
				opencount = atoi(record[opencountid].c_str());
				time2 = atof(record[time2id].c_str());
				time2 = time - time2;
				//battletype = atoi(record[battletypeindex].c_str());
				//if((battletype == 1 && battleTimer < time2) /*|| (battletype == 0 && passTimer < time2)*/)
				//{//城站即将结束，该战场不能进了
				//	for( BattleDeque::iterator bitr = ditr->second.begin();
				//		 bitr != ditr->second.end();
				//		 ++bitr )
				//	{
				//		playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
				//		if(playerData.valid()/* && playerData->getSceneID() == 0*/)
				//		{
				//			crPlayerDataEventPacket::buildReplyPacket(battleClosePacket,*bitr,WCH_JXJRecvBattleClose,NULL);
				//			netManager->sendPacket(playerData->getPlayerConnectServerAddress(),battleClosePacket);
				//		}
				//	}
				//	ditr->second.clear();
				//	++ditr;
				//	continue;
				//}
				sceneid = atoi(record[sceneindex].c_str());
				halfplayercount = playercount/2;
				//查找已经开启的战场
				if(attackshili>0)
				{//有指定要防守的势力
					for( openItr = openBattleMap->find(battleid);
						openItr != openBattleMap->end() && openItr->first == battleid && !ditr->second.empty();
						++openItr )
					{
						if(openItr->second.second.first != 0 && openItr->second.second.second > time2)
						{//
							battleid = openItr->first;
							//battleroomid = MAKEINT64(battleid,0);

							if(openItr->second.first.second.size()<halfplayercount)
							{//允许进入
								for( BattleDeque::iterator bitr = ditr->second.begin();
									bitr != ditr->second.end() && openItr->second.first.second.size()<halfplayercount;)
								{
									playerid = *bitr;
									playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
									if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass()/* && playerData->getSceneID() == 0*/)
									{
										playerGameData = playerData->getPlayerGameData();
										gameData = playerGameData->getDataClass();
										gameData->excHandle(MAKEINT64(WCH_LockData,1));
										gameData->getParam(WCHDATA_JXJMyTeam,param);
										teamVec = (TeamMemberVec *)param;
										if(!teamVec->empty())
										{//组队进入
											if(openItr->second.first.second.size()+teamVec->size()<=halfplayercount)
											{
												for( TeamMemberVec::iterator titr = teamVec->begin();
													titr != teamVec->end(); )
												{
													playerid2 = (*titr)->getPlayerID();
													if(playerid == playerid2)
													{
														openItr->second.first.second.push_back(playerid2);
														//if(openItr->second.second.first != 0)
														//{
														//通知玩家进入战场
														playerEnterBattle(gameServer,playerData.get(),sceneid,openItr->second.second.first,battleid,playerid2);
														//}
														//else
														//{//为什么要在这里设置上？针对掉线玩家？
														//	gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
														//}
													}
													else
													{
														playerData2 = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid2));
														if(playerData2.valid() && playerData2->getPlayerGameData() && playerData2->getPlayerGameData()->getDataClass() && playerData2->getSceneID() == 0)
														{
															openItr->second.first.second.push_back(playerid2);
															//if(openItr->second.second.first != 0)
															//{
															//通知玩家进入战场
															playerEnterBattle(gameServer,playerData2.get(),sceneid,openItr->second.second.first,battleid,playerid2);
															//}
															//else
															//{//为什么要在这里设置上？针对掉线玩家？
															//	gameData2 = playerData2->getPlayerGameData()->getDataClass();
															//	gameData2->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
															//}
														}
														else
														{//该队友已经离开组队
															titr = teamVec->erase(titr);
															continue;
														}
													}
													++titr;
												}
												bitr = ditr->second.erase(bitr);
											}
											else
											{
												++bitr;
											}
										}
										else
										{//单人进入
											openItr->second.first.second.push_back(playerid);
											bitr = ditr->second.erase(bitr);
											//if(openItr->second.second.first != 0)
											//{
											//通知玩家进入战场
											playerEnterBattle(gameServer,playerData.get(),sceneid,openItr->second.second.first,battleid,playerid);
											//}
											//else
											//{//为什么要在这里设置上？针对掉线玩家？
											//	gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
											//}
										}
										gameData->excHandle(MAKEINT64(WCH_LockData,0));
									}
									else
									{
										bitr = ditr->second.erase(bitr);
									}
								}
							}
						}
					}
				}
				else
				{//没有指定要防守的势力
					for( openItr = openBattleMap->begin();
						openItr != openBattleMap->end() && HIINT32(openItr->first) <= chengchiid && !ditr->second.empty();
						++openItr )
					{
						if(HIINT32(openItr->first) == chengchiid && HIINT16(LOINT32(openItr->first)) == defendshili && openItr->second.second.first != 0 && openItr->second.second.second > time2)
						{//
							battleid = openItr->first;
							//battleroomid = MAKEINT64(battleid,0);

							if(openItr->second.first.second.size()<halfplayercount)
							{//允许进入
								for( BattleDeque::iterator bitr = ditr->second.begin();
									bitr != ditr->second.end() && openItr->second.first.second.size()<halfplayercount;)
								{
									playerid = *bitr;
									playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
									if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass()/* && playerData->getSceneID() == 0*/)
									{
										playerGameData = playerData->getPlayerGameData();
										gameData = playerGameData->getDataClass();
										gameData->excHandle(MAKEINT64(WCH_LockData,1));
										gameData->getParam(WCHDATA_JXJMyTeam,param);
										teamVec = (TeamMemberVec *)param;
										if(!teamVec->empty())
										{//组队进入
											if(openItr->second.first.second.size()+teamVec->size()<=halfplayercount)
											{
												for( TeamMemberVec::iterator titr = teamVec->begin();
													titr != teamVec->end(); )
												{
													playerid2 = (*titr)->getPlayerID();
													if(playerid == playerid2)
													{
														openItr->second.first.second.push_back(playerid2);
														//if(openItr->second.second.first != 0)
														//{
														//通知玩家进入战场
														playerEnterBattle(gameServer,playerData.get(),sceneid,openItr->second.second.first,battleid,playerid2);
														//}
														//else
														//{//为什么要在这里设置上？针对掉线玩家？
														//	gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
														//}
													}
													else
													{
														playerData2 = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid2));
														if(playerData2.valid() && playerData2->getPlayerGameData() && playerData2->getPlayerGameData()->getDataClass() && playerData2->getSceneID() == 0)
														{
															openItr->second.first.second.push_back(playerid2);
															//if(openItr->second.second.first != 0)
															//{
															//通知玩家进入战场
															playerEnterBattle(gameServer,playerData2.get(),sceneid,openItr->second.second.first,battleid,playerid2);
															//}
															//else
															//{//为什么要在这里设置上？针对掉线玩家？
															//	gameData2 = playerData2->getPlayerGameData()->getDataClass();
															//	gameData2->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
															//}
														}
														else
														{//该队友已经离开组队
															titr = teamVec->erase(titr);
															continue;
														}
													}
													++titr;
												}
												bitr = ditr->second.erase(bitr);
											}
											else
											{
												++bitr;
											}
										}
										else
										{//单人进入
											openItr->second.first.second.push_back(playerid);
											bitr = ditr->second.erase(bitr);
											//if(openItr->second.second.first != 0)
											//{
											//通知玩家进入战场
											playerEnterBattle(gameServer,playerData.get(),sceneid,openItr->second.second.first,battleid,playerid);
											//}
											//else
											//{//为什么要在这里设置上？针对掉线玩家？
											//	gameData->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
											//}
										}
										gameData->excHandle(MAKEINT64(WCH_LockData,0));
									}
									else
									{
										bitr = ditr->second.erase(bitr);
									}
								}
							}
						}
					}	
				}
				++ditr;
			}
			else
			{//无效的chengchiid
				CRCore::notify(CRCore::ALWAYS)<<"crJXJBattleDequeDisposeMethod 无效的城池ID"<<chengchiid<<std::endl;
				//sprintf(gDebugInfo->buf(),"crJXJBattleDequeDisposeMethod 无效的城池ID=%d\n\0",chengchiid);
				//gDebugInfo->debugInfo(CRCore::ALWAYS);
				ditr = defendDequeMap->erase(ditr);
			}
		}
		else
		{
			++ditr;
		}
	}
	crPlayerDataEventPacket waitpacket;
	ref_ptr<crStreamBuf> waitstream = new crStreamBuf;
	waitstream->createBuf(1);
	unsigned char ipos;
	for( AttackDequeMap::iterator aitr = attackDequeMap->begin();
		 aitr != attackDequeMap->end();
		 ++aitr )
	{
		ipos = 0;
		for( BattleDeque::iterator bitr = aitr->second.begin();
			 bitr != aitr->second.end(); )
		{
			playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
			if(playerData.valid()/* && playerData->getSceneID() == 0*/)
			{
				waitstream->seekBegin();
				waitstream->_writeUChar(ipos);
				crPlayerDataEventPacket::buildReplyPacket(waitpacket,*bitr,WCH_JXJRecvBattleDequeWait,waitstream.get());
				netManager->sendPacket(playerData->getPlayerConnectServerAddress(),waitpacket);
				++bitr;
				if(ipos<201)
					++ipos;
			}
			else
			{//删除掉线玩家
				bitr = aitr->second.erase(bitr);
			}
		}
	}
	for( DefendDequeMap::iterator ditr = defendDequeMap->begin();
		 ditr != defendDequeMap->end();
		 ++ditr )
	{
		ipos = 0;
		for( BattleDeque::iterator bitr = ditr->second.begin();
			 bitr != ditr->second.end(); )
		{
			playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*bitr));
			if(playerData.valid()/* && playerData->getSceneID() == 0*/)
			{
				waitstream->seekBegin();
				waitstream->_writeUChar(ipos);
				crPlayerDataEventPacket::buildReplyPacket(waitpacket,*bitr,WCH_JXJRecvBattleDequeWait,waitstream.get());
				netManager->sendPacket(playerData->getPlayerConnectServerAddress(),waitpacket);
				++bitr;
				if(ipos<201)
					++ipos;
			}
			else
			{//删除掉线玩家
				bitr = ditr->second.erase(bitr);
			}
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJSceneServerRemovedMethod
//
/////////////////////////////////////////
crJXJSceneServerRemovedMethod::crJXJSceneServerRemovedMethod():
	m_this(NULL),
m_sceneid(0){}
crJXJSceneServerRemovedMethod::crJXJSceneServerRemovedMethod(const crJXJSceneServerRemovedMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_sceneid(0)
{
}
void crJXJSceneServerRemovedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_sceneid = LOINT64(param64);
		}
		else
		{
			m_sceneid = 0;
		}
		break;
	}
}
void crJXJSceneServerRemovedMethod::addParam(int i, const std::string& str)
{
}
void crJXJSceneServerRemovedMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	crTableIO::StrVec record;
	int sceneindex = chengchiTab->getTitleIndex("sceneid");
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJOpenBattleMap,param);
	OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
	unsigned short chengchiid;
	int sceneid,battleid;
	for( OpenBattleMap::iterator itr = openBattleMap->begin();
		itr != openBattleMap->end(); )
	{
		battleid = itr->first;
		chengchiid = HIINT32(battleid);
		if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
		{
			sceneid = atoi(record[sceneindex].c_str());
			if(sceneid == m_sceneid)
			{
				itr = openBattleMap->erase(itr);
			}
			else
			{
				++itr;
			}
		}
		else
		{
			itr = openBattleMap->erase(itr);
		}
	}

	/////sceneserver宕机时清此副本；
	ref_ptr<crTableIO> fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	record.clear();
	int fubensceneindex = fubenTab->getTitleIndex("sceneid");
	crData * groupData = NULL;
	StartedFubenMap * startedFubenMap;
	data->getParam(WCHDATA_JXJConsortiaMap,param);
	ConsortiaMap *consortiamap = (ConsortiaMap *)param;
	ConsortiaMap::iterator cmitr = consortiamap->begin();
	StartedFubenMap::iterator sfmitr;
	for (;cmitr != consortiamap->end();++cmitr)
	{
		if (cmitr->second.valid())
		{
			groupData = cmitr->second->getDataClass();
			if (groupData)
			{
				groupData->getParam(WCHDATA_JXJMyGroupStartedFuBenMap,param);
				startedFubenMap  = (StartedFubenMap *)param;
				sfmitr = startedFubenMap->begin();
				for (;sfmitr != startedFubenMap->end();)
				{
					if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(sfmitr->first),record)>=0)
					{
						sceneid = atoi(record[fubensceneindex].c_str());
						if (sceneid == m_sceneid)
						{
							sfmitr = startedFubenMap->erase(sfmitr);
						}
						else
						{
							++sfmitr;
						}
					}
				}
			}
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJGameServerCreateRoomReturnMethod
//
/////////////////////////////////////////
crJXJGameServerCreateRoomReturnMethod::crJXJGameServerCreateRoomReturnMethod(){}
crJXJGameServerCreateRoomReturnMethod::crJXJGameServerCreateRoomReturnMethod(const crJXJGameServerCreateRoomReturnMethod& handle):
	crMethod(handle)
{
}
void crJXJGameServerCreateRoomReturnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJGameServerCreateRoomReturnMethod::addParam(int i, const std::string& str)
{
}
void crJXJGameServerCreateRoomReturnMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		bool success = m_stream->_readBool();
		int roomid = m_stream->_readInt();
		int sceneid = m_stream->_readInt();
		_crInt32 battleid = m_stream->_readInt();
		void *param;
		crData *data = m_this->getDataClass();
		int playerid;
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
		crNetManager *netManager = gameServer->getNetManager();
		crNetDataManager *netDataManager = gameServer->getNetDataManager();
		ref_ptr<crGameServerPlayerData> playerData;
		if(success)
		{
			_crInt64 battleroomid = MAKEINT64(battleid,roomid);
			unsigned short chengchiid = HIINT32(battleid);
			crTableIO::StrVec record;
			ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
			int timeindex = chengchiTab->getTitleIndex("时间");
			int nameindex = chengchiTab->getTitleIndex("名字");
			chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record);
			int time = atoi(record[timeindex].c_str());

			crPlayerDataEventPacket packet;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(12);
			stream->_writeInt(sceneid);
			stream->_writeInt64(battleroomid);
			crPlayerDataEventPacket::buildReplyPacket(packet,0,WCH_JXJRecvEnterBattle,stream.get());
			ref_ptr<crStreamBuf> packetStream = packet.getStreamBuf();
			int bufsize = packetStream->getBufSize();

			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJOpenBattleMap,param);
			OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			OpenBattleMap::iterator itr = openBattleMap->find(battleid);
			crPlayerGameData *playerGameData;
			crData *playerDataClass;
			for(; itr != openBattleMap->end() && itr->first == battleid; ++itr)
			{
				if(itr->second.second.first == 0)
				{
					itr->second.second.first = roomid;
					itr->second.second.second = time;
					//通知玩家进入战场
					for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
						 pitr != itr->second.first.first.end();)
					{
						playerid = *pitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid()&&playerData->getSceneID()==0 &&playerData->getPlayerGameData()&&playerData->getPlayerGameData()->getDataClass())
						{
							playerGameData = playerData->getPlayerGameData();
							playerDataClass = playerGameData->getDataClass();
							playerDataClass->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);

							packetStream->seekBegin();
							packetStream->_writeInt(playerid);
							packetStream->setBufSize(bufsize);
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							++pitr;
						}
						else
						{//玩家已经离开游戏
							pitr = itr->second.first.first.erase(pitr);
						}
					}
					for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
						 pitr != itr->second.first.second.end();)
					{
						playerid = *pitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid()&&playerData->getSceneID()==0 &&playerData->getPlayerGameData()&&playerGameData->getDataClass())
						{
							playerGameData = playerData->getPlayerGameData();
							playerDataClass = playerGameData->getDataClass();
							playerDataClass->inputParam(WCHDATA_JXJBattleRoomID,&battleroomid);
							packetStream->seekBegin();
							packetStream->_writeInt(playerid);
							packetStream->setBufSize(bufsize);
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							++pitr;
						}
						else
						{//玩家已经离开游戏
							pitr = itr->second.first.second.erase(pitr);
						}
					}
					break;
				}
			}
			//发送给玩家系统消息
			std::string strMessageAttack,strMessageDefend;
			std::string strAttack,strDefend,strChengchiName;
			data->getParam(WCHDATA_JXJShiliWei,param);
			crJXJShili *shiliWei = (crJXJShili *)param;
			data->getParam(WCHDATA_JXJShiliShu,param);
			crJXJShili *shiliShu = (crJXJShili *)param;
			data->getParam(WCHDATA_JXJShiliWu,param);
			crJXJShili *shiliWu = (crJXJShili *)param;
			int weiID = shiliWei->getID();
			int shuID = shiliShu->getID();
			int wuID = shiliWu->getID();

			unsigned char aShiliid = (unsigned char)(LOINT16(LOINT32(battleid)));
			unsigned char dShiliid = (unsigned char)(HIINT16(LOINT32(battleid)));

			if(aShiliid == weiID)
			{
				strAttack = "魏国";
			}
			else if(aShiliid == shuID)
			{
				strAttack = "蜀国";
			}
			else if(aShiliid == wuID)
			{
				strAttack = "吴国";
			}
			else
			{
				strAttack = "群雄";
			}
			if(dShiliid == weiID)
			{
				strDefend = "魏国";
			}
			else if(dShiliid == shuID)
			{
				strDefend = "蜀国";
			}
			else if(dShiliid == wuID)
			{
				strDefend = "吴国";
			}
			else
			{
				strDefend = "群雄";
			}
			//if(!strAttack.empty()) strAttack = strAttack + std::string("国");
			//if(!strDefend.empty()) strDefend = strDefend + std::string("国");
			strChengchiName = record[nameindex];
			strMessageAttack = std::string("^3^")+std::string("我方正在攻击")+strDefend+std::string("[")+strChengchiName+std::string("]，请尽快前往增援!");
			strMessageDefend = std::string("^3^")+std::string("我方[")+strChengchiName+std::string("]正在遭受")+strAttack+std::string("攻击")+std::string("，请尽快前往增援!");

			ref_ptr<crJXJChatMessageInfo> achatInfo = new crJXJChatMessageInfo("[通告]",strMessageAttack,0,aShiliid);
			ref_ptr<crJXJChatMessageInfo> dchatInfo = new crJXJChatMessageInfo("[通告]",strMessageDefend,0,dShiliid);
			crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKEINT64(achatInfo.get(),NULL));
			crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKEINT64(dchatInfo.get(),NULL));
			data->excHandle(MAKEINT64(WCH_LockData,0));
			//////////////////////////////////////////////////////////////////////////
		}
		else
		{//战场创建失败,不再重新创建
			//void *param;
			//crData *data = m_this->getDataClass();
			//data->excHandle(MAKEINT64(WCH_LockData,1));
			//data->getParam(WCHDATA_JXJCreateBattleDeque,param);
			//CreateBattleDeque *createBattleDeque = (CreateBattleDeque *)param;
			//createBattleDeque->push_back(MAKEINT64(sceneid,battleid));
			//data->excHandle(MAKEINT64(WCH_LockData,0));
			crPlayerDataEventPacket packet;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJOpenBattleMap,param);
			OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			OpenBattleMap::iterator itr = openBattleMap->find(battleid);
			crData *pdata;
			for(; itr != openBattleMap->end() && itr->first == battleid; ++itr)
			{
				if(itr->second.second.first == 0)
				{
					//itr->second.second.first = roomid;
					//通知玩家战场创建失败
					for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
						 pitr != itr->second.first.first.end();
						 ++pitr )
					{
						playerid = *pitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid()&&playerData->getSceneID()==0&&playerData->getPlayerGameData()&&playerData->getPlayerGameData()->getDataClass())
						{
							pdata = playerData->getPlayerGameData()->getDataClass();
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
							//pdata->inputParam(WCHDATA_JXJBattleRoomID,NULL);///之前是注释的

							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBattleCreateFaild,NULL);
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
						 pitr != itr->second.first.second.end();
						 ++pitr )
					{
						playerid = *pitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid()&&playerData->getSceneID()==0&&playerData->getPlayerGameData()&&playerData->getPlayerGameData()->getDataClass())
						{
							pdata = playerData->getPlayerGameData()->getDataClass();
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
							//pdata->inputParam(WCHDATA_JXJBattleRoomID,NULL);///之前是注释的
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBattleCreateFaild,NULL);
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					openBattleMap->erase(itr);
					break;
				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJCreateBattleDisposeMethod
//
/////////////////////////////////////////
crJXJCreateBattleDisposeMethod::crJXJCreateBattleDisposeMethod():
	m_this(NULL),
	m_dt(NULL){}
crJXJCreateBattleDisposeMethod::crJXJCreateBattleDisposeMethod(const crJXJCreateBattleDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL)
{
}
void crJXJCreateBattleDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			if(lparam)
				m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crJXJCreateBattleDisposeMethod::addParam(int i, const std::string& str)
{
}
void crJXJCreateBattleDisposeMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJCreateBattleDeque,param);
	CreateBattleDeque *createBattleDeque = (CreateBattleDeque *)param;
	if(!createBattleDeque->empty())
	{
		_crInt64 createbattle = createBattleDeque->front();
		createBattleDeque->pop_front();
		bool create = false;
		int sceneid = LOINT64(createbattle);
		int battleid = HIINT64(createbattle);
		unsigned short chengchiid = HIINT32(battleid);
		ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
		crTableIO::StrVec record;
		if(chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
		{
			int timeid = chengchiTab->getTitleIndex("时间");
			int countid = chengchiTab->getTitleIndex("玩家数量");
			int nameid = chengchiTab->getTitleIndex("名字");
			char battleMode = crRoom::Extern;
			int timeLimit = atoi(record[timeid].c_str());
			short playerCount = (short)(atoi(record[countid].c_str()));
			std::string battleName = record[nameid];
			bool friendlyFire = false;
			ref_ptr<crStreamBuf>streamBuf = new crStreamBuf;
			streamBuf->createBuf(20+battleName.length());
			streamBuf->_writeInt(sceneid);
			streamBuf->_writeInt(battleid);//8
			streamBuf->_writeChar(battleMode);//1
			streamBuf->_writeString(battleName);//16+4
			streamBuf->_writeInt(timeLimit);//4
			streamBuf->_writeShort(playerCount);//2
			streamBuf->_writeBool(friendlyFire);//1
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crGameServerCallback *netCallback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
			std::string serverAddress = netCallback->findSceneServerAddress(sceneid);
			if(!serverAddress.empty())
			{
				crJXJGameServerCreateRoomPacket packet;
				crJXJGameServerCreateRoomPacket::buildRequestPacket(packet,streamBuf.get());
				gameServer->getNetManager()->sendPacket(serverAddress,packet);
				create = true;
			}
		}
		if(!create)
		{//通知玩家创建失败
			int playerid;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			crPlayerDataEventPacket packet;
			data->getParam(WCHDATA_JXJOpenBattleMap,param);
			OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			OpenBattleMap::iterator itr = openBattleMap->find(battleid);
			crData *pdata;
			for(; itr != openBattleMap->end() && itr->first == battleid; ++itr )
			{
				if(itr->second.second.first == 0)
				{
					//itr->second.second.first = roomid;
					//通知玩家战场创建失败
					for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
						pitr != itr->second.first.first.end();
						++pitr )
					{
						playerid = *pitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid()&&playerData->getSceneID()==0&&playerData->getPlayerGameData()&&playerData->getPlayerGameData()->getDataClass())
						{
							pdata = playerData->getPlayerGameData()->getDataClass();
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
							//pdata->inputParam(WCHDATA_JXJBattleRoomID,NULL);///之前是注释的

							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBattleCreateFaild,NULL);
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
						pitr != itr->second.first.second.end();
						++pitr )
					{
						playerid = *pitr;
						playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
						if(playerData.valid()&&playerData->getSceneID()==0&&playerData->getPlayerGameData()&&playerData->getPlayerGameData()->getDataClass())
						{
							pdata = playerData->getPlayerGameData()->getDataClass();
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
							//pdata->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
							//pdata->inputParam(WCHDATA_JXJBattleRoomID,NULL);///之前是注释的
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBattleCreateFaild,NULL);
							netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					openBattleMap->erase(itr);
					break;
				}
			}
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvEnterBattleMethod
//
/////////////////////////////////////////
crJXJRecvEnterBattleMethod::crJXJRecvEnterBattleMethod():
	m_netType(GameClient_Game){}
crJXJRecvEnterBattleMethod::crJXJRecvEnterBattleMethod(const crJXJRecvEnterBattleMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget)
{
}
void crJXJRecvEnterBattleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvEnterBattleMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	}
}
void crJXJRecvEnterBattleMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			int sceneid = m_stream->_readInt();
			_crInt64 battleroomid = m_stream->_readInt64();
			_crInt32 battleid = LOINT64(battleroomid);
			unsigned short chengchiid = HIINT32(battleid);
			//void *param;
			crData *data = m_this->getDataClass();
			ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
			crTableIO::StrVec record;
			if(/*type == FT_Chengchi && */chengchiid>0 && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),record)>=0)
			{
				unsigned char type = FT_Chengchi;
				data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
				data->inputParam(WCHDATA_JXJFubenOrChengchiID,&chengchiid);

				int nameid = chengchiTab->getTitleIndex("名字");
				
				int texid = 1034;//"是否进入城战%s"
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
				int mode = 2;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameid]));
				std::string output;
				noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);

				data->inputParam(WCHDATA_JXJBattleRoomID, &battleroomid);
				ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
				if(canvas.valid())
				{	
					crData *canvasData = canvas->getDataClass();
					canvasData->inputParam(WCHDATA_JXJEnterSceneID,&sceneid);
					crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
					if(textWidget)
					{
						textWidget->setString(output);
					}
					crFilterRenderManager::getInstance()->doModal(canvas.get());
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBattleDequeWaitMethod
//
/////////////////////////////////////////
crJXJRecvBattleDequeWaitMethod::crJXJRecvBattleDequeWaitMethod():
	m_netType(GameClient_Game),
	m_mintime(0){}
crJXJRecvBattleDequeWaitMethod::crJXJRecvBattleDequeWaitMethod(const crJXJRecvBattleDequeWaitMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget),
	m_mintime(handle.m_mintime),
	m_canvas(handle.m_canvas),
	m_chenzhan(handle.m_chenzhan),
	m_jianguo(handle.m_jianguo)
{
}
void crJXJRecvBattleDequeWaitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvBattleDequeWaitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	case 2:
		m_mintime = atoi(str.c_str());
		break;
	case 3:
		m_canvas = str;
		break;
	case 4:
		m_chenzhan = str;
		break;
	case 5:
		m_jianguo = str;
		break;
	default:
		break;
	}
}
void crJXJRecvBattleDequeWaitMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			unsigned char ipos = m_stream->_readUChar();
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			ref_ptr<crCanvasNode> canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if(canvas.valid() && canvas2.valid())
			{
				crButtonWidgetNode *chenzhanBtn = dynamic_cast<crButtonWidgetNode *>(canvas2->getWidget(m_chenzhan));
				crButtonWidgetNode *jianguoBtn = dynamic_cast<crButtonWidgetNode *>(canvas2->getWidget(m_jianguo));
				void *param;
				ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				crData * data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short selectID = *(unsigned short *)param;
				if(type == FT_Chengchi && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(selectID),record)>=0)
				{
					int nameindex = chengchiTab->getTitleIndex("名字");
					crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
					if(textWidget)
					{
						int battletypeindex = chengchiTab->getTitleIndex("类型");
						std::string str,str2;
						if(ipos>200)
							str = ">200";
						else
							str = crArgumentParser::appItoa(ipos);
						str2 = record[nameindex];
						
						//data->getParam(WCHDATA_JXJBattleTimer,param);
						//int time = *(int *)param;
						int texid = 1035;//"你已经在[%s]队列中,请等待！%s"
						//if(atoi(record[battletypeindex].c_str())==1 && time<=m_mintime)
						//	texid = 1072;
						crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&str2);
						noticeHandle->inputParam(WCHDATA_NoticeParam2,&str);
						std::string output;
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						textWidget->setString(output);
					}
					if((jianguoBtn && jianguoBtn->getVisiable()))
					{
						if(!canvas->getVisiable())
						{
							const crBoundingBox &bbox2 = canvas->getBoundBox();
							const crBoundingBox &bbox = jianguoBtn->getBoundBox();
							float posx = (bbox.m_max[0]-bbox.m_min[0])*0.5 + bbox.m_min[0]/* - (bbox2.m_max[0]-bbox2.m_min[0])*0.5*/;
							float posy = bbox.m_max[1] - (bbox2.m_max[1]-bbox2.m_min[1]);
							canvas->setMatrix(crMatrix::translate(posx,posy,0.0f));
							crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
						}
					}
					else if (chenzhanBtn && chenzhanBtn->getVisiable())
					{
						if (!canvas->getVisiable())
						{
							const crBoundingBox &bbox2 = canvas->getBoundBox();
							const crBoundingBox &bbox = chenzhanBtn->getBoundBox();
							float posx = (bbox.m_max[0]-bbox.m_min[0]) + bbox.m_min[0]*0.85 - 0.01/* - (bbox2.m_max[0]-bbox2.m_min[0])*0.5*/;
							float posy = bbox.m_max[1] + bbox2.yLength()*0.5 + 0.05;
							canvas->setMatrix(crMatrix::translate(posx,posy,0.0f));
							crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
						}

					}
					else
					{
						if(canvas->getVisiable())
							crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBattlePunishMethod
//
/////////////////////////////////////////
crJXJRecvBattlePunishMethod::crJXJRecvBattlePunishMethod():
	m_netType(GameClient_Game){}
crJXJRecvBattlePunishMethod::crJXJRecvBattlePunishMethod(const crJXJRecvBattlePunishMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget)
{
}
void crJXJRecvBattlePunishMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvBattlePunishMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	}
}
void crJXJRecvBattlePunishMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			short punish = m_stream->_readShort();
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			if(canvas.valid())
			{
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					canvasdata->inputParam(WCHDATA_JXJBattlePunishTime,&punish);
				}
				//crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
				//if(textWidget)
				//{
				//	int t;
				//	int hour,minute,s;
				//	hour = punish/3600;
				//	t = punish%3600;
				//	minute = t/60;
				//	s = t%60;
				//	textWidget->setString(/*"您提前从战场退出，还需要再等待"+*//*"惩罚时间:"+*/crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s)/*+"秒，才能进入排队系统,请等待！"*/);
				//}
				if(punish > 0)
				{
					if(!canvas->getVisiable())
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
				else
				{
					if(canvas->getVisiable())
						crFilterRenderManager::getInstance()->closeCanvas(canvas.get());
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBattleCloseMethod
//
/////////////////////////////////////////
crJXJRecvBattleCloseMethod::crJXJRecvBattleCloseMethod():
	m_netType(GameClient_Game){}
crJXJRecvBattleCloseMethod::crJXJRecvBattleCloseMethod(const crJXJRecvBattleCloseMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget)
{
}
void crJXJRecvBattleCloseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_netType = HIINT64(param64);
		}
		break;
	}
}
void crJXJRecvBattleCloseMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	}
}
void crJXJRecvBattleCloseMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == GameClient_Game)
		{
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			if(canvas.valid())
			{
				void *param;
				ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				crData * data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short selectID = *(unsigned short *)param;
				if(type == FT_Chengchi && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(selectID),record)>=0)
				{
					int nameindex = chengchiTab->getTitleIndex("名字");
					crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
					if(textWidget)
					{
						int texid = 1036;//"[%s]已经结束战斗，请点击退出！"
						crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameindex]));
						std::string output;
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						textWidget->setString(output);
					}
					if(!canvas->getVisiable())
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBattleCannotCreateMethod
//
/////////////////////////////////////////
crJXJRecvBattleCannotCreateMethod::crJXJRecvBattleCannotCreateMethod():
	m_netType(GameClient_Game){}
crJXJRecvBattleCannotCreateMethod::crJXJRecvBattleCannotCreateMethod(const crJXJRecvBattleCannotCreateMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget)
{
}
void crJXJRecvBattleCannotCreateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_netType = HIINT64(param64);
		}
		break;
	}
}
void crJXJRecvBattleCannotCreateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	}
}
void crJXJRecvBattleCannotCreateMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == GameClient_Game)
		{
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			if(canvas.valid())
			{
				void *param;
				ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				crData * data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short selectID = *(unsigned short *)param;
				if(type == FT_Chengchi && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(selectID),record)>=0)
				{
					int nameindex = chengchiTab->getTitleIndex("名字");
					crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
					if(textWidget)
					{
						int texid = 1080;//"[%s]已达到战场数量上限,不能开辟新战场了！"
						crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameindex]));
						std::string output;
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						textWidget->setString(output);
					}
					if(!canvas->getVisiable())
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBattleCapturedMethod
//
/////////////////////////////////////////
crJXJRecvBattleCapturedMethod::crJXJRecvBattleCapturedMethod():
	m_netType(GameClient_Game){}
crJXJRecvBattleCapturedMethod::crJXJRecvBattleCapturedMethod(const crJXJRecvBattleCapturedMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget)
{
}
void crJXJRecvBattleCapturedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_netType = HIINT64(param64);
		}
		break;
	}
}
void crJXJRecvBattleCapturedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	}
}
void crJXJRecvBattleCapturedMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == GameClient_Game)
		{
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			if(canvas.valid())
			{
				void *param;
				ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				crData * data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short selectID = *(unsigned short *)param;
				if(type == FT_Chengchi && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(selectID),record)>=0)
				{
					int nameindex = chengchiTab->getTitleIndex("名字");
					crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
					if(textWidget)
					{
						int texid = 1037;//"[%s]已经被攻陷，请点击退出!"
						crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameindex]));
						std::string output;
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						textWidget->setString(output);
					}
					if(!canvas->getVisiable())
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBattleCreateFaildMethod
//
/////////////////////////////////////////
crJXJRecvBattleCreateFaildMethod::crJXJRecvBattleCreateFaildMethod():
	m_netType(GameClient_Game){}
crJXJRecvBattleCreateFaildMethod::crJXJRecvBattleCreateFaildMethod(const crJXJRecvBattleCreateFaildMethod& handle):
	crMethod(handle),
	m_noticeCanvas(handle.m_noticeCanvas),
	m_textWidget(handle.m_textWidget)
{
}
void crJXJRecvBattleCreateFaildMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_netType = HIINT64(param64);
		}
		break;
	}
}
void crJXJRecvBattleCreateFaildMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeCanvas = str;
		break;
	case 1:
		m_textWidget = str;
		break;
	}
}
void crJXJRecvBattleCreateFaildMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == GameClient_Game)
		{
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_noticeCanvas);
			if(canvas.valid())
			{
				void *param;
				ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				crTableIO::StrVec record;
				crData * data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short selectID = *(unsigned short *)param;
				if(type == FT_Chengchi && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(selectID),record)>=0)
				{
					int nameindex = chengchiTab->getTitleIndex("名字");
					crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_textWidget));
					if(textWidget)
					{
						int texid = 1038;//"[%s]战场创建失败，请点击退出!"
						crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameindex]));
						std::string output;
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						textWidget->setString(output);
					}
					if(!canvas->getVisiable())
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJExitBattleDequeMethod
//
/////////////////////////////////////////
crJXJExitBattleDequeMethod::crJXJExitBattleDequeMethod()
{
}
crJXJExitBattleDequeMethod::crJXJExitBattleDequeMethod(const crJXJExitBattleDequeMethod& handle):
	crMethod(handle)
{
}
void crJXJExitBattleDequeMethod::inputParam(int i, void *param)
{
}
void crJXJExitBattleDequeMethod::addParam(int i, const std::string& str)
{
}
void crJXJExitBattleDequeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer)
	{
		crData *data = myPlayer->getDataClass();
		//data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
		//data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvExitBattleDeque,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvExitBattleDequeMethod
//
/////////////////////////////////////////
crJXJRecvExitBattleDequeMethod::crJXJRecvExitBattleDequeMethod():
	m_netType(GameClient_Game){}
crJXJRecvExitBattleDequeMethod::crJXJRecvExitBattleDequeMethod(const crJXJRecvExitBattleDequeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvExitBattleDequeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvExitBattleDequeMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvExitBattleDequeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			crData *data = m_this->getDataClass();
			int playerid = m_this->getPlayerID();
			data->getParam(WCHDATA_JXJBattleRoomID,param);
			_crInt64 battleroomid = *(_crInt64 *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char type = *(unsigned char *)param;
			char code = 0;
			if(battleroomid == 0 && type == FT_Chengchi)
			{
				bool found = false;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short chengchiid = *(unsigned short *)param;
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myShili = *(unsigned char *)param;
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJChengChiMap,param);
				ChengchiMap *chengchiMap = (ChengchiMap *)param;
				ChengchiMap::iterator itr = chengchiMap->find(chengchiid);
				if(itr != chengchiMap->end())
				{
					_crInt32 battleid;
					gsBrainData->getParam(WCHDATA_JXJDefendDequeMap,param);
					DefendDequeMap *defendDequeMap = (DefendDequeMap *)param;
					for( DefendDequeMap::iterator ditr = defendDequeMap->begin();
						ditr != defendDequeMap->end();
						++ditr )
					{
						battleid = ditr->first;
						if(HIINT32(battleid) == chengchiid)
						{
							BattleDeque &battleDeque = ditr->second;
							for( BattleDeque::iterator bitr = battleDeque.begin();
								bitr != battleDeque.end();
								++bitr )
							{
								if(*bitr == playerid)
								{
									battleDeque.erase(bitr);
									found = true;
									break;
								}
							}
							if(found)
								break;
						}
					}
					if(!found)
					{//我是攻方
						gsBrainData->getParam(WCHDATA_JXJAttackDequeMap,param);
						AttackDequeMap *attackDequeMap = (AttackDequeMap *)param;
						for( AttackDequeMap::iterator aitr = attackDequeMap->begin();
							aitr != attackDequeMap->end();
							++aitr )
						{
							battleid = aitr->first;
							if(HIINT32(battleid) == chengchiid)
							{
								BattleDeque &battleDeque = aitr->second;
								for( BattleDeque::iterator bitr = battleDeque.begin();
									bitr != battleDeque.end();
									++bitr )
								{
									if(*bitr == playerid)
									{
										battleDeque.erase(bitr);
										found = true;
										if(battleDeque.size() == 0)
											crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerBattDequeUpdata,MAKEINT64(MAKEINT32(chengchiid,0),battleid));

										break;
									}
								}
								if(found)
									break;
							}
						}
					}
					if(!found)
					{
						gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
						OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
						OpenBattleMap::iterator oitr;
						BattlePlayer::iterator bpitr;
						for( oitr = openBattleMap->begin();
							oitr != openBattleMap->end();
							++oitr )
						{
							battleid = oitr->first;
							if(HIINT32(battleid) == chengchiid)
							{
								if(LOINT16(LOINT32(battleid))==myShili)
								{//攻方
									for( bpitr = oitr->second.first.first.begin();
										bpitr != oitr->second.first.first.end();
										++bpitr )
									{
										if(*bpitr == playerid)
										{
											oitr->second.first.first.erase(bpitr);
											found = true;
											break;
										}
									}
								}
								else if(HIINT16(LOINT32(battleid))==myShili)
								{//我是守方
									for( bpitr = oitr->second.first.second.begin();
										bpitr != oitr->second.first.second.end();
										++bpitr )
									{
										if(*bpitr == playerid)
										{
											oitr->second.first.second.erase(bpitr);
											found = true;
											break;
										}
									}
								}
								if(found == true)
									break;
							}
						}
					}
				}
				gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
				data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
				data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
				//data->inputParam(WCHDATA_JXJBattleRoomID,NULL);///之前是注释的
				code = 1;
			}
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(1);
			stream->_writeChar(code);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvExitBattleDeque,stream.get());
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			//else
			//{//我已经在战场里面了，不能退出
			//	int id = LOINT64(battleroomid);
			//	int roomid = HIINT64(battleroomid);
			//	//if(roomid == 0)
			//	{
			//		crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			//		gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
			//		gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
			//		OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			//		bool found = false;
			//		for( OpenBattleMap::iterator itr = openBattleMap->find(id);
			//			itr != openBattleMap->end() && itr->first == id;
			//			++itr )
			//		{
			//			if(itr->second.second.first == roomid)
			//			{
			//				for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
			//					pitr != itr->second.first.first.end();
			//					++pitr )
			//				{
			//					if(*pitr == playerid)
			//					{
			//						found = true;
			//						itr->second.first.first.erase(pitr);
			//						break;
			//					}
			//				}
			//				if(!found)
			//				{
			//					for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
			//						pitr != itr->second.first.second.end();
			//						++pitr )
			//					{
			//						if(*pitr == playerid)
			//						{
			//							found = true;
			//							itr->second.first.second.erase(pitr);
			//							break;
			//						}
			//					}
			//				}
			//				if(found)
			//					break;
			//			}
			//		}
			//		gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
			//		data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
			//		data->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
			//	}
			//}
		}
		else if(m_netType == GameClient_Game)
		{
			bool cancelTask = false;
			char code = m_stream->_readChar();
			if(code==1)
			{
				crData *data = m_this->getDataClass();
				data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
				data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
			}
			else
			{
				cancelTask = true;
				int texid = 1056;
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
				int mode = 1;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
			}
			handle.outputParam(0,&cancelTask);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRefuseEnterBattleMethod
//
/////////////////////////////////////////
crJXJRefuseEnterBattleMethod::crJXJRefuseEnterBattleMethod()
{
}
crJXJRefuseEnterBattleMethod::crJXJRefuseEnterBattleMethod(const crJXJRefuseEnterBattleMethod& handle):
	crMethod(handle)
{
}
void crJXJRefuseEnterBattleMethod::inputParam(int i, void *param)
{
}
void crJXJRefuseEnterBattleMethod::addParam(int i, const std::string& str)
{
}
void crJXJRefuseEnterBattleMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer)
	{
		crData *data = myPlayer->getDataClass();
		data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRefuseEnterBattle,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvRefuseEnterBattleMethod
//
/////////////////////////////////////////
crJXJRecvRefuseEnterBattleMethod::crJXJRecvRefuseEnterBattleMethod():
	m_netType(GameClient_Game){}
crJXJRecvRefuseEnterBattleMethod::crJXJRecvRefuseEnterBattleMethod(const crJXJRecvRefuseEnterBattleMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvRefuseEnterBattleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvRefuseEnterBattleMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvRefuseEnterBattleMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			crData *data = m_this->getDataClass();
			int playerid = m_this->getPlayerID();
			data->getParam(WCHDATA_JXJBattleRoomID,param);
			_crInt64 battleroomid = *(_crInt64 *)param;
			if(battleroomid!=0)
			{
				int id = LOINT64(battleroomid);
				int roomid = HIINT64(battleroomid);
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
				OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
				bool found = false;
				for( OpenBattleMap::iterator itr = openBattleMap->find(id);
					itr != openBattleMap->end() && itr->first == id;
					++itr )
				{
					if(itr->second.second.first == roomid)
					{
						for( BattlePlayer::iterator pitr = itr->second.first.first.begin();
							pitr != itr->second.first.first.end();
							++pitr )
						{
							if(*pitr == playerid)
							{
								found = true;
								itr->second.first.first.erase(pitr);
								break;
							}
						}
						if(!found)
						{
							for( BattlePlayer::iterator pitr = itr->second.first.second.begin();
								pitr != itr->second.first.second.end();
								++pitr )
							{
								if(*pitr == playerid)
								{
									found = true;
									itr->second.first.second.erase(pitr);
									break;
								}
							}
						}
						break;
					}
				}
				gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
				data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
				data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
				data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAgreeEnterBattleMethod
//
/////////////////////////////////////////
crJXJAgreeEnterBattleMethod::crJXJAgreeEnterBattleMethod()
{
}
crJXJAgreeEnterBattleMethod::crJXJAgreeEnterBattleMethod(const crJXJAgreeEnterBattleMethod& handle):
	crMethod(handle)
{
}
void crJXJAgreeEnterBattleMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJAgreeEnterBattleMethod::addParam(int i, const std::string& str)
{
}
void crJXJAgreeEnterBattleMethod::operator()(crHandle &handle)
{
	//bool taskCanceled = true;
	CRCore::ref_ptr<crCanvasNode> sweepcanvas = crFilterRenderManager::getInstance()->findCanvas("UI_Sweep");
	if (sweepcanvas.valid())
	{
		if (sweepcanvas->getVisiable())
		{
			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(5025, NULL));
			return;
		}
	}
	//ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_Battleground_Jr4");
	if(canvas.valid())
	{
		void *param;
		crData *data = canvas->getDataClass();
		data->getParam(WCHDATA_JXJEnterSceneID,param);
		int sceneid = *(int *)param;
		if(sceneid>0)
		{
			//crWaitNetReturnStreamLogic::getLock();
			//crMyPlayerData::getInstance()->setLoginGameSceneMode(1);
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1060,NULL));
			crLoginScenePacket packet;
			crLoginScenePacket::buildRequestPacket(packet,sceneid,WCH_JXJAgreeEnterBattle);
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			netConductor->getNetManager()->sendPacket("all",packet);
			//taskCanceled = false;
		}
	}
	//handle.outputParam(0,&taskCanceled);
}

///////////////////////////////////////////
////
////crJXJBattleRemovedMethod
////
///////////////////////////////////////////
//crJXJBattleRemovedMethod::crJXJBattleRemovedMethod()
//{
//}
//crJXJBattleRemovedMethod::crJXJBattleRemovedMethod(const crJXJBattleRemovedMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJBattleRemovedMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRoom*)param;
//		break;
//	}
//}
//void crJXJBattleRemovedMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJBattleRemovedMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crData *data = m_this->getDataClass();
//	data->getParam(WCHDATA_JXJBattleID,param); 
//	int battleid = *(int *)param;
//	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
//	crJXJBattleRemovedPacket packet;
//	crJXJBattleRemovedPacket::buildRequestPacket(packet,battleid,m_this->getRoomID());
//	netConductor->getNetManager()->sendPacket("all",packet);
//}
///////////////////////////////////////////
////
////crJXJRecvBattleRemovedMethod
////
///////////////////////////////////////////
//crJXJRecvBattleRemovedMethod::crJXJRecvBattleRemovedMethod(){}
//crJXJRecvBattleRemovedMethod::crJXJRecvBattleRemovedMethod(const crJXJRecvBattleRemovedMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvBattleRemovedMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJRecvBattleRemovedMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJRecvBattleRemovedMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		_crInt32 battleid = m_stream->_readInt();
//		int roomid = m_stream->_readInt();
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJOpenBattleMap,param);
//		OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
//		OpenBattleMap::iterator itr = openBattleMap->find(battleid);
//		for(; itr != openBattleMap->end() && itr->first == battleid; ++itr)
//		{
//			if(itr->second.second.first == roomid)
//			{
//				itr->second.second.second = 0.0f;
//				break;
//			}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
///////////////////////////////////////////
////
////crJXJClientRecvBattleRemovedMethod
////
///////////////////////////////////////////
//crJXJClientRecvBattleRemovedMethod::crJXJClientRecvBattleRemovedMethod():
//	m_netType(GameClient_Game){}
//crJXJClientRecvBattleRemovedMethod::crJXJClientRecvBattleRemovedMethod(const crJXJClientRecvBattleRemovedMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJClientRecvBattleRemovedMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJClientRecvBattleRemovedMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJClientRecvBattleRemovedMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameClient_Game)
//		{
//			void *param;
//			crData *data = m_this->getDataClass();
//			data->excHandle(MAKEINT64(WCH_LockData,1));
//			data->inputParam(WCHDATA_JXJBattleRoomID,NULL);
//			data->inputParam(WCHDATA_JXJBattleChengchiID,NULL);
//			//解散组队
//			data->inputParam(WCHDATA_JXJTeamLeaderID,NULL);
//			data->getParam(WCHDATA_JXJMyTeam,param);
//			TeamMemberVec *myTeam = (TeamMemberVec *)param;
//			myTeam->clear();
//			data->excHandle(MAKEINT64(WCH_LockData,0));
//			CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
//			if(noticeText)
//			{
//				noticeText->setText(L"战场已经结束了");
//				noticeText->setVisiable(true);
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJBuildTaskListMethod
////
///////////////////////////////////////////
//crJXJBuildTaskListMethod::crJXJBuildTaskListMethod(){}
//crJXJBuildTaskListMethod::crJXJBuildTaskListMethod(const crJXJBuildTaskListMethod& handle):
//	crMethod(handle),
//	m_canvasName(handle.m_canvasName),
//	m_listName(handle.m_listName)
//{
//}
//void crJXJBuildTaskListMethod::inputParam(int i, void *param)
//{
//}
//void crJXJBuildTaskListMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_canvasName = str;
//		break;
//	case 1:
//		m_listName = str;
//		break;
//	}
//}
//void crJXJBuildTaskListMethod::operator()(crHandle &handle)
//{
//	ref_ptr<crCanvasNode> canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
//	if(canvasNode)
//	{
//		crListBoxWidgetNode *taskList = dynamic_cast<crListBoxWidgetNode *>(canvasNode->getWidget(m_listName));
//		if(taskList)
//		{
//			taskList->clearData();
//			crRole *mainRole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
//			if(!mainRole) return;
//			crData *myMetierData = mainRole->getMetierDataClass();
//			void *param;
//			myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
//			myMetierData->getParam(WCHDATA_GameTaskMap,param);
//			GameTaskMap *gameTaskMap = (GameTaskMap *)param;
//			if(!gameTaskMap||gameTaskMap->empty())
//			{
//				myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
//				return;
//			}
//			std::string str;
//			for( GameTaskMap::iterator itr = gameTaskMap->begin();
//				itr != gameTaskMap->end();
//				++itr )
//			{
//				str = crArgumentParser::appItoa(itr->second->getTaskID())+" "+itr->second->getTaskName();
//				if(!itr->second->getActivation())
//					str += "(未接)";
//				else if(itr->second->isComplete())
//				{
//					str += "(已完成)";
//				}
//				else
//				{
//					str += "(进行中)";
//				}
//				taskList->addData(str);
//			}
//			myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}

/////////////////////////////////////////
//
//crJXJUIUpdateTaskTraceMethod
//
/////////////////////////////////////////
crJXJUIUpdateTaskTraceMethod::crJXJUIUpdateTaskTraceMethod(){}
crJXJUIUpdateTaskTraceMethod::crJXJUIUpdateTaskTraceMethod(const crJXJUIUpdateTaskTraceMethod& handle):
	crMethod(handle),
	m_traceWidget(handle.m_traceWidget),
	m_newhandName(handle.m_newhandName),
	m_taskswt(handle.m_taskswt),
	m_skipTheBoot(handle.m_skipTheBoot),
	m_zhezhaoCanvas(handle.m_zhezhaoCanvas),
	m_renWuCanvas(handle.m_renWuCanvas),
	m_scrollbar(handle.m_scrollbar)
{
}
void crJXJUIUpdateTaskTraceMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIUpdateTaskTraceMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_traceWidget = str;
		break;
	case 1:
		m_newhandName = str;
		break;
	case 2:
		m_taskswt = str;
		break;
	case 3:
		m_skipTheBoot = str;
		break;
	case 4:
		m_zhezhaoCanvas = str;
		break;
	case 5:
		m_renWuCanvas = str;
		break;
	case 6:
		m_scrollbar = str;
		break;
	}
}
void crJXJUIUpdateTaskTraceMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this->getVisiable() && playerGameData)
	{
		void *param;
		crRole *mainRole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
		if(!mainRole || !mainRole->getMetierDataClass()) return;
		crHypertextWidgetNode *traceWidget = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_traceWidget));
		crMultiSwitch *newhandarrow = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_newhandName));
		crMultiSwitch *taskswt = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_taskswt));
		crButtonWidgetNode *skipTheBoot = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_skipTheBoot));
		if(skipTheBoot)skipTheBoot->setVisiable(false);
		crData *canvasdata = m_this->getDataClass();
		canvasdata->getParam(WCHDATA_JXJArrowsUISelect,param);
		int Arrows = *(int *)param;
		if (newhandarrow)
		{
			newhandarrow->setActiveSwitchSet(0);
		}
		if (taskswt)
		{
			taskswt->setActiveSwitchSet(0);
		}
		//float scrollvaue = traceWidget->getVScrollBar()->getValue();
		traceWidget->clearText();
		if (canvasdata)
		{
			canvasdata->getParam(WCHDATA_JXJRenWuUnFolden,param);
			bool unfolden = *(bool *)param;
			if (unfolden)
			{
				if (taskswt)
				{
					taskswt->setActiveSwitchSet(1);
				}
				crData *myMetierData = mainRole->getMetierDataClass();
				myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
				myMetierData->getParam(WCHDATA_GameTaskMap,param);
				GameTaskMap *gameTaskMap = (GameTaskMap *)param;
				if(!gameTaskMap||gameTaskMap->empty())
				{
					myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
					return;
				}
				ref_ptr<crTableIO> taskTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTab);
				int paramid = taskTab->getTitleIndex("参数1");
				ref_ptr<crTableIO>taskTitleTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
				crTableIO::StrVec record;
				int titleid = taskTitleTab->getTitleIndex("主题");
				int taskid = taskTitleTab->getTitleIndex("taskid");
				int title2id = taskTitleTab->getTitleIndex("主题简");
				std::string file,ext;
				unsigned char steptype;
				unsigned char i = 0;
				char tmpText[64];
				crGameTask* gameTask;
				std::string strtaskname;
				bool newhandShow = false;
				bool isNewHand = false;
				bool iscomplete = false;

				/*crData *playdata = playerGameData->getDataClass();
				playdata->getParam(WCHDATA_JXJTreasonBufferTimer,param);
				int buffertime = *(int *)param; */

				for( GameTaskMap::iterator itr = gameTaskMap->begin();
					i<crGlobalHandle::gData()->gMaxDisplayTaskTrace() && itr != gameTaskMap->end();
					++itr )
				{
					/*if(taskTitleTab->queryOneRecord(taskid,crArgumentParser::appItoa(itr->second->getTaskID()),record)>=0)
						if(record[titleid] == "日常任务" && buffertime >0)
							continue;*/

					gameTask = itr->second.get();
					file = gameTask->getHyperText();
					if(itr->second->getActivation() && !itr->second->isComplete())
					{
						if(!file.empty() && taskTitleTab->queryOneRecord(taskid,crArgumentParser::appItoa(gameTask->getTaskID()),record)>=0)
						{
							//ref_ptr<crCanvasNode> zhezhaoCanvas = crFilterRenderManager::getInstance()->findCanvas(m_zhezhaoCanvas);
							//ref_ptr<crCanvasNode> renWuCanvas = crFilterRenderManager::getInstance()->findCanvas(m_renWuCanvas);
							if(record[titleid] == "新手任务")
							{//显示新手引导箭头
								if(newhandShow) continue;
								crData *data = playerGameData->getDataClass();
								/////////////////////////////////////////
								int usenewguide = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJUseNewGuide,0).c_str());
								if (usenewguide == 0)
								{
									data->getParam(WCHDATA_JXJSkipNewHand,param);
									bool *skipnewhand = (bool *)param;
									if (*skipnewhand)
									{
										crFilterRenderManager::getInstance()->closeCanvas(m_zhezhaoCanvas);
									}
									else
									{
										if (newhandarrow && Arrows == 1)
										{
											newhandarrow->setActiveSwitchSet(1);
											crFilterRenderManager::getInstance()->showCanvas(m_zhezhaoCanvas,true);
											crFilterRenderManager::getInstance()->doModal(m_renWuCanvas);
											//crFilterRenderManager::getInstance()->showCanvas(renWuCanvas,true);
										}
										else
										{
											crFilterRenderManager::getInstance()->closeCanvas(m_zhezhaoCanvas);
											crFilterRenderManager::getInstance()->showCanvas(m_renWuCanvas,true);
										}
									}
								}
								///////////////////////////////////////////
								newhandShow = true;
								isNewHand = true;
								//if(!m_newhandCanvas.valid())
								//{
								//	m_newhandCanvas = crFilterRenderManager::getInstance()->findCanvas(m_newhandName);
								//}
								//if(m_newhandCanvas.valid() && !m_newhandCanvas->getVisiable())
								//{
								//	crFilterRenderManager::getInstance()->showCanvas(m_newhandCanvas.get(),true);
								//}
							}
							else if(isNewHand)
							{
								break;
							}
							if(record[titleid] == "奇遇任务")
								continue;
							steptype = itr->second->getTaskStepType();
							ItemMap itemMap;
							int index = 1;
							rcfg::ConfigScript cfg_script(&itemMap);
							cfg_script.Add("Hypertext");
							cfg_script.Push("Hypertext");

							cfg_script.Add("Content");
							cfg_script.Push("Content",index);index++;
							std::vector<float>v_i;
							v_i.push_back(255.0f);
							v_i.push_back(180.0f);
							v_i.push_back(80.0f);
							v_i.push_back(255.0f);
							cfg_script.Add("Color",v_i);
							cfg_script.Add("Text",record[title2id]);
							cfg_script.Pop();

							cfg_script.Add("Content");
							cfg_script.Push("Content",index);index++;
							std::vector<float>v_i2;
							v_i2.push_back(255.0f);
							v_i2.push_back(255.0f);
							v_i2.push_back(255.0f);
							v_i2.push_back(255.0f);
							cfg_script.Add("Color",v_i2);
							
							strtaskname = gameTask->getTaskName();
							if(gameTask->isTaskCanRefer())
							//if(gameTask->isComplete())
							{
								strtaskname += "(已完成)";
							}
							//else if(steptype >= TS_One && gameTask->getTaskSteps() == gameTask->getTaskProgress())
							//{
							//	strtaskname += "(已完成)";
							//}
							else/* if(gameTask->getActivation())*/
							{
								strtaskname += "(进行中)";
							}
							cfg_script.Add("Text",strtaskname+"\n"); 
							cfg_script.Pop();

							cfg_script.Pop();
							traceWidget->setHypertext(cfg_script,true);

							file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
							ext = crArgumentParser::getFileExtension(file);
							//steptype = itr->second->getTaskStepType();
							if(steptype == TS_Zero)
							{
								int progress = gameTask->getTaskProgress();
								if(progress >= 2) progress = 1;
								file = crArgumentParser::getFileNameEliminateExt(file)+crArgumentParser::appItoa(progress)+"."+ext;
								traceWidget->setHypertext(file,true);
								if (record[titleid] == "日常任务" || record[titleid] == "特殊任务")
								{
									void *param;
									int prog = 0;
									int full = 0;
									if (record[titleid] == "日常任务")
									{
										if(taskTab->queryOneRecord(0,crArgumentParser::appItoa(gameTask->getTaskID()),record)>=0)
										{
											/*ItemMap itemMap;
											int oneIndex = 1;
											rcfg::ConfigScript cfg_script(&itemMap);
											cfg_script.Add("Hypertext");
											cfg_script.Push("Hypertext",oneIndex++);
											cfg_script.Add("Content");
											cfg_script.Push("Content");
											std::vector<float>v_i;
											v_i.push_back(255.0f);
											v_i.push_back(255.0f);
											v_i.push_back(0.0f);
											v_i.push_back(255.0f);
											cfg_script.Add("Color",v_i);
											cfg_script.Add("Text",record[paramid]);
											cfg_script.Pop();

											cfg_script.Pop();
											traceWidget->setHypertext(cfg_script,true);*/

											full = atoi(record[paramid].c_str());
										}
										//std::wstring outstr;
										//ref_ptr<crHypertextWidgetNode> node = new crHypertextWidgetNode();
										//node ->setHypertext(file);
										//node->getString(1,outstr);
										////std::string zhongfen(outstr.length()-6,' ');
										////std::copy(outstr.begin()+6,outstr.end(),zhongfen.begin());
										//std::string zongfen(outstr.begin()+6,outstr.end());

										crData *data = playerGameData->getDataClass();
										data->getParam(WCHDATA_JXJGuoZhanJiFen,param);
										prog = *(int*)param;
										//full = atoi(record[paramid].c_str());//atoi(zongfen.c_str());

									} 
									else
									{
										/*ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_Country1");
										if (canvas.valid())
										{
											crData *canvasdata = canvas->getDataClass();
											canvasdata->getParam(WCHDATA_JXJZhanLingCityCountCanvas,param);
											prog = *(unsigned char *)param;
											full = 5;
										}*/
										prog = gameTask->getTaskProgress();
										full = gameTask->getTaskSteps() - 1;
									}
									ItemMap itemMap;
									int oneIndex = 1;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext",oneIndex++);
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									std::vector<float>v_i;
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"(%d/%d)\0",(int)prog,(int)full);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",oneIndex++);
									cfg_script.Add("DrawMode","TEXT");
									cfg_script.Add("Text",std::string(" /n"));
									cfg_script.Pop();

									cfg_script.Pop();
									traceWidget->setHypertext(cfg_script,true);
								}
							}
							else if(steptype == TS_Zero && gameTask->isTaskCanRefer())
							{
								file = crArgumentParser::getFileNameEliminateExt(file)+"1."+ext;
								traceWidget->setHypertext(file,true);
							}
							else
							{
								std::string relfile;
								int progress = gameTask->getTaskProgress();
								_crInt16 A,B;
								A = LOINT32(progress);
								B = HIINT32(progress);
								_crInt16 C,D;
								//int step = gameTask->getTaskSteps();
								int step = gameTask->getTaskSteps()-1;
								C = LOINT32(step);
								D = HIINT32(step);
								_crInt8 a,c;
								if(steptype >= TS_One && gameTask->isTaskCanRefer())
								{
									file = crArgumentParser::getFileNameEliminateExt(file)+"1."+ext;
									traceWidget->setHypertext(file,true);

									a = LOINT16(A);
									c = LOINT16(C);
									ItemMap itemMap;
									int oneIndex = 1;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext",oneIndex++);
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									std::vector<float>v_i;
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",oneIndex++);
									cfg_script.Add("DrawMode","TEXT");
									cfg_script.Add("Text",std::string(" /n"));
									cfg_script.Pop();

									cfg_script.Pop();
									traceWidget->setHypertext(cfg_script,true);
								}
								else if(steptype >= TS_One)
								{
									relfile = crArgumentParser::getFileNameEliminateExt(file)+"One."+ext;
									traceWidget->setHypertext(relfile,true);

									a = LOINT16(A);
									c = LOINT16(C);
									ItemMap itemMap;
									int indexOne = 1;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext",indexOne++);
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									std::vector<float>v_i;
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",indexOne++);
									cfg_script.Add("DrawMode","TEXT");
									cfg_script.Add("Text",std::string(" /n"));
									cfg_script.Pop();

									cfg_script.Pop();
									traceWidget->setHypertext(cfg_script,true);
								}
								if(steptype >= TS_Two)
								{
									relfile = crArgumentParser::getFileNameEliminateExt(file)+"Two."+ext;
									traceWidget->setHypertext(relfile,true);

									a = HIINT16(A);
									c = HIINT16(C);
									ItemMap itemMap;
									int indexTwo = 1;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext",indexTwo++);
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									std::vector<float>v_i;
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",indexTwo++);
									cfg_script.Add("DrawMode","TEXT");
									cfg_script.Add("Text",std::string(" /n"));
									cfg_script.Pop();

									cfg_script.Pop();
									traceWidget->setHypertext(cfg_script,true);
								}
								if(steptype >= TS_Three)
								{
									relfile = crArgumentParser::getFileNameEliminateExt(file)+"Three."+ext;
									traceWidget->setHypertext(relfile,true);

									a = LOINT16(B);
									c = LOINT16(D);
									ItemMap itemMap;
									int indexThree = 1;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext",indexThree++);
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									std::vector<float>v_i;
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",indexThree++);
									cfg_script.Add("DrawMode","TEXT");
									cfg_script.Add("Text",std::string(" /n"));
									cfg_script.Pop();

									cfg_script.Pop();
									traceWidget->setHypertext(cfg_script,true);
								}
								if(steptype >= TS_Four)
								{
									relfile = crArgumentParser::getFileNameEliminateExt(file)+"Four."+ext;
									traceWidget->setHypertext(relfile,true);

									a = HIINT16(B);
									c = HIINT16(D);
									ItemMap itemMap;
									int indexFour = 1;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext",indexFour++);
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									std::vector<float>v_i;
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									v_i.push_back(0.0f);
									v_i.push_back(255.0f);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",indexFour++);
									cfg_script.Add("DrawMode","TEXT");
									cfg_script.Add("Text",std::string(" /n"));
									cfg_script.Pop();

									cfg_script.Pop();
									traceWidget->setHypertext(cfg_script,true);
								}
							}
							//if(gameTask->isTaskCanRefer())
							//{
							//	file = crArgumentParser::getFileNameEliminateExt(file)+"1."+ext;
							//	traceWidget->setHypertext(file,true);
							//}
							i++;
						}
					}
					else if(!file.empty() && taskTitleTab->queryOneRecord(taskid,crArgumentParser::appItoa(gameTask->getTaskID()),record) >= 0)
					{
						if (record[titleid] == "主线任务")
						{
							crData *mainRoleData = mainRole->getDataClass();
							mainRoleData->getParam(WCHDATA_Level,param);
							unsigned char mylv = *(unsigned char *)param;
							ref_ptr<crTableIO>taskTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTab);
							crTableIO::StrVec recordz,recordn,recordt;
							int lvindex = taskTab->getTitleIndex("Level");
							//int taskidindex = taskTab->getTitleIndex("id");
							if(taskTab->queryOneRecord(0,crArgumentParser::appItoa(gameTask->getTaskID()),recordz) >= 0)
							{
								std::vector<int> lvidVec;
								crArgumentParser::appAtoVec(recordz[lvindex],lvidVec);
								if (lvidVec.size() > 0)
								{
									int lv = lvidVec[0];
									//bool iscomplete = false;
									if (lv == mylv && itr->second->isComplete())
									{
										iscomplete = true;
										continue;
									}
									else if (lv == mylv + 1 && iscomplete && !itr->second->isComplete())
									{
										ItemMap itemMap;
										int index = 1;
										rcfg::ConfigScript cfg_script(&itemMap);
										cfg_script.Add("Hypertext");
										cfg_script.Push("Hypertext");

										cfg_script.Add("Content");
										cfg_script.Push("Content",index);index++;
										std::vector<float>v_i;
										v_i.push_back(255.0f);
										v_i.push_back(180.0f);
										v_i.push_back(80.0f);
										v_i.push_back(255.0f);
										cfg_script.Add("Color",v_i);
										cfg_script.Add("Text",record[title2id]);
										cfg_script.Pop();

										cfg_script.Add("Content");
										cfg_script.Push("Content",index);index++;
										std::vector<float>v_i2;
										v_i2.push_back(255.0f);
										v_i2.push_back(255.0f);
										v_i2.push_back(255.0f);
										v_i2.push_back(255.0f);
										cfg_script.Add("Color",v_i2);

										strtaskname = gameTask->getTaskName();
										cfg_script.Add("Text",strtaskname); 
										cfg_script.Pop();

										cfg_script.Add("Content");
										cfg_script.Push("Content",index);index++;
										std::vector<float>v_i3;
										v_i3.push_back(255.0f);
										v_i3.push_back(0.0f);
										v_i3.push_back(0.0f);
										v_i3.push_back(255.0f);
										cfg_script.Add("Color",v_i3);
										sprintf(tmpText,"(%d级可接)\0",lv);
										cfg_script.Add("Text",tmpText);
										cfg_script.Pop();

										cfg_script.Add("Content");
										cfg_script.Push("Content",index++);
										cfg_script.Add("DrawMode","TEXT");
										cfg_script.Add("Text",std::string(" /n"));
										cfg_script.Pop();

										cfg_script.Pop();
										traceWidget->setHypertext(cfg_script,true);

										//file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
										//ext = crArgumentParser::getFileExtension(file);

										//int progress = gameTask->getTaskProgress();
										//file = crArgumentParser::getFileNameEliminateExt(file)+crArgumentParser::appItoa(progress)+"."+ext;
										//traceWidget->setHypertext(file,true);
										i++;
										iscomplete = false;
									}
								}
							}
						}
					}
				}
				//ref_ptr<crScrollBarWidgetNode> Vscrollbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbar));
				//crData *braindata = crBrain::getInstance()->getDataClass();
				//if (braindata && Vscrollbar.valid())
				//{
				//	braindata->getParam(WCHDATA_JXJNewHandTaskScrollBar,param);
				//	float taskScrollBar = *(float *)param;
				//	Vscrollbar->setValue(taskScrollBar);
				//}
				myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
		//traceWidget->getVScrollBar()->outerSetValue(scrollvaue);
	}
}
/////////////////////////////////////////
//
//crJXJUseBagItemMethod
//
/////////////////////////////////////////
crJXJUseBagItemMethod::crJXJUseBagItemMethod():m_isusing(false){}
crJXJUseBagItemMethod::crJXJUseBagItemMethod(const crJXJUseBagItemMethod& handle):
	crMethod(handle),
	m_isusing(handle.m_isusing)
{
}
void crJXJUseBagItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_itemid = LOINT64(param64);
			m_selectindex = HIINT64(param64);
		}
		else
		{
			m_itemid = 0;
			m_selectindex = 0;
		}
		break;
	}
}

void crJXJUseBagItemMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_isusing = (bool)(atoi(str.c_str()));
		break;
	default:
		break;
	}
}

void crJXJUseBagItemMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor && m_itemid > 0)
	{
		crDataObject *dataObject = NULL;
		void *param;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		
		data->getParam(WCHDATA_JXJItemObjectMap,param);
		ItemObjectMap *itemObjectMap = (ItemObjectMap *)param;
		ItemObjectMap::iterator itr = itemObjectMap->find(m_itemid);
		ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if(itr == itemObjectMap->end() && itemTab.valid())
		{
			crTableIO::StrVec record;
			int scriptid = itemTab->getTitleIndex("脚本");
			if(itemTab->queryOneRecord(0,crArgumentParser::appItoa(m_itemid),record)>=0)
			{
				std::string script = record[scriptid];
				if(!script.empty())
				{
					crData *itemdata = CREncapsulation::loadData(crGlobalHandle::getInstance()->getScriptDir()+script);
					if(itemdata)
					{
						dataObject = new crDataObject;
						dataObject->setDataClass(itemdata);
						(*itemObjectMap)[m_itemid] = dataObject;
					}
				}
			}
		}
		else
		{
			dataObject = itr->second.get();
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		if(dataObject)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(6);
			stream->_writeInt(m_itemid);
			stream->_writeUChar(m_selectindex);
			stream->_writeBool(m_isusing);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUseBagItem,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUseBagItemMethod
//
/////////////////////////////////////////
crJXJRecvUseBagItemMethod::crJXJRecvUseBagItemMethod():
	m_netType(GameClient_Game){}
crJXJRecvUseBagItemMethod::crJXJRecvUseBagItemMethod(const crJXJRecvUseBagItemMethod& handle):
	crMethod(handle),
	m_bagcanvas(handle.m_bagcanvas),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvUseBagItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvUseBagItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_bagcanvas = str;
		break;
	case 1:
		m_tipcanvas = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvUseBagItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				char success = 0;
				void *param;
				bool hasitem = false;
				int itemid = m_stream->_readInt();
				unsigned char selectid = m_stream->_readUChar();
				bool isusing = m_stream->_readBool();
				ref_ptr<crDataObject> dataObject;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				//检查我背包里是否有这个itemid
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itemBagVec = (JXJItemBagVec *)param;
				if (selectid < itemBagVec->size())
				{
					if((*itemBagVec)[selectid].valid())
					{
						if((*itemBagVec)[selectid]->getItemID() == itemid)
						{
							hasitem = true;
						}
					}
				}
				ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				if (hasitem && itemTab.valid())
				{
					data->getParam(WCHDATA_JXJItemObjectMap,param);
					ItemObjectMap *itemObjectMap = (ItemObjectMap *)param;
					ItemObjectMap::iterator itr = itemObjectMap->find(itemid);
					if(itr == itemObjectMap->end())
					{
						crTableIO::StrVec record;
						int scriptid = itemTab->getTitleIndex("脚本");
						if(itemTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record)>=0)
						{
							std::string script = record[scriptid];
							if(!script.empty())
							{
								crData *itemdata = CREncapsulation::loadData(crGlobalHandle::getInstance()->getScriptDir()+script);
								if(itemdata)
								{
									dataObject = new crDataObject;
									dataObject->setDataClass(itemdata);
									(*itemObjectMap)[itemid] = dataObject;
								}
							}
						}
					}
					else
					{
						dataObject = itr->second.get();
					}
					if(dataObject.valid())
					{
						int costtype = 0;
						int costnum = 0;
						bool isneedexpend = false;
						ref_ptr<crTableIO> TreasureCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTreasureCostTab);
						if (TreasureCostTab.valid())
						{
							int idIdx = TreasureCostTab->getTitleIndex("id");
							int costtypeIdx = TreasureCostTab->getTitleIndex("消耗类型");
							int costnumIdx = TreasureCostTab->getTitleIndex("消耗数量"); 
							if (idIdx >=0 && costnumIdx >=0 && costtypeIdx >= 0)
							{
								crTableIO::StrVec record;
								if (TreasureCostTab->queryOneRecord(idIdx,crArgumentParser::appItoa(itemid),record) >= 0)
								{
									costtype = atoi(record[costtypeIdx].c_str());
									costnum = atoi(record[costnumIdx].c_str());
									if (costtype > 0 && costnum > 0 )
									{
										isneedexpend = true;
									}
								}
							}
						}
						char useResult = 0;//0表示使用失败，1表示使用成功，-1表示道具使用过期
						crVector3i parami(itemid,selectid,(int)(&useResult));
						if (isneedexpend && !isusing)
						{
							useResult = USE_OpenTreasure_Error_Using;
						}
						else
						{
							dataObject->doEvent(MAKEINT64(WCH_JXJUseBagItem,GameServer),MAKEINT64(m_this,&parami));
						}
						if(useResult == 1)
						{//使用成功，扣除背包里的道具
							unsigned char itemcount = 0;
							if (selectid < itemBagVec->size())
							{
								if((*itemBagVec)[selectid].valid())
								{
									if ((*itemBagVec)[selectid]->getItemID() == itemid)
									{
										itemcount = (*itemBagVec)[selectid]->getItemCount();
										if (itemcount > 1)
										{
											itemcount -= 1;
											(*itemBagVec)[selectid]->setItemCount(itemcount);
										}
										else
										{
											itemcount = 0;
											(*itemBagVec)[selectid] = NULL;
										}
									}
								}
							}
							success = 1;
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(7);
							stream->_writeChar(useResult);
							stream->_writeInt(itemid);
							stream->_writeUChar(selectid);
							stream->_writeUChar(itemcount);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseBagItem,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
						else
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(9);
							stream->_writeChar(useResult);
							stream->_writeInt(itemid);
							stream->_writeInt(costnum);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseBagItem,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				///游戏日志
				std::string logdata = "使用物品（success，itemid）：" + crArgumentParser::appVectoa(crVector2i(success,itemid));
				GameLogData gamelog(Log_UseBagItem,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			char usesuccess = m_stream->_readChar();
			int itemid = m_stream->_readInt();
			if(usesuccess == 1)
			{
				unsigned char selectid = m_stream->_readUChar();
				unsigned char itemcount = m_stream->_readUChar();
				crData *data = m_this->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itemBagVec = (JXJItemBagVec *)param;
				if (selectid < itemBagVec->size())
				{
					if((*itemBagVec)[selectid].valid())
					{
						if ((*itemBagVec)[selectid]->getItemID() == itemid)
						{
							if (itemcount > 0)
							{
								(*itemBagVec)[selectid]->setItemCount(itemcount);
							}
							else
							{
								(*itemBagVec)[selectid] = NULL;
							}
						}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));

				ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_bagcanvas);
				if(canvas.valid())
					canvas->doEvent(WCH_UI_UpdateData);

				crData *braindata = crBrain::getInstance()->getDataClass();
				if (braindata)
				{
					braindata->excHandle(MAKEINT64(WCH_LockData,1));
					braindata->getParam(WCHDATA_JXJUseItemRemainCount,param);
					unsigned char* remaincount = (unsigned char *)param;
					if(*remaincount > 0)
					{
						*remaincount = itemcount;
						//m_this->doEvent(MAKEINT64(WCH_JXJUseBagItem,NULL),MAKEINT64(itemid,selectid));
					}
					braindata->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
			else
			{//提示道具使用失败
				int costnum = m_stream->_readInt();
				crData *braindata = crBrain::getInstance()->getDataClass();
				if (braindata)
				{
					braindata->inputParam(WCHDATA_JXJUseItemRemainCount,NULL);
				}
				std::string tipstr;
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				crTableIO::StrVec record;
				if(itemtab.valid() && itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record)>=0)
				{
					std::string output;
					//////////////////////提示信息
					crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
					int texid = 1026;
					switch (usesuccess)
					{
					case USE_JunlingCard_Error:
						texid = 4019;
						break;
					case USE_AddFreeRollCardCount_Error:
						texid = 4020;
						break;
					case USE_AddFreeRefineEquipCount_Error:
						texid = 4021;
						break;
					case USE_UseProduceCard_Error:
						texid = 2102;
						break;
					case USE_OpenTreasure_Error:
						texid = 2103;
						break;
					case USE_JianZhuLingError:
						texid = 6000;
						break;
					case USE_QieYeFu_Error:
						texid = 5033;
						break;
					case USE_OpenTreasure_goldnotenough_Error:
						texid = 5035;
						break;
					case USE_OpenTreasure_Error_Using:
						texid = 5036;
						break;
					case USE_OpenTreasure_Error_cding:
						texid = 5037;
						break;
					case USE_OpenTreasure_notingroup_Error:
						texid = 9192;
						break;
					case USE_Date_Error:
						texid = 1106;
						break;
					case USE_RefineStoneError:
						{
							ref_ptr<crCanvasNode>workshopCanvas = crFilterRenderManager::getInstance()->findCanvas("UI_Gongfang");
							if (workshopCanvas.valid()&&workshopCanvas->getDataClass())
							{
								ref_ptr<crData> canvasdata = workshopCanvas->getDataClass();
								canvasdata->excHandle(MAKEINT64(WCH_LockData,1));
								canvasdata->getParam(WCHDATA_JXJTheWayToEnterWorkshorp,param);
								char *openway = (char *)param;
								*openway = 1;
								canvasdata->excHandle(MAKEINT64(WCH_LockData,0));

								 ////crFilterRenderManager::getInstance()->showCanvas(workshopCanvas.get(),true);
								 //CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
								 //if(scene)
								 //{
									// crInstanceItem *item = scene->findSceneItem(4);
									// if(item)
									//	 item->doEvent(WCH_Touch);
								 //}
								ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_HuoDong");
								if(canvas.valid())
								{
									ref_ptr<crWidgetNode> widget = canvas->getWidget("XiLian");
									if(widget.valid())
									{
										widget->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
									}
								}
								return;
							}
						}
						break;
					case USE_HigherRefineStoneError:
						{
							ref_ptr<crCanvasNode>workshopCanvas = crFilterRenderManager::getInstance()->findCanvas("UI_Gongfang");
							if (workshopCanvas.valid()&&workshopCanvas->getDataClass())
							{
								ref_ptr<crData> canvasdata = workshopCanvas->getDataClass();
								canvasdata->excHandle(MAKEINT64(WCH_LockData,1));
								canvasdata->getParam(WCHDATA_JXJTheWayToEnterWorkshorp,param);
								char *openway = (char *)param;
								*openway = 2;
								canvasdata->excHandle(MAKEINT64(WCH_LockData,0));

								//crFilterRenderManager::getInstance()->showCanvas(workshopCanvas.get(),true);
								ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_HuoDong");
								if(canvas.valid())
								{
									ref_ptr<crWidgetNode> widget = canvas->getWidget("XiLian");
									if(widget.valid())
									{
										widget->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
									}
								}
								return;
							}
						}
						break;
					default:
						break;
					}

					if ( usesuccess == USE_OpenTreasure_Error_Using)
					{
						ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
						ref_ptr<crCanvasNode>CzanCanvas = crFilterRenderManager::getInstance()->findCanvas("UI_Beta2_Knapsack_Czan");
						if (msgCanvas.valid() && texid > 0 && CzanCanvas.valid())
						{
							ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_tipcontent));

							ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(CzanCanvas->getWidget("UI_Beta2_Knapsack_Czan_Sy"));
							if (btn.valid())
							{
								std::string notice;
								std::string numstr = crArgumentParser::appItoa(costnum);
								crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
								int mode = 2;
								noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
								noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
								noticeHandle->inputParam(WCHDATA_NoticeParam1,&numstr);
								noticeHandle->inputParam(WCHDATA_NoticeParam2,&(record[itemtab->getTitleIndex("name")]));
								noticeHandle->inputParam(WCHDATA_NoticeOutPut,&notice);
								crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);

								ItemMap itemMap;
								rcfg::ConfigScript cfg_script(&itemMap);
								cfg_script.Add("Hypertext");
								cfg_script.Push("Hypertext");
								cfg_script.Add("Content");
								cfg_script.Push("Content");
								cfg_script.Add("Text",notice);
								cfg_script.Pop();
								cfg_script.Pop();
								if (msg.valid())
								{
									msg->setHypertext(cfg_script);
								}
								crData *dlgData = msgCanvas->getDataClass();
								int commandtype = CDP_Widget;
								dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
								dlgData->inputParam(WCHDATA_CommandDlgParent,btn.get());
								crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
							}
						}
					}
					else
					{
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 1;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[itemtab->getTitleIndex("name")]));
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
					}
					//tipstr = "道具["+record[itemtab->getTitleIndex("name")]+"]使用失败！";
					//ref_ptr<crCanvasNode> tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
					//if (tipcanvas)
					//{
					//	crStaticTextWidgetNode *tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					//	if (tipcontent)
					//	{
					//		tipcontent->setString(tipstr);
					//	}
					//	crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
					//}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerOpenTreasureChestMethod
//
/////////////////////////////////////////
crJXJServerOpenTreasureChestMethod::crJXJServerOpenTreasureChestMethod():
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL),
	m_chestdroptype(0){}
crJXJServerOpenTreasureChestMethod::crJXJServerOpenTreasureChestMethod(const crJXJServerOpenTreasureChestMethod& handle):
	crMethod(handle),
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL),
	m_chestdroptype(handle.m_chestdroptype)
{
}
void crJXJServerOpenTreasureChestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crDataObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crPlayerGameData*)LOINT64(param64);
			CRCore::crVector3i vparam = *(crVector3i *)HIINT64(param64);
			m_itemid = vparam[0];
			m_selectid = vparam[1];
			m_useResult = (char *)vparam[2];
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crJXJServerOpenTreasureChestMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_chestdroptype = atoi(str.c_str());
	default:
		break;
	}
}

void crJXJServerOpenTreasureChestMethod::operator()(crHandle &handle)
{
	if(m_user && m_itemid > 0)
	{
		int playerid = m_user->getPlayerID();
		crData *userData = m_user->getDataClass();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			void *param;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			ref_ptr<crTableIO>chestDropTab;
			crTableIO::DataVec recordVec;
			if (m_chestdroptype==1)
			{
				chestDropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChestVipDropTab);
				if (chestDropTab.valid())
				{
					userData->getParam(WCHDATA_JXJVipLv,param);
					unsigned char myviplv = *(unsigned char *)param;
					int VipLvid = chestDropTab->getTitleIndex("VipLv");
					crVector2i VipLvVec;
					chestDropTab->queryRecords(0,crArgumentParser::appItoa(m_itemid),recordVec);
					for(crTableIO::DataVec::iterator riter = recordVec.begin(); riter!=recordVec.end();)
					{
						crArgumentParser::appAtoVec((*riter)[VipLvid],VipLvVec);
						if (myviplv >= VipLvVec[0] && myviplv <= VipLvVec[1])
						{
							++riter;
						}
						else
						{
							riter = recordVec.erase(riter);
						}
					}
				}
			}
			else if(m_chestdroptype==2)
			{//势力掉落
				userData->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;

				//chestDropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChestDropTab);
				crTableIO::DataVec recordVecqun;
				chestDropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiLiDropTab);
				int shiliindex = chestDropTab->getTitleIndex("势力");
				if (chestDropTab.valid())
				{
					chestDropTab->queryRecords(0,crArgumentParser::appItoa(m_itemid),shiliindex,crArgumentParser::appItoa(shiliid),recordVec);
					chestDropTab->queryRecords(0,crArgumentParser::appItoa(m_itemid),shiliindex,"2",recordVecqun);
					recordVec.insert(recordVec.end(),recordVecqun.begin(),recordVecqun.end());
				}
			}
			else
			{
				chestDropTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChestDropTab);
				if (chestDropTab.valid())
				{
					chestDropTab->queryRecords(0,crArgumentParser::appItoa(m_itemid),recordVec);
				}
			}
			if(!recordVec.empty())
			{
				int dropcountid = chestDropTab->getTitleIndex("掉落种数");
				int droptypeid = chestDropTab->getTitleIndex("掉落类型");
				int dropidindex = chestDropTab->getTitleIndex("dropid");
				int oddsid = chestDropTab->getTitleIndex("掉落几率");
				int countid = chestDropTab->getTitleIndex("数量");
				int dropcount = atoi(recordVec[0][dropcountid].c_str());
				//检查背包空格数量
				//crData *userData = m_user->getDataClass();
				userData->excHandle(MAKEINT64(WCH_LockData,1));
				userData->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itemBagVec = (JXJItemBagVec *)param;
				userData->getParam(WCHDATA_JXJItemEndUsedTime,param);
				ItemUsedTimeMap *itemusedtimemap = (ItemUsedTimeMap *)param;
				_crInt64 curtime = time(0);
				bool hasspace = false;
				int packetRemainSize = 0;
				for( JXJItemBagVec::iterator itr = itemBagVec->begin();
					itr != itemBagVec->end();
					++itr )
				{
					if(!(itr->valid()))
					{
						packetRemainSize++;
						if(packetRemainSize>=dropcount)
						{
							hasspace = true;
						}
					}
				}
				if(hasspace)
				{
					bool issuc= true;
					ref_ptr<crTableIO> TreasureCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTreasureCostTab);
					if (TreasureCostTab.valid())
					{
						int idIdx = TreasureCostTab->getTitleIndex("id");
						int costtypeIdx = TreasureCostTab->getTitleIndex("消耗类型");
						int costnumIdx = TreasureCostTab->getTitleIndex("消耗数量");
						int cdIdx = TreasureCostTab->getTitleIndex("冷却时间");
						if (idIdx >=0 && costnumIdx >=0 && costtypeIdx >= 0 && cdIdx >=0)
						{
							crTableIO::StrVec record;
							if (TreasureCostTab->queryOneRecord(idIdx,crArgumentParser::appItoa(m_itemid),record) >= 0)
							{
								int costtype = atoi(record[costtypeIdx].c_str());
								int costnum = atoi(record[costnumIdx].c_str());
								int cd = atoi(record[cdIdx].c_str());
								_crInt64 lastusetime = 0;
								ItemUsedTimeMap::iterator ititr = itemusedtimemap->find(m_itemid);
								if (ititr != itemusedtimemap->end())
								{
									lastusetime = ititr->second;
								}
								if (cd + lastusetime < curtime)
								{
									switch (costtype)
									{
									case T_Giftgold:
										{
											userData->getParam(WCHDATA_JXJGoldingot,param);
											int goldingot = *(int *)param;
											if (goldingot >= costnum)
											{
												bool needdeductgold = false;
												MoneyChangeData moneydata(-costnum,"开启新兵礼包");
												m_user->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&moneydata,&needdeductgold));
												if (needdeductgold)
												{
													issuc = true;
												}
												else
												{
													issuc = false;
													*m_useResult = USE_OpenTreasure_goldnotenough_Error;

												}
											}
											else
											{
												issuc = false;
												*m_useResult = USE_OpenTreasure_goldnotenough_Error;

											}
										}
										break;
									case T_GroupContribute:
										{
											userData-> getParam(WCHDATA_JXJConsortiaID,param);
											int mygroupid = *( int *)param;
											if(mygroupid == 0)
											{
												issuc = false;
												*m_useResult = USE_OpenTreasure_notingroup_Error;
											}
										}
										break;
									default:
										break;
									}
								}
								else
								{
									issuc = false;
									*m_useResult = USE_OpenTreasure_Error_cding;
								}
							}
						}
					}

					if (issuc)
					{
						int odds = 0;
						//bool isdroped;
						unsigned char droptype;
						int count;
						crVector2i countrange;
						CRCore::rangei counrnd;
						RewardItemVec rewarditemvec;
						ref_ptr<crBagItemData> itemdata;
						std::vector<std::pair<int,int> > DropedResVec;//resid,count
						std::vector<std::pair<unsigned short,int> > DropedEquipVec;//equipid,count
						////std::vector<crVector3i> DropedItemVec;//itemid,magicid,count
						//crVector2i vec2;
						crRole *mainRole = m_user->getMainRole();
						//for( int i = 0; i<recordVec.size(); i++)
						//{
						//	if(dropcount <= 0)
						//		break;
						//	odds = atoi(recordVec[i][oddsid].c_str());
						//	isdroped = crGameDices::getInstance()->dice(1,100)<=odds;
						//	if(isdroped)
						//	{
						//		dropcount--;
						int recordCount = recordVec.size();
						std::vector< std::pair<int,int> >DroprndVec;
						int i,j,k;
						int dropodds;
						for (i = 0; i < recordCount; i++)
						{
							dropodds = atoi(recordVec[i][oddsid].c_str());
							odds += dropodds;
							DroprndVec.push_back(std::make_pair(odds,dropodds));
						}
						crVector2i vec2;
						rangei rndi(0,odds);
						int r;
						for(i = 0; i<dropcount;i++)
						{
							r = rndi.get_random();
							for(j = 0; j<recordCount; j++)
							{
								if(r<=DroprndVec[j].first)
								{//该物品掉出
									DroprndVec[j].first = -1;
									odds -= DroprndVec[j].second;
									rndi.set(0,odds);
									for (k = j+1; k < recordCount; k++)
									{
										DroprndVec[k].first -= DroprndVec[j].second;
									}
									droptype = atoi(recordVec[j][droptypeid].c_str());

									crArgumentParser::appAtoVec(recordVec[j][countid],countrange);
									counrnd.set(countrange[0],countrange[1]);
									count = counrnd.get_random();
									if(count>0)
									{
										droptype = atoi(recordVec[j][droptypeid].c_str());
										switch (droptype)
										{
										case T_Food:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJFood,count));
											break;
										case T_Wood:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJWood,count));
											break;
										case T_Iron:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJIron,count));
											break;
										case T_Horse:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJHorse,count));
											break;
										case T_Copper:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJCoppercash,count));
											break;
										case T_Exp:
											if(mainRole)
											{
												mainRole->doEvent(WCH_JXJRecvExperience,MAKEINT64(count,NULL));
											}
											break;
										case T_Achievement:
											if(mainRole)
											{
												mainRole->doEvent(WCH_JXJRecvAchievement,MAKEINT64(count,NULL));
											}
											break;
										case T_Giftgold:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJGiftGold,count));
											break;
										case T_TroopsEquip:
											DropedEquipVec.push_back(std::make_pair(atoi(recordVec[j][dropidindex].c_str()),count));
											break;
										case T_Item:
											{
												crArgumentParser::appAtoVec(recordVec[j][dropidindex],vec2);
												itemdata = new crBagItemData;
												itemdata->setItemID(vec2[0]);
												itemdata->setEquipMagic(vec2[1]);
												itemdata->setItemCount(count);
												rewarditemvec.push_back(itemdata);

												if (itemusedtimemap->find(vec2[0]) != itemusedtimemap->end())
												{
													(*itemusedtimemap)[vec2[0]] = curtime;
												}
												else
												{
													itemusedtimemap->insert(std::make_pair(vec2[0],curtime));
												}
											}
											//DropedItemVec.push_back(std::make_pair(atoi(recordVec[i][dropidindex].c_str()),count));
											break;
										case T_Contribute:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJCountryContribute,count));
											break;
										case T_JiangHun:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJCardPieces,count));
											break;
										case T_Exploit:
											if(mainRole)
											{
												mainRole->doEvent(WCH_JXJRecvExploit,MAKEINT64(count,NULL));
											}
											break;
										case T_Zhanquan:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJZhengZhanQuan,count));
											break;
										case T_GroupContribute:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJConsortiaMemberMap,count));
											break;
										case T_AchievePoint:
											DropedResVec.push_back(std::make_pair(WCHDATA_JXJAchievePointsCount,count));
											break;
										}
									}
									break;
								}
							}
						}
						if(!DropedResVec.empty())
						{
							std::string str= "开宝箱";
							MoneyChangeData  moneydata;//(itr->second,str);
							for( std::vector<std::pair<int,int> >::iterator itr = DropedResVec.begin();
								itr != DropedResVec.end();
								++itr )
							{
								//userData->getParam(itr->first,param);
								//resparam = (int *)param;
								//*resparam += itr->second;
								switch (itr->first)
								{
								case WCHDATA_JXJCoppercash:
									m_user->doEvent(WCH_JXJRecvCoppercash,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJFood:
									m_user->doEvent(WCH_JXJRecvFood,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJWood:
									m_user->doEvent(WCH_JXJRecvWood,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJIron:
									m_user->doEvent(WCH_JXJRecvIron,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJHorse:
									m_user->doEvent(WCH_JXJRecvHorse,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJGiftGold:
									moneydata.first = itr->second;
									moneydata.second = str;
									m_user->doEvent(WCH_JXJRecvGiftgold,MAKEINT64(&moneydata,NULL));
									break;
								case WCHDATA_JXJCountryContribute:
									m_user->doEvent(WCH_JXJRecvCountryContribute,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJCardPieces:
									m_user->doEvent(WCH_JXJRecvCardPieces,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJZhengZhanQuan:
									m_user->doEvent(WCH_JXJRecvZhengZanQuan,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJConsortiaMemberMap:
									m_user->doEvent(WCH_JXJRecvGroupContribution,MAKEINT64(itr->second,NULL));
									break;
								case WCHDATA_JXJAchievePointsCount:
									m_user->doEvent(WCH_JXJRecvAchievePoint,MAKEINT64(itr->second,NULL));
									break;
								default:
									break;
								}
							}
						}
						if(!DropedEquipVec.empty())
						{
							userData->getParam(WCHDATA_JXJTroopsEquipMap,param);
							TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
							TroopsEquipMap::iterator troopsItr;
							for( std::vector<std::pair<unsigned short,int> >::iterator itr = DropedEquipVec.begin();
								itr != DropedEquipVec.end();
								++itr )
							{
								troopsItr = troopsEquipMap->find(itr->first);
								if(troopsItr != troopsEquipMap->end())
								{
									troopsItr->second += itr->second;
								}
								else
								{
									(*troopsEquipMap)[itr->first] = itr->second;
								}
							}
						}
						m_user->doEvent(WCH_JXJRecvRewardItems,MAKEINT64(&rewarditemvec,GP_RewardItem));
						*m_useResult = 1;
					}
					//else
					//{
					//	*m_useResult = USE_OpenTreasure_goldnotenough_Error;
					//}
					/////
					////////////发送给客户端
					//int ressize = DropedResVec.size();
					//int equipsize = DropedEquipVec.size();
					//int itemsize = rewarditemvec.size();
					//stream->createBuf(3+ressize*8+itemsize*7+equipsize*6);
					////stream->_writeBool(true);
					////stream->_writeInt(m_itemid);
					////stream->_writeInt(m_selectid);
					//stream->_writeUChar(ressize);
					//for( std::vector<std::pair<int,int> >::iterator itr = DropedResVec.begin();
					//	itr != DropedResVec.end();
					//	++itr )
					//{
					//	stream->_writeInt(itr->first);
					//	stream->_writeInt(itr->second);
					//}
					//stream->_writeUChar(equipsize);
					//for( std::vector<std::pair<unsigned short,int> >::iterator itr = DropedEquipVec.begin();
					//	itr != DropedEquipVec.end();
					//	++itr )
					//{
					//	stream->_writeUShort(itr->first);
					//	stream->_writeInt(itr->second);
					//}
					//stream->_writeUChar(itemsize);
					//for( RewardItemVec::iterator itr = rewarditemvec.begin();
					//	itr != rewarditemvec.end();
					//	++itr )
					//{
					//	stream->_writeInt((*itr)->getItemID());
					//	stream->_writeUShort((*itr)->getEquipMagic());
					//	stream->_writeUChar((*itr)->getItemCount());
					//}
					//crPlayerDataEventPacket packet;
					//crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvOpenTreasureChest,stream.get());
					//gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				else
				{//返回失败

					*m_useResult = USE_OpenTreasure_Error;
					stream->createBuf(1);
					stream->_writeBool(false);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvOpenTreasureChest,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				userData->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvOpenTreasureChestMethod
//
/////////////////////////////////////////
crJXJRecvOpenTreasureChestMethod::crJXJRecvOpenTreasureChestMethod():
	m_netType(GameClient_Game){}
crJXJRecvOpenTreasureChestMethod::crJXJRecvOpenTreasureChestMethod(const crJXJRecvOpenTreasureChestMethod& handle):
	crMethod(handle)/*,
					m_tipcanvas(handle.m_tipcanvas),
					m_tipcontent(handle.m_tipcontent)*/
{
}
void crJXJRecvOpenTreasureChestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvOpenTreasureChestMethod::addParam(int i, const std::string& str)
{
	//switch (i)
	//{
	//case 0:
	//	m_tipcanvas = str;
	//	break;
	//case 1:
	//	m_tipcontent = str;
	//	break;
	//default:
	//	break;
	//}
}
void crJXJRecvOpenTreasureChestMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			std::string tipstr;
			bool sucess  = m_stream->_readBool();
			if(!sucess)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2008,NULL));
			}
		}
	}
}
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameClient_Game)
//		{
//			std::string tipstr;
//			bool sucess  = m_stream->_readBool();
//			if(sucess)
//			{
//				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
//				crTableIO::StrVec record;
//				tipstr = "恭喜您获得: ";
//				void *param;
//				crData *userData = m_this->getDataClass();
//				userData->excHandle(MAKEINT64(WCH_LockData,1));
//				//////删除宝箱
//				userData->getParam(WCHDATA_JXJItemBagVec,param);
//				JXJItemBagVec *itemBagVec = (JXJItemBagVec *)param;
//				//int useitemid = m_stream->_readInt();
//				//int useselectid = m_stream->_readInt();
//				//if (useselectid < itemBagVec->size())
//				//{
//				//	if((*itemBagVec)[useselectid].valid())
//				//	{
//				//		if ((*itemBagVec)[useselectid]->getItemID() == useitemid)
//				//		{
//				//			int itemcount = (*itemBagVec)[useselectid]->getItemCount();
//				//			if (itemcount > 1)
//				//			{
//				//				(*itemBagVec)[useselectid]->setItemCount(itemcount - 1);
//				//			}
//				//			else
//				//			{
//				//				(*itemBagVec)[useselectid] = NULL;
//				//			}
//				//		}
//				//	}
//				//}
//				///////////////////////
//				int id,count;
//				unsigned short equipid;
//				int size = m_stream->_readUChar();
//				if(size>0)
//				{
//					int *resparam;
//					for( int i = 0; i< size; i++)
//					{
//						id = m_stream->_readInt();
//						count = m_stream->_readInt();
//						userData->getParam(id,param);
//						resparam = (int *)param;
//						*resparam += count;
//						tipstr = tipstr + crArgumentParser::appItoa(count);
//						switch (id)
//						{
//						case WCHDATA_JXJFood:
//							tipstr = tipstr + std::string("粮食 ");
//							break;
//						case WCHDATA_JXJWood:
//							tipstr = tipstr + std::string("木材 ");
//							break;
//						case WCHDATA_JXJIron:
//							tipstr = tipstr + std::string("铁矿 ");
//							break;
//						case WCHDATA_JXJHorse:
//							tipstr = tipstr + std::string("马匹 ");
//							break;
//						case WCHDATA_JXJCoppercash:
//							tipstr = tipstr + std::string("铜钱 ");
//							break;
//						case WCHDATA_JXJGiftGold:
//							tipstr = tipstr + std::string("礼金 ");
//							break;
//						default:
//							break;
//						}
//					}
//				}
//				size = m_stream->_readUChar();
//				if(size>0)
//				{
//					userData->getParam(WCHDATA_JXJTroopsEquipMap,param);
//					TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
//					TroopsEquipMap::iterator troopsItr;
//					for( int i = 0; i< size; i++)
//					{
//						equipid = m_stream->_readUShort();
//						count = m_stream->_readInt();
//						troopsItr = troopsEquipMap->find(equipid);
//						if(troopsItr != troopsEquipMap->end())
//						{
//							troopsItr->second += count;
//						}
//						else
//						{
//							(*troopsEquipMap)[equipid] = count;
//						}
//						tipstr = tipstr + crArgumentParser::appItoa(count);
//						if (troopsEquipTab)
//						{
//							troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record);
//							tipstr = tipstr + record[troopsEquipTab->getTitleIndex("name")] + " ";
//						}
//					}
//				}
//				size = m_stream->_readUChar();
//				if(size>0)
//				{
//					unsigned short equipmagic;
//					for( int i = 0; i< size; i++)
//					{
//						id = m_stream->_readInt();
//						equipmagic = m_stream->_readUShort();
//						count = m_stream->_readUChar();
//						//for( JXJItemBagVec::iterator bagItr = itemBagVec->begin();
//						//	 bagItr != itemBagVec->end();
//						//	 ++bagItr )
//						//{
//						//	if(!(bagItr->valid()))
//						//	{
//						//		*bagItr = new crBagItemData;
//						//		(*bagItr)->setItemID(id);
//						//		(*bagItr)->setItemCount(count);
//						//		break;
//						//	}
//						//}
//						tipstr = tipstr + crArgumentParser::appItoa(count);
//						if (itemtab)
//						{
//							itemtab->queryOneRecord(0,crArgumentParser::appItoa(id),record);
//							tipstr = tipstr + record[itemtab->getTitleIndex("name")] + " ";
//						}
//					}
//				}
//				userData->excHandle(MAKEINT64(WCH_LockData,0));
//			//}
//			//else
//			//{
//			//	tipstr = "打开宝箱失败！";
//			//	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
//			//	//if(noticeText)
//			//	//{
//			//	//	noticeText->setText(L"不能使用");
//			//	//	noticeText->setVisiable(true);
//			//	//}
//			//	crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1019,NULL));
//			//}
//				////////////////////////提示信息
//			//crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
//			//noticeHandle->inputParam(WCHDATA_NoticeTextID,NULL);
//			//int mode = 1;
//			//noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
//			//noticeHandle->inputParam(WCHDATA_NoticeString,&tipstr);
//			//crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
//			/////////////////////////////
//			//ref_ptr<crCanvasNode> tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//			//if (tipcanvas)
//			//{
//			//	crStaticTextWidgetNode *tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//			//	if (tipcontent)
//			//	{
//			//		tipcontent->setString(tipstr);
//			//	}
//			//	crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//			//}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJServerUseProduceCardMethod
//
/////////////////////////////////////////
crJXJServerUseProduceCardMethod::crJXJServerUseProduceCardMethod():
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL){}
crJXJServerUseProduceCardMethod::crJXJServerUseProduceCardMethod(const crJXJServerUseProduceCardMethod& handle):
	crMethod(handle),
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL)
{
}
void crJXJServerUseProduceCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crDataObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crPlayerGameData*)LOINT64(param64);
			CRCore::crVector3i vparam = *(crVector3i *)HIINT64(param64);
			m_itemid = vparam[0];
			m_selectid = vparam[1];
			m_useResult = (char *)vparam[2];
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crJXJServerUseProduceCardMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerUseProduceCardMethod::operator()(crHandle &handle)
{
	if(m_user && m_itemid > 0)
	{
		int playerid = m_user->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			ref_ptr<crTableIO>produceCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJProduceCardTab);
			crTableIO::StrVec record;
			if(produceCardTab->queryOneRecord(0,crArgumentParser::appItoa(m_itemid),record)>=0)
			{
				int timeid = produceCardTab->getTitleIndex("时间");
				int typeindex = produceCardTab->getTitleIndex("类型");
				//int percentid = produceCardTab->getTitleIndex("百分比");
				unsigned char type = atoi(record[typeindex].c_str());
				//short percent = atoi(record[percentid].c_str());
				int timer = atoi(record[timeid].c_str());
				void *param;
				crData *data = m_user->getDataClass();
				//int maxcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJExtraProduceMaxCount).c_str());
				data->getParam(WCHDATA_JXJVipLv, param);
				unsigned char viplv = *(unsigned char *)param;
				int maxtime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJResAddTimeMax, viplv).c_str()));
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJExtraProduceMap,param);
				ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
				ExtraProduceMap::iterator itr = extraProduceMap->find(type);
				ref_ptr<crExtraProduce> extraProduce;
				if(itr != extraProduceMap->end())
				{
					extraProduce = itr->second;
					if (extraProduce->timer() + timer <= maxtime)
					{
						extraProduce->timer() += timer;
						*m_useResult = 1;
					}
					else
					{//使用失败
						*m_useResult = USE_UseProduceCard_Error;
					}
					//if(percent>extraProduce->getPercent())
					//{
					//	extraProduce->timer() = timer;
					//	extraProduce->setPercent(percent);
					//	*m_useResult = 1;
					//}
					//else if(percent==extraProduce->getPercent())
					//{
					//	if (extraProduce->timer() + timer <= maxtime)
					//	{
					//		extraProduce->timer() += timer;
					//		*m_useResult = 1;
					//	}
					//	else
					//	{//使用失败
					//		*m_useResult = USE_UseProduceCard_Error;
					//	}
					//}
					//else
					//{//使用失败
					//	*m_useResult = USE_UseProduceCard_Error;
					//}
				}
				else
				{
					extraProduce = new crExtraProduce;
					extraProduce->timer() = timer;
					//extraProduce->setPercent(percent);
					(*extraProduceMap)[type] = extraProduce;
					*m_useResult = 1;
				}
				if(*m_useResult == 1)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(5);
					stream->_writeUChar(type);
					stream->_writeInt(extraProduce->timer());
					//stream->_writeShort(extraProduce->getPercent());
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseProduceCard,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUseProduceCardMethod
//
/////////////////////////////////////////
crJXJRecvUseProduceCardMethod::crJXJRecvUseProduceCardMethod():
	m_netType(GameClient_Game){}
crJXJRecvUseProduceCardMethod::crJXJRecvUseProduceCardMethod(const crJXJRecvUseProduceCardMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUseProduceCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvUseProduceCardMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvUseProduceCardMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			unsigned char type = m_stream->_readUChar();
			int timer = m_stream->_readInt();
			//short percent = m_stream->_readShort();

			void *param;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJExtraProduceMap,param);
			ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
			ExtraProduceMap::iterator itr = extraProduceMap->find(type);
			ref_ptr<crExtraProduce> extraProduce;
			if(itr != extraProduceMap->end())
			{
				extraProduce = itr->second;
				extraProduce->timer() = timer;
				//extraProduce->setPercent(percent);
			}
			else
			{
				extraProduce = new crExtraProduce;
				extraProduce->timer() = timer;
				//extraProduce->setPercent(percent);
				(*extraProduceMap)[type] = extraProduce;
			}
			data->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerUseVipCardMethod
//
/////////////////////////////////////////
crJXJServerUseVipCardMethod::crJXJServerUseVipCardMethod():
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL){}
crJXJServerUseVipCardMethod::crJXJServerUseVipCardMethod(const crJXJServerUseVipCardMethod& handle):
	crMethod(handle),
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL)
{
}
void crJXJServerUseVipCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crDataObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crPlayerGameData*)LOINT64(param64);
			CRCore::crVector3i vparam = *(crVector3i *)HIINT64(param64);
			m_itemid = vparam[0];
			m_selectid = vparam[1];
			m_useResult = (char *)(vparam[2]);
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crJXJServerUseVipCardMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerUseVipCardMethod::operator()(crHandle &handle)
{
	if(m_user && m_itemid > 0)
	{
		int playerid = m_user->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			ref_ptr<crTableIO>vipCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJVipCardTab);
			crTableIO::StrVec record;
			if(vipCardTab->queryOneRecord(0,crArgumentParser::appItoa(m_itemid),record)>=0)
			{
				int expid = vipCardTab->getTitleIndex("vipexp");
				int exp = atoi(record[expid].c_str());
				if(exp>0)
					m_user->doEvent(WCH_JXJAddVipExp,MAKEINT64(exp,NULL));
				int moneyid = vipCardTab->getTitleIndex("money");
				int money = atoi(record[moneyid].c_str());
				bool goldsuccess = false;
				if(money>0)
				{
					//领取元宝
					MoneyChangeData moneyChangeData(money,"使用军师卡获得元宝");
					m_user->doEvent(WCH_MoneyChange,MAKEINT64(&moneyChangeData,&goldsuccess));
				}
				///游戏日志
				std::string logdata = "使用军师卡："+crArgumentParser::appItoa(m_itemid)+"获得："+crArgumentParser::appItoa(exp)+"VIP经验，"+crArgumentParser::appItoa(money)+"元宝 ";
				logdata += goldsuccess ? "元宝获得成功" : "元宝获得失败";
				GameLogData gamelog(Log_UseVipCard, logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog, MAKEINT64(playerid, &gamelog));
				*m_useResult = 1;
				//void *param;
				//crData *data = m_user->getDataClass();
				//data->excHandle(MAKEINT64(WCH_LockData,1));
				//data->getParam(WCHDATA_JXJVipLv,param);
				//unsigned char *viplv = (unsigned char *)param;
				//if(*viplv<lv)
				//{
				//	*viplv = lv;
				//	*m_useResult = 1;
				//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//	stream->createBuf(1);
				//	stream->_writeUChar(*viplv);
				//	crPlayerDataEventPacket packet;
				//	crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseVipCard,stream.get());
				//	gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				//}
				//data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvUseVipCardMethod
////
///////////////////////////////////////////
//crJXJRecvUseVipCardMethod::crJXJRecvUseVipCardMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvUseVipCardMethod::crJXJRecvUseVipCardMethod(const crJXJRecvUseVipCardMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvUseVipCardMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			_crInt64 param64 = *(_crInt64*)param;
//			m_stream = (crStreamBuf *)(LOINT64(param64));
//			m_netType = HIINT64(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJRecvUseVipCardMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJRecvUseVipCardMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameClient_Game)
//		{
//			unsigned char viplv = m_stream->_readUChar();
//			crData *userData = m_this->getDataClass();
//			userData->inputParam(WCHDATA_JXJVipLv,&viplv);
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJServerUseResPackMethod
//
/////////////////////////////////////////
crJXJServerUseResPackMethod::crJXJServerUseResPackMethod():
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL){}
crJXJServerUseResPackMethod::crJXJServerUseResPackMethod(const crJXJServerUseResPackMethod& handle):
	crMethod(handle),
	m_selectid(0),
	m_itemid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL)
{
}
void crJXJServerUseResPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crDataObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crPlayerGameData*)LOINT64(param64);
			CRCore::crVector3i vparam = *(crVector3i *)HIINT64(param64);
			m_itemid = vparam[0];
			m_selectid = vparam[1];
			m_useResult = (char *)vparam[2];
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crJXJServerUseResPackMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerUseResPackMethod::operator()(crHandle &handle)
{
	if(m_user && m_itemid > 0)
	{
		int playerid = m_user->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			ref_ptr<crTableIO>resPackTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResPackTab);
			crTableIO::StrVec record;
			if(resPackTab->queryOneRecord(0,crArgumentParser::appItoa(m_itemid),record)>=0)
			{
				int typeindex = resPackTab->getTitleIndex("类型");
				int countid = resPackTab->getTitleIndex("数量");
				int endTimeIdx = resPackTab->getTitleIndex("结束时间");
				if(!record[endTimeIdx].empty())
				{//有使用日期限制
					crVector3i curtm,endtm;
					crArgumentParser::appTimetoVec(record[endTimeIdx],endtm,'|');
					time_t t = time( 0 );
					char tmp[20];
					strftime( tmp, sizeof(tmp), "%Y|%m|%d\0", localtime(&t) );
					crArgumentParser::appTimetoVec(tmp,curtm,'|');
					if(curtm>endtm)
					{//过期
						*m_useResult = -1;
						return;
					}
				}
				void *param;
				crData *data = m_user->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				int resid = 0;
				int count = atoi(record[countid].c_str());
				crVector4i count4;
				switch (atoi(record[typeindex].c_str()))
				{
				case T_Food:
					resid = WCHDATA_JXJFood;
					break;
				case T_Wood:
					resid = WCHDATA_JXJWood;
					break;
				case T_Iron:
					resid = WCHDATA_JXJIron;
					break;
				case T_Horse:
					resid = WCHDATA_JXJHorse;
					break;
				case T_Copper:
					resid = WCHDATA_JXJCoppercash;
					break;
				case T_FWIH:
					resid = -1;
					break;
				}
				if(resid>0)
				{
					data->getParam(resid,param);
					int *res = (int*)param;
					if(count>0)
					{
						//*res += count;
						INTLIMITADD(*res,count,INT_MAX);
					}
					else if(count == -1 && resid!=T_Copper)
					{//爆仓
						//府库上限检查
						data->getParam(WCHDATA_JXJFukulv, param);
						unsigned char fukulv = *(unsigned char *)param;
						ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
						int foodlimitid = fukutab->getTitleIndex("粮食");
						crTableIO::StrVec record;
						if(fukutab->queryOneRecord(0, crArgumentParser::appItoa((int)fukulv), record)>=0)
						{
							float fukulimitaddpercent = 0.0f;
							m_user->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
							float limit = atof(record[foodlimitid+resid-T_Food].c_str()) * (1.0f + fukulimitaddpercent);
							count = limit-*res;
							*res = limit;
						}
					}
				}
				else if(resid == -1)
				{//所有资源,不包括铜钱
					if(count>0)
					{
						int *res;
						for( int i = 0; i<4; i++)
						{
							data->getParam(WCHDATA_JXJFood+i,param);
							res = (int*)param;
							INTLIMITADD(*res,count,INT_MAX);
							count4[i] = count;
						}
					}
					else if(count == -1)
					{//爆仓
						//府库上限检查
						data->getParam(WCHDATA_JXJFukulv, param);
						unsigned char fukulv = *(unsigned char *)param;
						ref_ptr<crTableIO>fukutab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFukuTab);
						int foodlimitid = fukutab->getTitleIndex("粮食");
						crTableIO::StrVec record;
						if(fukutab->queryOneRecord(0, crArgumentParser::appItoa((int)fukulv), record)>=0)
						{
							float fukulimitaddpercent = 0.0f;
							m_user->doEvent(WCH_JXJGetFukuLimitAdd,MAKEINT64(&fukulimitaddpercent,NULL));
							int *res;
							float limit;
							for( int i = 0; i<4; i++)
							{
								data->getParam(WCHDATA_JXJFood+i,param);
								res = (int*)param;
								limit = atof(record[foodlimitid+i].c_str()) * (1.0f + fukulimitaddpercent);
								count4[i] = limit-*res;
								*res = limit;
							}
						}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				if(resid!=0)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(21);
					stream->_writeInt(resid);
					if(resid==-1)
						stream->_writeVec4i(count4);
					else
						stream->_writeInt(count);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseResPack,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					*m_useResult = 1;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUseResPackMethod
//
/////////////////////////////////////////
crJXJRecvUseResPackMethod::crJXJRecvUseResPackMethod():
	m_netType(GameClient_Game){}
crJXJRecvUseResPackMethod::crJXJRecvUseResPackMethod(const crJXJRecvUseResPackMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUseResPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvUseResPackMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvUseResPackMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			int id,count,resid = 0;
			crVector4i count4;
			id = m_stream->_readInt();
			if(id==-1)
				count4 = m_stream->_readVec4i();
			else
				count = m_stream->_readInt();
			void *param;
			crData *userData = m_this->getDataClass();
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			if(id>0)
			{
				userData->getParam(id,param);
				int *resparam = (int *)param;
				//*resparam += count;
				INTLIMITADD(*resparam,count,INT_MAX);
				switch (id)
				{
				case WCHDATA_JXJFood:
					resid = T_Food;
					break;
				case WCHDATA_JXJWood:
					resid = T_Wood;
					break;
				case WCHDATA_JXJIron:
					resid = T_Iron;
					break;
				case WCHDATA_JXJHorse:
					resid = T_Horse;
					break;
				case WCHDATA_JXJCoppercash:
					resid = T_Copper;
					break;
				}
				if(count!=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(resid,count));
			}
			else if(id == -1)
			{//所有资源
				int *resparam;
				for( int i = 0; i<4; i++)
				{
					userData->getParam(WCHDATA_JXJFood+i,param);
					resparam = (int *)param;
					INTLIMITADD(*resparam,count4[i],INT_MAX);
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Food+i,count4[i]));
				}
			}
			userData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerUseTroopsEquipPackMethod
//
/////////////////////////////////////////
crJXJServerUseTroopsEquipPackMethod::crJXJServerUseTroopsEquipPackMethod():
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL){}
crJXJServerUseTroopsEquipPackMethod::crJXJServerUseTroopsEquipPackMethod(const crJXJServerUseTroopsEquipPackMethod& handle):
	crMethod(handle),
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL)
{
}
void crJXJServerUseTroopsEquipPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crDataObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crPlayerGameData*)LOINT64(param64);
			CRCore::crVector3i vparam = *(crVector3i *)HIINT64(param64);
			m_itemid = vparam[0];
			m_selectid = vparam[1];
			m_useResult = (char *)vparam[2];
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crJXJServerUseTroopsEquipPackMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerUseTroopsEquipPackMethod::operator()(crHandle &handle)
{
	if(m_user && m_itemid > 0)
	{
		int playerid = m_user->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			ref_ptr<crTableIO>troopsEquipPackTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipPackTab);
			crTableIO::StrVec record;
			if(troopsEquipPackTab->queryOneRecord(0,crArgumentParser::appItoa(m_itemid),record)>=0)
			{
				int equipindex = troopsEquipPackTab->getTitleIndex("equipid");
				int countid = troopsEquipPackTab->getTitleIndex("数量");
				unsigned short euqipid = atoi(record[equipindex].c_str());
				if(euqipid>0)
				{
					int count = atoi(record[countid].c_str());
					void *param;
					crData *data = m_user->getDataClass();
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_JXJTroopsEquipMap,param);
					TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
					TroopsEquipMap::iterator itr = troopsEquipMap->find(euqipid);
					if(itr != troopsEquipMap->end())
					{
						itr->second += count;
					}
					else
					{
						troopsEquipMap->insert(std::make_pair(euqipid,count));
					}
					data->excHandle(MAKEINT64(WCH_LockData,0));

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(6);
					stream->_writeUShort(euqipid);
					stream->_writeInt(count);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseTroopsEquipPack,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					*m_useResult = 1;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUseTroopsEquipPackMethod
//
/////////////////////////////////////////
crJXJRecvUseTroopsEquipPackMethod::crJXJRecvUseTroopsEquipPackMethod():
	m_netType(GameClient_Game){}
crJXJRecvUseTroopsEquipPackMethod::crJXJRecvUseTroopsEquipPackMethod(const crJXJRecvUseTroopsEquipPackMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUseTroopsEquipPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvUseTroopsEquipPackMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvUseTroopsEquipPackMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			unsigned short euqipid = m_stream->_readUShort();
			int count = m_stream->_readInt();

			void *param;
			crData *userData = m_this->getDataClass();
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			userData->getParam(WCHDATA_JXJTroopsEquipMap,param);
			TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
			TroopsEquipMap::iterator itr = troopsEquipMap->find(euqipid);
			if(itr != troopsEquipMap->end())
			{
				itr->second += count;
			}
			else
			{
				troopsEquipMap->insert(std::make_pair(euqipid,count));
			}
			userData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerUseTroopsPackMethod
//
/////////////////////////////////////////
crJXJServerUseTroopsPackMethod::crJXJServerUseTroopsPackMethod():
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL){}
crJXJServerUseTroopsPackMethod::crJXJServerUseTroopsPackMethod(const crJXJServerUseTroopsPackMethod& handle):
	crMethod(handle),
	m_itemid(0),
	m_selectid(0),
	m_useResult(NULL),
	m_this(NULL),
	m_user(NULL)
{
}
void crJXJServerUseTroopsPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crDataObject*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_user = (crPlayerGameData*)LOINT64(param64);
			CRCore::crVector3i vparam = *(crVector3i *)HIINT64(param64);
			m_itemid = vparam[0];
			m_selectid = vparam[1];
			m_useResult = (char *)vparam[2];
		}
		else
		{
			m_itemid = 0;
		}
		break;
	}
}

void crJXJServerUseTroopsPackMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerUseTroopsPackMethod::operator()(crHandle &handle)
{
	if(m_user && m_itemid > 0)
	{
		int playerid = m_user->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			void *param;
			ref_ptr<crTableIO>troopsPackTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsPackTab);
			crTableIO::StrVec record;
			if(troopsPackTab->queryOneRecord(0,crArgumentParser::appItoa(m_itemid),record) >= 0)
			{
				int aindex = troopsPackTab->getTitleIndex("abstractid");
				int countid = troopsPackTab->getTitleIndex("数量");
				int troopsid =  atoi(record[aindex].c_str());
				int count = atoi(record[countid].c_str());
				ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
				if(troopsid>0 && troopsTab->queryOneRecord(0,crArgumentParser::appItoa(troopsid),record)>=0)
				{
					crData *data = m_user->getDataClass();
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_JXJTroopsMap,param);
					TroopsMap *troopsMap = (TroopsMap *)param;
					TroopsMap::iterator itr = troopsMap->find(troopsid);
					if(itr != troopsMap->end())
					{
						int maxSoldiers = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxSoldiers,viplv).c_str());
						INTLIMITADD(itr->second,count,maxSoldiers)
						count = itr->second;
					}
					else
					{
						(*troopsMap)[troopsid] = count;
					}
					data->excHandle(MAKEINT64(WCH_LockData,0));
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(8);
					stream->_writeInt(troopsid);
					stream->_writeInt(count);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseTroopsPack,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					*m_useResult = 1;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUseTroopsPackMethod
//
/////////////////////////////////////////
crJXJRecvUseTroopsPackMethod::crJXJRecvUseTroopsPackMethod():
	m_netType(GameClient_Game){}
crJXJRecvUseTroopsPackMethod::crJXJRecvUseTroopsPackMethod(const crJXJRecvUseTroopsPackMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUseTroopsPackMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvUseTroopsPackMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvUseTroopsPackMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			int id,count,extra;
			id = m_stream->_readInt();
			count = m_stream->_readInt();
			void *param;
			crData *userData = m_this->getDataClass();
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			userData->getParam(WCHDATA_JXJTroopsMap,param);
			TroopsMap *troopsMap = (TroopsMap *)param;
			if(troopsMap->find(id)!=troopsMap->end())
			{
				extra = count-(*troopsMap)[id];
			}
			else
				extra = count;

			(*troopsMap)[id] = count;
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			if(extra!=0)
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(id,extra));
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetRecruitSpeedMethod
//
/////////////////////////////////////////
crJXJGetRecruitSpeedMethod::crJXJGetRecruitSpeedMethod():
	m_output(NULL){}
crJXJGetRecruitSpeedMethod::crJXJGetRecruitSpeedMethod(const crJXJGetRecruitSpeedMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetRecruitSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetRecruitSpeedMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetRecruitSpeedMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		void *param;
		float percent = 0.0f;
		crData *data = m_this->getDataClass();
		//crTableIO::StrVec techrecord;
		//ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		//int shuxingindex = techlvtab->getTitleIndex("属性加成");
		//int lvindex = techlvtab->getTitleIndex("lv");
		////科技减少招募CD
		//data->getParam(WCHDATA_JXJTechZhaoMulv,param);
		//unsigned char techlv = *(unsigned char *)param;
		//if (techlv > 0)
		//{
		//	if(techlvtab->queryOneRecord(0,crArgumentParser::appItoa(WCHDATA_JXJTechZhaoMulv),lvindex,crArgumentParser::appItoa(techlv),techrecord)>=0)
		//	{
		//		percent += atof(techrecord[shuxingindex].c_str());
		//	}
		//}
		//兵营等级减少招兵CD
		crTableIO::StrVec bingyingrecord;
		ref_ptr<crTableIO>bingyingtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBingYingTab);
		int cdindex = bingyingtab->getTitleIndex("减招兵CD");
		data->getParam(WCHDATA_JXJBingyinglv,param);
		unsigned char bingyinglv = *(unsigned char *)param;
		if (bingyingtab->queryOneRecord(0,crArgumentParser::appItoa(bingyinglv),bingyingrecord)>=0)
		{
			percent += atof(bingyingrecord[cdindex].c_str());
		}
		//委任减少招募CD
		//
		crTableIO::StrVec cardrecord;
		ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
		int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
		int addpercentindex = cardtab->getTitleIndex("政卡加成");
		data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

		for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
			carditr!=appjiangkavec->end();
			++carditr)
		{
			if ((*carditr)!=NULL)
			{
				if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord)>=0)
				{
					if(atoi(cardrecord[zhengkatypeindex].c_str()) == ZhengAdd_ReduceRecruitCD)
					{
						//percent +=(100 - percent) * atof(cardrecord[addpercentindex].c_str())/100.0f;
						percent += atof(cardrecord[addpercentindex].c_str());
						break;
					}
				}
			}
		}
		if (percent > 100.0f)
		{
			percent = 100.0f;
		}
		*m_output = percent * 0.01f;//*0.01f
	}
}
/////////////////////////////////////////
//
//crJXJGetRecruitConsumeMethod
//
/////////////////////////////////////////
crJXJGetRecruitConsumeMethod::crJXJGetRecruitConsumeMethod():
	m_output(NULL){}
crJXJGetRecruitConsumeMethod::crJXJGetRecruitConsumeMethod(const crJXJGetRecruitConsumeMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetRecruitConsumeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (double *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetRecruitConsumeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetRecruitConsumeMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		float percent = 0.0f;
		crData *data = m_this->getDataClass();
		crTableIO::StrVec techrecord,cardrecord;
		ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
		ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
		int addpercentindex = cardtab->getTitleIndex("政卡加成");
		int shuxingindex = techlvtab->getTitleIndex("属性加成");
		int lvindex = techlvtab->getTitleIndex("lv");
		if (data)
		{
			void *param;
			////科技减少招募消耗
			//data->getParam(WCHDATA_JXJTechRenDelv,param);
			//unsigned char techlv = *(unsigned char *)param;
			//if (techlv > 0)
			//{
			//	if(techlvtab->queryOneRecord(0,crArgumentParser::appItoa(WCHDATA_JXJTechRenDelv),lvindex,crArgumentParser::appItoa(techlv),techrecord)>=0)
			//	{
			//		percent += atof(techrecord[shuxingindex].c_str());
			//	}
			//}
			//委任减少招募消耗
			data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
			JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

			for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
				carditr!=appjiangkavec->end();
				++carditr)
			{
				if ((*carditr)!=NULL)
				{
					if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord)>=0)
					{
						if(atoi(cardrecord[zhengkatypeindex].c_str()) == ZhengAdd_ReduceRecruitResource)
						{
							percent +=atof(cardrecord[addpercentindex].c_str());
							break;
						}
					}
				}
			}
			//国家建设减少招募消耗
			int countrybuildingtype = BuildCountryType_TaiMiao;
			int countrybuildingmsgid =WCHDATA_JXJTaiMiao;
			int gongxian = 0;
			data -> getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *( unsigned char *)param;
			int shilimsgid = 0;
			if(shiliid >= c_startShiliID)
			{
				if(crGlobalHandle::isClient())
				{
					//crData *braindata = crBrain::getInstance()->getDataClass();
					//braindata->getParam(WCHDATA_JXJMyCountryData,param);
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_JXJMyCountryData,param);
					crJXJShili *shili = (crJXJShili *)param;
					if (shili && shili->getDataClass())
					{
						crData *shilidata = shili->getDataClass();	
						shilidata->getParam(countrybuildingmsgid,param);
						gongxian = *(int *)param;
					}
					data->excHandle(MAKEINT64(WCH_LockData,0));
				}
				else
				{
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					if (gsBrainData)
					{
						gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
						crJXJShili *shili = (crJXJShili *)param;
						if (shili && shili->getDataClass())
						{
							crData *shilidata = shili->getDataClass();	
							shilidata->getParam(countrybuildingmsgid,param);
							gongxian = *(int *)param;
						}
					}
				}
				ref_ptr<crTableIO>countrybuildtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCountryBuildTab);
				crTableIO::DataVec records;
				crTableIO::StrVec recordc;
				int typeindex = countrybuildtab->getTitleIndex("type");
				int addindex = countrybuildtab->getTitleIndex("加成");
				int moneyneedindex = countrybuildtab->getTitleIndex("铜钱");
				countrybuildtab->queryRecords(typeindex,crArgumentParser::appItoa(countrybuildingtype),records);
				crTableIO::DataVec::iterator itr;
				crTableIO::DataVec::iterator peritr;
				int lv;
				if(!records.empty())
				{
					peritr = records.begin();
					itr = peritr;
					itr++;
					for (;
						itr != records.end();
						++itr,++peritr)
					{
						if (gongxian <  atoi((*itr)[moneyneedindex].c_str()))
						{
							break;
						}
					}
					lv = atoi((*peritr)[0].c_str());
				}
				if(countrybuildtab->queryOneRecord(0,crArgumentParser::appItoa(lv),typeindex,crArgumentParser::appItoa(countrybuildingtype),recordc)>=0)
				{
					percent += atof(recordc[addindex].c_str());
				}
			}
		}

		*m_output = percent * 0.01;//*0.01f
	}
}
/////////////////////////////////////////
//
//crJXJGetGetBuildingLevelUpSpeedMethod
//
/////////////////////////////////////////
crJXJGetGetBuildingLevelUpSpeedMethod::crJXJGetGetBuildingLevelUpSpeedMethod():
	m_output(NULL){}
crJXJGetGetBuildingLevelUpSpeedMethod::crJXJGetGetBuildingLevelUpSpeedMethod(const crJXJGetGetBuildingLevelUpSpeedMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetGetBuildingLevelUpSpeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetGetBuildingLevelUpSpeedMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetGetBuildingLevelUpSpeedMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		void *param;
		float percent = 0.0f;
		crData *data = m_this->getDataClass();
		crTableIO::StrVec techrecord;
		ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		int shuxingindex = techlvtab->getTitleIndex("属性加成");
		//int lvindex = techlvtab->getTitleIndex("lv");
		////科技减少建筑CD
		data->getParam(WCHDATA_JXJTechBuildingCDlv, param);
		unsigned char techlv = *(unsigned char *)param;
		if (techlv > 0)
		{
			if (techlvtab->queryOneRecord(0, crArgumentParser::appItoa(WCHDATA_JXJTechBuildingCDlv), techrecord) >= 0)
			{
				percent += atof(techrecord[shuxingindex].c_str());
			}
		}
		//委任减少建筑CD
		//
		crTableIO::StrVec cardrecord;
		ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
		int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
		int addpercentindex = cardtab->getTitleIndex("政卡加成");
		data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

		for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
			carditr!=appjiangkavec->end();
			++carditr)
		{
			if ((*carditr)!=NULL)
			{
				if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord)>=0)
				{
					if(atoi(cardrecord[zhengkatypeindex].c_str()) == ZhengAdd_ReduceBuildingLevelUpCD)
					{
						//percent +=(100 - percent) * atof(cardrecord[addpercentindex].c_str())/100.0f;
						percent += atof(cardrecord[addpercentindex].c_str());
						break;
					}
				}
			}
		}
		if (percent > 100.0f)
		{
			percent = 100.0f;
		}
		*m_output = percent*0.01f;//*0.01f
	}
}
/////////////////////////////////////////
//
//crJXJGetGetBuildingLevelUpConsumeMethod
//
/////////////////////////////////////////
crJXJGetGetBuildingLevelUpConsumeMethod::crJXJGetGetBuildingLevelUpConsumeMethod():
	m_output(NULL){}
crJXJGetGetBuildingLevelUpConsumeMethod::crJXJGetGetBuildingLevelUpConsumeMethod(const crJXJGetGetBuildingLevelUpConsumeMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetGetBuildingLevelUpConsumeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetGetBuildingLevelUpConsumeMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetGetBuildingLevelUpConsumeMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		float percent = 0.0f;
		//科技减少建筑消耗
		//委任减少建筑消耗

		void *param;
		crData *data = m_this->getDataClass();
		crTableIO::StrVec cardrecord;
		ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
		int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
		int addpercentindex = cardtab->getTitleIndex("政卡加成");
		if (data)
		{
			data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
			JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

			for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
				carditr!=appjiangkavec->end();
				++carditr)
			{
				if ((*carditr)!=NULL)
				{
					if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord)>=0)
					{
						if(atoi(cardrecord[zhengkatypeindex].c_str()) == ZhengAdd_ReduceBuildingLevelUpResource)
						{
							percent +=atof(cardrecord[addpercentindex].c_str());
							break;
						}
					}
				}
			}
		}

		*m_output = percent * 0.01f;//*0.01f
	}
}
/////////////////////////////////////////
//
//crJXJGetRevenueIncreaseMethod
//
/////////////////////////////////////////
crJXJGetRevenueIncreaseMethod::crJXJGetRevenueIncreaseMethod():
	m_output(NULL){}
crJXJGetRevenueIncreaseMethod::crJXJGetRevenueIncreaseMethod(const crJXJGetRevenueIncreaseMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetRevenueIncreaseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_output = (float *)(LOINT64(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetRevenueIncreaseMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetRevenueIncreaseMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		void *param;
		float percent = 0.0f;
		crData *data = m_this->getDataClass();
		crTableIO::StrVec techrecord;
		ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		int shuxingindex = techlvtab->getTitleIndex("属性加成");
		//int lvindex = techlvtab->getTitleIndex("lv");
		////科技增加税收收入
		data->getParam(WCHDATA_JXJTechZhengShuilv,param);
		unsigned char techlv = *(unsigned char *)param;
		if (techlv > 0)
		{
			if(techlvtab->queryOneRecord(0,crArgumentParser::appItoa(WCHDATA_JXJTechZhengShuilv),techrecord)>=0)
			{
				percent += atof(techrecord[shuxingindex].c_str());
			}
		}
		//委任增加税收收入
		crTableIO::StrVec cardrecord;
		ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
		int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
		int addpercentindex = cardtab->getTitleIndex("政卡加成");
		if (data)
		{
			data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
			JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

			for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
				carditr!=appjiangkavec->end();
				++carditr)
			{
				if ((*carditr)!=NULL)
				{
					if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord)>=0)
					{
						if(atoi(cardrecord[zhengkatypeindex].c_str()) == ZhengAdd_IncreaseCopperGet)
						{
							percent +=atof(cardrecord[addpercentindex].c_str());
							break;
						}
					}
				}
			}
		}
		///额外税收产出
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJExtraProduceMap,param);
		ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
		ExtraProduceMap::iterator itr = extraProduceMap->find(T_CopperExtraProduce);
		if (itr != extraProduceMap->end())
		{
			percent += itr->second->getPercent();
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		*m_output = percent * 0.01f;
	}
}
/////////////////////////////////////////
//
//crJXJIsTaskCanActiveMethod
//
/////////////////////////////////////////
crJXJIsTaskCanActiveMethod::crJXJIsTaskCanActiveMethod():
m_this(NULL),
m_output(NULL)
{
}
crJXJIsTaskCanActiveMethod::crJXJIsTaskCanActiveMethod(const crJXJIsTaskCanActiveMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
}
void crJXJIsTaskCanActiveMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_task = (crGameTask*)(LOINT64(param64));
			m_output = (bool *)(HIINT64(param64));
		}
		else
		{
			m_task = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crJXJIsTaskCanActiveMethod::addParam(int i, const std::string& str)
{
}
void crJXJIsTaskCanActiveMethod::operator()(crHandle &handle)
{
	if(m_task.valid() && !m_task->getActivation() && !m_task->isComplete() && m_output)
	{
		*m_output = false;
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *(unsigned char *)param;
		const CRCore::crVector2ub& lvrange = m_task->getLvRange();
		if(lv>=lvrange[0] && lv<=lvrange[1])
		{
			int pretask = m_task->getPreTask();
			if(pretask == 0)
			{
				*m_output = true;
			}
			else
			{
				crData *myMetierData = m_this->getMetierDataClass();
				if(myMetierData)
				{
					myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
					myMetierData->getParam(WCHDATA_GameTaskMap,param);
					GameTaskMap *gameTaskMap = (GameTaskMap *)param;
					GameTaskMap::iterator preItr = gameTaskMap->find(pretask);
					if(preItr != gameTaskMap->end() && preItr->second->isComplete())
					{
						*m_output = true;
					}
					myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJDisplayTaskGoalMethod
//
/////////////////////////////////////////
crJXJDisplayTaskGoalMethod::crJXJDisplayTaskGoalMethod():
	m_this(NULL),
	m_textWidget(NULL)
{
}
crJXJDisplayTaskGoalMethod::crJXJDisplayTaskGoalMethod(const crJXJDisplayTaskGoalMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_textWidget(NULL)
{
}
void crJXJDisplayTaskGoalMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_task = (crGameTask*)(LOINT64(param64));
			m_textWidget = (crHypertextWidgetNode *)(HIINT64(param64));
		}
		else
		{
			m_task = NULL;
			m_textWidget = NULL;
		}
		break;
	}
}
void crJXJDisplayTaskGoalMethod::addParam(int i, const std::string& str)
{
}
void crJXJDisplayTaskGoalMethod::operator()(crHandle &handle)
{
	if(m_task.valid() && m_textWidget)
	{
		if(m_task->getActivation() && !m_task->isComplete())
		{
			std::string file = m_task->getHyperText();
			if(!file.empty())
			{
				std::string ext;
				unsigned char steptype;
				char tmpText[64];
				//ItemMap itemMap;
				//rcfg::ConfigScript cfg_script(&itemMap);
				//cfg_script.Add("Hypertext");
				//cfg_script.Push("Hypertext");
				//cfg_script.Add("Content");
				//cfg_script.Push("Content",1);
				//std::vector<float>v_i;
				//v_i.push_back(255.0f);
				//v_i.push_back(0.0f);
				//v_i.push_back(0.0f);
				//v_i.push_back(255.0f);
				//cfg_script.Add("Color",v_i);
				//cfg_script.Add("Text",m_task->getTaskName()+"\n");
				//cfg_script.Pop();
				//cfg_script.Pop();
				//m_textWidget->setHypertext(cfg_script,true);

				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
				ext = crArgumentParser::getFileExtension(file);
				steptype = m_task->getTaskStepType();
				if(steptype == TS_Zero)
				{
					int progress = m_task->getTaskProgress();
					file = crArgumentParser::getFileNameEliminateExt(file)+crArgumentParser::appItoa(progress)+"."+ext;
					m_textWidget->setHypertext(file,true);

					std::vector<std::string> record;
					ref_ptr<crTableIO> taskTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTab);
					int paramid = taskTab->getTitleIndex("参数1");
					if(taskTab->queryOneRecord(0,crArgumentParser::appItoa(m_task->getTaskID()),record)>=0)
					{
						if (!record[paramid].empty())
						{
							ItemMap itemMap;
							int oneIndex = 1;
							rcfg::ConfigScript cfg_script(&itemMap);
							cfg_script.Add("Hypertext");
							cfg_script.Push("Hypertext",oneIndex++); 
							cfg_script.Add("Content");
							cfg_script.Push("Content");
							std::vector<float>v_i;
							v_i.push_back(255.0f);
							v_i.push_back(255.0f);
							v_i.push_back(0.0f);
							v_i.push_back(255.0f);
							cfg_script.Add("Color",v_i);
							cfg_script.Add("Text",record[paramid]);
							cfg_script.Pop();

							cfg_script.Pop();
							m_textWidget->setHypertext(cfg_script,true);
						}
					}
				}
				else if(m_task->isTaskCanRefer())
				{
					file = crArgumentParser::getFileNameEliminateExt(file)+"1."+ext;
					m_textWidget->setHypertext(file,true);
				}
				else
				{
					std::string relfile;
					int progress = m_task->getTaskProgress();
					_crInt16 A,B;
					A = LOINT32(progress);
					B = HIINT32(progress);
					_crInt16 C,D;
					int step = m_task->getTaskSteps()-1;
					C = LOINT32(step);
					D = HIINT32(step);
					_crInt8 a,c;
					if(steptype >= TS_One)
					{
						relfile = crArgumentParser::getFileNameEliminateExt(file)+"One."+ext;
						m_textWidget->setHypertext(relfile,true);

						a = LOINT16(A);
						c = LOINT16(C);
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("Content");
						cfg_script.Push("Content");
						std::vector<float>v_i;
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
						cfg_script.Pop();
						m_textWidget->setHypertext(cfg_script,true);
					}
					if(steptype >= TS_Two)
					{
						relfile = crArgumentParser::getFileNameEliminateExt(file)+"Two."+ext;
						m_textWidget->setHypertext(relfile,true);

						a = HIINT16(A);
						c = HIINT16(C);
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("Content");
						cfg_script.Push("Content");
						std::vector<float>v_i;
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
						cfg_script.Pop();
						m_textWidget->setHypertext(cfg_script,true);
					}
					if(steptype >= TS_Three)
					{
						relfile = crArgumentParser::getFileNameEliminateExt(file)+"Three."+ext;
						m_textWidget->setHypertext(relfile,true);

						a = LOINT16(B);
						c = LOINT16(D);
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("Content");
						cfg_script.Push("Content");
						std::vector<float>v_i;
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
						cfg_script.Pop();
						m_textWidget->setHypertext(cfg_script,true);
					}
					if(steptype >= TS_Four)
					{
						relfile = crArgumentParser::getFileNameEliminateExt(file)+"Four."+ext;
						m_textWidget->setHypertext(relfile,true);

						a = HIINT16(B);
						c = HIINT16(D);
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("Content");
						cfg_script.Push("Content");
						std::vector<float>v_i;
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
						cfg_script.Pop();
						m_textWidget->setHypertext(cfg_script,true);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetTaskMethod
//
/////////////////////////////////////////
crJXJGetTaskMethod::crJXJGetTaskMethod()
{
}
crJXJGetTaskMethod::crJXJGetTaskMethod(const crJXJGetTaskMethod& handle):
	crMethod(handle)
{
}
void crJXJGetTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}
void crJXJGetTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetTaskMethod::operator()(crHandle &handle)
{
	void *param;
	crData *metierData = m_this->getMetierDataClass();
	if(metierData)
	{
		metierData->getParam(WCHDATA_CurrentTaskID,param);
		int taskid = *(int *)param;
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		if(gameTask.valid() && !gameTask->getActivation())
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(taskid);
			int playerid = m_this->getPlayerID();
			crNetConductor *netConductor;
			if(crGlobalHandle::isClient())
			{
				netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crJXJServerMetierEventPacket packet;
					crJXJServerMetierEventPacket::buildRequestPacket(packet,WCH_RecvGetTask,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			else
			{
				netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
				if(netConductor)
				{//server to client
					crJXJPlayerMetierEventPacket packet;
					crJXJPlayerMetierEventPacket::buildReplyPacket(packet,playerid,WCH_RecvGetTask,stream.get());
					ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
					if(playerData.valid())
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJAdvanceTaskMethod
//
/////////////////////////////////////////
crJXJAdvanceTaskMethod::crJXJAdvanceTaskMethod():
	m_taskid(0),
	m_stepType(0)
{
}
crJXJAdvanceTaskMethod::crJXJAdvanceTaskMethod(const crJXJAdvanceTaskMethod& handle):
	crMethod(handle),
	m_taskid(0),
	m_stepType(0)
{
}
void crJXJAdvanceTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_taskid = LOINT64(param64);
			m_stepType = (unsigned char)(HIINT64(param64));
		}
		break;
	}
}
void crJXJAdvanceTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJAdvanceTaskMethod::operator()(crHandle &handle)
{
	void *param;
	crData *metierData;
	crRole *mainRole = m_this->getMainRole();
	if(mainRole && mainRole->getMetierDataClass())
	{
		metierData = mainRole->getMetierDataClass();
		//if(crGlobalHandle::isClient())
		//{
		//	crRole *mainrole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
		//	metierData = mainrole->getMetierDataClass();
		//}
		//else
		//{
		//	metierData = m_this->getMetierDataClass();
		//}
		int taskid = m_taskid;
		if(taskid == 0)
		{
			metierData->getParam(WCHDATA_CurrentTaskID,param);
			taskid = *(int *)param;
		}
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
		if(gameTask.valid() && gameTask->isTaskCanAdvance(m_stepType))
		{
			crNetConductor *netConductor;
			if(crGlobalHandle::isClient())
			{
				netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(5);
					stream->_writeInt(m_taskid);
					stream->_writeUChar(m_stepType);
					crJXJServerMetierEventPacket packet;
					crJXJServerMetierEventPacket::buildRequestPacket(packet,WCH_RecvAdvanceTask,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
					gameTask->advance(m_stepType);
				}
			}
			else
			{
				netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
				if(netConductor)
				{//server to client
					if(gameTask->advance(m_stepType))
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(8);
						stream->_writeInt(taskid);
						stream->_writeInt(gameTask->getTaskProgress());

						int playerid = m_this->getPlayerID();
						crJXJPlayerMetierEventPacket packet;
						crJXJPlayerMetierEventPacket::buildReplyPacket(packet,playerid,WCH_RecvAdvanceTask,stream.get());
						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
						if(playerData.valid())
							netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

						//crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						//if(dbConductor)
						//{//任务日志
						//	crNetDataManager *netDataManager = netConductor->getNetDataManager();
						//	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
						//	int serverid = callback->getServerID();
						//	crDBSavePacket dbpacket;
						//	ref_ptr<crJXJInsertTaskrecord> insertTaskrecord = new crJXJInsertTaskrecord;
						//	insertTaskrecord->buildUpdateSql(playerid,serverid,mainRole->getIName(),m_taskid,TS_Progress,gameTask->getTaskProgress());
						//	crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
						//	dbConductor->getNetManager()->sendPacket("all",dbpacket);
						//}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJReferTaskMethod
//
/////////////////////////////////////////
crJXJReferTaskMethod::crJXJReferTaskMethod():
	m_taskid(0),
	m_scriptadd(false)
{
}
crJXJReferTaskMethod::crJXJReferTaskMethod(const crJXJReferTaskMethod& handle):
	crMethod(handle),
	m_taskid(handle.m_taskid),
	m_scriptadd(handle.m_scriptadd)
{
}
void crJXJReferTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(!m_scriptadd && param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_taskid = LOINT64(param64);
		}
		break;
	}
}
void crJXJReferTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskid = atoi(str.c_str());
		m_scriptadd = true;
		break;
	}
}
void crJXJReferTaskMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->getPlayerGameData())
	{
		crRole *mainrole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
		void *param;
		crData *metierData = mainrole->getMetierDataClass();
		if(metierData)
		{
			//metierData->getParam(WCHDATA_CurrentTaskID,param);
			//int taskid = *(int *)param;
			ref_ptr<crGameTask> gameTask;
			metierData->excHandle(MAKEINT64(WCH_LockData,1));
			metierData->getParam(WCHDATA_GameTaskMap,param);
			GameTaskMap* gameTaskMap = (GameTaskMap* )param;
			GameTaskMap::iterator itr = gameTaskMap->find(m_taskid);
			gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
			if(gameTask.valid() && gameTask->isTaskCanRefer())
			{
				gameTask->refer();
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(m_taskid);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crJXJServerMetierEventPacket packet;
					crJXJServerMetierEventPacket::buildRequestPacket(packet,WCH_RecvReferTask,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			metierData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGetTaskMethod
//
/////////////////////////////////////////
crJXJRecvGetTaskMethod::crJXJRecvGetTaskMethod():
	m_netType(GameClient_Game){}
crJXJRecvGetTaskMethod::crJXJRecvGetTaskMethod(const crJXJRecvGetTaskMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvGetTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvGetTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvGetTaskMethod::operator()(crHandle &handle)
{
	if(m_stream.valid() && m_this->getMetierDataClass())
	{
		int taskid = m_stream->_readInt();
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		if(gameTask.valid() && !gameTask->getActivation())
		{
			if(m_netType == GameServer)
			{
				do 
				{
					crData *data = m_this->getDataClass();
					data->getParam(WCHDATA_Level,param);
					unsigned char lv = *((unsigned char*)param);
					const crVector2ub &lvRange = gameTask->getLvRange();
					if(lvRange != crVector2ub(0,0))
					{
						if(lv<lvRange[0] || lv>lvRange[1])
						{
							break;
						}
					}
					int perTaskID = gameTask->getPreTask();
					if(perTaskID!=0)
					{
						GameTaskMap::iterator gameTaskItr = gameTaskMap->find(perTaskID);
						crGameTask *preGameTask = gameTaskItr!=gameTaskMap->end()?gameTaskItr->second.get():NULL;
						if(!preGameTask || !preGameTask->isComplete())
						{//前置任务没有完成
							break;
						}
					}
					gameTask->setActivation(true);

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(taskid);
					int playerid = m_this->getPlayerID();
					crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
					if(netConductor)
					{//server to client
						crJXJPlayerMetierEventPacket packet;
						crJXJPlayerMetierEventPacket::buildReplyPacket(packet,playerid,WCH_RecvGetTask,stream.get());
						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
						if(playerData.valid())
							netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

						crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						if(dbConductor)
						{//任务日志
							crNetDataManager *netDataManager = netConductor->getNetDataManager();
							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
							int serverid = callback->getServerID();
							crDBSavePacket dbpacket;
							ref_ptr<crJXJInsertTaskrecord> insertTaskrecord = new crJXJInsertTaskrecord;
							insertTaskrecord->buildUpdateSql(playerid,serverid,m_this->getIName(),taskid,TS_Activation,gameTask->getTaskProgress());
							crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
							dbConductor->getNetManager()->sendPacket("all",dbpacket);
						}
					}
				} while (0);
			}
			else if(m_netType == GameClient_Game)
			{
				gameTask->setActivation(true);
				ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_RenWu");
				if(canvas.valid())
				{
					canvas->doEvent(WCH_UI_UpdateData);
				}
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));

		if(m_netType == GameClient_Game)
		{
			ref_ptr<crTableIO> taskTitleTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
			int taskidindex = taskTitleTab->getTitleIndex("taskid");
			crTableIO::StrVec record;
			if(taskTitleTab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),record)>=0)
			{
				if(record[0] == "8")
				{//奇遇任务激活
					crData *roledata = m_this->getDataClass();
					roledata->inputParam(WCHDATA_JXJQiyuTaskID,&taskid);
					ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas("UI_Qiyu");
					if(canvas.valid())
					{
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvAdvanceTaskMethod
//
/////////////////////////////////////////
crJXJRecvAdvanceTaskMethod::crJXJRecvAdvanceTaskMethod():
	m_netType(GameClient_Game){}
crJXJRecvAdvanceTaskMethod::crJXJRecvAdvanceTaskMethod(const crJXJRecvAdvanceTaskMethod& handle):
	crMethod(handle),
	m_netType(GameClient_Game)
{
}
void crJXJRecvAdvanceTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvAdvanceTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvAdvanceTaskMethod::operator()(crHandle &handle)
{
	if(m_stream.valid() && m_this->getMetierDataClass())
	{
		int taskid = m_stream->_readInt();
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		ref_ptr<crGameTask> gameTask;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator itr = gameTaskMap->find(taskid);
		gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
		if(gameTask.valid())
		{
			if(m_netType == GameServer)
			{
				/*unsigned char steptype = 0;
				if(!m_stream->eof())*/
				unsigned char steptype = m_stream->_readUChar();
				if(gameTask->advance(steptype))
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(8);
					stream->_writeInt(taskid);
					stream->_writeInt(gameTask->getTaskProgress());
					int playerid = m_this->getPlayerID();
					crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
					if(netConductor)
					{//server to client
						crJXJPlayerMetierEventPacket packet;
						crJXJPlayerMetierEventPacket::buildReplyPacket(packet,playerid,WCH_RecvAdvanceTask,stream.get());
						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
						if(playerData.valid())
							netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

						//crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						//if(dbConductor)
						//{//任务日志
						//	crNetDataManager *netDataManager = netConductor->getNetDataManager();
						//	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
						//	int serverid = callback->getServerID();
						//	crDBSavePacket dbpacket;
						//	ref_ptr<crJXJInsertTaskrecord> insertTaskrecord = new crJXJInsertTaskrecord;
						//	insertTaskrecord->buildUpdateSql(playerid,serverid,m_this->getIName(),taskid,TS_Progress,gameTask->getTaskProgress());
						//	crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
						//	dbConductor->getNetManager()->sendPacket("all",dbpacket);
						//}
					}
				}
			}
			else if(m_netType == GameClient_Game)
			{
				int progress = m_stream->_readInt();
				gameTask->setTaskProgress(progress);
				crCanvasNode *canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_RenWu");
				if(canvas)
				{
					canvas->doEvent(WCH_UI_UpdateData);
				}
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJTaskAwardMethod
//
/////////////////////////////////////////
crJXJTaskAwardMethod::crJXJTaskAwardMethod():
	m_output(NULL)
{
}
crJXJTaskAwardMethod::crJXJTaskAwardMethod(const crJXJTaskAwardMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJTaskAwardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_gameTask = (crGameTask *)(LOINT64(param64));
			m_output = (bool *)(HIINT64(param64));
		}
		else
		{
			m_gameTask = NULL;
			m_output = NULL;
		}
		break;
	}
}
void crJXJTaskAwardMethod::addParam(int i, const std::string& str)
{
}
void crJXJTaskAwardMethod::operator()(crHandle &handle)
{
	if(m_gameTask.valid())
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
		crNetDataManager *netDataManager = netConductor->getNetDataManager();
		int playerid = m_this->getPlayerID();
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
		//ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if(playerData.valid()/*&& itemtab.valid()*/)
		{
			ref_ptr<crPlayerGameData> playergamedata =  playerData->getPlayerGameData();
			int taskid = m_gameTask->getTaskID();
			//void *param;
			//std::vector<crVector3i> bagitem;
			//std::vector<crVector3i> jiangkaitem;
			crTableIO::StrVec record;//recordtask,recorditem;
			ref_ptr<crTableIO>taskTitleTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
			crData *data = playergamedata->getDataClass();
			//int itemaward1index = taskTitleTab->getTitleIndex("道具奖励1");
			int awardIdx[2] = {0};
			awardIdx[0] = taskTitleTab->getTitleIndex("奖励1");
			awardIdx[1] = taskTitleTab->getTitleIndex("奖励2");
			int taskidindex = taskTitleTab->getTitleIndex("taskid");
			std::vector<CRCore::crVector4i> awards;
			CRCore::crVector4i awardVec;
			int exp = m_gameTask->getExp();
			if(exp!=0)
			{
				awardVec.set(T_Exp,0,0,exp);
				awards.push_back(awardVec);
			}
			int gold = m_gameTask->getGold();
			if(gold!=0)
			{//
				awardVec.set(T_Copper,0,0,gold);
				awards.push_back(awardVec);
			}
			//int achievement = m_gameTask->getExp2();
			//if (achievement != 0)
			//{
			//	awardVec.set(T_Achievement,0,0,achievement);
			//	awards.push_back(awardVec);
			//}
			if(taskTitleTab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),record)>=0)
			{
				for (int i = 0; i < 2; ++ i)
				{
					if (record[awardIdx[i]] == "") continue;
					crArgumentParser::appAtoVec(record[awardIdx[i]],awardVec);
					awards.push_back(awardVec);

				}
			}
			data->excHandle(MAKEINT64(WCH_LockData,1));
			sendReward(awards,playergamedata.get(),"任务奖励");
			data->excHandle(MAKEINT64(WCH_LockData,0));
			*m_output = true;
			//rewarditemindex[2] = taskTitleTab->getTitleIndex("类型2");
			//rewarditemindex[3] = taskTitleTab->getTitleIndex("奖励2");
			//crVector3i vec3;
			//
			//int itemtypeindex = itemtab->getTitleIndex("类型");
			//if (taskidindex > 0 && taskTitleTab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),recordtask)>=0 && rewarditemindex[0] > 0
			//	&& rewarditemindex[1] > 0 && rewarditemindex[2] > 0 && rewarditemindex[3] > 0)
			//{
			//	int zhanquancount = 0;
			//	for (int j = 0;j<2;j++)
			//	{
			//		if (atoi(recordtask[j==0?rewarditemindex[0]:rewarditemindex[2]].c_str()) == T_Item)
			//		{
			//			crArgumentParser::appAtoVec(recordtask[j==0?rewarditemindex[1]:rewarditemindex[3]],vec3);
			//			if (vec3[0]>0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(vec3[0]),recorditem)>=0)
			//			{
			//				if (atoi(recorditem[itemtypeindex].c_str()) == IT_Jiangka)
			//				{
			//					jiangkaitem.push_back(vec3);
			//				}
			//				else
			//				{
			//					bagitem.push_back(vec3);
			//				}
			//			}
			//		}
			//		else if(atoi(recordtask[j==0?rewarditemindex[0]:rewarditemindex[2]].c_str()) == T_Zhanquan)
			//		{
			//			zhanquancount = atoi(recordtask[j==0?rewarditemindex[1]:rewarditemindex[3]].c_str());
			//		}
			//	}
			//	crPlayerGameData *gameData = playerData->getPlayerGameData();
			//	crData *data = gameData->getDataClass();
			//	data->excHandle(MAKEINT64(WCH_LockData,1));
			//	//物品奖励的时候需要判断玩家包裹里是否有空位
			//	bool canrefer1 = false;
			//	bool canrefer2 = false;
			//	int emptybag = 0;
			//	data->getParam(WCHDATA_JXJItemBagVec,param);
			//	JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			//	data->getParam(WCHDATA_JXJJiangkaBagVec,param);
			//	JXJItemBagVec *cardbagvec = (JXJItemBagVec *)param;
			//	if (!bagitem.empty())
			//	{
			//		for (JXJItemBagVec::iterator itr = itembagvec->begin(); itr!=itembagvec->end();++itr)
			//		{
			//			if ((*itr) == NULL)
			//			{
			//				emptybag ++;
			//				if (emptybag >= bagitem.size())
			//				{
			//					canrefer1 = true;
			//					break;
			//				}
			//			}
			//		}
			//	}
			//	else
			//	{
			//		canrefer1 = true;
			//	}
			//	if (!jiangkaitem.empty())
			//	{
			//		emptybag = 0;
			//		for (JXJItemBagVec::iterator itr = cardbagvec->begin(); itr!=cardbagvec->end();++itr)
			//		{
			//			if ((*itr) == NULL)
			//			{
			//				emptybag ++;
			//				if (emptybag >= jiangkaitem.size())
			//				{
			//					canrefer2 = true;
			//					break;
			//				}
			//			}
			//		}
			//	}
			//	else
			//	{
			//		canrefer2 = true;
			//	}
			//	if (canrefer1 && canrefer2)
			//	{
			//		RewardItemVec rewardItems;
			//		ref_ptr<crBagItemData> itemdata;
			//		unsigned char type = 0;
			//		for (std::vector<crVector3i>::iterator vitr = bagitem.begin(); vitr != bagitem.end(); ++vitr)
			//		{
			//			itemdata = new crBagItemData;
			//			itemdata->setItemID((*vitr)[0]);
			//			itemdata->setEquipMagic((*vitr)[1]);
			//			itemdata->setItemCount((*vitr)[2]);
			//			rewardItems.push_back(itemdata);
			//		}
			//		for (std::vector<crVector3i>::iterator vitr = jiangkaitem.begin(); vitr != jiangkaitem.end(); ++vitr)
			//		{
			//			itemdata = new crBagItemData;
			//			itemdata->setItemID((*vitr)[0]);
			//			//itemdata->setEquipMagic((*vitr)[1]);
			//			itemdata->setItemCount((*vitr)[2]);
			//			rewardItems.push_back(itemdata);
			//		}
			//		if(!rewardItems.empty())
			//			gameData->doEvent(WCH_JXJRecvRewardItems,MAKEINT64(&rewardItems,type));
			//		if(zhanquancount != 0 && playergamedata.valid())
			//			playergamedata->doEvent(WCH_JXJRecvZhengZanQuan,MAKEINT64(zhanquancount,NULL));
			//	}
			//	else
			//	{
			//		*m_output = false;
			//	}
			//	data->excHandle(MAKEINT64(WCH_LockData,0));
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvReferTaskMethod
//
/////////////////////////////////////////
crJXJRecvReferTaskMethod::crJXJRecvReferTaskMethod():
	m_netType(GameClient_Game){}
crJXJRecvReferTaskMethod::crJXJRecvReferTaskMethod(const crJXJRecvReferTaskMethod& handle):
	crMethod(handle),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvReferTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvReferTaskMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tipcontent = str;
		break;
	default:
		break;
	}
}
void crJXJRecvReferTaskMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				bool success = false;
				char extcode = 0;
				int taskid = m_stream->_readInt();
				void *param;
				crData *metierData = m_this->getMetierDataClass();
				if(metierData)
				{
					ref_ptr<crGameTask> gameTask;
					metierData->getParam(WCHDATA_GameTaskMap,param);
					metierData->excHandle(MAKEINT64(WCH_LockData,1));
					GameTaskMap* gameTaskMap = (GameTaskMap* )param;
					GameTaskMap::iterator itr = gameTaskMap->find(taskid);
					gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
					metierData->excHandle(MAKEINT64(WCH_LockData,0));
					if(gameTask.valid() && gameTask->isTaskCanRefer())
					{
						//bool firsttasksuccess = true;
						//if(taskid == 1)
						//{//第一个任务，交还部队
						//	crPlayerGameData *playerGameData = playerData->getPlayerGameData();
						//	crData *pdata = playerGameData->getDataClass();
						//	pdata->excHandle(MAKEINT64(WCH_LockData,1));
						//	do 
						//	{
						//		pdata->getParam(WCHDATA_JXJFormationInfoVec,param);
						//		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
						//		if(formationInfoVec->size()<3)
						//		{
						//			firsttasksuccess = false;
						//			break;
						//		}
						//		crVector4i troops[3];
						//		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops1),troops[0]);
						//		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops2),troops[1]);
						//		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJXumuTroops3),troops[2]);
						//		bool same = true;
						//		crVector4i info;
						//		for( int i = 0; i<3; i++)
						//		{
						//			if(!(*formationInfoVec)[i].valid())
						//			{
						//				same = false;
						//				break;
						//			}
						//			info.set((*formationInfoVec)[i]->getAbstractID(),(*formationInfoVec)[i]->getCount(),(*formationInfoVec)[i]->getEquips()[0],(*formationInfoVec)[i]->getEquips()[1]);
						//			if(info!=troops[i])
						//			{
						//				same = false;
						//				break;
						//			}
						//		}
						//		if(!same)
						//		{
						//			firsttasksuccess = false;
						//			break;
						//		}
						//		formationInfoVec->clear();
						//	} while (0);
						//	pdata->excHandle(MAKEINT64(WCH_LockData,0));
						//	if(!firsttasksuccess)
						//	{//需要改成发包给客户端，提示玩家角色创建错误，需要重新创建角色，玩家点击确定后重启游戏登录后进入重新创建角色流程
						//		crKickoffPlayerPacket kpacket;
						//		crKickoffPlayerPacket::buildReplyPacket(kpacket,playerid);
						//		netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),kpacket);
						//		netConductor->getNetDataManager()->removePlayerData(playerid);
						//		crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netConductor->getNetDataManager()->getNetCallback());
						//		callback->removeDropedPlayer(playerData.get());

						//		crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						//		if(dbConductor)
						//		{
						//			crDBSavePacket packet;
						//			ref_ptr<crUpdatePlayerGameData> updatePlayerGameData = new crUpdatePlayerGameData;
						//			updatePlayerGameData->buildUpdateSql(playerGameData->getID(),NULL);
						//			crDBSavePacket::buildRequestPacket(packet,GameDB,playerData->getGameDBID(),updatePlayerGameData.get());
						//			dbConductor->getNetManager()->sendPacket("all",packet);
						//		}
						//	}
						//}
						//if(firsttasksuccess)
						//{
						if(taskid == 1)
						{//第一个任务，交还部队
							crData *data = m_this->getDataClass();
							data->getParam(WCHDATA_Level,param);
							unsigned char lv = *(unsigned char *)param;
							//const CRCore::crVector2ub& lvrange = gameTask->getLvRange();
							if(lv==1)
							{//lv==1
								crPlayerGameData *playerGameData = playerData->getPlayerGameData();
								crData *pdata = playerGameData->getDataClass();
								pdata->excHandle(MAKEINT64(WCH_LockData,1));
								pdata->getParam(WCHDATA_JXJFormationInfoVec,param);
								FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
								formationInfoVec->clear();
								pdata->getParam(WCHDATA_JXJSavedFormationIndex,param);
								unsigned char savedformationindex = *(unsigned char *)param;
								pdata->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
								SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
								if(savedformationindex < savedformationVec->size()) 
									(*savedformationVec)[savedformationindex].second.clear();
								pdata->excHandle(MAKEINT64(WCH_LockData,0));
								extcode = 1;
							}
						}
						m_this->doMetierEvent(WCH_TASKAWARD,MAKEINT64(gameTask.get(),&success));
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						if(success)
						{
							gameTask->refer();
							m_this->doEvent(WCH_JXJServerActiveTask);
							//send result
							stream->createBuf(6);
							stream->_writeBool(success);
							stream->_writeInt(taskid);
							if(taskid==1) stream->_writeChar(extcode);

							crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
							if(dbConductor)
							{//任务日志
								crNetDataManager *netDataManager = netConductor->getNetDataManager();
								crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
								int serverid = callback->getServerID();
								crDBSavePacket dbpacket;
								ref_ptr<crJXJInsertTaskrecord> insertTaskrecord = new crJXJInsertTaskrecord;
								insertTaskrecord->buildUpdateSql(playerid,serverid,m_this->getIName(),taskid,TS_Complete,gameTask->getTaskProgress());
								crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
								dbConductor->getNetManager()->sendPacket("all",dbpacket);
							}
							crData *data = m_this->getDataClass();
							data->getParam(WCHDATA_JXJQiyuTaskID,param);
							int qiyutaskid = *(int *)param;
							if(taskid == qiyutaskid)
							{
								data->excHandle(MAKEINT64(WCH_LockData,1));
								data->getParam(WCHDATA_JXJQiyuCompleteCount,param);
								unsigned char* qiyucount = (unsigned char *)param;
								(*qiyucount)++;
								data->excHandle(MAKEINT64(WCH_LockData,0));
							}
						}
						else
						{
							stream->createBuf(5);
							stream->_writeBool(success);
							stream->_writeInt(taskid);
						}
						crJXJPlayerMetierEventPacket packet;
						crJXJPlayerMetierEventPacket::buildReplyPacket(packet,playerid,WCH_RecvReferTask,stream.get());
						netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool success = m_stream->_readBool();
			int taskid = m_stream->_readInt();
			void *param;
			if (success)
			{
				if(taskid == 1)
				{//第一个任务，交还部队
					char extcode = m_stream->_readUChar();
					if(extcode==1)
					{
						crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
						crData *pdata = playerGameData->getDataClass();
						pdata->excHandle(MAKEINT64(WCH_LockData,1));
						pdata->getParam(WCHDATA_JXJFormationInfoVec,param);
						FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
						formationInfoVec->clear();
						pdata->getParam(WCHDATA_JXJSavedFormationIndex,param);
						unsigned char savedformationindex = *(unsigned char *)param;
						pdata->getParam(WCHDATA_JXJSavedFormationInfoVec,param);
						SavedFormationInfoVec *savedformationVec = (SavedFormationInfoVec *)param;
						if(savedformationindex < savedformationVec->size()) 
							(*savedformationVec)[savedformationindex].second.clear();
						pdata->excHandle(MAKEINT64(WCH_LockData,0));
					}
				}
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJQiyuTaskID,param);
				int qiyutaskid = *(int *)param;
				if(taskid == qiyutaskid)
				{
					data->excHandle(MAKEINT64(WCH_LockData,1));
					data->getParam(WCHDATA_JXJQiyuCompleteCount,param);
					unsigned char* qiyucount = (unsigned char *)param;
					(*qiyucount)++;
					data->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
			else if(m_this->getMetierDataClass())
			{
				crData *metierData = m_this->getMetierDataClass();
				ref_ptr<crGameTask> gameTask;
				metierData->getParam(WCHDATA_GameTaskMap,param);
				metierData->excHandle(MAKEINT64(WCH_LockData,1));
				GameTaskMap* gameTaskMap = (GameTaskMap* )param;
				GameTaskMap::iterator itr = gameTaskMap->find(taskid);
				gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
				metierData->excHandle(MAKEINT64(WCH_LockData,0));
				if(gameTask.valid())
				{
					gameTask->setTaskProgress(gameTask->getTaskSteps()-1);
				}
				std::string tipstr = "请先整理背包和将卡背包，使其分别有4格空间！";
				ref_ptr<crCanvasNode> tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
				if (tipcanvas.valid())
				{
					crStaticTextWidgetNode *tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					if (tipcontent)
					{
						tipcontent->setString(tipstr);
					}
					crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
				}
			}
			crCanvasNode *canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_RenWu");
			if(canvas)
			{
				canvas->doEvent(WCH_UI_UpdateData);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJResetTaskMethod
//
/////////////////////////////////////////
crJXJResetTaskMethod::crJXJResetTaskMethod():
	m_taskid(0),
	m_scriptadd(false)
{
}
crJXJResetTaskMethod::crJXJResetTaskMethod(const crJXJResetTaskMethod& handle):
	crMethod(handle),
	m_taskid(handle.m_taskid),
	m_scriptadd(handle.m_scriptadd)
{
}
void crJXJResetTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(!m_scriptadd && param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_taskid = LOINT64(param64);
		}
		break;
	}
}
void crJXJResetTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskid = atoi(str.c_str());
		m_scriptadd = true;
		break;
	}
}
void crJXJResetTaskMethod::operator()(crHandle &handle)
{
	if(crMyPlayerData::getInstance()->getPlayerGameData())
	{
		crRole *mainrole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
		void *param;
		crData *metierData = mainrole->getMetierDataClass();
		if(metierData)
		{
			//metierData->getParam(WCHDATA_CurrentTaskID,param);
			//int taskid = *(int *)param;
			ref_ptr<crGameTask> gameTask;
			metierData->excHandle(MAKEINT64(WCH_LockData,1));
			metierData->getParam(WCHDATA_GameTaskMap,param);
			GameTaskMap* gameTaskMap = (GameTaskMap* )param;
			GameTaskMap::iterator itr = gameTaskMap->find(m_taskid);
			gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
			if(gameTask.valid() && m_taskid != 1 && !gameTask->isComplete())
			{
				gameTask->setTaskProgress(0);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(m_taskid);
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				if(netConductor)
				{//client to server
					crJXJServerMetierEventPacket packet;
					crJXJServerMetierEventPacket::buildRequestPacket(packet,WCH_RecvResetTask,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			metierData->excHandle(MAKEINT64(WCH_LockData,0));
			crJXJCheckOpenFubenTipCanvasMethod::m_trueExecCount = 1;
			crJXJCheckOpenFubenTipCanvasTwoMethod::m_trueExecCount = 1;
			crCanvasNode *canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_RenWu");
			if(canvas)
			{
				canvas->doEvent(WCH_UI_UpdateData);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvResetTaskMethod
//
/////////////////////////////////////////
crJXJRecvResetTaskMethod::crJXJRecvResetTaskMethod():
	m_netType(GameClient_Game){}
crJXJRecvResetTaskMethod::crJXJRecvResetTaskMethod(const crJXJRecvResetTaskMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvResetTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvResetTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvResetTaskMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				int taskid = m_stream->_readInt();
				void *param;
				crData *metierData = m_this->getMetierDataClass();
				if(metierData)
				{
					ref_ptr<crGameTask> gameTask;
					metierData->getParam(WCHDATA_GameTaskMap,param);
					metierData->excHandle(MAKEINT64(WCH_LockData,1));
					GameTaskMap* gameTaskMap = (GameTaskMap* )param;
					GameTaskMap::iterator itr = gameTaskMap->find(taskid);
					gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
					metierData->excHandle(MAKEINT64(WCH_LockData,0));
					if(gameTask.valid() && taskid != 1 && !gameTask->isComplete())
					{
						gameTask->setTaskProgress(0);

						crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						if(dbConductor)
						{//任务日志
							crNetDataManager *netDataManager = netConductor->getNetDataManager();
							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
							int serverid = callback->getServerID();
							crDBSavePacket dbpacket;
							ref_ptr<crJXJInsertTaskrecord> insertTaskrecord = new crJXJInsertTaskrecord;
							insertTaskrecord->buildUpdateSql(playerid,serverid,m_this->getIName(),taskid,TS_Reset,gameTask->getTaskProgress());
							crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
							dbConductor->getNetManager()->sendPacket("all",dbpacket);
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCoppercashMethod
//
/////////////////////////////////////////
crJXJRecvCoppercashMethod::crJXJRecvCoppercashMethod():
	m_this(NULL),
	m_coppercash(0)
{
}

crJXJRecvCoppercashMethod::crJXJRecvCoppercashMethod(const crJXJRecvCoppercashMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_coppercash(0)
{
}

void crJXJRecvCoppercashMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_coppercash = LOINT64(param64);
		}
		else
		{
			m_coppercash = 0;
		}
		break;
	}
}

void crJXJRecvCoppercashMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCoppercashMethod::operator()(crHandle &handle)
{
	if(m_coppercash!=0)
	{	
		void *param;
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			crData *gameData = m_this->getDataClass();
			gameData->excHandle(MAKEINT64(WCH_LockData,1));
			gameData->getParam(WCHDATA_JXJCoppercash,param);
			int *copper = (int *)param;
			INTLIMITADD(*copper,m_coppercash,INT_MAX)

			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(*copper);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvCoppercash,stream.get());
			if (playerData.valid())
			{
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			gameData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvCoppercashMethod
//
/////////////////////////////////////////
crJXJClientRecvCoppercashMethod::crJXJClientRecvCoppercashMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvCoppercashMethod::crJXJClientRecvCoppercashMethod(const crJXJClientRecvCoppercashMethod& handle):
	crMethod(handle)
{
}
void crJXJClientRecvCoppercashMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvCoppercashMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientRecvCoppercashMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int copper = m_stream->_readInt(); 
			crData *data = m_this->getDataClass();
			if(data)
			{
				data->getParam(WCHDATA_JXJCoppercash,param);
				int extra = copper-(*(int *)param);
				data->inputParam(WCHDATA_JXJCoppercash,&copper);
				if(extra!=0)
				{
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Copper,extra));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGiftgoldMethod
//
/////////////////////////////////////////
crJXJRecvGiftgoldMethod::crJXJRecvGiftgoldMethod():
	m_this(NULL),
	m_moneydata(NULL)
{
}

crJXJRecvGiftgoldMethod::crJXJRecvGiftgoldMethod(const crJXJRecvGiftgoldMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_moneydata(handle.m_moneydata)
{
}

void crJXJRecvGiftgoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_moneydata = (MoneyChangeData *)(LOINT64(param64));
		}
		else
		{
			m_moneydata = NULL;
		}
		break;
	}
}

void crJXJRecvGiftgoldMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvGiftgoldMethod::operator()(crHandle &handle)
{
	int playerid = m_this->getPlayerID();
	int getgiftgold = m_moneydata->first;
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	//if(getgiftgold > 0)
	//{	
		void *param;
		std::string str = m_moneydata->second;
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid() && dbConductor)
		{
			crData *gameData = m_this->getDataClass();
			gameData->excHandle(MAKEINT64(WCH_LockData,1));
			gameData->getParam(WCHDATA_JXJGiftGold,param);
			int *giftgold = (int *)param;
			INTLIMITADD(*giftgold,getgiftgold,INT_MAX)

			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(*giftgold); 
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvGiftgold,stream.get());
			if (playerData.valid())
			{
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			gameData->excHandle(MAKEINT64(WCH_LockData,0));
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
			int serverid = callback->getServerID();
			//crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
			//ref_ptr<crDataBase> globalSession = db->beginSession();
			crDBSavePacket dbpacket;
			ref_ptr<crInsertPlayerGiftGold> insertPlayergiftgold = new crInsertPlayerGiftGold;
			insertPlayergiftgold->buildUpdateSql(playerid,serverid,getgiftgold,str,m_this->getAdvertid());
			crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertPlayergiftgold.get());
			dbConductor->getNetManager()->sendPacket("all",dbpacket);
			//if(globalSession->executeUpdate(insertPlayergiftgold.get()))
			//{//插入成功
			//	globalSession->commit();
			//}
			//else
			//{
			//	globalSession->rollback();
			//}
			//db->endSession(globalSession.get());	

			char buf[128];
			sprintf(buf,"%s,获得礼金,%d\0",m_moneydata->second.c_str(),m_moneydata->first);
			GameLogData gamelog(Log_RecvGiftgold,buf);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
		}
	//}
	//else
	//{
	//	CRCore::notify(CRCore::ALWAYS)<<"获得非法礼金crJXJRecvGiftgoldMethod Error 获得礼金="<<getgiftgold<<",playerid="<<playerid<<std::endl;
	//}
}
/////////////////////////////////////////
//
//crJXJClientRecvGiftgoldMethod
//
/////////////////////////////////////////
crJXJClientRecvGiftgoldMethod::crJXJClientRecvGiftgoldMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvGiftgoldMethod::crJXJClientRecvGiftgoldMethod(const crJXJClientRecvGiftgoldMethod& handle):
	crMethod(handle)
{
}
void crJXJClientRecvGiftgoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvGiftgoldMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientRecvGiftgoldMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int giftgold = m_stream->_readInt(); 
			crData *data = m_this->getDataClass();
			if(data)
			{
				data->getParam(WCHDATA_JXJGiftGold,param);
				int extra = giftgold-(*(int *)param);
				data->inputParam(WCHDATA_JXJGiftGold,&giftgold);
				if(extra!=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Giftgold,extra));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCountryContributeMethod
//
/////////////////////////////////////////
crJXJRecvCountryContributeMethod::crJXJRecvCountryContributeMethod():
	m_this(NULL),
	m_countryContribute(0)
{
}

crJXJRecvCountryContributeMethod::crJXJRecvCountryContributeMethod(const crJXJRecvCountryContributeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_countryContribute(0)
{
}

void crJXJRecvCountryContributeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_countryContribute = LOINT64(param64);
		}
		else
		{
			m_countryContribute = 0;
		}
		break;
	}
}

void crJXJRecvCountryContributeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCountryContributeMethod::operator()(crHandle &handle)
{
	if(m_countryContribute!=0)
	{	
		void *param;
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			crData *gameData = m_this->getDataClass();
			gameData->excHandle(MAKEINT64(WCH_LockData,1));
			gameData->getParam(WCHDATA_JXJCountryContribute,param);
			int *countryContribute = (int *)param;
			INTLIMITADD(*countryContribute,m_countryContribute,INT_MAX)

			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(*countryContribute);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvCountryContribute,stream.get());
			if (playerData.valid())
			{
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			gameData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvCountryContributeMethod
//
/////////////////////////////////////////
crJXJClientRecvCountryContributeMethod::crJXJClientRecvCountryContributeMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvCountryContributeMethod::crJXJClientRecvCountryContributeMethod(const crJXJClientRecvCountryContributeMethod& handle):
	crMethod(handle)
{
}
void crJXJClientRecvCountryContributeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvCountryContributeMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientRecvCountryContributeMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int countryContribution = m_stream->_readInt(); 
			crData *data = m_this->getDataClass();
			if(data)
			{
				data->getParam(WCHDATA_JXJCountryContribute,param);
				int extra = countryContribution-(*(int *)param);
				data->inputParam(WCHDATA_JXJCountryContribute,&countryContribution);
				if(extra!=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Contribute,extra));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCardPiecesMethod
//
/////////////////////////////////////////
crJXJRecvCardPiecesMethod::crJXJRecvCardPiecesMethod():
	m_this(NULL),
	m_jianghun(0)
{
}

crJXJRecvCardPiecesMethod::crJXJRecvCardPiecesMethod(const crJXJRecvCardPiecesMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_jianghun(0)
{
}

void crJXJRecvCardPiecesMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_jianghun = LOINT64(param64);
		}
		else
		{
			m_jianghun = 0;
		}
		break;
	}
}

void crJXJRecvCardPiecesMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCardPiecesMethod::operator()(crHandle &handle)
{
	if(m_jianghun!=0)
	{	
		void *param;
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			crData *gameData = m_this->getDataClass();
			gameData->excHandle(MAKEINT64(WCH_LockData,1));
			gameData->getParam(WCHDATA_JXJCardPieces,param);
			int *cardpieces = (int *)param;
			INTLIMITADD(*cardpieces,m_jianghun,INT_MAX)

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(*cardpieces);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvCardPieces,stream.get());
			if (playerData.valid())
			{
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			gameData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvCardPiecesMethod
//
/////////////////////////////////////////
crJXJClientRecvCardPiecesMethod::crJXJClientRecvCardPiecesMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvCardPiecesMethod::crJXJClientRecvCardPiecesMethod(const crJXJClientRecvCardPiecesMethod& handle):
	crMethod(handle)
{
}
void crJXJClientRecvCardPiecesMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvCardPiecesMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientRecvCardPiecesMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int jianghun = m_stream->_readInt(); 
			crData *data = m_this->getDataClass();
			if(data)
			{
				data->getParam(WCHDATA_JXJCardPieces,param);
				int extra = jianghun-(*(int *)param);
				data->inputParam(WCHDATA_JXJCardPieces,&jianghun);
				if(extra!=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_JiangHun,extra));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvActiveTaskVecMethod
//
/////////////////////////////////////////
crJXJRecvActiveTaskVecMethod::crJXJRecvActiveTaskVecMethod():
	m_netType(GameClient_Game){}
crJXJRecvActiveTaskVecMethod::crJXJRecvActiveTaskVecMethod(const crJXJRecvActiveTaskVecMethod& handle):
	crMethod(handle),
	m_netType(GameClient_Game)
{
}
void crJXJRecvActiveTaskVecMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvActiveTaskVecMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvActiveTaskVecMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		unsigned char size = m_stream->_readUChar();
		void *param;
		crData *metierData = m_this->getMetierDataClass();
		if(!metierData)return;
		metierData->getParam(WCHDATA_GameTaskMap,param);
		metierData->excHandle(MAKEINT64(WCH_LockData,1));
		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
		GameTaskMap::iterator taskitr;
		int taskid;
		//bool firsttask = false;
		for( int i = 0; i<size; i++)
		{
			taskid = m_stream->_readInt();
			//if(taskid == 1)
			//	firsttask = true;
			taskitr = gameTaskMap->find(taskid);
			if(taskitr!=gameTaskMap->end())
			{
				taskitr->second->setActivation(true);
			}
		}
		metierData->excHandle(MAKEINT64(WCH_LockData,0));
		crCanvasNode *canvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_RenWu");
		if(canvas)
		{
			canvas->doEvent(WCH_UI_UpdateData);
		}
		//if(firsttask)
		//{//第一个任务，交还部队
		//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		//	crData *pdata = playerGameData->getDataClass();
		//	pdata->excHandle(MAKEINT64(WCH_LockData,1));
		//	pdata->getParam(WCHDATA_JXJFormationInfoVec,param);
		//	FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		//	formationInfoVec->clear();
		//	pdata->excHandle(MAKEINT64(WCH_LockData,0));
		//}
		////判断是否有新手任务，如果有，则出现新手提示箭头
	}
}
/////////////////////////////////////////
//
//crJXJNewHandUIInitMethod
//
/////////////////////////////////////////
crJXJNewHandUIInitMethod::crJXJNewHandUIInitMethod():
m_taskid(NULL){}
crJXJNewHandUIInitMethod::crJXJNewHandUIInitMethod(const crJXJNewHandUIInitMethod& handle):
	crMethod(handle),
	m_rectCanvasName(handle.m_rectCanvasName),
	m_taskid(handle.m_taskid),
	m_targetCanvasName(handle.m_targetCanvasName),
	m_targetWidgetName(handle.m_targetWidgetName)
{
}
void crJXJNewHandUIInitMethod::inputParam(int i, void *param)
{
}
void crJXJNewHandUIInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_rectCanvasName = str;
		break;
	case 1:
		m_taskid = atoi(str.c_str());
		break;
	case 2:
		m_targetCanvasName = str;
		break;
	case 3:
		m_targetWidgetName = str;
		break;
	case 4:
		m_targetCanvasPos = str;
		break;
	}
}
void crJXJNewHandUIInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> rectCanvas = crFilterRenderManager::getInstance()->findCanvas(m_rectCanvasName);
	ref_ptr<crCanvasNode> renwucanvas = crFilterRenderManager::getInstance()->findCanvas("UI_ManorStair_RenWu");
	if(rectCanvas.valid() && renwucanvas.valid())
	{
		crData *data = renwucanvas->getDataClass();
		if(!data)return;
		data->inputParam(WCHDATA_JXJNewHandTaskID,&m_taskid);
		data->inputParam(WCHDATA_JXJTargetCanvasName,&m_targetCanvasName);
		data->inputParam(WCHDATA_JXJTargetWidgetName,&m_targetWidgetName);
		data->inputParam(WCHDATA_JXJRectCanvasName,&m_rectCanvasName);
		ref_ptr<crCanvasNode> targetCanvas = crFilterRenderManager::getInstance()->findCanvas(m_targetCanvasName);
		if(!targetCanvas)return;
		crWidgetNode *targetWidget = targetCanvas->getWidget(m_targetWidgetName);
		if(!targetWidget)return;
		crMatrix mat = targetCanvas->getMatrix();
		crVector3 pos = targetWidget->getBound().center();
		pos = pos * mat;
		rectCanvas->setPosition(pos);
	}
}
/////////////////////////////////////////
//
//crJXJSwitchModelMethod
//
/////////////////////////////////////////
crJXJSwitchModelMethod::crJXJSwitchModelMethod():
m_this(NULL),
m_swNode(NULL){}
crJXJSwitchModelMethod::crJXJSwitchModelMethod(const crJXJSwitchModelMethod& handle):
crMethod(handle),
m_this(handle.m_this),
m_swNode(handle.m_swNode),
m_switchNodeName(handle.m_switchNodeName),
m_swvalue(handle.m_swvalue)
{
}
void crJXJSwitchModelMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJSwitchModelMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_switchNodeName = str;
		break;
	case 1:
		m_swvalue = atoi(str.c_str());
		break;
	}
}
void crJXJSwitchModelMethod::operator()(crHandle &handle)
{
	if(!m_swNode)
	{
		crNode *relNode = m_this->getRelNode();
		if(!relNode)return;
		CRCore::crSearchNodeBYNameVisitor searchByNameVisitor;
		searchByNameVisitor.setNameId(m_switchNodeName);
		searchByNameVisitor.setSearchNodeType(MULTISWITCH);
		relNode->accept(searchByNameVisitor);
		m_swNode = dynamic_cast<crMultiSwitch *>(searchByNameVisitor.getResult());
	}
	if(m_swNode)
	{
		m_swNode->setActiveSwitchSet(m_swvalue);
	}
}
/////////////////////////////////////////
//
//crJXJTouchItemMethod
//
/////////////////////////////////////////
crJXJTouchItemMethod::crJXJTouchItemMethod():
	m_itemid(0){}
crJXJTouchItemMethod::crJXJTouchItemMethod(const crJXJTouchItemMethod& handle):
	crMethod(handle),
	m_itemid(handle.m_itemid)
{
}
void crJXJTouchItemMethod::inputParam(int i, void *param)
{
}
void crJXJTouchItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemid = atoi(str.c_str());
		break;
	}
}
void crJXJTouchItemMethod::operator()(crHandle &handle)
{
	CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
	if(scene)
	{
		crInstanceItem *item = scene->findSceneItem(m_itemid);
		if(item)
		{
			item->doEvent(WCH_Touch);
		}
	}
}

///////////////////////////////////////////
////
////crJXJAutoCheckAndReferTaskMethod
////
///////////////////////////////////////////
//crJXJAutoCheckAndReferTaskMethod::crJXJAutoCheckAndReferTaskMethod():
//	m_this(NULL)
//{
//}
//crJXJAutoCheckAndReferTaskMethod::crJXJAutoCheckAndReferTaskMethod(const crJXJAutoCheckAndReferTaskMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJAutoCheckAndReferTaskMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//void crJXJAutoCheckAndReferTaskMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJAutoCheckAndReferTaskMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(playerData)
//	{
//		crRole *mainRole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
//		if(!mainRole || !mainRole->getMetierDataClass()) return;
//		crData *uidata = m_this->getDataClass();
//		if(!uidata)return;
//		void *param;
//		uidata->getParam(WCHDATA_JXJRectCanvasName,param);
//		std::string rectCanvasName = *(std::string *)param;
//		ref_ptr<crCanvasNode> rectcanvas = crFilterRenderManager::getInstance()->findCanvas(rectCanvasName);
//		uidata->getParam(WCHDATA_JXJNewHandTaskID,param);
//		int taskid = *(int *)param;
//		if (taskid > 0)
//		{
//			crData *myMetierData = mainRole->getMetierDataClass();
//			if(!myMetierData)return;
//			myMetierData->excHandle(MAKEINT64(WCH_LockData,1));
//			myMetierData->getParam(WCHDATA_GameTaskMap,param);
//			GameTaskMap *gameTaskMap = (GameTaskMap *)param;
//			if(gameTaskMap)
//			{
//				for (GameTaskMap::iterator itr = gameTaskMap->begin(); itr != gameTaskMap->end(); ++itr)
//				{
//					if (itr->second!=NULL)
//					{
//						if ( taskid == itr->second->getTaskID())
//						{
//							if(itr->second->isTaskCanRefer())
//							{
//								itr->second->doEvent(WCH_JXJAutoReferTask);
//								break;
//							}
//							else if (itr->second->isTaskCanAdvance(CRNetApp::TS_Zero))
//							{
//								itr->second->doEvent(WCH_JXJAutoAdvanceTask,MAKEINT64(CRNetApp::TS_Zero,NULL));
//								break;
//							}
//						}
//					}
//				}
//			}
//			myMetierData->excHandle(MAKEINT64(WCH_LockData,0));
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJCheckBuildingLvMethod
//
/////////////////////////////////////////
crJXJCheckBuildingLvMethod::crJXJCheckBuildingLvMethod():
	m_buildingid(0),
	m_lv(0),
	m_trueExecCount(1)
{
}
crJXJCheckBuildingLvMethod::crJXJCheckBuildingLvMethod(const crJXJCheckBuildingLvMethod& handle):
	crMethod(handle),
	m_buildingid(handle.m_buildingid),
	m_lv(handle.m_lv),
	m_trueExecCount(handle.m_trueExecCount)
{
}
void crJXJCheckBuildingLvMethod::inputParam(int i, void *param)
{
}
void crJXJCheckBuildingLvMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_buildingid = atoi(str.c_str());
		break;
	case 1:
		m_lv = (unsigned char)(atoi(str.c_str()));
		break;
	case 2:
		m_trueExecCount = (char)(atoi(str.c_str()));
		break;
	}
}
void crJXJCheckBuildingLvMethod::operator()(crHandle &handle)
{
	bool check = false;
	if(m_trueExecCount != 0)
	{
		crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
		if(playerData && playerData->getDataClass())
		{
			void *param;
			crData *data = playerData->getDataClass();
			if(!data)return;
			data->getParam(m_buildingid,param);
			unsigned char lv = *(unsigned char *)param;
			if(lv>=m_lv)
			{
				check = true;
				if (m_trueExecCount > 0)
					m_trueExecCount--;
			}
		}
	}
	handle.outputParam(0,&check);
}
/////////////////////////////////////////
//
//crJXJAutoReferMeMethod
//
/////////////////////////////////////////
crJXJAutoReferMeMethod::crJXJAutoReferMeMethod()
{
}
crJXJAutoReferMeMethod::crJXJAutoReferMeMethod(const crJXJAutoReferMeMethod& handle):
crMethod(handle)
{
}
void crJXJAutoReferMeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJAutoReferMeMethod::addParam(int i, const std::string& str)
{
}
void crJXJAutoReferMeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		crData *data = m_this->getParentCanvas()->getDataClass();
		if(!data)return;
		void *param;
		data->getParam(WCHDATA_JXJGetRenWuRewardID,param);
		int taskid = *(int *)param;
		playerData->doEvent(WCH_JXJReferTask,MAKEINT64(taskid,NULL));
	}
}
/////////////////////////////////////////
//
//crJXJAutoAdvanceMeMethod
//
/////////////////////////////////////////
crJXJAutoAdvanceMeMethod::crJXJAutoAdvanceMeMethod():
	m_stepType(0)
{
}
crJXJAutoAdvanceMeMethod::crJXJAutoAdvanceMeMethod(const crJXJAutoAdvanceMeMethod& handle):
	crMethod(handle),
	m_stepType(0)
{
}
void crJXJAutoAdvanceMeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crGameTask*)param;
		break;
	//case 2:
	//	if(param)
	//	{
	//		_crInt64 param64 = *(_crInt64*)param;
	//		m_stepType = LOINT64(param64);
	//	}
	//	break;
	}
}
void crJXJAutoAdvanceMeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_stepType = atoi(str.c_str());
		break;
	}
}
void crJXJAutoAdvanceMeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData && playerData->getDataClass())
	{
		playerData->doEvent(WCH_JXJAdvanceTask,MAKEINT64(m_this->getTaskID(),m_stepType));
	}
}

/////////////////////////////////////////
//
//crJXJNewHandBtnClickMethod
//
/////////////////////////////////////////
crJXJNewHandBtnClickMethod::crJXJNewHandBtnClickMethod():
	m_flag(0)
{}
crJXJNewHandBtnClickMethod::crJXJNewHandBtnClickMethod(const crJXJNewHandBtnClickMethod& handle):
	crMethod(handle),
	m_this(handle.m_this),
	m_renwucanvas(handle.m_renwucanvas),
	m_Barrackscanvas(handle.m_Barrackscanvas),
	m_ArmyRaido(handle.m_ArmyRaido),
	m_jiangKaBagCanvas(handle.m_jiangKaBagCanvas),
	m_jiangKaColorRadio(handle.m_jiangKaColorRadio),
	m_flag(handle.m_flag),
	m_jiangKaSystemRadio(handle.m_jiangKaSystemRadio),
	m_ArmySelRaido(handle.m_ArmySelRaido),
	m_gongfangCanvas(handle.m_gongfangCanvas),
	m_gongfangRaido(handle.m_gongfangRaido),
	m_kejiRaido(handle.m_kejiRaido)
{
}
void crJXJNewHandBtnClickMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJNewHandBtnClickMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_renwucanvas = str;
		break;
	case 1:
		m_Barrackscanvas = str;
		break;
	case 2:
		m_ArmyRaido = str;
		break;
	case 3:
		m_jiangKaBagCanvas = str;
		break;
	case 4:
		m_jiangKaColorRadio = str;
		break;
	case 5:
		m_jiangKaSystemRadio = str;
		break;
	case 6:
		m_ArmySelRaido = str;
		break;
	case 7:
		m_gongfangCanvas = str;
		break;
	case 8:
		m_gongfangRaido = str;
		break;
	case 9:
		m_kejiRaido = str;
		break;
	default:
		break;
	}
}
void crJXJNewHandBtnClickMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!playerData)return;
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();//强制选择窗口
	if(!canvas)return;
	ref_ptr<crCanvasNode> renwucanvas = crFilterRenderManager::getInstance()->findCanvas(m_renwucanvas);//右侧任务界面
	if(!renwucanvas)return;
	void *param;
	crData *data = renwucanvas->getDataClass();
	if(!data)return;
	data->getParam(WCHDATA_JXJNewHandTaskID,param);
	int taskid = *(int *)param;
	///
	crFilterRenderManager::getInstance()->closeCanvas(canvas.get());
	///
	if (taskid == 7)
	{
		ref_ptr<crCanvasNode> Barrackscanvas = crFilterRenderManager::getInstance()->findCanvas(m_Barrackscanvas);
		if (Barrackscanvas.valid())
		{
			crRadioGroupWidgetNode *ArmyRaido = dynamic_cast<crRadioGroupWidgetNode *>(Barrackscanvas->getWidget(m_ArmyRaido));
			crRadioGroupWidgetNode *ArmySelRaido = dynamic_cast<crRadioGroupWidgetNode *>(Barrackscanvas->getWidget(m_ArmySelRaido));
			if (ArmySelRaido)
			{
				ArmySelRaido->select(0);
				ArmySelRaido->doEvent(WCH_UI_SelectChange);
			}
			crFilterRenderManager::getInstance()->closeCanvas(canvas.get());
			if (ArmyRaido)
			{
				if (ArmyRaido->getSelect() != 1)
				{
					ArmyRaido->select(1);
					ArmyRaido->doEvent(WCH_UI_SelectChange);
				}
			}
		}
	}
	if(taskid == 22)
	{
		ref_ptr<crCanvasNode> gongfangCanvas = crFilterRenderManager::getInstance()->findCanvas(m_gongfangCanvas);
		if (gongfangCanvas.valid())
		{
			crRadioGroupWidgetNode *gongfangRaido = dynamic_cast<crRadioGroupWidgetNode *>(gongfangCanvas->getWidget(m_gongfangRaido));
			if (gongfangRaido)
			{
				gongfangRaido->select(1);
				gongfangRaido->doEvent(WCH_UI_SelectChange);
			}
		}
	}
	if(taskid == 10001)
	{
		ref_ptr<crCanvasNode> gongfangCanvas = crFilterRenderManager::getInstance()->findCanvas(m_gongfangCanvas);
		if (gongfangCanvas.valid())
		{
			crRadioGroupWidgetNode *gongfangRaido = dynamic_cast<crRadioGroupWidgetNode *>(gongfangCanvas->getWidget(m_gongfangRaido));
			if (gongfangRaido)
			{
				gongfangRaido->select(2);
				gongfangRaido->doEvent(WCH_UI_SelectChange);
			}
		}
	}
	if(taskid == 18)
	{
		ref_ptr<crCanvasNode> jiangKaBagCanvas = crFilterRenderManager::getInstance()->findCanvas(m_jiangKaBagCanvas);
		if (jiangKaBagCanvas.valid() && jiangKaBagCanvas->getVisiable())
		{
			crRadioGroupWidgetNode *jiangKaColorRadio = dynamic_cast<crRadioGroupWidgetNode *>(jiangKaBagCanvas->getWidget(m_jiangKaColorRadio));
			crRadioGroupWidgetNode *jiangKaSystemRadio = dynamic_cast<crRadioGroupWidgetNode *>(jiangKaBagCanvas->getWidget(m_jiangKaSystemRadio));
			if (jiangKaColorRadio)
			{
				jiangKaColorRadio->select(0);
				jiangKaColorRadio->doEvent(WCH_UI_SelectChange);
			}
			if (jiangKaSystemRadio)
			{
				if (jiangKaSystemRadio->getSelect() != 1)
				{
					jiangKaSystemRadio->select(1);
					jiangKaSystemRadio->doEvent(WCH_UI_SelectChange);
				}
			}
		}
	}
	data->getParam(WCHDATA_JXJTargetCanvasName,param);
	std::string targetCanvasName = *(std::string *)param;
	data->getParam(WCHDATA_JXJTargetWidgetName,param);
	std::string targetWidgetName = *(std::string *)param;

	ref_ptr<crCanvasNode> targetCanvas = crFilterRenderManager::getInstance()->findCanvas(targetCanvasName);
	if(!targetCanvas)return;
	crWidgetNode *targetWidget = targetCanvas->getWidget(targetWidgetName);
	if(!targetWidget)return;
	targetWidget->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
}

/////////////////////////////////////////
//
//crJXJMainRoleInitMethod
//
/////////////////////////////////////////
crJXJMainRoleInitMethod::crJXJMainRoleInitMethod():
	m_this(NULL),
	m_playerGameData(NULL)
{
}
crJXJMainRoleInitMethod::crJXJMainRoleInitMethod(const crJXJMainRoleInitMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_playerGameData(NULL)
{
}
void crJXJMainRoleInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_playerGameData = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerGameData = (crPlayerGameData *)(LOINT64(param64));
		}
		break;
	}
}
void crJXJMainRoleInitMethod::addParam(int i, const std::string& str)
{
}
void crJXJMainRoleInitMethod::operator()(crHandle &handle)
{
	if(m_playerGameData)
	{
		m_playerGameData->doEvent(WCH_JXJCheckResBuildingLevel);
		void *param;
		crTableIO::StrVec record;
		ref_ptr<crTableIO>lordlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordlvTab);
		unsigned char lv = 0;
		int expneed = 0;

		int lvindex = lordlvtab->getTitleIndex("lv");
		int bingfaindex = lordlvtab->getTitleIndex("兵法");
		int zhenfaindex = lordlvtab->getTitleIndex("阵法");
		int dongchaindex = lordlvtab->getTitleIndex("洞察");
		int tongshuaiindex = lordlvtab->getTitleIndex("统率");
		crData *data = m_playerGameData->getDataClass();
		crData *maindata = m_this->getDataClass();
		if(data)data->excHandle(MAKEINT64(WCH_LockData,1));
		maindata->excHandle(MAKEINT64(WCH_LockData,1));
		maindata->getParam(WCHDATA_Level,param);
		unsigned char *mylv = (unsigned char *)param;
		//兵法
		maindata->getParam(WCHDATA_JXJBingFa,param);
		short *bingfa = (short *)param;
		//阵法
		maindata->getParam(WCHDATA_JXJZhenFa,param);
		short *zhenfa = (short *)param;
		//洞察
		maindata->getParam(WCHDATA_JXJDongCha,param);
		short *dongcha = (short *)param;
		//统率
		maindata->getParam(WCHDATA_JXJTongShuai,param);
		short *tongshuai = (short *)param;

		if(lordlvtab->queryOneRecord(lvindex,crArgumentParser::appItoa(*mylv),record)>=0)
		{
			if(bingfaindex>=0)
			{
				*bingfa = atoi(record[bingfaindex].c_str());
			}
			if(zhenfaindex>=0)
			{
				*zhenfa = atoi(record[zhenfaindex].c_str());
			}
			if(dongchaindex>=0)
			{
				*dongcha = atoi(record[dongchaindex].c_str());
			}
			if(tongshuaiindex>=0)
			{
				*tongshuai = atoi(record[tongshuaiindex].c_str());
			}
		}
		/////////////活动update
		maindata->getParam(WCHDATA_JXJNewHuodongMap,param);
		NewHuodongMap *huodongMap = (NewHuodongMap *)param;

		for( NewHuodongMap::iterator hmItr = huodongMap->begin();
			hmItr != huodongMap->end(); 
			++hmItr )
		{
			hmItr->second->activationCheck(m_this->getPlayerID());
			if(hmItr->second->getActivation()==1)
			{
				hmItr->second->doEvent(WCH_UPDATE,MAKEINT64(m_playerGameData,NULL));
			}
		}
		maindata->excHandle(MAKEINT64(WCH_LockData,0));
		if(data)data->excHandle(MAKEINT64(WCH_LockData,0));
		////////////////
		m_playerGameData->doEvent(WCH_JXJPlayerDataMonitor);
		bool mainroleinited = true;
		maindata->inputParam(WCHDATA_JXJMainRoleInited,&mainroleinited);
	}
}
/////////////////////////////////////////
//
//crJXJGameServerInitMethod
//
/////////////////////////////////////////
crJXJGameServerInitMethod::crJXJGameServerInitMethod():
	m_this(NULL)
{
}
crJXJGameServerInitMethod::crJXJGameServerInitMethod(const crJXJGameServerInitMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_version(handle.m_version)
{
}
void crJXJGameServerInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}
void crJXJGameServerInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_version = str;
		break;
	}
}
void crJXJGameServerInitMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));

	crDataBase *global_db = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
	ref_ptr<crDataBase> db_session = global_db->beginSession();

	data->getParam(WCHDATA_JXJChengChiMap,param);
	ChengchiMap *chengchiMap = (ChengchiMap *)param;
	ref_ptr<crChengchi2QueryData> chengchi2Query = new crChengchi2QueryData;
	chengchi2Query->buildQuerySql();
	db_session->executeQuery(chengchi2Query.get());
	crDataBase::QueryResultVec &chengchi2QueryResultVec = db_session->getQueryResult();
	CRCore::ref_ptr<crJXJChengfangInfo> chengfangInfo;
	for( crDataBase::QueryResultVec::iterator itr = chengchi2QueryResultVec.begin();
		 itr != chengchi2QueryResultVec.end();
		 ++itr )
	{
		chengchi2Query = dynamic_cast<crChengchi2QueryData *>(itr->get());
		chengfangInfo = new crJXJChengfangInfo;
		chengfangInfo->setStream(chengchi2Query->getStream());
		chengchiMap->insert(std::make_pair(chengchi2Query->getID(),chengfangInfo));
		//(*chengchiMap)[chengchi2Query->getID()] = chengfangInfo;
	}
	db_session->releaseQuery();


	data->getParam(WCHDATA_JXJConsortiaMap,param);
	ConsortiaMap *consortiaMap = (ConsortiaMap *)param;
	ref_ptr<crJXJConsortia> jxjConsortia;
	ref_ptr<crConsortiaQueryData> consortiaQuery = new crConsortiaQueryData;
	consortiaQuery->buildQuerySql();
	db_session->executeQuery(consortiaQuery.get());
	crDataBase::QueryResultVec &consortiaQueryResultVec = db_session->getQueryResult();
	for( crDataBase::QueryResultVec::iterator itr = consortiaQueryResultVec.begin();
		itr != consortiaQueryResultVec.end();
		++itr )
	{
		consortiaQuery = dynamic_cast<crConsortiaQueryData *>(itr->get());
		jxjConsortia = new crJXJConsortia;
		jxjConsortia->setID(consortiaQuery->getID());
		//jxjConsortia->setName(consortiaQuery->getName());
		//jxjConsortia->setCreator(consortiaQuery->getCreator());
		//jxjConsortia->setLevel(consortiaQuery->getLevel());
		//jxjConsortia->setAffiche(consortiaQuery->getAffiche());
		jxjConsortia->setCreateDate(consortiaQuery->getCreateDate());
		jxjConsortia->setUpdateDate(consortiaQuery->getUpdateDate());
		jxjConsortia->setStream(consortiaQuery->getStream());
		jxjConsortia->loadData();
		jxjConsortia->updateToRank(data);
		
		//if (jxjConsortia->willDismiss())
		//{
		//	dismissGroupMap->insert(DismissGroupMap::value_type(jxjConsortia->getID(),jxjConsortia->getDismissTime()));
		//}
		(*consortiaMap)[jxjConsortia->getID()] = jxjConsortia;

		crData * groupData = jxjConsortia->getDataClass();
		if (groupData)
		{
			groupData->getParam(WCHDATA_JXJGroupDayLastUpdate,param);
			time_t tmpTime = *(time_t *)param;
			data->inputParam(WCHDATA_JXJGroupDayLastUpdate,&tmpTime);
			groupData->getParam(WCHDATA_JXJGroupWeekLastUpdate,param);
			tmpTime = *(time_t *)param;
			data->inputParam(WCHDATA_JXJGroupWeekLastUpdate,&tmpTime);
		}
		
	}
	db_session->releaseQuery();

	//////
	ref_ptr<crJXJShili> shili;
	ref_ptr<crShiliQueryData> shiliquery = new crShiliQueryData;
	shiliquery->buildQuerySql();
	db_session->executeQuery(shiliquery.get());
	int i = 0;
	crDataBase::QueryResultVec &shiliQueryResultVec = db_session->getQueryResult();
	for( crDataBase::QueryResultVec::iterator itr = shiliQueryResultVec.begin();
		itr != shiliQueryResultVec.end();
		++itr,i++ )
	{
		shiliquery = dynamic_cast<crShiliQueryData *>(shiliQueryResultVec[i].get());
		if (shiliquery.valid())
		{
			shili = new crJXJShili;
			shili->setID(shiliquery->getID());
			//shili->setKing(shiliquery->getKing());
			//shili->setKingName(shiliquery->getKingName());
			//shili->setAffiche(shiliquery->getAffiche());
			shili->setStream(shiliquery->getStream());
			shili->loadData();
			data->inputParam(WCHDATA_JXJShiliWei+i,shili.get());

			crData * shiliData = shili->getDataClass();
			if (shiliData)
			{
				shiliData->getParam(WCHDATA_JXJShiliDayLastUpdate,param);
				time_t tmpTime = *(time_t *)param;
				data->inputParam(WCHDATA_JXJShiliDayLastUpdate,&tmpTime);
			}
		}
	}
	db_session->releaseQuery();

	crData * shiliDataPtr[3] = {NULL,NULL,NULL};
	PeopleMap *peopleMapPtr[3] = {NULL,NULL,NULL};
	char shiliOffset = 0;
	for (int i = WCHDATA_JXJShiliWei; i <= WCHDATA_JXJShiliWu; ++ i,++ shiliOffset)
	{
		data->getParam(i,param);
		shili = (crJXJShili *)param;
		if (shili.valid())
		{
			crData * shiliData = shili->getDataClass();
			if (shiliData)
			{
				shiliDataPtr[shiliOffset] = shiliData;
				shiliData->getParam(WCHDATA_JXJPeopleMap,param);
				peopleMapPtr[shiliOffset] = (PeopleMap *)param;

				shiliData->getParam(WCHDATA_JXJShiliVersion,param);
				int shiliVersion = *(int *)param;
				if (shiliVersion < JXJVERSION_0010)
				{
					for (PeopleMap::iterator pmItr = peopleMapPtr[shiliOffset]->begin();
						pmItr != peopleMapPtr[shiliOffset]->end(); ++ pmItr)
					{
						pmItr->second->setShili(shili->getID());
						pmItr->second->needInsert();
					}
				}
			}
		}
	}
	int start = 0;
	const int count = 1000;
	bool breakLoop =  false;

	ref_ptr<crJXJPeopleMapQueryData> peopleMapQuery = new crJXJPeopleMapQueryData;
	while (!breakLoop)
	{
		peopleMapQuery->buildQuerySql(start,count);
		db_session->executeQuery(peopleMapQuery.get());

		int i = 0;
		crDataBase::QueryResultVec &peopleMapQueryVec = db_session->getQueryResult();

		CRCore::notify(CRCore::ALWAYS)<<"peopleMapQueryVec Size is :"<< peopleMapQueryVec.size() <<std::endl;
		for( crDataBase::QueryResultVec::iterator itr = peopleMapQueryVec.begin();
			itr != peopleMapQueryVec.end();
			++itr,i++ )
		{
			peopleMapQuery = dynamic_cast<crJXJPeopleMapQueryData*>(peopleMapQueryVec[i].get());
			if (peopleMapQuery.valid() &&
				peopleMapQuery->getShili() >= c_startShiliID)
			{
				shiliOffset = peopleMapQuery->getShili() - c_startShiliID;
				if (shiliDataPtr[shiliOffset])
				{
					shiliDataPtr[shiliOffset]->excHandle(MAKEINT64(WCH_LockData,1));
					if (peopleMapPtr[shiliOffset])
					{
						CRCore::ref_ptr<PeopleInfo> people = new PeopleInfo(peopleMapQuery->getPlayerID(),peopleMapQuery->getName(),
							peopleMapQuery->getShili());
						people->setConsortiaID(peopleMapQuery->getConsortiaID(),false);
						people->setDeadTroopsNum(peopleMapQuery->getDeadTroopsNum(),false);
						people->setKillNum(peopleMapQuery->getKillNum(),false);
						people->setLv(peopleMapQuery->getLv(),false);
						people->setNewrStep(peopleMapQuery->getNewerStep(),false);
						people->setSamllAcc(peopleMapQuery->getSmallAcc(),false);
						people->setTroopsLv(peopleMapQuery->getTroopsLv(),false);
						people->setGiftGold(peopleMapQuery->getGiftGold(),false);
						people->setTotalRecharge(peopleMapQuery->getRecharge(),false);
						people->setTroopsnum(peopleMapQuery->gettroopsnum());
						people->setExploit(peopleMapQuery->getexploit());
						ConsortiaMap::iterator cmItr = consortiaMap->find(people->getConsortiaId())  ;
						if (cmItr != consortiaMap->end())
						{
							std::string groupName;
							cmItr->second->getName(groupName);
							people->setConsortiaName(groupName);
						}
						shiliDataPtr[shiliOffset]->getParam(WCHDATA_JXJCountrySmallAccNum ,param);
						short *smallAccCount = (short *)param;
						if (people->getSmallAcc())
						{
							++ (*smallAccCount );
						}
						peopleMapPtr[shiliOffset]->insert(PeopleMap::value_type(people->getID(),people));


					}
					shiliDataPtr[shiliOffset]->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
		start += count;
		breakLoop = peopleMapQueryVec.size() < count;
		db_session->releaseQuery();
	}

	/////
	global_db->endSession(db_session.get());
	data->excHandle(MAKEINT64(WCH_LockData,0));
	crGlobalHandle::setVersion(readVersion(m_version));
	CRCore::notify(CRCore::ALWAYS)<<"crJXJGameServerInitMethod Version:"<<crGlobalHandle::getVersion()<<std::endl;
	//sprintf(gDebugInfo->buf(),"crJXJGameServerInitMethod Version:%d\n\0",crGlobalHandle::getVersion());
	//gDebugInfo->debugInfo(CRCore::ALWAYS);
}
int crJXJGameServerInitMethod::readVersion(const std::string &filename)
{
	std::ifstream fin(filename.c_str(), std::ios_base::in|std::ios::binary);
	if(!fin)
		return 0;
	int ver = 0;
	fin.seekg(0, std::ios::end); 
	int count  =  fin.tellg();
	fin.seekg(0, std::ios::beg);
	char *buf = new char[count+1];
	memset(buf,0,count+1);
	fin.read(buf,count);
	crArgumentParser::readKeyValue(buf,"version",ver);
	fin.close();
	delete [] buf;
	return ver;
}
/////////////////////////////////////////
//
//crJXJQuickUseBagItemMethod
//
/////////////////////////////////////////
crJXJQuickUseBagItemMethod::crJXJQuickUseBagItemMethod():
	m_this(NULL)
{
}
crJXJQuickUseBagItemMethod::crJXJQuickUseBagItemMethod(const crJXJQuickUseBagItemMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJQuickUseBagItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crJXJQuickUseBagItemMethod::addParam(int i, const std::string& str)
{
}
void crJXJQuickUseBagItemMethod::operator()(crHandle &handle)
{
	bool taskcancel = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crListControlNode *selectNode = m_this->getSelectNode();
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJOpenBagNum,param);
		unsigned char openbagnum = *(unsigned char *)param;
		if(selectNode)
		{
			//int selectid = selectNode->getData();
			unsigned char selectid = selectNode->getData();//(unsigned char)m_this->MouseOnNodeIndex(m_ea->getXnormalized(),m_ea->getYnormalized());
			if (selectid>=0 && selectid < openbagnum)
			{
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->inputParam(WCHDATA_JXJSaleItemID,&selectid);
				taskcancel = false;
			}
		}
	}
	handle.outputParam(0,&taskcancel);
}
/////////////////////////////////////////
//
//crJXJAccomplishUpdateMethod
//
/////////////////////////////////////////
crJXJAccomplishUpdateMethod::crJXJAccomplishUpdateMethod():
	m_dt(NULL)
{
}
crJXJAccomplishUpdateMethod::crJXJAccomplishUpdateMethod(const crJXJAccomplishUpdateMethod& handle):
	crMethod(handle),
	m_dt(NULL)
{
}
void crJXJAccomplishUpdateMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crJXJAccomplishUpdateMethod::addParam(int i, const std::string& str)
{
}
void crJXJAccomplishUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && myPlayer->getMainRole())
	{
		crData *data = myPlayer->getDataClass();
		crData *roleData = myPlayer->getMainRole()->getDataClass();
		void *param;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		roleData->excHandle(MAKEINT64(WCH_LockData,1));
		roleData->getParam(WCHDATA_JXJAccomplishMap,param);
		AccomplishMap *accomplishMap = (AccomplishMap *)param;
		for( AccomplishMap::iterator itr = accomplishMap->begin();
			 itr != accomplishMap->end();
			 ++itr )
		{
			if(itr->second!=NULL && !itr->second->getComplete())
				itr->second->doEvent(WCH_UPDATE,MAKEINT64((int)(m_dt),NULL));
		}
		roleData->excHandle(MAKEINT64(WCH_LockData,0));
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSearchFubenPassCountMethod
//
/////////////////////////////////////////
crJXJSearchFubenPassCountMethod::crJXJSearchFubenPassCountMethod():
	m_this(NULL),
	m_mode(0)
{
}
crJXJSearchFubenPassCountMethod::crJXJSearchFubenPassCountMethod(const crJXJSearchFubenPassCountMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_mode(handle.m_mode)
{
}
void crJXJSearchFubenPassCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crJXJAccomplish*)param;
		break;
	}
}
void crJXJSearchFubenPassCountMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_mode = atoi(str.c_str());
		break;
	}
}
void crJXJSearchFubenPassCountMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && !m_this->getComplete())
	{
		/*ref_ptr<crTableIO>fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		ref_ptr<crTableIO>chapterTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChapterTab);
		crTableIO::StrVec record1,record2;
		int chapterIndex = fubenTab->getTitleIndex("chapterid");
		int modeIndex = chapterTab->getTitleIndex("mode");
		int chapterid,mode;*/
		crData *data = myPlayer->getDataClass();
		void *param;
		//int passcount = 0;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_JXJFubenProgressMap,param);
		//unsigned short fubenid;
		//FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
		//for( FubenProgressMap::iterator itr = fubenProgressMap->begin();
		//	itr != fubenProgressMap->end();
		//	++itr )
		//{
		//	if(itr->second->getComplete())
		//	{
		//		fubenid = itr->first;
		//		if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record1)>=0)
		//		{
		//			chapterid = atoi(record1[chapterIndex].c_str());
		//			if(chapterTab->queryOneRecord(0,crArgumentParser::appItoa(chapterid),record2)>=0)
		//			{
		//				mode = atoi(record2[modeIndex].c_str());
		//				if(mode == m_mode)
		//				{
		//					//passcount++;
		//					passcount = passcount + (itr->second->getComplete() - 1);
		//					m_this->setStep(passcount);
		//					if(m_this->isComplete())
		//					{
		//						///////////////弹窗
		//						//ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		//						//if(canvas.valid() && canvas->getDataClass())
		//						//{
		//						//	crData *data = canvas->getDataClass();
		//						//	data->inputParam(WCHDATA_JXJVisiableTime,&m_time);
		//						//	unsigned short accomplishid = *(unsigned short *)param;
		//						//	data->inputParam(WCHDATA_JXJCurAccomplishID,&accomplishid);

		//						//	//void *param;
		//						//	//crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		//						//	//crRole *mainRole = playerGameData->getMainRole();
		//						//	//crData *mainRoleData = mainRole->getDataClass();
		//						//	//mainRoleData->getParam(WCHDATA_Level,param);
		//						//	//unsigned char *nowlv = (unsigned char *)param;
		//						//	//if (int(*nowlv) > 2)
		//						//	//{
		//						//		crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		//						//	//}
		//						//}

		//						///////////////////////
		//						break;
		//					}
		//				}
		//			}
		//		}
		//	}
		//}
		//data->excHandle(MAKEINT64(WCH_LockData,0));

		data->getParam(WCHDATA_JXJPassZhengZhanTianXiaCount,param);
		unsigned short passcount = *(unsigned short *)param;
		
		m_this->setStep(passcount);
	}
}
/////////////////////////////////////////
//
//crJXJSearchFubenPassCountCompleteCheckMethod
//
/////////////////////////////////////////
crJXJSearchFubenPassCountCompleteCheckMethod::crJXJSearchFubenPassCountCompleteCheckMethod():
	m_this(NULL),
	m_player(NULL),
	m_mode(0)
{
}
crJXJSearchFubenPassCountCompleteCheckMethod::crJXJSearchFubenPassCountCompleteCheckMethod(const crJXJSearchFubenPassCountCompleteCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_player(NULL),
	m_mode(handle.m_mode)
{
}
void crJXJSearchFubenPassCountCompleteCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_player = NULL;
		}
		break;
	case 1:
		m_this = (crJXJAccomplish*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crPlayerGameData *)(LOINT64(param64));
		}
		else
		{
			m_player = NULL;
		}
		break;
	}
}
void crJXJSearchFubenPassCountCompleteCheckMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_mode = atoi(str.c_str());
		break;
	}
}
void crJXJSearchFubenPassCountCompleteCheckMethod::operator()(crHandle &handle)
{
	if(m_player)
	{
		/*ref_ptr<crTableIO>fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		ref_ptr<crTableIO>chapterTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChapterTab);
		crTableIO::StrVec record1,record2;
		int chapterIndex = fubenTab->getTitleIndex("chapterid");
		int modeIndex = chapterTab->getTitleIndex("mode");
		int chapterid,mode;*/
		crData *data = m_player->getDataClass();
		void *param;
		//int passcount = 0;
		//data->excHandle(MAKEINT64(WCH_LockData,1));
		//data->getParam(WCHDATA_JXJFubenProgressMap,param);
		//unsigned short fubenid;
		//FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
		//for( FubenProgressMap::iterator itr = fubenProgressMap->begin();
		//	itr != fubenProgressMap->end();
		//	++itr )
		//{
		//	if(itr->second->getComplete())
		//	{
		//		fubenid = itr->first;
		//		if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record1)>=0)
		//		{
		//			chapterid = atoi(record1[chapterIndex].c_str());
		//			if(chapterTab->queryOneRecord(0,crArgumentParser::appItoa(chapterid),record2)>=0)
		//			{
		//				mode = atoi(record2[modeIndex].c_str());
		//				if(mode == m_mode)
		//				{
		//					//passcount++;
		//					passcount = passcount + (itr->second->getComplete() - 1);
		//					m_this->setStep(passcount);
		//					if(m_this->isComplete())
		//					{
		//						break;
		//					}
		//				}
		//			}
		//		}
		//	}
		//}
		//data->excHandle(MAKEINT64(WCH_LockData,0));

		data->getParam(WCHDATA_JXJPassZhengZhanTianXiaCount,param);
		unsigned short passcount = *(unsigned short *)param;

		m_this->setStep(passcount);
	}
}
/////////////////////////////////////////
//
//crJXJRecvAccomplishCompleteMethod
//
/////////////////////////////////////////
crJXJRecvAccomplishCompleteMethod::crJXJRecvAccomplishCompleteMethod():
	m_time(5.0f),
	m_netType(GameClient_Game){}
crJXJRecvAccomplishCompleteMethod::crJXJRecvAccomplishCompleteMethod(const crJXJRecvAccomplishCompleteMethod& handle):
	crMethod(handle),
	m_time(handle.m_time),
	m_canvas(handle.m_canvas)
{
}
void crJXJRecvAccomplishCompleteMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvAccomplishCompleteMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_time = atof(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJRecvAccomplishCompleteMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			crRole *mainRole = m_this->getMainRole();
			if(playerData.valid() && mainRole && mainRole->getDataClass())
			{
				unsigned short accid = m_stream->_readShort();
				void *param;
				crData *playerdata = m_this->getDataClass();
				playerdata->excHandle(MAKEINT64(WCH_LockData,1));
				crData *data = mainRole->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJAccomplishMap,param);
				AccomplishMap *accomplishMap = (AccomplishMap *)param;
				AccomplishMap::iterator itr = accomplishMap->find(accid);
				if(itr != accomplishMap->end())
				{
					if(!(itr->second->isComplete()))
					{//
						itr->second->doEvent(WCH_JXJServerCompleteCheck,MAKEINT64(m_this,NULL));
						if(itr->second->isComplete())
						{
							itr->second->setComplete(true);
							unsigned short point = itr->second->getAccomplishPoint();
							data->getParam(WCHDATA_JXJAccomplishPoint,param);
						    unsigned short *accpoint = (unsigned short *)param;
							*accpoint += point;

							ref_ptr<crData> playergamedata = m_this->getDataClass();
							playergamedata->getParam(WCHDATA_JXJAchievePointsCount,param);
							int *dailypoints = (int*)param;
							*dailypoints += (int)point;

							//返回信息
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(8);
							stream->_writeUShort(accid);
							stream->_writeUShort(*accpoint);
							stream->_writeInt(*dailypoints);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvAccomplishComplete,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

						}
						//ref_ptr<crTableIO>accomplishTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJAccomplishTab);
						//if(accomplishTab)
						//{
						//	crTableIO::StrVec record;
						//	int pointindex = accomplishTab->getTitleIndex("成就");
						//	if(accomplishTab->queryOneRecord(0,crArgumentParser::appItoa(accid),record)>=0)
						//	{
						//		int point = atoi(record[pointindex].c_str());
						//		data->getParam(WCHDATA_JXJAccomplishPoint,param);
						//		unsigned short *accpoint = (unsigned short *)param;
						//		*accpoint += point;
						//		itr->second->setComplete(true);
						//		//返回信息
						//		ref_ptr<crStreamBuf> stream = new crStreamBuf;
						//		stream->createBuf(2);
						//		stream->_writeUShort(*accpoint);
						//		crPlayerDataEventPacket packet;
						//		crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvAccomplishComplete,stream.get());
						//		gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						//	}
						//}
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				playerdata->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			crRole *mainRole = m_this->getMainRole();
			if(mainRole && mainRole->getDataClass())
			{
				unsigned short accid = m_stream->_readUShort();
				unsigned short accpoint = m_stream->_readUShort();
				int coperpoints = m_stream->_readInt();
				void *param;
				crData *data = mainRole->getDataClass();
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJAccomplishPoint,param);
				unsigned short *oldaccpoint = (unsigned short *)param;
				unsigned short changepoint = accpoint - *oldaccpoint;//变化数值用于提示
				*oldaccpoint = accpoint;

				ref_ptr<crData> playergamedata = m_this->getDataClass();
				playergamedata->getParam(WCHDATA_JXJAchievePointsCount,param);
				int *dailypoints = (int*)param;
				*dailypoints = coperpoints;

				data->getParam(WCHDATA_JXJAccomplishMap,param);
				AccomplishMap *accomplishMap = (AccomplishMap *)param;
				AccomplishMap::iterator itr = accomplishMap->find(accid);
				if(itr != accomplishMap->end())
				{
					itr->second->setComplete(true);
					ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
					if(canvas.valid() && canvas->getDataClass())
					{
						crData *canvasdata = canvas->getDataClass();
						if (canvasdata)
						{
							canvasdata->inputParam(WCHDATA_JXJVisiableTime,&m_time);
							canvasdata->inputParam(WCHDATA_JXJCurAccomplishID,&accid);
						}

						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUpdateRankingDataMethod
//
/////////////////////////////////////////
crJXJUpdateRankingDataMethod::crJXJUpdateRankingDataMethod():
	m_this(NULL)/*,
				m_playerData(NULL)*/{}
crJXJUpdateRankingDataMethod::crJXJUpdateRankingDataMethod(const crJXJUpdateRankingDataMethod& handle):
	crMethod(handle),
	m_this(NULL)/*,
	//m_playerData(NULL)*/
{
}
void crJXJUpdateRankingDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	//case 2:
	//	if(param)
	//	{
	//		_crInt64 param64 = *(_crInt64*)param;
	//		m_playerData = (crGameServerPlayerData *)(LOINT64(param64));
	//	}
	//	else
	//	{
	//		m_playerData = NULL;
	//	}
	//	break;
	}
}

void crJXJUpdateRankingDataMethod::addParam(int i, const std::string& str)
{
}

void crJXJUpdateRankingDataMethod::operator()(crHandle &handle)
{
	if(/*m_playerData && */m_this->getMainRole() && m_this->getMainRole()->getDataClass())
	{
		int playerid = m_this->getPlayerID();
		//排除GM
		short quanxian = crGlobalHandle::gData()->getGMAuthority(playerid);
		if(quanxian>0 && quanxian<JXJGMPermission_newer)
			return;
		//CRCore::ref_ptr<CREncapsulation::crTableIO> gmTab = crGlobalHandle::gData()->gGMTable();
		//if(gmTab.valid())
		//{
		//	crTableIO::StrVec record;
		//	if(gmTab->queryOneRecord(0,crArgumentParser::appItoa(playerid),record)>=0)
		//		return;//GM帐号
		//}
		void *param;
		crData *maindata = m_this->getMainRole()->getDataClass();
		crData *gameData = m_this->getDataClass();
		gameData->getParam(WCHDATA_JXJShiliID,param);
		unsigned char shiliid = *(unsigned char *)param;
		gameData->getParam(WCHDATA_JXJCountryContribute,param);
		int contribute = *(int *)param;
		///统计领地总等级
		unsigned short manorlv = 0;
		for (int i = WCHDATA_JXJFuyalv; i <= WCHDATA_JXJFukulv; i++)
		{
			gameData->getParam(i,param);
			manorlv += *(unsigned char *)param;
		}
		for (int i = WCHDATA_JXJMingjulv1; i <= WCHDATA_JXJKuangshanlv4; i++)
		{
			gameData->getParam(i,param);
			manorlv += *(unsigned char *)param;
		}
		/////////////////////////

		//int startShili = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
		//int rankingid = shiliid - c_startShiliID;
		gameData->excHandle(MAKEINT64(WCH_LockData,1));
		gameData->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troopsMap = (TroopsMap *)param;
		int troopsCount = 0;
		for( TroopsMap::iterator itr = troopsMap->begin();
			itr != troopsMap->end();
			++itr )
		{
			troopsCount += itr->second;
		}
		gameData->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		for( FormationInfoVec::iterator itr = formationInfoVec->begin();
			itr != formationInfoVec->end();
			++itr )
		{
			troopsCount += (*itr)->getCount();
		}
		gameData->excHandle(MAKEINT64(WCH_LockData,0));

		maindata->getParam(WCHDATA_JXJExploit,param);
		int exploit = *(int *)param;
		maindata->getParam(WCHDATA_JXJGovPost,param);
		unsigned char govpost = *(unsigned char*) param;
		maindata->getParam(WCHDATA_Level,param);
		unsigned char level = *(unsigned char*) param;
		maindata->getParam(WCHDATA_JXJNobility,param);
		unsigned char nobility = *(unsigned char*) param;
		maindata->getParam(WCHDATA_JXJAccomplishPoint,param);
		unsigned short point = *(unsigned short *) param;

		gameData->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxRankingNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxExpRanking,viplv).c_str());
		crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
		serverData->excHandle(MAKEINT64(WCH_LockData,1));
		////////////////////功勋排行榜
		ref_ptr<crPlayerRanking> ranking;
		{
			//serverData->getParam(WCHDATA_JXJExpRankingMap1+rankingid,param);
			int minexploit = 0;
			serverData->getParam(WCHDATA_JXJExpRankingMap,param);
			ExpRankingMap *expRankingMap = (ExpRankingMap *)param;
			if(expRankingMap->size()>=maxRankingNum)
			{
				minexploit = expRankingMap->rbegin()->first;
			}
			//if(exploit>=minexploit)
			//{//更新在榜玩家的数据
			//	for( ExpRankingMap::iterator itr = expRankingMap->begin();
			//		 itr != expRankingMap->end();
			//		 ++itr )
			//	{
			//		ranking = itr->second.get();
			//		if(ranking->getPlayerID() == playerid)
			//		{
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			break;
			//		}
			//	}
			//}
			if(exploit>minexploit)
			{
				//serverData->getParam(WCHDATA_JXJExpRankingWaitMap,param);
				//ExpRankingMap *expRankingWaitMap = (ExpRankingMap *)param;
				//寻找playerid是否存在
				bool found = false;
				for( ExpRankingMap::iterator fitr = expRankingMap->begin();
					fitr != expRankingMap->end();
					++fitr )
				{
					ranking = fitr->second.get();
					if(playerid == ranking->getPlayerID())
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != exploit)
						{
							expRankingMap->erase(fitr);
							expRankingMap->insert(std::make_pair(exploit,ranking.get()));
						}
						found = true;
						break;
					}
				}
				if(!found)
				{
					if(expRankingMap->size()>=maxRankingNum)
					{
						minexploit = expRankingMap->rbegin()->first;
						ranking = expRankingMap->rbegin()->second.get();
						if(exploit>minexploit)
						{
							ranking->setPlayerID(playerid);
							ranking->setName(m_this->getCharacterName());
							ranking->setShiliID(shiliid);

							ranking->setExploit(exploit);
							ranking->setGovpost(govpost);
							ranking->setLevel(level);
							ranking->setNobility(nobility);
							ranking->setAccomplishPoint(point);
							ranking->setTroops(troopsCount);
							ranking->setCountrycontribute(contribute);
							ranking->setManorlv(manorlv);
							ExpRankingMap::iterator citr = expRankingMap->begin();
							ExpRankingMap::iterator nitr = citr;
							nitr++;
							while( nitr != expRankingMap->end())
							{
								citr++;
								nitr++;
							}
							expRankingMap->erase(citr);
							expRankingMap->insert(std::make_pair(exploit,ranking.get()));
						}
					}
					else
					{
						ranking = new crPlayerRanking;
						ranking->setPlayerID(playerid);
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						expRankingMap->insert(std::make_pair(exploit,ranking.get()));
					}
				}
			}
		}
		/////////////////////等级排行榜
		{
			unsigned char minlevel = 0;
			serverData->getParam(WCHDATA_JXJLevelRankingMap,param);
			LevelRankingMap *rankingMap = (LevelRankingMap *)param;
			if(rankingMap->size()>=maxRankingNum)
			{
				minlevel = rankingMap->rbegin()->first;
			}
			//if(level>=minlevel)
			//{//更新在榜玩家的数据
			//	for( LevelRankingMap::iterator itr = rankingMap->begin();
			//		itr != rankingMap->end();
			//		++itr )
			//	{
			//		ranking = itr->second.get();
			//		if(ranking->getPlayerID() == playerid)
			//		{
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			break;
			//		}
			//	}
			//}
			if(level>minlevel)
			{
				//serverData->getParam(WCHDATA_JXJLevelRankingWaitMap,param);
				//LevelRankingMap *rankingWaitMap = (LevelRankingMap *)param;
				//寻找playerid是否存在
				bool found = false;
				for( LevelRankingMap::iterator fitr = rankingMap->begin();
					fitr != rankingMap->end();
					++fitr )
				{
					ranking = fitr->second.get();
					if(playerid == ranking->getPlayerID())
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != level)
						{
							rankingMap->erase(fitr);
							rankingMap->insert(std::make_pair(level,ranking.get()));
						}
						//rankingWaitMap->erase(fitr);
						found = true;
						break;
					}
				}
				if(!found)
				{
					if(rankingMap->size()>=maxRankingNum)
					{
						minlevel = rankingMap->rbegin()->first;
						ranking = rankingMap->rbegin()->second.get();
						if(level>minlevel)
						{
							ranking->setPlayerID(playerid);
							ranking->setName(m_this->getCharacterName());
							ranking->setShiliID(shiliid);

							ranking->setExploit(exploit);
							ranking->setGovpost(govpost);
							ranking->setLevel(level);
							ranking->setNobility(nobility);
							ranking->setAccomplishPoint(point);
							ranking->setTroops(troopsCount);
							ranking->setCountrycontribute(contribute);
							ranking->setManorlv(manorlv);
							LevelRankingMap::iterator citr = rankingMap->begin();
							LevelRankingMap::iterator nitr = citr;
							nitr++;
							while( nitr != rankingMap->end())
							{
								citr++;
								nitr++;
							}
							rankingMap->erase(citr);
							rankingMap->insert(std::make_pair(level,ranking.get()));
						}
					}
					else
					{
						ranking = new crPlayerRanking;
						ranking->setPlayerID(playerid);
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						rankingMap->insert(std::make_pair(level,ranking.get()));
					}
				}
			}
		}
		//////////////////////////官职排行榜
		{
			_crInt64 mingovexp = 0;
			_crInt64 mygovexp = MAKEINT64(exploit,govpost);
			serverData->getParam(WCHDATA_JXJGovpostRankingMap,param);
			GovpostRankingMap *rankingMap = (GovpostRankingMap *)param;
			if(rankingMap->size()>=maxRankingNum)
			{
				mingovexp = rankingMap->rbegin()->first;
			}
			//if(mygovexp>=mingovexp)
			//{//更新在榜玩家的数据
			//	for( GovpostRankingMap::iterator itr = rankingMap->begin();
			//		itr != rankingMap->end();
			//		++itr )
			//	{
			//		ranking = itr->second.get();
			//		if(ranking->getPlayerID() == playerid)
			//		{
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			break;
			//		}
			//	}
			//}
			if(mygovexp>mingovexp)
			{
				//serverData->getParam(WCHDATA_JXJGovpostRankingWaitMap,param);
				//GovpostRankingMap *rankingWaitMap = (GovpostRankingMap *)param;
				//寻找playerid是否存在
				bool found = false;
				for( GovpostRankingMap::iterator fitr = rankingMap->begin();
					fitr != rankingMap->end();
					++fitr )
				{
					ranking = fitr->second.get();
					if(playerid == ranking->getPlayerID())
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != mygovexp)
						{
							rankingMap->erase(fitr);
							rankingMap->insert(std::make_pair(mygovexp,ranking.get()));
						}
						//rankingMap->erase(fitr);
						found = true;
						break;
					}
				}
				if(!found)
				{
					if(rankingMap->size()>=maxRankingNum)
					{
						mingovexp = rankingMap->rbegin()->first;
						ranking = rankingMap->rbegin()->second.get();
						if(mygovexp>mingovexp)
						{
							ranking->setPlayerID(playerid);
							ranking->setName(m_this->getCharacterName());
							ranking->setShiliID(shiliid);

							ranking->setExploit(exploit);
							ranking->setGovpost(govpost);
							ranking->setLevel(level);
							ranking->setNobility(nobility);
							ranking->setAccomplishPoint(point);
							ranking->setTroops(troopsCount);
							ranking->setCountrycontribute(contribute);
							ranking->setManorlv(manorlv);
							GovpostRankingMap::iterator citr = rankingMap->begin();
							GovpostRankingMap::iterator nitr = citr;
							nitr++;
							while( nitr != rankingMap->end())
							{
								citr++;
								nitr++;
							}
							rankingMap->erase(citr);
							rankingMap->insert(std::make_pair(mygovexp,ranking.get()));
						}
					}
					else
					{
						ranking = new crPlayerRanking;
						ranking->setPlayerID(playerid);
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						rankingMap->insert(std::make_pair(mygovexp,ranking.get()));
					}
				}
			}
		}
		/////////////////////////成就点数排行榜
		{
			unsigned short minpoint = 0;
			serverData->getParam(WCHDATA_JXJAccomplishRankingMap,param);
			AccomplishRankingMap *rankingMap = (AccomplishRankingMap *)param;
			if(rankingMap->size()>=maxRankingNum)
			{
				minpoint = rankingMap->rbegin()->first;
			}
			//if(point>=minpoint)
			//{//更新在榜玩家的数据
			//	for( AccomplishRankingMap::iterator itr = rankingMap->begin();
			//		itr != rankingMap->end();
			//		++itr )
			//	{
			//		ranking = itr->second.get();
			//		if(ranking->getPlayerID() == playerid)
			//		{
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			break;
			//		}
			//	}
			//}
			if(point>minpoint)
			{
				//serverData->getParam(WCHDATA_JXJAccomplishRankingWaitMap,param);
				//AccomplishRankingMap *rankingWaitMap = (AccomplishRankingMap *)param;
				//寻找playerid是否存在
				bool found = false;
				for( AccomplishRankingMap::iterator fitr = rankingMap->begin();
					fitr != rankingMap->end();
					++fitr )
				{
					ranking = fitr->second.get();
					if(playerid == ranking->getPlayerID())
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != point)
						{
							rankingMap->erase(fitr);
							rankingMap->insert(std::make_pair(point,ranking.get()));
						}
						//rankingMap->erase(fitr);
						found = true;
						break;
					}
				}
				if(!found)
				{
					if(rankingMap->size()>=maxRankingNum)
					{
						minpoint = rankingMap->rbegin()->first;
						ranking = rankingMap->rbegin()->second.get();
						if(point>minpoint)
						{
							ranking->setPlayerID(playerid);
							ranking->setName(m_this->getCharacterName());
							ranking->setShiliID(shiliid);

							ranking->setExploit(exploit);
							ranking->setGovpost(govpost);
							ranking->setLevel(level);
							ranking->setNobility(nobility);
							ranking->setAccomplishPoint(point);
							ranking->setTroops(troopsCount);
							ranking->setCountrycontribute(contribute);
							ranking->setManorlv(manorlv);
							AccomplishRankingMap::iterator citr = rankingMap->begin();
							AccomplishRankingMap::iterator nitr = citr;
							nitr++;
							while( nitr != rankingMap->end())
							{
								citr++;
								nitr++;
							}
							rankingMap->erase(citr);
							rankingMap->insert(std::make_pair(point,ranking.get()));
						}
					}
					else
					{
						ranking = new crPlayerRanking;
						ranking->setPlayerID(playerid);
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						rankingMap->insert(std::make_pair(point,ranking.get()));
					}
				}
			}
		}
		////////////////////////兵力排行榜
		{
			int minTroopsRankingCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMinTroopsRankingCount,0).c_str());

			serverData->getParam(WCHDATA_JXJTroopsRankingMap,param);
			TroopsRankingMap *rankingMap = (TroopsRankingMap *)param;
			////更新在榜玩家的数据
			//for( TroopsRankingMap::iterator itr = rankingMap->begin();
			//	itr != rankingMap->end();
			//	++itr )
			//{
			//	ranking = itr->second.get();
			//	if(ranking->getPlayerID() == playerid)
			//	{
			//		ranking->setExploit(exploit);
			//		ranking->setGovpost(govpost);
			//		ranking->setLevel(level);
			//		ranking->setNobility(nobility);
			//		ranking->setAccomplishPoint(point);
			//		ranking->setTroops(troopsCount);
			//		ranking->setCountrycontribute(contribute);
			//		ranking->setManorlv(manorlv);
			//		break;
			//	}
			//}
			//serverData->getParam(WCHDATA_JXJTroopsRankingWaitMap,param);
			//TroopsRankingMap *rankingWaitMap = (TroopsRankingMap *)param;
			//寻找playerid是否存在
			bool found = false;
			for( TroopsRankingMap::iterator fitr = rankingMap->begin();
				fitr != rankingMap->end();
				++fitr )
			{
				ranking = fitr->second.get();
				if(playerid == ranking->getPlayerID())
				{
					if(troopsCount>=minTroopsRankingCount)
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != troopsCount)
						{
							rankingMap->erase(fitr);
							rankingMap->insert(std::make_pair(troopsCount,ranking.get()));
						}
					}
					else
					{
						rankingMap->erase(fitr);
					}
					//rankingWaitMap->erase(fitr);
					found = true;
					break;
				}
			}
			/*if(!found)
			{
				if(troopsCount>minTroopsRankingCount) rankingWaitMap->insert(std::make_pair(troopsCount,ranking.get()));
			}
			else */if(!found && troopsCount>=minTroopsRankingCount)
			{
				//if(rankingWaitMap->size()>=maxRankingNum)
				//{
				//	int minvalue = rankingWaitMap->rbegin()->first;
				//	ranking = rankingWaitMap->rbegin()->second.get();
				//	if(troopsCount>minvalue)
				//	{
				//		ranking->setExploit(exploit);
				//		ranking->setGovpost(govpost);
				//		ranking->setPlayerID(playerid);
				//		ranking->setName(m_this->getCharacterName());
				//		ranking->setShiliID(shiliid);
				//		ranking->setLevel(level);
				//		ranking->setNobility(nobility);
				//		ranking->setAccomplishPoint(point);
				//		ranking->setTroops(troopsCount);
				//		ranking->setCountrycontribute(contribute);
				//		ranking->setManorlv(manorlv);
				//		TroopsRankingMap::iterator citr = rankingWaitMap->begin();
				//		TroopsRankingMap::iterator nitr = citr;
				//		nitr++;
				//		while( nitr != rankingWaitMap->end())
				//		{
				//			citr++;
				//			nitr++;
				//		}
				//		rankingWaitMap->erase(citr);
				//		rankingWaitMap->insert(std::make_pair(troopsCount,ranking.get()));
				//	}
				//}
				//else
				//{
					ranking = new crPlayerRanking;
					ranking->setPlayerID(playerid);
					ranking->setName(m_this->getCharacterName());
					ranking->setShiliID(shiliid);

					ranking->setExploit(exploit);
					ranking->setGovpost(govpost);
					ranking->setLevel(level);
					ranking->setNobility(nobility);
					ranking->setAccomplishPoint(point);
					ranking->setTroops(troopsCount);
					ranking->setCountrycontribute(contribute);
					ranking->setManorlv(manorlv);
					rankingMap->insert(std::make_pair(troopsCount,ranking.get()));
				//}
			}
		}
		/////////////////////////国家贡献排行榜
		{
			int mincontribute = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingMinContribute,0).c_str());
			serverData->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
			CountrycontributeRankingMap *rankingMap = (CountrycontributeRankingMap *)param;
			////更新在榜玩家的数据
			//for( CountrycontributeRankingMap::iterator itr = rankingMap->begin();
			//	itr != rankingMap->end();
			//	++itr )
			//{
			//	ranking = itr->second.get();
			//	if(ranking->getPlayerID() == playerid)
			//	{
			//		ranking->setExploit(exploit);
			//		ranking->setGovpost(govpost);
			//		ranking->setLevel(level);
			//		ranking->setNobility(nobility);
			//		ranking->setAccomplishPoint(point);
			//		ranking->setTroops(troopsCount);
			//		ranking->setCountrycontribute(contribute);
			//		ranking->setManorlv(manorlv);
			//		break;
			//	}
			//}
			//serverData->getParam(WCHDATA_JXJCountrycontributeRankingWaitMap,param);
			//CountrycontributeRankingMap *rankingWaitMap = (CountrycontributeRankingMap *)param;
			//寻找playerid是否存在
			bool found = false;
			for( CountrycontributeRankingMap::iterator fitr = rankingMap->begin();
				fitr != rankingMap->end();
				++fitr )
			{
				ranking = fitr->second.get();
				if(playerid == ranking->getPlayerID())
				{
					if(contribute>=mincontribute)
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != contribute)
						{
							rankingMap->erase(fitr);
							rankingMap->insert(std::make_pair(contribute,ranking.get()));
						}
					}
					else
					{
						rankingMap->erase(fitr);
					}
					//rankingWaitMap->erase(fitr);
					found = true;
					break;
				}
			}
			/*			if(found)
			{
			if(contribute>mincontribute) rankingWaitMap->insert(std::make_pair(contribute,ranking.get()));
			}
			else */if(!found && contribute>=mincontribute)
			{
				//if(rankingWaitMap->size()>=maxRankingNum)
				//{
				//	int minvalue = rankingWaitMap->rbegin()->first;
				//	ranking = rankingWaitMap->rbegin()->second.get();
				//	if(contribute>minvalue)
				//	{
				//		ranking->setExploit(exploit);
				//		ranking->setGovpost(govpost);
				//		ranking->setPlayerID(playerid);
				//		ranking->setName(m_this->getCharacterName());
				//		ranking->setShiliID(shiliid);
				//		ranking->setLevel(level);
				//		ranking->setNobility(nobility);
				//		ranking->setAccomplishPoint(point);
				//		ranking->setTroops(troopsCount);
				//		ranking->setCountrycontribute(contribute);
				//		ranking->setManorlv(manorlv);
				//		CountrycontributeRankingMap::iterator citr = rankingWaitMap->begin();
				//		CountrycontributeRankingMap::iterator nitr = citr;
				//		nitr++;
				//		while( nitr != rankingWaitMap->end())
				//		{
				//			citr++;
				//			nitr++;
				//		}
				//		rankingWaitMap->erase(citr);
				//		rankingWaitMap->insert(std::make_pair(contribute,ranking.get()));
				//	}
				//}
				//else
				//{
					ranking = new crPlayerRanking;
					ranking->setPlayerID(playerid);
					ranking->setName(m_this->getCharacterName());
					ranking->setShiliID(shiliid);

					ranking->setExploit(exploit);
					ranking->setGovpost(govpost);
					ranking->setLevel(level);
					ranking->setNobility(nobility);
					ranking->setAccomplishPoint(point);
					ranking->setTroops(troopsCount);
					ranking->setCountrycontribute(contribute);
					ranking->setManorlv(manorlv);
					rankingMap->insert(std::make_pair(contribute,ranking.get()));
				//}
			}
			//int mincontribute = 0;
			//serverData->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
			//CountrycontributeRankingMap *rankingMap = (CountrycontributeRankingMap *)param;
			//if(rankingMap->size()>=maxRankingNum)
			//{
			//	mincontribute = rankingMap->rbegin()->first;
			//}
			//if(contribute>mincontribute)
			//{
			//	ref_ptr<crPlayerRanking> ranking;
			//	serverData->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
			//	CountrycontributeRankingMap *rankingWaitMap = (CountrycontributeRankingMap *)param;
			//	//寻找playerid是否存在
			//	bool found = false;
			//	for( CountrycontributeRankingMap::iterator fitr = rankingWaitMap->begin();
			//		fitr != rankingWaitMap->end();
			//		++fitr )
			//	{
			//		ranking = fitr->second.get();
			//		if(playerid == ranking->getPlayerID())
			//		{
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			rankingWaitMap->erase(fitr);
			//			found = true;
			//			break;
			//		}
			//	}
			//	if(found)
			//	{
			//		rankingWaitMap->insert(std::make_pair(point,ranking.get()));
			//	}
			//	else
			//	{
			//		if(rankingWaitMap->size()>=maxRankingNum)
			//		{
			//			mincontribute = rankingWaitMap->rbegin()->first;
			//			ranking = rankingWaitMap->rbegin()->second.get();
			//			if(contribute>mincontribute)
			//			{
			//				ranking->setExploit(exploit);
			//				ranking->setGovpost(govpost);
			//				ranking->setPlayerID(playerid);
			//				ranking->setName(m_this->getCharacterName());
			//				ranking->setShiliID(shiliid);
			//				ranking->setLevel(level);
			//				ranking->setNobility(nobility);
			//				ranking->setAccomplishPoint(point);
			//				ranking->setTroops(troopsCount);
			//				ranking->setCountrycontribute(contribute);
			//				ranking->setManorlv(manorlv);
			//				CountrycontributeRankingMap::iterator citr = rankingWaitMap->begin();
			//				CountrycontributeRankingMap::iterator nitr = citr;
			//				nitr++;
			//				while( nitr != rankingWaitMap->end())
			//				{
			//					citr++;
			//					nitr++;
			//				}
			//				rankingWaitMap->erase(citr);
			//				rankingWaitMap->insert(std::make_pair(point,ranking.get()));
			//			}
			//		}
			//		else
			//		{
			//			ranking = new crPlayerRanking;
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setPlayerID(playerid);
			//			ranking->setName(m_this->getCharacterName());
			//			ranking->setShiliID(shiliid);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			rankingWaitMap->insert(std::make_pair(contribute,ranking.get()));
			//		}
			//	}
			//}
		}
		/////////////////////////领地发展排行榜
		{
			unsigned short minmanorlv = 0;
			serverData->getParam(WCHDATA_JXJManorlvRankingMap,param);
			ManorlvRankingMap *rankingMap = (ManorlvRankingMap *)param;
			if(rankingMap->size()>=maxRankingNum)
			{
				minmanorlv = rankingMap->rbegin()->first;
			}
			//if(manorlv>=minmanorlv)
			//{//更新在榜玩家的数据
			//	for( ManorlvRankingMap::iterator itr = rankingMap->begin();
			//		itr != rankingMap->end();
			//		++itr )
			//	{
			//		ranking = itr->second.get();
			//		if(ranking->getPlayerID() == playerid)
			//		{
			//			ranking->setExploit(exploit);
			//			ranking->setGovpost(govpost);
			//			ranking->setLevel(level);
			//			ranking->setNobility(nobility);
			//			ranking->setAccomplishPoint(point);
			//			ranking->setTroops(troopsCount);
			//			ranking->setCountrycontribute(contribute);
			//			ranking->setManorlv(manorlv);
			//			break;
			//		}
			//	}
			//}
			if(manorlv>minmanorlv)
			{
				//serverData->getParam(WCHDATA_JXJManorlvRankingWaitMap,param);
				//ManorlvRankingMap *rankingWaitMap = (ManorlvRankingMap *)param;
				//寻找playerid是否存在
				bool found = false;
				for( ManorlvRankingMap::iterator fitr = rankingMap->begin();
					fitr != rankingMap->end();
					++fitr )
				{
					ranking = fitr->second.get();
					if(playerid == ranking->getPlayerID())
					{
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						if(fitr->first != manorlv)
						{
							rankingMap->erase(fitr);
							rankingMap->insert(std::make_pair(manorlv,ranking.get()));
						}
						//rankingMap->erase(fitr);
						found = true;
						break;
					}
				}
				if(!found)
				{
					if(rankingMap->size()>=maxRankingNum)
					{
						minmanorlv = rankingMap->rbegin()->first;
						ranking = rankingMap->rbegin()->second.get();
						if(manorlv>minmanorlv)
						{
							ranking->setPlayerID(playerid);
							ranking->setName(m_this->getCharacterName());
							ranking->setShiliID(shiliid);

							ranking->setExploit(exploit);
							ranking->setGovpost(govpost);
							ranking->setLevel(level);
							ranking->setNobility(nobility);
							ranking->setAccomplishPoint(point);
							ranking->setTroops(troopsCount);
							ranking->setCountrycontribute(contribute);
							ranking->setManorlv(manorlv);
							ManorlvRankingMap::iterator citr = rankingMap->begin();
							ManorlvRankingMap::iterator nitr = citr;
							nitr++;
							while( nitr != rankingMap->end())
							{
								citr++;
								nitr++;
							}
							rankingMap->erase(citr);
							rankingMap->insert(std::make_pair(manorlv,ranking.get()));
						}
					}
					else
					{
						ranking = new crPlayerRanking;
						ranking->setPlayerID(playerid);
						ranking->setName(m_this->getCharacterName());
						ranking->setShiliID(shiliid);

						ranking->setExploit(exploit);
						ranking->setGovpost(govpost);
						ranking->setLevel(level);
						ranking->setNobility(nobility);
						ranking->setAccomplishPoint(point);
						ranking->setTroops(troopsCount);
						ranking->setCountrycontribute(contribute);
						ranking->setManorlv(manorlv);
						rankingMap->insert(std::make_pair(manorlv,ranking.get()));
					}
				}
			}
		}
		serverData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIAttachUpdateMethod
//
/////////////////////////////////////////
crJXJUIAttachUpdateMethod::crJXJUIAttachUpdateMethod():
	m_this(NULL)
{
}

crJXJUIAttachUpdateMethod::crJXJUIAttachUpdateMethod(const crJXJUIAttachUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}

void crJXJUIAttachUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 3:
		m_targetWidget = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIAttachUpdateMethod::addParam(int i, const std::string& str)
{
}

void crJXJUIAttachUpdateMethod::operator()(crHandle &handle)
{
	if(m_targetWidget.valid())
	{
		ref_ptr<crCanvasNode> targetCanvas = m_targetWidget->getParentCanvas();
		crVector3 centerCoord = m_targetWidget->getBound().center();
		crMatrix mat = targetCanvas->getMatrix();
		m_this->setPosition(centerCoord * mat);
	}
}
/////////////////////////////////////////
//
//crJXJEnterBattleTimerMethod
//
/////////////////////////////////////////
crJXJEnterBattleTimerMethod::crJXJEnterBattleTimerMethod():
	m_interval(30)
{
}

crJXJEnterBattleTimerMethod::crJXJEnterBattleTimerMethod(const crJXJEnterBattleTimerMethod& handle):
	crMethod(handle),
	m_interval(handle.m_interval),
	m_timerText(handle.m_timerText)
{
}

void crJXJEnterBattleTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJEnterBattleTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atoi(str.c_str());
		break;
	case 1:
		m_timerText = str;
		break;
	}
}

void crJXJEnterBattleTimerMethod::operator()(crHandle &handle)
{
	bool timeout = false;
	crData *data = m_this->getDataClass();
	if(data)
	{
		void *param;
		data->getParam(WCHDATA_JXJEnterBattleTimer,param);
		int *timer = (int *)param;
		(*timer)--;
		if(*timer <= 0)
		{
			*timer = m_interval;
			timeout = true;
		}
		crStaticTextWidgetNode *textWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timerText));
		if(textWidget)
		{
			textWidget->setString(crArgumentParser::appItoa(*timer));
		}
	}
	handle.outputParam(0,&timeout);
}
/////////////////////////////////////////
//
//crJXJResetEnterBattleTimerMethod
//
/////////////////////////////////////////
crJXJResetEnterBattleTimerMethod::crJXJResetEnterBattleTimerMethod():
	m_interval(30)
{
}

crJXJResetEnterBattleTimerMethod::crJXJResetEnterBattleTimerMethod(const crJXJResetEnterBattleTimerMethod& handle):
	crMethod(handle),
	m_interval(handle.m_interval)
{
}

void crJXJResetEnterBattleTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJResetEnterBattleTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atoi(str.c_str());
		break;
	}
}

void crJXJResetEnterBattleTimerMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	if(data)
	{
		data->inputParam(WCHDATA_JXJEnterBattleTimer,&m_interval);
	}
}
/////////////////////////////////////////
//
//crJXJCreateItemTipsMethod
//
/////////////////////////////////////////
crJXJCreateItemTipsMethod::crJXJCreateItemTipsMethod():
	m_outscript(NULL){}
crJXJCreateItemTipsMethod::crJXJCreateItemTipsMethod(const crJXJCreateItemTipsMethod& handle):
	crMethod(handle),
	m_item(handle.m_item),
	m_outscript(NULL)
{
}
void crJXJCreateItemTipsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_outscript = NULL;
		}
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_item = *(CRCore::crVector2i *)(LOINT64(param64));
			m_outscript = (rcfg::ConfigScript *)(HIINT64(param64));
		}
		else
		{
			m_outscript = NULL;
		}
		break;
	case 3:
		if(param)
			m_otherLordEquipVec = *(JXJLordEquipVec *)param;
		break;
	}
}
void crJXJCreateItemTipsMethod::addParam(int i, const std::string& str)
{
}
void crJXJCreateItemTipsMethod::createContent(int &nContent,std::string perstr,int base,int add,bool percent,bool baseattr,const std::vector<float>&color)
{
	char buf[64];
	std::string str;
	m_outscript->Add("Content");
	m_outscript->Push("Content",nContent++);
	if(base+add<0)
		perstr = perstr+"-";
	else
		perstr = perstr+"+";
	if(add>0)
	{
		m_outscript->Add("Color",color);
		if(percent)
		{
			float fbase = (float)base * 0.1f;
			float fadd = (float)add * 0.1f;
			sprintf(buf,"%.1f%%(+%.1f%%)\n\0",fbase+fadd,fadd);
			m_outscript->Add("Text",str);
			//m_outscript->Add("Text",perstr+crArgumentParser::appFtoa(fbase+fadd)+"%(+"+crArgumentParser::appFtoa(fadd)+"%)\n");
		}
		else
		{
			m_outscript->Add("Text",perstr+crArgumentParser::appItoa(base+add)+"(+"+crArgumentParser::appItoa(add)+")\n");
		}
	}
	else if(add<0)
	{
		m_outscript->Add("Color",color);
		if(percent)
		{
			float fbase = (float)base * 0.1f;
			float fadd = (float)add * 0.1f;
			sprintf(buf,"%.1f%%(+%.1f%%)\n\0",fbase+fadd,fadd);
			str = perstr+buf;
			m_outscript->Add("Text",str);
			//m_outscript->Add("Text",perstr+crArgumentParser::appFtoa(fbase+fadd)+"%(+"+crArgumentParser::appFtoa(fadd)+"%)\n");
		}
		else
		{
			m_outscript->Add("Text",perstr+crArgumentParser::appItoa(base+add)+"(+"+crArgumentParser::appItoa(add)+")\n");
		}
	}
	else if(base>0)
	{
		if(!baseattr)
		{
			m_outscript->Add("Color",color);
		}
		if(percent)
		{
			float fbase = (float)base * 0.1f;
			sprintf(buf,"%.1f%%\n\0",fbase);
			str = perstr+buf;
			m_outscript->Add("Text",str);
			//m_outscript->Add("Text",perstr+crArgumentParser::appFtoa(fbase)+"%\n");
		}
		else
		{
			m_outscript->Add("Text",perstr+crArgumentParser::appItoa(base)+"\n");
		}
	}
	else if(base<0)
	{
		m_outscript->Add("Color",color);
		if(percent)
		{
			float fbase = (float)base * 0.1f;
			sprintf(buf,"%.1f%%\n\0",fbase);
			str = perstr+buf;
			m_outscript->Add("Text",str);
			//m_outscript->Add("Text",perstr+crArgumentParser::appFtoa(fbase)+"%\n");
		}
		else
		{
			m_outscript->Add("Text",perstr+crArgumentParser::appItoa(base)+"\n");
		}
	}
	m_outscript->Pop();
}
void crJXJCreateItemTipsMethod::setMagicAttrTips(int &nContent,int startid,const CREncapsulation::crTableIO::StrVec &record,const std::vector<float> &color)
{
	short base/*,baseadd*/;
	////float add;
	//base = getBaseAttrPercent(startid,record);
	//if(base!=0)
	//{
	//	//if(base!=0 && lvstartid>0)
	//	//{
	//	//	baseadd = base;
	//	//	add = getBaseAttrPercent(lvstartid,lvrecord) * 0.001f;
	//	//	base = (float)(base) * (1.0f+add);
	//	//	baseadd = base - baseadd; 
	//	//}
	//	//else
	//	//{
	//	//	baseadd = 0;
	//	//}
	//	//if(base!=0)
	//	//{
	//	createContent(nContent,"基础属性",base,0,true,false,color);
	//	//}
	//	return;
	//}
	std::string perstr[27]={"攻速","CD缩减","移动速度","护甲值","法术抗性","格挡几率","攻击力","生命","暴击",
	"闪避","攻城攻击","射程","命中","穿透","法术穿透","潜行","反潜行","视野","无视闪避\n","反弹物伤",
	"反弹法伤","物理吸血","法术吸血","暴击伤害","溅射伤害\n","物伤加深","法伤加深"};

	std::string _str;
	for (int i = 0; i<27;i++)
	{
		if(i==18)
		{//无视闪避
			base = (short)(atoi(record[startid+i].c_str()));
			if(base!=0)
			{
				m_outscript->Add("Content");
				m_outscript->Push("Content",nContent++);
				m_outscript->Add("Color",color);
				m_outscript->Add("Text","无视闪避\n");
				m_outscript->Pop();
			}
		}
		//else if(i==23)
		//{//暴击剑,不可叠加
		//	base = (short)(atoi(record[startid+i].c_str()));
		//	if(base!=0)
		//	{
		//		m_outscript->Add("Content");
		//		m_outscript->Push("Content",nContent++);
		//		m_outscript->Add("Color",color);
		//		m_outscript->Add("Text","暴击伤害提升到250%\n");
		//		m_outscript->Pop();
		//	}
		//}
		else if(i==24)
		{//溅射,不可叠加
			crVector2f vecbase/*,vecadd*/;
			if(crArgumentParser::appAtoVec(record[startid+i],vecbase))
			{
				//if(lvstartid>0 && crArgumentParser::appAtoVec(lvrecord[lvstartid+i],vecadd))
				//{
				//	vecbase[0] *= 1.0f+vecadd[0] * 0.001f;
				//	vecbase[1] *= 1.0f+vecadd[1] * 0.001f;
				//}
				m_outscript->Add("Content");
				m_outscript->Push("Content",nContent++);
				m_outscript->Add("Color",color);
				char buf[64];
				sprintf(buf,"近战溅射伤害(%d,%.1f%%)\n\0",(short)vecbase[0],vecbase[1]*0.1f);
				m_outscript->Add("Text",buf);
				m_outscript->Pop();
			}
		}
		else if(i==25)
		{
			_str = perstr[i];
			base = (short)(atoi(record[startid+i].c_str()));
			if(base<0)
			{
				base = -base;
				_str = "物伤减免";
			}
			//if(base!=0 && lvstartid>0)
			//{
			//	baseadd = base;
			//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
			//	base = (float)(base) * (1.0f+add);
			//	baseadd = base - baseadd; 
			//}
			//else
			//{
			//	baseadd = 0;
			//}
			if(base!=0)
			{
				createContent(nContent,_str,base,0,true,false,color);
			}
		}
		else if(i==26)
		{
			_str = perstr[i];
			base = (short)(atoi(record[startid+i].c_str()));
			if(base<0)
			{
				base = -base;
				_str = "法伤减免";
			}
			//if(base!=0 && lvstartid>0)
			//{
			//	baseadd = base;
			//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
			//	base = (float)(base) * (1.0f+add);
			//	baseadd = base - baseadd; 
			//}
			//else
			//{
			//	baseadd = 0;
			//}
			if(base!=0)
			{
				createContent(nContent,_str,base,0,true,false,color);
			}
		}
		else
		{
			base = (short)(atoi(record[startid+i].c_str()));
			//if(base!=0 && lvstartid>0)
			//{
			//	baseadd = base;
			//	add = atof(lvrecord[lvstartid+i].c_str()) * 0.001f;
			//	base = (float)(base) * (1.0f+add);
			//	baseadd = base - baseadd; 
			//}
			//else
			//{
			//	baseadd = 0;
			//}
			if(base!=0)
			{
				if(i<=1||(i>=3&&i<=10)||(i>=12&&i<=14)||(i>=19&&i<=22)||i==23)
					createContent(nContent,perstr[i],base,0,true,false,color);
				else
					createContent(nContent,perstr[i],base,0,false,false,color);
			}
		}
	}
}
//int crJXJCreateItemTipsMethod::getBaseAttrPercent(int startid,const CREncapsulation::crTableIO::StrVec &recrod)
//{
//	int percent = atoi(recrod[startid+2].c_str());
//	if(percent>0)
//	{
//		for (int i = 3; i<10; i++)
//		{
//			if(i == 6)
//				continue;
//			if(percent != atoi(recrod[startid+i].c_str()))
//			{
//				percent = 0;
//				break;
//			}
//		}
//		return percent;
//	}
//	return 0;
//}
std::string crJXJCreateItemTipsMethod::getMagicAttrTipsStr(int startid,const CREncapsulation::crTableIO::StrVec &record, char sign)
{
	std::string str;
	char buf[64];
	//int basepercent = getBaseAttrPercent(startid,record);
	//if(basepercent>0)
	//{
	//	float f = (float)basepercent * 0.1f;

	//	//sprintf(buf,"基础属性+%.1f%%\0",f);
	//	if (basepercent - ((int)f * 10) > 0)
	//	{
	//		sprintf(buf,"基础属性+%.1f%%\0",f);
	//	}
	//	else
	//	{
	//		sprintf(buf,"基础属性+%.0f%%\0",f);
	//	}
	//	str = buf;
	//	//str = "基础属性"+crArgumentParser::appFtoa(f)+"%";
	//	return str;
	//}
	short base;
	std::string perstr[27]={"攻速","CD缩减","移动速度","护甲值","法术抗性","基础格挡","攻击力","生命","基础暴击",
		"基础闪避","攻城攻击","射程","基础命中","穿透","法术穿透","潜行","反潜行","视野","无视闪避\n","反弹物伤",
		"反弹法伤","物理吸血","法术吸血","暴击伤害","溅射伤害\n","物伤加深","法伤加深"};
	std::vector<float>v_i;
	std::string _str;
	for (int i = 0; i<28;i++)
	{
		if(i==18)
		{//无视闪避
			base = (short)(atoi(record[startid+i].c_str()));
			if(base!=0)
			{
				str += "无视闪避";
				str += sign;
			}
		}
		//else if(i==23)
		//{//暴击剑,不可叠加
		//	base = (short)(atoi(record[startid+i].c_str()));
		//	if(base!=0)
		//	{
		//		float f = (float)base * 0.1f;
		//		//sprintf(buf,"暴击伤害+%.1f%%\0",f);
		//		if (base - ((int)f * 10) > 0)
		//		{
		//			sprintf(buf,"暴击伤害+%.1f%%,\0",f);
		//		}
		//		else
		//		{
		//			sprintf(buf,"暴击伤害+%.0f%%,\0",f);
		//		}
		//		str += buf;
		//		//str += "暴击伤害提升到250%,";
		//	}
		//}
		else if(i==24)
		{//溅射,不可叠加
			crVector2f vecbase;
			if(crArgumentParser::appAtoVec(record[startid+i],vecbase))
			{
				char buf[64];
				sprintf(buf,"近战溅射伤害(%d,%.1f%%)%c\0",(short)vecbase[0],vecbase[1]*0.1f,sign);
				//sprintf(buf,"溅射伤害(%d,%d%%),\0",(short)vecbase[0],(short)vecbase[1]);
				str += buf;
			}
		}
		else if(i==25)
		{
			_str = perstr[i];
			base = (short)(atoi(record[startid+i].c_str()));
			if(base<0)
			{
				base = -base;
				_str = "物伤减免";
			}
			if(base!=0)
			{
				float f = (float)base * 0.1f;
				if (base - ((int)f * 10) > 0)
				{
					sprintf(buf,"+%.1f%%%c\0",f,sign);
				}
				else
				{
					sprintf(buf,"+%.0f%%%c\0",f,sign);
				}
				str += _str+buf;
				//str += _str+crArgumentParser::appFtoa(f)+"%,";
			}
		}
		else if(i==26)
		{
			_str = perstr[i];
			base = (short)(atoi(record[startid+i].c_str()));
			if(base<0)
			{
				base = -base;
				_str = "法伤减免";
			}
			if(base!=0)
			{
				float f = (float)base * 0.1f;
				if (base - ((int)f * 10) > 0)
				{
					sprintf(buf,"+%.1f%%%c\0",f,sign);
				}
				else
				{
					sprintf(buf,"+%.0f%%%c\0",f,sign);
				}
				str += _str+buf;
				//str += _str+crArgumentParser::appFtoa(f)+"%,";
			}
		}
		else if (i == 27)
		{
			if ((startid + i) < record.size())
			{
				crTableIO::StrVec bufRec;
				ref_ptr<crTableIO>skillAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SkillDataAttrTab);
				int bufindex = skillAttrTab->getTitleIndex("描述");
				int bufaid = atoi(record[startid + i].c_str());
				if (bufaid > 0)
				{
					if (skillAttrTab->queryOneRecord(0, crArgumentParser::appItoa(bufaid), bufRec) >= 0)
					{//buf描述
						if (!bufRec[bufindex].empty())
						{
							str += bufRec[bufindex] + sign;
						}
					}
				}
			}
		}
		else
		{
			base = (short)(atoi(record[startid+i].c_str()));
			if(base!=0)
			{
				if(i<=1||(i>=3&&i<=10)||(i>=12&&i<=14)||(i>=19&&i<=22)||i==23)
				{
					float f = (float)base * 0.1f;
					if (base - ((int)f * 10) > 0)
					{
						sprintf(buf,"%.1f%%%c\0",f,sign);
					}
					else
					{
						sprintf(buf,"%.0f%%%c\0",f,sign);
					}
					
					if(base<0)
						str += perstr[i]+"-"+buf;
					else
						str += perstr[i]+"+"+buf;
					//str += perstr[i]+crArgumentParser::appFtoa(f)+"%,";
				}
				else
				{
					if(base<0)
						str += perstr[i]+"-"+crArgumentParser::appItoa(base)+sign;
					else
						str += perstr[i]+"+"+crArgumentParser::appItoa(base)+sign;
				}
			}
		}
	}
	if(!str.empty())
		str[str.length()-1] = '\n';
	return str;
}
void crJXJCreateItemTipsMethod::operator()(crHandle &handle)
{
	if(m_outscript)
	{
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec record,roleRec,bufRec;
		crTableIO::DataVec records;
		std::string strItemID = crArgumentParser::appItoa(m_item[0]);
		if (itemtab.valid() && itemtab->queryOneRecord(0,strItemID,record)>=0)
		{
			ref_ptr<crTableIO>equipRoleExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRoleExtraTab);
			ref_ptr<crTableIO>equipTroopsExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipTroopsExtraTab);
			ref_ptr<crTableIO>roleTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);

			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
			crRole *mainRole = playerGameData->getMainRole();
			crData *roleData = mainRole->getDataClass();
			void *param;
			roleData->getParam(WCHDATA_Level,param);
			unsigned char rolelv = *(unsigned char *)param;

			int nameindex = itemtab->getTitleIndex("name");
			int typeindex = itemtab->getTitleIndex("类型");
			int colorindex = itemtab->getTitleIndex("品质");
			int needlvindex = itemtab->getTitleIndex("人物等级");
			int miaoshuindex = itemtab->getTitleIndex("物品描述");
			int priceindex = itemtab->getTitleIndex("回收价格");
			int cardindex = itemtab->getTitleIndex("将卡类型");
			int itemtype = atoi(record[typeindex].c_str());
			std::vector<float>v_i;
			v_i.resize(4);
			std::string str;
			ref_ptr<crTableIO>skillAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SkillDataAttrTab);
			int bufindex = skillAttrTab->getTitleIndex("描述");
			int bufaid;
			if(itemtype == IT_Jiangka)
			{
				int abstractindex = itemtab->getTitleIndex("abstractid");
				int abstractid = atoi(record[abstractindex].c_str());
				if(abstractid>0)
				{
					ref_ptr<crTableIO>equipAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_EquipDataAttrTab);
					ref_ptr<crTableIO>cardExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCardExtraTab);
					crTableIO::StrVec skillRec,equipRec,carExtraRec,otherCardRec;
					m_outscript->Add("Hypertext");
					m_outscript->Push("Hypertext");
					m_outscript->Add("LineSpacing",2);
					v_i[0] = 32;
					v_i[1] = 32;
					v_i[2] = 32;
					v_i[3] = 255;
					m_outscript->Add("Color",v_i);
					//m_outscript->Add("CharacterSize",12);
					int nContent = 1;
					//物品描述
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					m_outscript->Add("Text",record[miaoshuindex]+"\n");
					m_outscript->Pop();
					int cardtype = atoi(record[cardindex].c_str());
					if(cardtype<2)
					{
						if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(abstractid),skillRec)>=0)
						{//buf描述
							if(!skillRec[bufindex].empty())
							{
								m_outscript->Add("Content");
								m_outscript->Push("Content",nContent++);
								m_outscript->Add("Text",skillRec[bufindex]+"\n");
								m_outscript->Pop();
							}
						}
						if(equipAttrTab->queryOneRecord(0,strItemID/*crArgumentParser::appItoa(abstractid)*/,equipRec)>=0)
						{//被动将卡属性描述
							int startindex = equipAttrTab->getTitleIndex("攻速");
							std::string str = getMagicAttrTipsStr(startindex,equipRec);
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Text",str+"\n");
							m_outscript->Pop();
						}
						if(cardtype == 0 && !skillRec.empty())
						{//
							int damageindex = skillAttrTab->getTitleIndex("伤害");
							int percentDamageindex = skillAttrTab->getTitleIndex("千分比伤害");
							int cdindex = skillAttrTab->getTitleIndex("CD");
							int rindex = skillAttrTab->getTitleIndex("使用半径");
							int damage = atoi(skillRec[damageindex].c_str());
							int percentdamage = atoi(skillRec[percentDamageindex].c_str());
							//if(damage>0 || percentdamage>0)
							//{
							//	if(damage>0 && percentdamage>0)
							//	{
							//		char damagebuf[64];
							//		sprintf(damagebuf,",普攻伤害%.1f%%\n\0",percentdamage*0.1f);
							//		m_outscript->Add("Content");
							//		m_outscript->Push("Content",nContent++);
							//		m_outscript->Add("Text","技能伤害："+skillRec[damageindex]+damagebuf);
							//		m_outscript->Pop();
							//	}
							//	else if(damage>0)
							//	{
							//		m_outscript->Add("Content");
							//		m_outscript->Push("Content",nContent++);
							//		m_outscript->Add("Text","技能伤害："+skillRec[damageindex]+"\n");
							//		m_outscript->Pop();
							//	}
							//	else
							//	{
							//		char damagebuf[64];
							//		sprintf(damagebuf,"技能伤害：普攻伤害%.1f%%\n\0",percentdamage*0.1f);
							//		m_outscript->Add("Content");
							//		m_outscript->Push("Content",nContent++);
							//		m_outscript->Add("Text",damagebuf);
							//		m_outscript->Pop(); 
							//	}
							//}
							if(!skillRec[cdindex].empty())
							{
								int cd = atoi(skillRec[cdindex].c_str());
								if(cd>0)
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Text","冷却时间："+skillRec[cdindex]+"，");
									m_outscript->Pop();
								}
							}
							if(!skillRec[rindex].empty())
							{
								int r = atoi(skillRec[rindex].c_str());
								if(r > 0)
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Text","施法距离："+skillRec[rindex]+"\n");
									m_outscript->Pop();
								}
								else
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Text","施法距离：以自身为中心\n");
									m_outscript->Pop();
								}
							}
						}
						//专属加成描述
						equipTroopsExtraTab->queryRecords(0,strItemID,records);
						int startid = 0;
						if(!records.empty())
						{
							startid = equipTroopsExtraTab->getTitleIndex("攻速");
							int troopsid = 0;
							std::string strbingzhong;
							for( crTableIO::DataVec::iterator ditr = records.begin();
								ditr != records.end();
								++ditr )
							{
								troopsid = atoi((*ditr)[2].c_str());
								switch (troopsid)
								{
								case 0:
									strbingzhong = "步兵加成";
									break;
								case 1:
									strbingzhong = "弓兵加成";
									break;
								case 2:
									strbingzhong = "骑兵加成";
									break;
								case 3:
									strbingzhong = "器械加成";
									break;
								}
								m_outscript->Add("Content");
								m_outscript->Push("Content",nContent++);
								v_i[0] = 90;
								v_i[1] = 0;
								v_i[2] = 0;
								v_i[3] = 255;
								m_outscript->Add("Color",v_i);
								//m_outscript->Add("Text",strbingzhong+":");

								str = getMagicAttrTipsStr(startid,*ditr);
								//bufaid = atoi((*ditr)[startid+27].c_str());
								//if(bufaid>0)
								//{
								//	if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
								//	{//buf描述
								//		if(!bufRec[bufindex].empty())
								//		{
								//			if(str.empty())
								//				str = bufRec[bufindex];
								//			else
								//				str+=","+bufRec[bufindex];
								//		}
								//	}
								//}
								m_outscript->Add("Text",strbingzhong+":"+str+"\n");

								m_outscript->Pop();
							}
						}
						else
						{
							startid = equipRoleExtraTab->getTitleIndex("攻速");
							equipRoleExtraTab->queryRecords(0,strItemID,records);
							if(!records.empty())
							{
								int roleaid = 0;
								for( crTableIO::DataVec::iterator ditr = records.begin();
									ditr != records.end();
									++ditr )
								{
									roleaid = atoi((*ditr)[2].c_str());
									if(roleTab->queryOneRecord(0,crArgumentParser::appItoa(roleaid),roleRec)>=0)
									{
										m_outscript->Add("Content");
										m_outscript->Push("Content",nContent++);
										v_i[0] = 90;
										v_i[1] = 0;
										v_i[2] = 0;
										v_i[3] = 255;
										m_outscript->Add("Color",v_i);
										//m_outscript->Add("Text",roleRec[1]+"加成:");
										str = getMagicAttrTipsStr(startid,*ditr);
										//bufaid = atoi((*ditr)[startid+27].c_str());
										//if(bufaid>0)
										//{
										//	if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
										//	{//buf描述
										//		if(!bufRec[bufindex].empty())
										//		{
										//			if(str.empty())
										//				str = bufRec[bufindex];
										//			else
										//				str+=","+bufRec[bufindex];
										//		}
										//	}
										//}
										m_outscript->Add("Text",roleRec[1]+"加成:"+str+"\n");
										m_outscript->Pop();
									}
								}
							}
						}
						/////////组合将卡描述
						//if(cardtype == 0)
						//{//主卡
						//	bool bFound = false;
						//	int nRowCount = cardExtraTab->getRowCount();
						//	std::string strSearch1("|");
						//	strSearch1 += strItemID + "|";
						//	for (int i=0; i<nRowCount; i++)
						//	{
						//		if ((*cardExtraTab)(i,0).find(strSearch1)!=std::string::npos)
						//		{
						//			carExtraRec = cardExtraTab->getDataVec()[i];
						//			bFound = true;
						//			break;
						//		}
						//	}

						//	if(bFound)
						//	{
						//		std::string otherCard = carExtraRec[1];
						//		otherCard.erase(0,1);
						//		int i = otherCard.find('|');
						//		otherCard = otherCard.substr(0,i);
						//		if (itemtab->queryOneRecord(0,otherCard,otherCardRec)>=0)
						//		{
						//			std::string otherName = otherCardRec[nameindex];
						//			int startindex = cardExtraTab->getTitleIndex("攻速");
						//			str = getMagicAttrTipsStr(startindex,carExtraRec);
						//			bufaid = atoi(carExtraRec[startindex+27].c_str());
						//			if(bufaid>0)
						//			{
						//				if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
						//				{//buf描述
						//					if(!bufRec[bufindex].empty())
						//					{
						//						if(str.empty())
						//							str = bufRec[bufindex];
						//						else
						//							str+=","+bufRec[bufindex];
						//					}
						//				}
						//			}
						//			m_outscript->Add("Content");
						//			m_outscript->Push("Content",nContent++);
						//			v_i[0] = 0;
						//			v_i[1] = 40;
						//			v_i[2] = 100;
						//			v_i[3] = 255;
						//			m_outscript->Add("Color",v_i);
						//			m_outscript->Add("Text","与"+otherName+"组合："+str+"\n");
						//			m_outscript->Pop();
						//		}
						//	}
						//}
						//else
						//{//副卡
						//	bool bFound = false;
						//	int nRowCount = cardExtraTab->getRowCount();
						//	std::string strSearch1("|");
						//	strSearch1 += strItemID + "|";
						//	for (int i=0; i<nRowCount; i++)
						//	{
						//		if ((*cardExtraTab)(i,1).find(strSearch1) != std::string::npos)
						//		{
						//			carExtraRec = cardExtraTab->getDataVec()[i];
						//			bFound = true;
						//			break;
						//		}
						//	}

						//	if(bFound)
						//	{
						//		std::string otherCard = carExtraRec[0];
						//		otherCard.erase(0,1);
						//		int i = otherCard.find('|');
						//		otherCard = otherCard.substr(0,i);
						//		if (itemtab->queryOneRecord(0,otherCard,otherCardRec)>=0)
						//		{
						//			std::string otherName = otherCardRec[nameindex];
						//			//int startindex = cardExtraTab->getTitleIndex("攻速");
						//			//str = getMagicAttrTipsStr(startindex,carExtraRec);
						//			//bufaid = atoi(carExtraRec[startindex+27].c_str());
						//			//if(bufaid>0)
						//			//{
						//			//	if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
						//			//	{//buf描述
						//			//		if(!bufRec[bufindex].empty())
						//			//		{
						//			//			str+=","+bufRec[bufindex];
						//			//		}
						//			//	}
						//			//}
						//			m_outscript->Add("Content");
						//			m_outscript->Push("Content",nContent++);
						//			v_i[0] = 0;
						//			v_i[1] = 40;
						//			v_i[2] = 100;
						//			v_i[3] = 255;
						//			m_outscript->Add("Color",v_i);
						//			m_outscript->Add("Text","可与"+otherName+"组合\n");
						//			m_outscript->Pop();
						//		}
						//	}
						//}
					}
					int price = atoi(record[priceindex].c_str());
					if(price>0)
					{
						//出售价格
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("Text","出售将魂:"+record[priceindex]+"\n");
						m_outscript->Pop();
					}
					else
					{
						//不可出售
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("Text","不可出售/n");
						m_outscript->Pop();
					}
					//End
					m_outscript->Pop();
				}
				else
				{//政卡
					ref_ptr<crTableIO>ZhengCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
					crTableIO::StrVec ZhengRecord;
					std::string zhengstr;
					int zhengtypeindex = ZhengCardTab->getTitleIndex("政卡类型");
					int zhengaddindex = ZhengCardTab->getTitleIndex("政卡加成");
					m_outscript->Add("Hypertext");
					m_outscript->Push("Hypertext");
					m_outscript->Add("LineSpacing",2);
					v_i[0] = 0;
					v_i[1] = 0;
					v_i[2] = 0;
					v_i[3] = 255;
					m_outscript->Add("Color",v_i);
					m_outscript->Add("CharacterSize",12);
					int nContent = 1;
					////物品描述
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					m_outscript->Add("Text",record[miaoshuindex]+"\n");
					m_outscript->Pop();
					//加成数值
					if(ZhengCardTab->queryOneRecord(0,strItemID,ZhengRecord)>=0)
					{
						switch (atoi(ZhengRecord[zhengtypeindex].c_str()))
						{
						case ZhengAdd_ReduceBuildingLevelUpResource:
							zhengstr = "减少建筑升级消耗：";
							break;
						case ZhengAdd_IncreaseCopperGet:
							zhengstr = "增加铜币收入：";
							break;
						case ZhengAdd_IncreaseFoodGet:
							zhengstr = "增加粮食收入：";
							break;
						case ZhengAdd_ReduceRecruitResource:
							zhengstr = "减少招募消耗：";
							break;
						case ZhengAdd_IncreaseWoodGet:
							zhengstr = "增加木材收入：";
							break;
						case ZhengAdd_IncreaseIronGet:
							zhengstr = "增加铁矿收入：";
							break;
						case ZhengAdd_IncreaseHoreseGet:
							zhengstr = "增加马匹收入：";
							break;
						case ZhengAdd_ReduceRecruitCD:
							zhengstr = "减少招募时间：";
							break;
						case ZhengAdd_AddFukuLimit:
							zhengstr = "增加府库容量：";
							break;
						case ZhengAdd_ReduceBuildingLevelUpCD:
							zhengstr = "减少建筑升级时间：";
							break;
						default:
							break;
						}
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("Text",zhengstr + ZhengRecord[zhengaddindex]+"%\n");
						m_outscript->Pop();
					}
					int price = atoi(record[priceindex].c_str());
					if(price>0)
					{
						//出售价格
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("Text","出售将魂:"+record[priceindex]+"\n");
						m_outscript->Pop();
					}
					else
					{
						//不可出售
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("Text","不可出售/n");
						m_outscript->Pop();
					}
					//End
					m_outscript->Pop();
				}
			}
			else if(itemtype == IT_Equip)
			{
				crTableIO::StrVec lordrecord;
				ref_ptr<crTableIO>equiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
				if (equiptab->queryOneRecord(0,strItemID,lordrecord)>=0)
				{
					int bingfaindex = equiptab->getTitleIndex("兵法");
					int zhengfaindex = equiptab->getTitleIndex("阵法");
					int dongchaindex = equiptab->getTitleIndex("洞察");
					int tongsuaiindex = equiptab->getTitleIndex("统率");
					int bingzhongindex = equiptab->getTitleIndex("兵种");

					int partindex = equiptab->getTitleIndex("partid");
					int partid = atoi(lordrecord[partindex].c_str());
					switch (partid)
					{
					case ET_Helmet:
						str = "头盔";
						break;
					case ET_Armour:
						str = "铠甲";
						break;
					case ET_Weapon:
						str = "武器";
						break;
					case ET_Book:
						str = "书籍";
						break;
					case ET_Horse:
						str = "马匹";
						break;
					}
					m_outscript->Add("Hypertext");
					m_outscript->Push("Hypertext");
					m_outscript->Add("LineSpacing",2);
					v_i[0] = 32;
					v_i[1] = 32;
					v_i[2] = 32;
					v_i[3] = 255;
					m_outscript->Add("Color",v_i);
					m_outscript->Add("CharacterSize",15);
					int nContent = 1;
					//部位
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					m_outscript->Add("CharacterSize",16);
					m_outscript->Add("Text",str+"\n");
					m_outscript->Pop();
					//ref_ptr<crTableIO>equiplvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquiplvTab);
					//int lvstartid = 0;
					//_crInt16 lo16 = LOINT32(m_item[1]);
					//_crInt16 hi16 = HIINT32(m_item[1]);
					//unsigned char magicid = LOINT16(lo16);
					//unsigned char equiplv = HIINT16(lo16);
					//unsigned char equipinlay = LOINT16(hi16);
					//float addbingfa = 0.0f;
					//float addzhengfa = 0.0f;
					//float adddongcha = 0.0f;
					//float addtongshuai = 0.0f;
					//crTableIO::StrVec equiplvrecord;
					//int bingfaid = equiplvtab->getTitleIndex("兵法");
					//if(equiplv>0&&equiplvtab->queryOneRecord(0,strItemID,2,crArgumentParser::appItoa(equiplv),equiplvrecord)>=0)
					//{
					//	lvstartid = equiplvtab->getTitleIndex("攻速");
					//	addbingfa = atof(equiplvrecord[bingfaid].c_str()) * 0.001f;
					//	addzhengfa = atof(equiplvrecord[bingfaid+1].c_str()) * 0.001f;
					//	adddongcha = atof(equiplvrecord[bingfaid+2].c_str()) * 0.001f;
					//	addtongshuai = atof(equiplvrecord[bingfaid+3].c_str()) * 0.001f;
					//}
					//兵法
					v_i[0] = 32;
					v_i[1] = 32;
					v_i[2] = 32;
					v_i[3] = 255;
					short bingfa = atoi(lordrecord[bingfaindex].c_str());
					if(bingfa!=0)
					{
						//short abingfa = bingfa;
						//bingfa = (float)bingfa * (1.0f + addbingfa);
						//abingfa = bingfa-abingfa;
						createContent(nContent,"兵法:",bingfa,0,false,true,v_i);
					}
					//阵法
					short zhengfa = atoi(lordrecord[zhengfaindex].c_str());
					if(zhengfa!=0)
					{
						//short azhengfa = zhengfa;
						//zhengfa = (float)zhengfa * (1.0f + addzhengfa);
						//azhengfa = zhengfa-azhengfa;
						createContent(nContent,"阵法:",zhengfa,0,false,true,v_i);
					}
					//洞察
					short dongcha = atoi(lordrecord[dongchaindex].c_str());
					if(dongcha!=0)
					{
						//short adongcha = dongcha;
						//dongcha = (float)dongcha * (1.0f + adddongcha);
						//adongcha = dongcha-adongcha;
						createContent(nContent,"洞察:",dongcha,0,false,true,v_i);
					}
					//统率
					short tongsuai = atoi(lordrecord[tongsuaiindex].c_str());
					if(tongsuai!=0)
					{
						//short atongsuai = tongsuai;
						//tongsuai = (float)tongsuai * (1.0f + addtongshuai);
						//atongsuai = tongsuai-atongsuai;
						createContent(nContent,"统率:",tongsuai,0,false,true,v_i);
					}
					//兵种专属
					int bingzhong = atoi(lordrecord[bingzhongindex].c_str());
					std::string strbingzhong;
					switch (bingzhong)
					{
					case 0:
						strbingzhong = "步兵专属(精附)";
						break;
					case 1:
						strbingzhong = "弓兵专属(精附)";
						break;
					case 2:
						strbingzhong = "骑兵专属(精附)";
						break;
					case 3:
						strbingzhong = "器械专属(精附)";
						break;
					}
					if(bingzhong!=-1)
					{
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						v_i[0] = 32;
						v_i[1] = 32;
						v_i[2] = 32;
						v_i[3] = 255;
						m_outscript->Add("Color",v_i);
						m_outscript->Add("CharacterSize",16);
						m_outscript->Add("Text",strbingzhong+"\n");
						m_outscript->Pop();
					}
					/////////////精炼描述
					crTableIO::StrVec refrecord,qualityRec;
					ref_ptr<crTableIO>equipref0tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine0Tab);
					ref_ptr<crTableIO>equipref1tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine1Tab);
					ref_ptr<crTableIO>equipref2tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine2Tab);
					ref_ptr<crTableIO>refcreatetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefineCreateTab);
					int rowcount = refcreatetab->getRowCount();
					int row;
					crVector2i idrange;
					int refstart = equipref0tab->getTitleIndex("攻速");
					_crInt16 lo16 = LOINT32(m_item[1]);
					_crInt16 hi16 = HIINT32(m_item[1]);
					unsigned char ref0 = LOINT16(lo16);
					unsigned char ref1 = HIINT16(lo16);
					unsigned char ref2 = LOINT16(hi16);
					unsigned char inlayid = HIINT16(hi16);
					crVector4 ref0color,ref1color,ref2color;
					ref_ptr<crTableIO>qualitytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJQualityTab);
					int qualityid;
					if(ref0>0||ref1>0||ref2>0)
					{
						for(row = 0; row<rowcount; row++)
						{
							crArgumentParser::appAtoVec((*refcreatetab)(row,1),idrange);
							qualityid = atoi((*refcreatetab)(row,0).c_str());
							qualitytab->queryOneRecord(0,crArgumentParser::appItoa(qualityid),qualityRec);
							if(ref0>=idrange[0]&&ref0<idrange[1])
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),ref0color);
							}
							if(ref1>=idrange[0]&&ref1<idrange[1])
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),ref1color);
							}
							if(ref2>=idrange[0]&&ref2<idrange[1])
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),ref2color);
							}
						}
						m_outscript->Add("Content");
						m_outscript->Push("Content", nContent++);
						v_i[0] = 32;
						v_i[1] = 32;
						v_i[2] = 32;
						v_i[3] = 255;
						m_outscript->Add("Color",v_i);
						m_outscript->Add("CharacterSize",16);
						m_outscript->Add("Text","精炼属性：\n");
						m_outscript->Pop();
					}
					if(ref0>0&&equipref0tab->queryOneRecord(0,crArgumentParser::appItoa(ref0),refrecord)>=0)
					{
						v_i[0] = ref0color[0];
						v_i[1] = ref0color[1];
						v_i[2] = ref0color[2];
						v_i[3] = ref0color[3];
						setMagicAttrTips(nContent,refstart,refrecord,v_i);
						bufaid = atoi(refrecord[refstart+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					if(ref1>0&&equipref1tab->queryOneRecord(0,crArgumentParser::appItoa(ref1),refrecord)>=0)
					{
						v_i[0] = ref1color[0];
						v_i[1] = ref1color[1];
						v_i[2] = ref1color[2];
						v_i[3] = ref1color[3];
						setMagicAttrTips(nContent,refstart,refrecord,v_i);
						bufaid = atoi(refrecord[refstart+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					if(ref2>0&&equipref2tab->queryOneRecord(0,crArgumentParser::appItoa(ref2),refrecord)>=0)
					{
						v_i[0] = ref2color[0];
						v_i[1] = ref2color[1];
						v_i[2] = ref2color[2];
						v_i[3] = ref2color[3];
						setMagicAttrTips(nContent,refstart,refrecord,v_i);
						bufaid = atoi(refrecord[refstart+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					//镶嵌描述
					crVector4 stonecolor;
					ref_ptr<crTableIO>equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
					ref_ptr<crTableIO>inlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInlayTab);
					std::string equipinlayStr = crArgumentParser::appItoa(inlayid);
					crTableIO::StrVec inlayrecord;
					if(inlayid>0 && equipinlaytab->queryOneRecord(0,crArgumentParser::appItoa(partid),2,equipinlayStr,inlayrecord)>=0)
					{
						m_outscript->Add("Content");
						m_outscript->Push("Content", nContent++);
						v_i[0] = 32;
						v_i[1] = 32;
						v_i[2] = 32;
						v_i[3] = 255;
						m_outscript->Add("Color",v_i);
						m_outscript->Add("CharacterSize",16);
						m_outscript->Add("Text","附炼属性：\n");
						m_outscript->Pop();
						stonecolor.set(0,0,0,255);
						crTableIO::StrVec inlayRec;
						if(inlaytab->queryOneRecord(1,equipinlayStr,inlayRec)>=0)
						{
							int stoneid = atoi(inlayRec[0].c_str());
							int qualityid = 0;
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(stoneid),inlayRec)>=0)
							{
								int qualityindex = itemtab->getTitleIndex("品质");
								qualityid = atoi(inlayRec[qualityindex].c_str());
							}
							if(qualitytab->queryOneRecord(0,crArgumentParser::appItoa(qualityid),qualityRec)>=0)
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),stonecolor);
							}
						}
						int inlaybingfaid = equipinlaytab->getTitleIndex("兵法");
						int inlaystartid = equipinlaytab->getTitleIndex("攻速");
						v_i[0] = stonecolor[0];
						v_i[1] = stonecolor[1];
						v_i[2] = stonecolor[2];
						v_i[3] = stonecolor[3];
						//兵法
						short bingfa = atoi(inlayrecord[inlaybingfaid].c_str());
						if(bingfa!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","兵法:+"+inlayrecord[inlaybingfaid]+"\n");
							m_outscript->Pop();
						}
						//阵法
						short zhengfa = atoi(inlayrecord[inlaybingfaid+1].c_str());
						if(zhengfa!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","阵法:+"+inlayrecord[inlaybingfaid+1]+"\n");
							m_outscript->Pop();
						}
						//洞察
						short dongcha = atoi(inlayrecord[inlaybingfaid+2].c_str());
						if(dongcha!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","洞察:+"+inlayrecord[inlaybingfaid+2]+"\n");
							m_outscript->Pop();
						}
						//统率
						short tongsuai = atoi(inlayrecord[inlaybingfaid+3].c_str());
						if(tongsuai!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","统率:+"+inlayrecord[inlaybingfaid+3]+"\n");
							m_outscript->Pop();
						}

						setMagicAttrTips(nContent,inlaystartid,inlayrecord,v_i);
						bufaid = atoi(inlayrecord[inlaystartid+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					////套装描述
					ref_ptr<crTableIO>suitequiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipSuitTab);
					crTableIO::StrVec suitequiprecord,srecord2;
					int equipindex = suitequiptab->getTitleIndex("头盔");
					JXJLordEquipVec *lordequipvec =NULL;

					if(suitequiptab->queryOneRecord(equipindex+partid,strItemID,suitequiprecord)>=0)
					{//是套装
						int suitenameindex = suitequiptab->getTitleIndex("套装名");
						roleData->getParam(WCHDATA_JXJLordEquipVec,param);
						JXJLordEquipVec lordequipvec = *(JXJLordEquipVec *)param;
						int maxcount = 0;
						int equipcount = 0;
						int equipid = 0;
						//其他玩家套装
						if (!m_otherLordEquipVec.empty())
						{
							lordequipvec = m_otherLordEquipVec;
							m_otherLordEquipVec.clear();
						}
						for (int i = 0; i<ET_Count; i++)
						{
							equipid = atoi(suitequiprecord[equipindex + i].c_str());
							if (equipid>0)
							{
								maxcount++;
								if ((lordequipvec)[i].first == equipid)
								{
									equipcount++;
								}
							}
						}

						//////////////////////////////////////////////////////////////////////////
						char buf[256];
						sprintf(buf,"%s(%d/%d)/n\0",suitequiprecord[suitenameindex].c_str(),equipcount,maxcount);
						//套装名称
						m_outscript->Add("Content");
						m_outscript->Push("Content", nContent++);
						v_i[0] = 32;
						v_i[1] = 32;
						v_i[2] = 32;
						v_i[3] = 255;
						m_outscript->Add("Color",v_i);
						m_outscript->Add("CharacterSize",16);
						m_outscript->Add("Text",buf);
						m_outscript->Pop();

						ref_ptr<crTableIO>suitequip2tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipSuit2Tab);
						int s2startindex = suitequip2tab->getTitleIndex("攻速");
						//int s2texindex = suitequip2tab->getTitleIndex("描述");
						crTableIO::DataVec suitequip2Rec;
						suitequip2tab->queryRecords(0,suitequiprecord[0],suitequip2Rec);
						for(int i = 0; i<suitequip2Rec.size();++i)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							if(i+2 <= equipcount)
							{
								v_i[0] = 32;
								v_i[1] = 32;
								v_i[2] = 32;
								v_i[3] = 255;
								m_outscript->Add("Color",v_i);
							}
							else
							{
								v_i[0] = 120;
								v_i[1] = 120;
								v_i[2] = 120;
								v_i[3] = 255;
								m_outscript->Add("Color",v_i);
							}
							str = getMagicAttrTipsStr(s2startindex,suitequip2Rec[i]);
							//bufaid = atoi(suitequip2Rec[i][s2startindex+27].c_str());
							//if(bufaid>0)
							//{
							//	if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							//	{//buf描述
							//		if(!bufRec[bufindex].empty())
							//		{
							//			if(str.empty())
							//				str = bufRec[bufindex];
							//			else
							//				str+=","+bufRec[bufindex];
							//		}
							//	}
							//}
							sprintf(buf,"装备%d件:%s/n\0",i+2,str.c_str());
							m_outscript->Add("Text",buf);
							m_outscript->Pop();
						}
						for(int i = 0; i<ET_Count; i++)
						{
							equipid = atoi(suitequiprecord[equipindex+i].c_str());
							if(equipid>0)
							{
								m_outscript->Add("Content");
								m_outscript->Push("Content",nContent++);
								if((lordequipvec)[i].first == equipid)
								{
									v_i[0] = 32;
									v_i[1] = 32;
									v_i[2] = 32;
									v_i[3] = 255;
									m_outscript->Add("Color",v_i);
								}
								else
								{
									v_i[0] = 192;
									v_i[1] = 192;
									v_i[2] = 192;
									v_i[3] = 255;
									m_outscript->Add("Color",v_i);
								}
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(equipid),srecord2)>=0)
									str = srecord2[nameindex];
								m_outscript->Add("Text",str+"\n");
								m_outscript->Pop();
							}
						}
					}
					//专属加成描述
					int extstartid;
					equipTroopsExtraTab->queryRecords(0,strItemID,records);
					if(!records.empty())
					{
						extstartid = equipTroopsExtraTab->getTitleIndex("攻速");
						int troopsid = 0;
						for( crTableIO::DataVec::iterator ditr = records.begin();
							 ditr != records.end();
							 ++ditr )
						{
							troopsid = atoi((*ditr)[2].c_str());
							switch (bingzhong)
							{
							case 0:
								strbingzhong = "步兵加成";
								break;
							case 1:
								strbingzhong = "弓兵加成";
								break;
							case 2:
								strbingzhong = "骑兵加成";
								break;
							case 3:
								strbingzhong = "器械加成";
								break;
							}
							m_outscript->Add("Content");
							m_outscript->Push("Content", nContent++);
							v_i[0] = 32;
							v_i[1] = 32;
							v_i[2] = 32;
							v_i[3] = 255;
							m_outscript->Add("Color",v_i);
							//m_outscript->Add("Text",strbingzhong+":");
							str = getMagicAttrTipsStr(extstartid,*ditr);
							//bufaid = atoi((*ditr)[extstartid+27].c_str());
							//if(bufaid>0)
							//{
							//	if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							//	{//buf描述
							//		if(!bufRec[bufindex].empty())
							//		{
							//			if(str.empty())
							//				str = bufRec[bufindex];
							//			else
							//				str+=","+bufRec[bufindex];
							//		}
							//	}
							//}
							m_outscript->Add("Text",strbingzhong+":"+str+"\n");
							m_outscript->Pop();
						}
					}
					else
					{
						extstartid = equipRoleExtraTab->getTitleIndex("攻速");
						equipRoleExtraTab->queryRecords(0,strItemID,records);
						if(!records.empty())
						{
							int roleaid = 0;
							for( crTableIO::DataVec::iterator ditr = records.begin();
								ditr != records.end();
								++ditr )
							{
								roleaid = atoi((*ditr)[2].c_str());
								if(roleTab->queryOneRecord(0,crArgumentParser::appItoa(roleaid),roleRec)>=0)
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content", nContent++);
									v_i[0] = 32;
									v_i[1] = 32;
									v_i[2] = 32;
									v_i[3] = 255;
									m_outscript->Add("Color",v_i);
									//m_outscript->Add("Text",roleRec[1]+"加成:");
									str = getMagicAttrTipsStr(extstartid,*ditr);
									//bufaid = atoi((*ditr)[extstartid+27].c_str());
									//if(bufaid>0)
									//{
									//	if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
									//	{//buf描述
									//		if(!bufRec[bufindex].empty())
									//		{
									//			if(str.empty())
									//				str = bufRec[bufindex];
									//			else
									//				str+=","+bufRec[bufindex];
									//		}
									//	}
									//}
									m_outscript->Add("Text",roleRec[1]+"加成:"+str+"\n");
									m_outscript->Pop();
								}
							}
						}
					}

					//需要等级
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					if(rolelv<atoi(record[needlvindex].c_str()))
					{
						v_i[0] = 190;
						v_i[1] = 20;
						v_i[2] = 20;
						v_i[3] = 255;
						m_outscript->Add("Color",v_i);
					}
					m_outscript->Add("CharacterSize",16);
					m_outscript->Add("Text","需要等级:"+record[needlvindex]+"\n");
					m_outscript->Pop();
					int price = atoi(record[priceindex].c_str());
					if(price>0)
					{
						//出售价格
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("CharacterSize",16);
						m_outscript->Add("Text","出售价格:"+record[priceindex]+"\n");
						m_outscript->Pop();
					}
					else
					{
						//不可出售
						m_outscript->Add("Content");
						m_outscript->Push("Content",nContent++);
						m_outscript->Add("CharacterSize",16);
						m_outscript->Add("Text","不可出售/n");
						m_outscript->Pop();
					}
					//物品描述，装备兵种加成描述
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					m_outscript->Add("Text",record[miaoshuindex]+"\n");
					m_outscript->Pop();
					//End
					m_outscript->Pop();
				}
			}
			else
			{
				m_outscript->Add("Hypertext");
				m_outscript->Push("Hypertext");
				m_outscript->Add("LineSpacing", 2);
				v_i[0] = 32;
				v_i[1] = 32;
				v_i[2] = 32;
				v_i[3] = 255;
				m_outscript->Add("Color",v_i);
				m_outscript->Add("CharacterSize",16);
				int nContent = 1;
				//类型
				switch (itemtype)
				{
				case IT_Material:
					str = "材料";
					break;
				case IT_Paper:
					str = "图纸";
					break;
				case IT_Other:
					str = "其它道具";
					break;
				case IT_Mission:
					str = "任务道具";
					break;
				case IT_SmeltMaterial:
					str = "材料";
					break;
				case IT_Gemstone:
					str = "八卦石";
					break;
				}
				m_outscript->Add("Content");
				m_outscript->Push("Content",nContent++);
				m_outscript->Add("Text",str+"\n");
				m_outscript->Pop();

				//需要等级
				int needlv = atoi(record[needlvindex].c_str());
				if(needlv>0)
				{
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					if(rolelv<needlv)
					{
						v_i[0] = 190;
						v_i[1] = 20;
						v_i[2] = 20;
						v_i[3] = 255;
						m_outscript->Add("Color",v_i);
					}
					m_outscript->Add("Text","需要等级:"+record[needlvindex]+"\n");
					m_outscript->Pop();
				}
				int price = atoi(record[priceindex].c_str());
				if(price>0)
				{
					//出售价格
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					m_outscript->Add("Text","出售价格:"+record[priceindex]+"\n");
					m_outscript->Pop();
				}
				else
				{
					//不可出售
					m_outscript->Add("Content");
					m_outscript->Push("Content",nContent++);
					m_outscript->Add("Text","不可出售/n");
					m_outscript->Pop();
				}
				//物品描述
				m_outscript->Add("Content");
				m_outscript->Push("Content",nContent++);
				m_outscript->Add("CharacterSize",15);
				m_outscript->Add("Text",record[miaoshuindex]+"\n");
				m_outscript->Pop();
				//End
				m_outscript->Pop();
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCreateItemRefineTipsMethod
//
/////////////////////////////////////////
crJXJCreateItemRefineTipsMethod::crJXJCreateItemRefineTipsMethod(){}
crJXJCreateItemRefineTipsMethod::crJXJCreateItemRefineTipsMethod(const crJXJCreateItemRefineTipsMethod& handle):
	crJXJCreateItemTipsMethod(handle)
{
}
void crJXJCreateItemRefineTipsMethod::operator()(crHandle &handle)
{
	if(m_outscript)
	{
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec record,bufRec;
		crTableIO::DataVec records;
		std::string strItemID = crArgumentParser::appItoa(m_item[0]);
		if (itemtab.valid() && itemtab->queryOneRecord(0,strItemID,record)>=0)
		{
			ref_ptr<crTableIO>roleTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_RoleDataAttrTab);

			int typeindex = itemtab->getTitleIndex("类型");
			int itemtype = atoi(record[typeindex].c_str());
			std::vector<float>v_i;
			v_i.resize(4);
			std::string str;
			ref_ptr<crTableIO>skillAttrTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_SkillDataAttrTab);
			int bufindex = skillAttrTab->getTitleIndex("描述");
			int bufaid;
			if(itemtype == IT_Equip)
			{
				crTableIO::StrVec lordrecord;
				ref_ptr<crTableIO>equiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
				if (equiptab->queryOneRecord(0,strItemID,lordrecord)>=0)
				{
					m_outscript->Add("Hypertext");
					m_outscript->Push("Hypertext");
					m_outscript->Add("LineSpacing",2);
					v_i[0] = 255;
					v_i[1] = 255;
					v_i[2] = 255;
					v_i[3] = 255;
					m_outscript->Add("Color",v_i);
					m_outscript->Add("CharacterSize",14);
					int nContent = 1;
					/////////////精炼描述
					crTableIO::StrVec refrecord,qualityRec;
					ref_ptr<crTableIO>equipref0tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine0Tab);
					ref_ptr<crTableIO>equipref1tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine1Tab);
					ref_ptr<crTableIO>equipref2tab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine2Tab);
					ref_ptr<crTableIO>refcreatetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefineCreateTab);
					int rowcount = refcreatetab->getRowCount();
					int row;
					crVector2i idrange;
					int refstart = equipref0tab->getTitleIndex("攻速");
					_crInt16 lo16 = LOINT32(m_item[1]);
					_crInt16 hi16 = HIINT32(m_item[1]);
					unsigned char ref0 = LOINT16(lo16);
					unsigned char ref1 = HIINT16(lo16);
					unsigned char ref2 = LOINT16(hi16);
					unsigned char inlayid = HIINT16(hi16);
					crVector4 ref0color,ref1color,ref2color;
					ref_ptr<crTableIO>qualitytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJQualityTab);
					int qualityid;
					if(ref0>0||ref1>0||ref2>0)
					{
						for(row = 0; row<rowcount; row++)
						{
							crArgumentParser::appAtoVec((*refcreatetab)(row,1),idrange);
							qualityid = atoi((*refcreatetab)(row,0).c_str());
							qualitytab->queryOneRecord(0,crArgumentParser::appItoa(qualityid),qualityRec);
							if(ref0>=idrange[0]&&ref0<idrange[1])
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),ref0color);
							}
							if(ref1>=idrange[0]&&ref1<idrange[1])
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),ref1color);
							}
							if(ref2>=idrange[0]&&ref2<idrange[1])
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),ref2color);
							}
						}
						//m_outscript->Add("Content");
						//m_outscript->Push("Content",nContent++);
						//v_i[0] = 0;
						//v_i[1] = 255;
						//v_i[2] = 0;
						//v_i[3] = 255;
						//m_outscript->Add("Color",v_i);
						//m_outscript->Add("Text","精炼属性：\n");
						//m_outscript->Pop();
					}
					if(ref0>0&&equipref0tab->queryOneRecord(0,crArgumentParser::appItoa(ref0),refrecord)>=0)
					{
						v_i[0] = ref0color[0];
						v_i[1] = ref0color[1];
						v_i[2] = ref0color[2];
						v_i[3] = ref0color[3];
						setMagicAttrTips(nContent,refstart,refrecord,v_i);
						bufaid = atoi(refrecord[refstart+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					if(ref1>0&&equipref1tab->queryOneRecord(0,crArgumentParser::appItoa(ref1),refrecord)>=0)
					{
						v_i[0] = ref1color[0];
						v_i[1] = ref1color[1];
						v_i[2] = ref1color[2];
						v_i[3] = ref1color[3];
						setMagicAttrTips(nContent,refstart,refrecord,v_i);
						bufaid = atoi(refrecord[refstart+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					if(ref2>0&&equipref2tab->queryOneRecord(0,crArgumentParser::appItoa(ref2),refrecord)>=0)
					{
						v_i[0] = ref2color[0];
						v_i[1] = ref2color[1];
						v_i[2] = ref2color[2];
						v_i[3] = ref2color[3];
						setMagicAttrTips(nContent,refstart,refrecord,v_i);
						bufaid = atoi(refrecord[refstart+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					//End
					//镶嵌描述
					int partidindex = equiptab->getTitleIndex("partid");
					crVector4 stonecolor;
					ref_ptr<crTableIO>equipinlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipinlayTab);
					ref_ptr<crTableIO>inlaytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInlayTab);
					std::string equipinlayStr = crArgumentParser::appItoa(inlayid);
					crTableIO::StrVec inlayrecord;
					if(inlayid>0 && equipinlaytab->queryOneRecord(0,crArgumentParser::appItoa(atoi(lordrecord[partidindex].c_str())),2,equipinlayStr,inlayrecord)>=0)
					{
						//m_outscript->Add("Content");
						//m_outscript->Push("Content",nContent++);
						//v_i[0] = 0;
						//v_i[1] = 255;
						//v_i[2] = 0;
						//v_i[3] = 255;
						//m_outscript->Add("Color",v_i);
						//m_outscript->Add("CharacterSize",16);
						//m_outscript->Add("Text","附炼属性：\n");
						//m_outscript->Pop();
						stonecolor.set(0,0,0,255);
						crTableIO::StrVec inlayRec;
						if(inlaytab->queryOneRecord(1,equipinlayStr,inlayRec)>=0)
						{
							int stoneid = atoi(inlayRec[0].c_str());
							int qualityid = 0;
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(stoneid),inlayRec)>=0)
							{
								int qualityindex = itemtab->getTitleIndex("品质");
								qualityid = atoi(inlayRec[qualityindex].c_str());
							}
							if(qualitytab->queryOneRecord(0,crArgumentParser::appItoa(qualityid),qualityRec)>=0)
							{
								crArgumentParser::appAtoVec(qualityRec[1].c_str(),stonecolor);
							}
						}
						int inlaybingfaid = equipinlaytab->getTitleIndex("兵法");
						int inlaystartid = equipinlaytab->getTitleIndex("攻速");
						v_i[0] = stonecolor[0];
						v_i[1] = stonecolor[1];
						v_i[2] = stonecolor[2];
						v_i[3] = stonecolor[3];
						//兵法
						short bingfa = atoi(inlayrecord[inlaybingfaid].c_str());
						if(bingfa!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","兵法:+"+inlayrecord[inlaybingfaid]+"\n");
							m_outscript->Pop();
						}
						//阵法
						short zhengfa = atoi(inlayrecord[inlaybingfaid+1].c_str());
						if(zhengfa!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","阵法:+"+inlayrecord[inlaybingfaid+1]+"\n");
							m_outscript->Pop();
						}
						//洞察
						short dongcha = atoi(inlayrecord[inlaybingfaid+2].c_str());
						if(dongcha!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","洞察:+"+inlayrecord[inlaybingfaid+2]+"\n");
							m_outscript->Pop();
						}
						//统率
						short tongsuai = atoi(inlayrecord[inlaybingfaid+3].c_str());
						if(tongsuai!=0)
						{
							m_outscript->Add("Content");
							m_outscript->Push("Content",nContent++);
							m_outscript->Add("Color",v_i);
							m_outscript->Add("Text","统率:+"+inlayrecord[inlaybingfaid+3]+"\n");
							m_outscript->Pop();
						}

						setMagicAttrTips(nContent,inlaystartid,inlayrecord,v_i);
						bufaid = atoi(inlayrecord[inlaystartid+27].c_str());
						if(bufaid>0)
						{
							if(skillAttrTab->queryOneRecord(0,crArgumentParser::appItoa(bufaid),bufRec)>=0)
							{//buf描述
								if(!bufRec[bufindex].empty())
								{
									m_outscript->Add("Content");
									m_outscript->Push("Content",nContent++);
									m_outscript->Add("Color",v_i);
									m_outscript->Add("Text",bufRec[bufindex]+"\n");
									m_outscript->Pop();
								}
							}
						}
					}
					m_outscript->Pop();
				}
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJConsortiaRankingMethod
////
///////////////////////////////////////////
//crJXJConsortiaRankingMethod::crJXJConsortiaRankingMethod():
//	m_this(NULL){}
//crJXJConsortiaRankingMethod::crJXJConsortiaRankingMethod(const crJXJConsortiaRankingMethod& handle):
//	crMethod(handle),
//	m_this(NULL)
//{
//}
//void crJXJConsortiaRankingMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crServerBrainHandle*)param;
//		break;
//	}
//}
//
//void crJXJConsortiaRankingMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJConsortiaRankingMethod::operator()(crHandle &handle)
//{
//	return;
//	if(m_this)
//	{
//		void *param;
//		crData *data = m_this->getDataClass();
//		data->excHandle(MAKEINT64(WCH_LockData,1));
//		data->getParam(WCHDATA_JXJConsortiaMap,param);
//		ConsortiaMap *consortiaMap = (ConsortiaMap *)param;
//		if(consortiaMap && !consortiaMap->empty())
//		{
//			ref_ptr<crJXJConsortia> consortia;
//			//data->getParam(WCHDATA_JXJConsortialvRankingMap,param);
//			//ConsortialvRankingMap *lvRankingMap = (ConsortialvRankingMap *)param;
//			data->getParam(WCHDATA_JXJConsortiaLvRank,param);
//			ConsortialvRank * lvRankingMap = (ConsortialvRank *) param;
//			lvRankingMap->clear();
//			//data->getParam(WCHDATA_JXJConsortiaMemberRankingMap,param);
//			ConsortiaMemberRankingMap *memberRankingMap = (ConsortiaMemberRankingMap *)param;
//			memberRankingMap->clear();
//			unsigned char lv;
//			unsigned short count;
//			crData *consortiaData;
//			ConsortiaMemberMap *consortiaMemberMap;
//			ConsortiaMap::iterator itr = consortiaMap->begin();
//			for (; itr != consortiaMap->end(); ++itr )
//			{
//				consortia = itr->second;
//				if (consortia.valid())
//				{
//					consortiaData = consortia->getDataClass();
//					consortiaData->excHandle(MAKEINT64(WCH_LockData,1));
//					consortiaData->getParam(WCHDATA_JXJConsortialv,param);
//					lv = *(unsigned char *)param;
//					consortiaData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
//					consortiaMemberMap = (ConsortiaMemberMap*)param;
//					count = consortiaMemberMap->size();
//					consortiaData->excHandle(MAKEINT64(WCH_LockData,0));
//					itr->second->updateToRank(data);
//					memberRankingMap->insert(std::make_pair(count,consortia));
//				}
//			}
//		}
//		data->excHandle(MAKEINT64(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJPeopleModelGroupInitMethod
//
/////////////////////////////////////////
crJXJPeopleModelGroupInitMethod::crJXJPeopleModelGroupInitMethod()
{
}

crJXJPeopleModelGroupInitMethod::crJXJPeopleModelGroupInitMethod(const crJXJPeopleModelGroupInitMethod& handle):
	crMethod(handle),
	m_titleText(handle.m_titleText),
	m_enterSwitch(handle.m_enterSwitch)
{
}

void crJXJPeopleModelGroupInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJPeopleModelGroupInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_titleText = str;
		break;
	case 1:
		m_enterSwitch = str;
		break;
	}
}

void crJXJPeopleModelGroupInitMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crStaticTextWidgetNode *titleText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_titleText));
		crMultiSwitch *enterSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_enterSwitch));
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short id = *(unsigned short *)param;
		if(titleText) titleText->clearString();
		if(type == FT_Fuben)
		{
			if(enterSwitch) enterSwitch->setActiveSwitchSet(0);
			if(titleText)
			{
				ref_ptr<crTableIO>fubenTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
				int nameindex = fubenTab->getTitleIndex("name");
				crTableIO::StrVec record;
				if(fubenTab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
				{
					std::string output;
					//////////////////////提示信息
					crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
					int texid = 1024;//组队副本[%s]
					noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
					int mode = 2;
					noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
					noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameindex]));
					noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
					crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
					titleText->setString(output);
				}
			}
		}
		else if(type == FT_Chengchi)
		{
			if(enterSwitch) enterSwitch->setActiveSwitchSet(1);
			if(titleText)
			{
				ref_ptr<crTableIO>chenchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
				int nameindex = chenchiTab->getTitleIndex("名字");
				crTableIO::StrVec record;
				if(chenchiTab->queryOneRecord(0,crArgumentParser::appItoa(id),record)>=0)
				{
					std::string output;
					//////////////////////提示信息
					crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
					int texid = 1025;//城战[%s]
					noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
					int mode = 2;
					noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
					noticeHandle->inputParam(WCHDATA_NoticeParam1,&(record[nameindex]));
					noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
					crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
					titleText->setString(output);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crExternSelectedGameMethod
//
/////////////////////////////////////////
crExternSelectedGameMethod::crExternSelectedGameMethod(){}
crExternSelectedGameMethod::crExternSelectedGameMethod(const crExternSelectedGameMethod& handle):
	crMethod(handle)
{
}
void crExternSelectedGameMethod::inputParam(int i, void *param)
{
}

void crExternSelectedGameMethod::addParam(int i, const std::string& str)
{
}

void crExternSelectedGameMethod::operator()(crHandle &handle)
{
	ref_ptr<crQueryGameListData> gameData = new crQueryGameListData;
	gameData->setID(crGlobalHandle::gData()->gGameID());
	gameData->setGameName("JXJ");
	gameData->setCName("将星诀");
	//gameData->setUIFile("jxjui.cru");
	gameData->setRoleCount(4);
	crMyPlayerData::getInstance()->setSelectedGame(gameData.get());
	crData *data = crGlobalHandle::getInstance()->getDataClass();
	CREncapsulation::loadIncludeData(crGlobalHandle::getInstance()->getGameDir()+"ClientEvent.cfg",data);

	crQueryGameInfoPacket packet;
	crQueryGameInfoPacket::buildRequestPacket(packet,crGlobalHandle::gData()->gGameID());
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJGameLogMethod
//
/////////////////////////////////////////
crJXJGameLogMethod::crJXJGameLogMethod():
	m_playerid(0)
{
	m_gameLogData = GameLogData(0,"");
}
crJXJGameLogMethod::crJXJGameLogMethod(const crJXJGameLogMethod& handle):
	crMethod(handle),
	m_playerid(0)
{
	m_gameLogData = GameLogData(0,"");
}
void crJXJGameLogMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerid = LOINT64(param64);
			m_gameLogData = *(GameLogData *)(HIINT64(param64));
		}
		else
		{
			m_playerid = 0;
			m_gameLogData = GameLogData(0,"");
		}
		break;
	}
}
void crJXJGameLogMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	std::vector<int> intvec;
	//	crArgumentParser::appAtoVec(str,intvec);
	//	for( std::vector<int>::iterator itr = intvec.begin();
	//		 itr != intvec.end();
	//		 ++itr )
	//	{
	//		m_logset.insert(*itr);
	//	}
	//	break;
	//}
}
void crJXJGameLogMethod::operator()(crHandle &handle)
{
	//if(m_logset.empty() || m_logset.find(m_gameLogData.first)!=m_logset.end())
	//{
		crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
		if(dbConductor)
		{
		//	crDBSavePacket packet;
		//	ref_ptr<crInsertGameLog> insertGameLog = new crInsertGameLog;
		//	insertGameLog->buildUpdateSql(m_playerid,m_gameLogData.first,m_gameLogData.second);
		//	crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,insertGameLog.get());
		//	dbConductor->getNetManager()->sendPacket("all",packet);
			crJXJSaveLogPacket packet;
			crJXJSaveLogPacket::buildRequestPacket(packet,m_playerid,m_gameLogData.first,m_gameLogData.second);
			dbConductor->getNetManager()->sendPacket("all",packet);
		}
	//}
}
/////////////////////////////////////////
//
//crJXJSceneLogMethod
//
/////////////////////////////////////////
crJXJSceneLogMethod::crJXJSceneLogMethod():
	m_playerid(0)
{
	m_gameLogData = GameLogData(0,"");
}
crJXJSceneLogMethod::crJXJSceneLogMethod(const crJXJSceneLogMethod& handle):
	crMethod(handle),
	m_playerid(0)
{
	m_gameLogData = GameLogData(0,"");
}
void crJXJSceneLogMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_playerid = LOINT64(param64);
			m_gameLogData = *(GameLogData *)(HIINT64(param64));
		}
		else
		{
			m_playerid = 0;
			m_gameLogData = GameLogData(0,"");
		}
		break;
	}
}
void crJXJSceneLogMethod::addParam(int i, const std::string& str)
{
	//switch(i) 
	//{
	//case 0:
	//	std::vector<int> intvec;
	//	crArgumentParser::appAtoVec(str,intvec);
	//	for( std::vector<int>::iterator itr = intvec.begin();
	//		itr != intvec.end();
	//		++itr )
	//	{
	//		m_logset.insert(*itr);
	//	}
	//	break;
	//}
}
void crJXJSceneLogMethod::operator()(crHandle &handle)
{
	//if(m_logset.empty() || m_logset.find(m_gameLogData.first)!=m_logset.end())
	//{
		crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
		if(dbConductor)
		{
			crJXJSaveLogPacket packet;
			crJXJSaveLogPacket::buildRequestPacket(packet,m_playerid,m_gameLogData.first,m_gameLogData.second);
			dbConductor->getNetManager()->sendPacket("all",packet);
		}
	//}
}
/////////////////////////////////////////
//
//crJXJRechargeDisposeMethod
//
/////////////////////////////////////////
crJXJRechargeDisposeMethod::crJXJRechargeDisposeMethod():
m_count(50){}
crJXJRechargeDisposeMethod::crJXJRechargeDisposeMethod(const crJXJRechargeDisposeMethod& handle):
	crMethod(handle),
	m_count(handle.m_count)
{
}
void crJXJRechargeDisposeMethod::inputParam(int i, void *param)
{
}
void crJXJRechargeDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_count = atoi(str.c_str());
		break;
	}
}
void crJXJRechargeDisposeMethod::operator()(crHandle &handle)
{//提取充值变成元宝
	int money = 0;
	bool success = false;
	void *param;
	int firstpaycount = 0;
	std::string chongzhistr,consortianame;//充值描述，军团名称
	ref_ptr<crGameServerPlayerData> playerData;
	ref_ptr<crData> data;
	const float c_moneyScale = 1.0f;//从10.0f改成1.0f
	crServerBrainHandle *gsBrain = crServerBrainHandle::getInstance();
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	crNetManager *netManager = gameServer->getNetManager();
	crNetDataManager *netDataManager = gameServer->getNetDataManager();
	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
	int serverid = callback->getServerID();
	crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
	ref_ptr<crDataBase> globalSession = db->beginSession();
	ref_ptr<crJXJRechargerecordQueryData> rechargerecordQuery = new crJXJRechargerecordQueryData;
	rechargerecordQuery->buildQuerySql(serverid,m_count);
	globalSession->executeQuery(rechargerecordQuery.get());
	crDataBase::QueryResultVec rechargerecordQueryResultVec = globalSession->getQueryResult();
	globalSession->releaseQuery();
	db->endSession(globalSession.get());

	crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
	ref_ptr<crDataBase> gameglobalSession;
	ref_ptr<crCheckPayMoneyCountData> checkpaymoneycount = new crCheckPayMoneyCountData;
	crDataBase::QueryResultVec checkpaymoneycountResultVec;
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(!rechargerecordQueryResultVec.empty() && dbConductor)
	{
		int playerid = 0;
		int id = 0;
		std::string ordernumber;
		crPlayerDataEventPacket packet;
		crDBSavePacket dbpacket;
		ref_ptr<crStreamBuf>stream;
		ref_ptr<crPlayerMoneyQueryData> playerMoneyQuery = new crPlayerMoneyQueryData;
		ref_ptr<crUpdatePlayerMoney> updatePlayerMoney = new crUpdatePlayerMoney;
		ref_ptr<crInsertPlayerMoney> insertPlayerMoney = new crInsertPlayerMoney;
		//ref_ptr<crJXJUpdateRechargerecord> updateRechargerecord = new crJXJUpdateRechargerecord;
		ref_ptr<crJXJRemoveRechargerecord> removeRechargerecord = new crJXJRemoveRechargerecord;
		ref_ptr<crJXJInsertMoneyrecord> insertMoneyrecord = new crJXJInsertMoneyrecord;
		int vipExpFactor = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRMBToVipExpFactor,0).c_str());
		int getvipexp = 0;
		bool mainroleinited = false;
		ref_ptr<crData> mainroledata;
		for( crDataBase::QueryResultVec::iterator itr = rechargerecordQueryResultVec.begin();
			itr != rechargerecordQueryResultVec.end();
			++itr )
		{
			rechargerecordQuery = dynamic_cast<crJXJRechargerecordQueryData *>(itr->get());
			playerid = rechargerecordQuery->getPlayerID();
			playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if( playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass()
				&& playerData->getPlayerGameData()->getMainRole() && playerData->getPlayerGameData()->getMainRole()->getDataClass() )
			{//玩家在线
				mainroledata = playerData->getPlayerGameData()->getMainRole()->getDataClass();
				mainroledata->getParam(WCHDATA_JXJMainRoleInited,param);
				mainroleinited = *(bool *)param;
				if(mainroleinited)
				{
					consortianame.clear();
					chongzhistr = "充值";
					success = false;
					money = rechargerecordQuery->getMoney() * c_moneyScale;
					id = rechargerecordQuery->getID();
					ordernumber = rechargerecordQuery->getOrderNumber();
					gsBrain->doEvent(WCH_JXJGetConsortiaName,MAKEINT64(playerid,&consortianame));
					//检测是否首冲
					gameglobalSession = gameglobaldb->beginSession();
					checkpaymoneycount->buildQuerySql(playerid,serverid);
					gameglobalSession->executeQuery(checkpaymoneycount.get());
					checkpaymoneycountResultVec = gameglobalSession->getQueryResult();
					gameglobalSession->releaseQuery();
					if (!checkpaymoneycountResultVec.empty())
					{
						checkpaymoneycount = dynamic_cast<crCheckPayMoneyCountData *>(checkpaymoneycountResultVec[0].get());
						firstpaycount = checkpaymoneycount->getCount();
						if (firstpaycount == 0)
						{
							chongzhistr = "首次充值";
						}
					}
					gameglobaldb->endSession(gameglobalSession.get());

					globalSession = db->beginSession();
					playerMoneyQuery->buildQuerySql(playerid,serverid);
					globalSession->executeQuery(playerMoneyQuery.get());
					int dbmoney = 0;
					crDataBase::QueryResultVec &playerMoneyQueryResultVec = globalSession->getQueryResult();
					if(!playerMoneyQueryResultVec.empty())
					{
						playerMoneyQuery = dynamic_cast<crPlayerMoneyQueryData *>(playerMoneyQueryResultVec[0].get());
						dbmoney = playerMoneyQuery->getMoney();
						globalSession->releaseQuery();
						updatePlayerMoney->buildUpdateSql(playerid,serverid,money);
						removeRechargerecord->buildUpdateSql(id);
						if(globalSession->executeUpdate(updatePlayerMoney.get()) && /*globalSession->executeUpdate(insertMoneyrecord.get()) &&*/ globalSession->executeUpdate(removeRechargerecord.get()))
						{//插入成功
							globalSession->commit();
							success = true;
						}
						else
						{
							globalSession->rollback();
						}
					}
					else
					{
						globalSession->releaseQuery();
						insertPlayerMoney->buildUpdateSql(playerid,serverid,money);
						removeRechargerecord->buildUpdateSql(id);
						if(globalSession->executeUpdate(insertPlayerMoney.get()) && /*globalSession->executeUpdate(insertMoneyrecord.get()) &&*/ globalSession->executeUpdate(removeRechargerecord.get()))
						{//插入成功
							globalSession->commit();
							success = true;
						}
						else
						{
							globalSession->rollback();
						}
					}
					db->endSession(globalSession.get());
					if(success)
					{//充值成功
						data = playerData->getPlayerGameData()->getDataClass();
						data->getParam(WCHDATA_Money,param);
						int *curmoney = (int *)param;
						insertMoneyrecord->buildUpdateSql(playerid, serverid, money, *curmoney, chongzhistr, consortianame, playerData->getPlayerGameData()->getCharacterName(),playerData->getPlayerGameData()->getAdvertid(),ordernumber);
						crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertMoneyrecord.get());
						dbConductor->getNetManager()->sendPacket("all",dbpacket);

						getvipexp = money * vipExpFactor;
						if (getvipexp < 0)getvipexp = 0;

						data->excHandle(MAKEINT64(WCH_LockData,1));
						data->getParam(WCHDATA_JXJShouchong,param);
						unsigned char *shouchong = (unsigned char *)param;
						if(*shouchong == 0)
						{
							*shouchong = 1;
						}
						*curmoney = dbmoney+money;
						stream = new crStreamBuf;
						stream->createBuf(5);
						stream->_writeInt(*curmoney);
						stream->_writeUChar(*shouchong);
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvMoneyChange,stream.get());
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

						//CRCore::notify(CRCore::FATAL)<<"元宝充值 "<< money << std::endl;
						//同步元宝累计充值
						data->getParam(WCHDATA_JXJPlayerTotalPayGold, param);
						int *PlayerTotalPayGold = (int *)param;
						(*PlayerTotalPayGold) += money;

						playerData->getPlayerGameData()->doEvent(WCH_JXJAddVipExp,MAKEINT64(getvipexp,NULL));

						//记录当天充值数量
						data->getParam(WCHDATA_JXJChongZhiCountT,param);
						int czcount = *(int *)param;
						czcount += money;
						data->inputParam(WCHDATA_JXJChongZhiCountT,&czcount);

						playerData->getPlayerGameData()->getMainRole()->doEvent(WCH_JXJHuodongExtUpdate,MAKEINT64(money,NULL));
						
						data->excHandle(MAKEINT64(WCH_LockData,0));

						//CRCore::notify(CRCore::FATAL)<<"元宝累计充值 "<< *PlayerTotalPayGold << std::endl;

						data->getParam(WCHDATA_JXJShiliID, param);
						unsigned char shiliid = *(unsigned char *)param;

						crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();

						gsBrainData->excHandle(MAKEINT64(WCH_LockData, 1));

						gsBrainData->getParam(WCHDATA_JXJShiliWei + shiliid - c_startShiliID, param);
						crJXJShili *shili = (crJXJShili *)param;
						if (shili && shili->getDataClass())
						{
							crData *shiliData = shili->getDataClass();
							CRCore::ScopedLock<crData> lock(*shiliData);

							shiliData->getParam(WCHDATA_JXJPeopleMap, param);
							PeopleMap *peopleMap = (PeopleMap *)param;
							PeopleMap::iterator itr = peopleMap->find(playerid);
							if (itr != peopleMap->end())
							{
								if (itr->second->getTotalRecharge() != (*PlayerTotalPayGold))
								{
									itr->second->setTotalRecharge(*PlayerTotalPayGold);

									//CRCore::notify(CRCore::FATAL)<<"设置元宝累计充值 " << std::endl;
								}
							}
						}

						gsBrainData->excHandle(MAKEINT64(WCH_LockData, 0));
					}
				}
			}
		}
	}
	//if (playerData.valid() && playerData->getPlayerGameData() && success && data && money > 0)
	//{
	//	data -> getParam(WCHDATA_JXJVipLv,param);
	//	unsigned char viplv = *(unsigned char *)param;
	//	int lvToVipExpFactor = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRMBToVipExpFactor,viplv).c_str());
	//	int getvipexp = money * lvToVipExpFactor;
	//	if (getvipexp < 0)getvipexp = 0;
	//	playerData->getPlayerGameData()->doEvent(WCH_JXJAddVipExp,MAKEINT64(getvipexp,NULL));
	//}
}
/////////////////////////////////////////
//
//crJXJMoneyChangeMethod
//
/////////////////////////////////////////
crJXJMoneyChangeMethod::crJXJMoneyChangeMethod():
	m_this(NULL),
	m_output(NULL)
{
	m_moneydata = MoneyChangeData(0,"");
}
crJXJMoneyChangeMethod::crJXJMoneyChangeMethod(const crJXJMoneyChangeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
	m_moneydata = MoneyChangeData(0,"");
}
void crJXJMoneyChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_moneydata = *(MoneyChangeData *)(LOINT64(param64));
			m_output = (bool *)HIINT64(param64);
		}
		else
		{
			m_moneydata = MoneyChangeData(0,"");
			m_output = NULL;
		}
		break;
	}
}
void crJXJMoneyChangeMethod::addParam(int i, const std::string& str)
{
}
void crJXJMoneyChangeMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(m_moneydata.first != 0 && m_output && dbConductor)
	{
		int playerid = m_this->getPlayerID();
		std::string consortianame;//军团名称
		crServerBrainHandle *gsBrain = crServerBrainHandle::getInstance();
		gsBrain->doEvent(WCH_JXJGetConsortiaName,MAKEINT64(playerid,&consortianame));

		*m_output = false;
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_Money,param);
		int *money = (int *)param;
		if(*money+m_moneydata.first>=0)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
			int serverid = callback->getServerID();
			//ref_ptr<crJXJInsertMoneyrecord> insertMoneyrecord = new crJXJInsertMoneyrecord;
			//insertMoneyrecord->buildUpdateSql(m_this->getPlayerID(),serverid,m_moneydata.first,*money,m_moneydata.second,"","");

			crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
			ref_ptr<crDataBase> globalSession = db->beginSession();
			ref_ptr<crPlayerMoneyQueryData> playerMoneyQuery = new crPlayerMoneyQueryData;
			playerMoneyQuery->buildQuerySql(playerid,serverid);
			globalSession->executeQuery(playerMoneyQuery.get());
			int dbmoney = 0;
			crDataBase::QueryResultVec &playerMoneyQueryResultVec = globalSession->getQueryResult();
			if(!playerMoneyQueryResultVec.empty())
			{
				playerMoneyQuery = dynamic_cast<crPlayerMoneyQueryData *>(playerMoneyQueryResultVec[0].get());
				dbmoney = playerMoneyQuery->getMoney();
				globalSession->releaseQuery();
				if(dbmoney+m_moneydata.first>=0)
				{
					ref_ptr<crUpdatePlayerMoney> updatePlayerMoney = new crUpdatePlayerMoney;
					updatePlayerMoney->buildUpdateSql(playerid,serverid,m_moneydata.first);
					if(globalSession->executeUpdate(updatePlayerMoney.get())/* && globalSession->executeUpdate(insertMoneyrecord.get())*/)
					{//插入成功
						globalSession->commit();
						*m_output = true;
					}
					else
					{
						globalSession->rollback();
					}
				}
			}
			else if(m_moneydata.first>0)
			{
				globalSession->releaseQuery();
				ref_ptr<crInsertPlayerMoney> insertPlayerMoney = new crInsertPlayerMoney;
				insertPlayerMoney->buildUpdateSql(playerid,serverid,m_moneydata.first);
				if(globalSession->executeUpdate(insertPlayerMoney.get())/* && globalSession->executeUpdate(insertMoneyrecord.get())*/)
				{//插入成功
					globalSession->commit();
					*m_output = true;
				}
				else
				{
					globalSession->rollback();
				}
			}
			db->endSession(globalSession.get());
			if(*m_output)
			{
				crDBSavePacket dbpacket;
				ref_ptr<crJXJInsertMoneyrecord> insertMoneyrecord = new crJXJInsertMoneyrecord;
				insertMoneyrecord->buildUpdateSql(playerid, serverid,m_moneydata.first,*money,m_moneydata.second,consortianame,m_this->getCharacterName(),m_this->getAdvertid(),"");
				crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertMoneyrecord.get());
				dbConductor->getNetManager()->sendPacket("all",dbpacket);

				*money = dbmoney + m_moneydata.first;
				//data->getParam(WCHDATA_JXJPlayerTotalPayGold, param);
				//int *PlayerTotalPayGold = (int *)param;
				//(*PlayerTotalPayGold) += m_moneydata.first;
				////同步元宝累计充值
				//crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();

				//data->getParam(WCHDATA_JXJShiliID, param);
				//unsigned char shiliid = *(unsigned char *)param;

				//gsBrainData->excHandle(MAKEINT64(WCH_LockData, 1));

				//gsBrainData->getParam(WCHDATA_JXJShiliWei + shiliid - c_startShiliID, param);
				//crJXJShili *shili = (crJXJShili *)param;
				//if (shili && shili->getDataClass())
				//{
				//	crData *shiliData = shili->getDataClass();
				//	CRCore::ScopedLock<crData> lock(*shiliData);

				//	shiliData->getParam(WCHDATA_JXJPeopleMap, param);
				//	PeopleMap *peopleMap = (PeopleMap *)param;
				//	PeopleMap::iterator itr = peopleMap->find(m_this->getPlayerID());
				//	if (itr != peopleMap->end())
				//	{
				//		if (itr->second->getTotalRecharge() != (*PlayerTotalPayGold))
				//		{
				//			itr->second->setTotalRecharge(*PlayerTotalPayGold);
				//		}
				//	}
				//}

				//gsBrainData->excHandle(MAKEINT64(WCH_LockData, 0));
				//充值对军师经验的影响
				//if (m_moneydata.first > 0)
				//{
				//	crData *data = m_this->getDataClass();
				//	data -> getParam(WCHDATA_JXJVipLv,param);
				//	unsigned char viplv = *(unsigned char *)param;
				//	int lvToVipExpFactor = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRMBToVipExpFactor,viplv).c_str());
				//	int getvipexp = m_moneydata.first * lvToVipExpFactor;
				//	if (getvipexp < 0)
				//	{
				//		getvipexp = 0;
				//	}
				//	m_this->doEvent(WCH_JXJAddVipExp,MAKEINT64(getvipexp,NULL));
				//}
				//放在外部逻辑做了
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				crNetManager *netManager = gameServer->getNetManager();
				crNetDataManager *netDataManager = gameServer->getNetDataManager();
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(m_this->getPlayerID()));
				if(playerData.valid())
				{//玩家在线
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(*money);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvMoneyChange,stream.get());
					netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvMoneyChangeMethod
//
/////////////////////////////////////////
crJXJRecvMoneyChangeMethod::crJXJRecvMoneyChangeMethod():
	m_netType(GameClient_Game){}
crJXJRecvMoneyChangeMethod::crJXJRecvMoneyChangeMethod(const crJXJRecvMoneyChangeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvMoneyChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvMoneyChangeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvMoneyChangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameClient_Game)
		{
			int extramoney = 0;
			int money = m_stream->_readInt();
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_Money,param);
			int lastMoney = *(int *)param;
			data->inputParam(WCHDATA_Money,&money);
			extramoney = money-lastMoney;
			if(extramoney!=0)
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Gold,extramoney));
			if(!m_stream->eof())
			{
				unsigned char shouchong = m_stream->_readUChar();
				data->inputParam(WCHDATA_JXJShouchong,&shouchong);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJVipChangeMethod
//
/////////////////////////////////////////
crJXJVipChangeMethod::crJXJVipChangeMethod():
	m_this(NULL),
	m_output(NULL)
{
	m_vipdata = VipChangeData(0,0);
}
crJXJVipChangeMethod::crJXJVipChangeMethod(const crJXJVipChangeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL)
{
	m_vipdata = VipChangeData(0,0);
}
void crJXJVipChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_vipdata = *(VipChangeData *)(LOINT64(param64));
			m_output = (bool *)HIINT64(param64);
		}
		else
		{
			m_vipdata = VipChangeData(0,0);
			m_output = NULL;
		}
		break;
	}
}
void crJXJVipChangeMethod::addParam(int i, const std::string& str)
{
}
void crJXJVipChangeMethod::operator()(crHandle &handle)
{
	if(m_vipdata.first != 0 || m_vipdata.second != 0)
	{
		*m_output = false;
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char *viplv = (unsigned char *)param;
		data->getParam(WCHDATA_JXJVipExp,param);
		int *vipexp = (int *)param;
		if(*vipexp+m_vipdata.second>=0 && (int)(*viplv)+(int)(m_vipdata.first)>=0)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
			int serverid = callback->getServerID();

			crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
			ref_ptr<crDataBase> globalSession = db->beginSession();
			ref_ptr<crPlayerVipQueryData> playerVipQuery = new crPlayerVipQueryData;
			playerVipQuery->buildQuerySql(m_this->getPlayerID(),serverid);
			globalSession->executeQuery(playerVipQuery.get());
			unsigned char dbviplv = 0;
			int dbvipexp = 0;
			crDataBase::QueryResultVec &playerVipQueryResultVec = globalSession->getQueryResult();
			if(!playerVipQueryResultVec.empty())
			{
				playerVipQuery = dynamic_cast<crPlayerVipQueryData *>(playerVipQueryResultVec[0].get());
				dbviplv = playerVipQuery->getViplv();
				dbvipexp = playerVipQuery->getVipexp();
				globalSession->releaseQuery();
				if(dbvipexp+m_vipdata.second>=0 && (int)(dbviplv)+(int)(m_vipdata.first)>=0)
				{
					ref_ptr<crUpdatePlayerVip> updatePlayerVip = new crUpdatePlayerVip;
					updatePlayerVip->buildUpdateSql(m_this->getPlayerID(),serverid,m_vipdata.first,m_vipdata.second);
					if(globalSession->executeUpdate(updatePlayerVip.get()))
					{//插入成功
						globalSession->commit();
						*m_output = true;
					}
					else
					{
						globalSession->rollback();
					}
				}
			}
			else/* if(m_vipdata.first>=0)*/
			{
				globalSession->releaseQuery();
				ref_ptr<crInsertPlayerVip> insertPlayerVip = new crInsertPlayerVip;
				insertPlayerVip->buildUpdateSql(m_this->getPlayerID(),serverid,m_vipdata.first,m_vipdata.second);
				if(globalSession->executeUpdate(insertPlayerVip.get()))
				{//插入成功
					globalSession->commit();
					*m_output = true;
				}
				else
				{
					globalSession->rollback();
				}
			}
			db->endSession(globalSession.get());
			if(*m_output)
			{
				*viplv = dbviplv + m_vipdata.first;
				*vipexp = dbvipexp + m_vipdata.second;
				//放在外部逻辑做了
				//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				//crNetManager *netManager = gameServer->getNetManager();
				//crNetDataManager *netDataManager = gameServer->getNetDataManager();
				//ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(m_this->getPlayerID()));
				//if(playerData.valid())
				//{//玩家在线
				//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//	stream->createBuf(4);
				//	stream->_writeInt(*money);
				//	crPlayerDataEventPacket packet;
				//	crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvMoneyChange,stream.get());
				//	netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				//}
			}
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvVipChangeMethod
//
/////////////////////////////////////////
crJXJRecvVipChangeMethod::crJXJRecvVipChangeMethod():
	m_netType(GameClient_Game){}
crJXJRecvVipChangeMethod::crJXJRecvVipChangeMethod(const crJXJRecvVipChangeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvVipChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvVipChangeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvVipChangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameClient_Game)
		{
			int extraviplv = 0;
			unsigned char viplv = m_stream->_readUChar();
			int vipexp = m_stream->_readInt();
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char lastViplv = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJVipExp,param);
			int lastVipexp = *(int *)param;
			data->inputParam(WCHDATA_JXJVipLv,&viplv);
			data->inputParam(WCHDATA_JXJVipExp,&vipexp);
			extraviplv = viplv-lastViplv;
			//if(extraviplv!=0)
			//	crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Gold,extramoney));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCheckPlayerGameNameMethod
//
/////////////////////////////////////////
crJXJRecvCheckPlayerGameNameMethod::crJXJRecvCheckPlayerGameNameMethod(){}
crJXJRecvCheckPlayerGameNameMethod::crJXJRecvCheckPlayerGameNameMethod(const crJXJRecvCheckPlayerGameNameMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_widget(handle.m_widget)
{
}
void crJXJRecvCheckPlayerGameNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCheckPlayerGameNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_widget = str;
		break;
	}
}

void crJXJRecvCheckPlayerGameNameMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvas.valid())
	{
		crWidgetNode *widget = canvas->getWidget(m_widget);
		if(widget)
			widget->doEvent(WCH_RecvCheckPlayerGameName,MAKEINT64(m_stream.get(),NULL));
	}
}
/////////////////////////////////////////
//
//crJXJSendServerTimerMethod
//
/////////////////////////////////////////
crJXJSendServerTimerMethod::crJXJSendServerTimerMethod()
{
}
crJXJSendServerTimerMethod::crJXJSendServerTimerMethod(const crJXJSendServerTimerMethod& handle):
	crMethod(handle)
{
}
void crJXJSendServerTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJSendServerTimerMethod::addParam(int i, const std::string& str)
{
}
void crJXJSendServerTimerMethod::operator()(crHandle &handle)
{
	int playerid = m_this->getPlayerID();
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
	if(playerData.valid())
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(8);
		stream->_writeDouble(crGlobalHandle::getInstance()->timer());
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvServerTimer,stream.get());
		gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvServerTimerMethod
//
/////////////////////////////////////////
crJXJRecvServerTimerMethod::crJXJRecvServerTimerMethod():
	m_netType(GameClient_Game),
m_delta(1.0f){}
crJXJRecvServerTimerMethod::crJXJRecvServerTimerMethod(const crJXJRecvServerTimerMethod& handle):
	crMethod(handle),
	m_delta(handle.m_delta)
{
}
void crJXJRecvServerTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvServerTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_delta = atof(str.c_str());
		break;
	}
}

void crJXJRecvServerTimerMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
#ifndef _DEBUG
			if(crDisplaySettings::instance()->getRunMode() < crDisplaySettings::Robot)
			{
				double servertime = m_stream->_readDouble();
				//char gbuf[256];
				//sprintf(gbuf,"timer()=%f servertime=%f\n\0",crGlobalHandle::getInstance()->timer(),servertime);
				//gDebugInfo->debugInfo(CRCore::NOTICE,gbuf);
				if(fabs(crGlobalHandle::getInstance()->timer() - servertime)>m_delta)
				{
					crBrain::getInstance()->doEvent(MAKEINT64(WCH_EXITGAME,2));
				}
				else
				{
					crGlobalHandle::getInstance()->timer() = servertime;
				}
			}
#endif
		}
	}
}
/////////////////////////////////////////
//
//crJXJOnlineTimerUpdateMethod
//
/////////////////////////////////////////
crJXJOnlineTimerUpdateMethod::crJXJOnlineTimerUpdateMethod():
	m_child(0),
	m_dt(NULL)
{
}
crJXJOnlineTimerUpdateMethod::crJXJOnlineTimerUpdateMethod(const crJXJOnlineTimerUpdateMethod& handle):
	crMethod(handle),
	m_child(0),
	m_childinterval(handle.m_childinterval),
	m_dt(NULL)
{
}
void crJXJOnlineTimerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float *)(LOINT64(param64));
		}
		break;
	}
}
void crJXJOnlineTimerUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_childinterval);
		break;
	case 1:
		m_child = atoi(str.c_str());//2禁用防沉迷
		break;
	}
}
void crJXJOnlineTimerUpdateMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJOnlineTimer,param);
	int *t = (int *)param;
	int pert = *t;
	int nowt = pert+*m_dt;
	*t = nowt>86400?0:nowt;
	data->excHandle(MAKEINT64(WCH_LockData,0));
	if(m_child==2)
		return;
	char tt = 0;
	int delta1 = m_childinterval[0];
	int delta2 = m_childinterval[0] * 2;
	int delta3 = m_childinterval[0] * 3;
	if((pert<delta1&&nowt>=delta1))
		tt = 1;
	else if((pert<delta2&&nowt>=delta2))
		tt = 2;
	else if(nowt>=delta3 && nowt%m_childinterval[1]==0)
		tt = 3;
	if(tt>0)
	{
		int playerid = m_this->getPlayerID();
		if(m_child==0)
		{//查询数据库
			ref_ptr<crJXJChildQueryData> childQuery = new crJXJChildQueryData;
			childQuery->buildQuerySql(playerid);

			crDataBase *accountdb = crDataBaseManager::getInstance()->getAccountDB();
			ref_ptr<crDataBase> accountSession = accountdb->beginSession();
			accountSession->executeQuery(childQuery.get());
			crDataBase::QueryResultVec &childQueryResultVec = accountSession->getQueryResult();
			if(!childQueryResultVec.empty())
			{
				childQuery = dynamic_cast<crJXJChildQueryData *>(childQueryResultVec[0].get());
				m_child = childQuery->getChild();
			}
			accountSession->releaseQuery();
			accountdb->endSession(accountSession.get());
		}
		if(m_child<2)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(2);
				stream->_writeChar(m_child);
				stream->_writeChar(tt);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvChildCheck,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvChildCheckMethod
//
/////////////////////////////////////////
crJXJRecvChildCheckMethod::crJXJRecvChildCheckMethod():
	m_netType(GameClient_Game){}
crJXJRecvChildCheckMethod::crJXJRecvChildCheckMethod(const crJXJRecvChildCheckMethod& handle):
	crMethod(handle),
	m_canvas1(handle.m_canvas1),
	m_canvas2(handle.m_canvas2),
	m_canvas3(handle.m_canvas3),
	m_timeText1(handle.m_timeText1),
	m_timeText2(handle.m_timeText2)
{
}
void crJXJRecvChildCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvChildCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas1 = str;
		break;
	case 1:
		m_canvas2 = str;
		break;
	case 2:
		m_canvas3 = str;
		break;
	case 3:
		m_timeText1 = str;
		break;
	case 4:
		m_timeText2 = str;
		break;
	}
}

void crJXJRecvChildCheckMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{//1115
			char child = m_stream->_readChar();
			char tt = m_stream->_readChar();
			ref_ptr<crCanvasNode> canvas;
			if(tt>=3)
			{
				canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas3);
				if(canvas.valid())
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
			}
			else
			{
				int texid = 1115;
				std::string str = crArgumentParser::appItoa(tt);
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
				int mode = 2;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				noticeHandle->inputParam(WCHDATA_NoticeParam1,&str);
				std::string output;
				noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
				ref_ptr<crStaticTextWidgetNode> textWidget;
				switch (child)
				{
				case 0:
					canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas1);
					if(canvas.valid()) textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_timeText1));
					break;
				case 1:
					canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas2);
					if(canvas.valid()) textWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_timeText2));
					break;
				}
				if(textWidget.valid())
					textWidget->setString(output);
				if(canvas.valid())
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRobotMethod
//
/////////////////////////////////////////
crJXJRobotMethod::crJXJRobotMethod():
m_currentState(1),
m_currentStep(1),
m_lastupdtime(0){}
crJXJRobotMethod::crJXJRobotMethod(const crJXJRobotMethod& handle):
	crMethod(handle),
	m_robotTab(handle.m_robotTab),
	m_currentState(1),
	m_currentStep(1),
	m_lastupdtime(0),
	m_canvas(handle.m_canvas),
	m_cameraLockBtn(handle.m_cameraLockBtn)
{
	m_lastupdtime = time(0);
}
void crJXJRobotMethod::inputParam(int i, void *param)
{
}
void crJXJRobotMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_robotTab = crTableIO::openFile(crGlobalHandle::getInstance()->getTableDir()+str);
		break;
	case 1:
		m_canvas = str;
		break;
	case 2:
		m_cameraLockBtn = str;
		break;
	default:
		break;
	}
}
void crJXJRobotMethod::battleAI()
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCamera> camera = crCameraManager::getInstance()->getMainCamera();
	if(myPlayer && camera.valid())
	{
		void *param;
		crMatrixTransform *cameraNode = dynamic_cast<crMatrixTransform *>(camera->getAttachedNode());
		//crData *cameraData = cameraNode->getDataClass();
		//CRCore::ScopedLock<crData> lock(*cameraData);
		//cameraData->getParam(WCHDATA_SelectMyRoleVec,param);
		//SelectMyRoleVec *selectMyRoles = (SelectMyRoleVec *)param;
		crVector2i equips = crVector2i(-1,-1);
		crTableIO::StrVec itemrecord;
		ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if(!itemtab.valid()) return;
		crMyPlayerData *me = crMyPlayerData::getInstance();
		crData *playerdata = me->getPlayerGameData()->getDataClass();
		playerdata->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *myteam = (FormationInfoVec *)param;
		ref_ptr<crCanvasNode> miniMapCanvas = CRCore::crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (miniMapCanvas.valid())
		{
			ref_ptr<crCheckBoxWidgetNode> cameraLock = dynamic_cast<crCheckBoxWidgetNode *>(miniMapCanvas->getChildNode(m_cameraLockBtn));
			if (cameraLock.valid() && !cameraLock->getSelect())
			{
				cameraLock->select(true);
			}
		}
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		float px = 0;
		float py = 0;
		if(type == FT_Chengchi)
		{
			crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
			if (room && room->getDataClass())
			{
				crData *roomData = room->getDataClass();
				roomData->excHandle(MAKEINT64(WCH_LockData,1));
				roomData->getParam(WCHDATA_JXJCampBirthPointMap,param);
				JXJCampBirthpointMap *campMap = (JXJCampBirthpointMap *)param;
				roomData->getParam(WCHDATA_JXJBattleID, param);
				int battleid = *(int *)param;
				playerdata->getParam(WCHDATA_JXJShiliID, param);
				unsigned char myShili = *(unsigned char *)param;
				unsigned char dshili = (unsigned char)(HIINT16(LOINT32(battleid)));
				if (myShili == dshili)
				{
					unsigned char ashili = (unsigned char)(LOINT16(LOINT32(battleid)));
					JXJCampBirthpoint::iterator itr_point;
					if(campMap && !(*campMap)[ashili].empty())
					{
						JXJCampBirthpointMap::iterator itr_map = campMap->find(ashili);
						if (itr_map!=campMap->end())
						{
							itr_point = itr_map->second.begin();
							for (;itr_point!=itr_map->second.end();itr_point++)
							{
								px = itr_point->first.x()*crGlobalHandle::gData()->gUnitScale();
								py = itr_point->first.y()*crGlobalHandle::gData()->gUnitScale();
								break;
							}
						}
					}
				}
				else
				{
					playerdata->getParam(WCHDATA_JXJFubenOrChengchiID,param);
					unsigned short chengchiid = *(unsigned short *)param;
					if(chengchiid > 0)
					{
						ref_ptr<crTableIO>chengchiMarkTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengchiMarkTab);
						if (chengchiMarkTab.valid())
						{
							crTableIO::StrVec recordc;
							int idxIndex = chengchiMarkTab->getTitleIndex("x");
							int idyIndex = chengchiMarkTab->getTitleIndex("y");
							if(chengchiMarkTab->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),recordc) >= 0)
							{
								px =atof(recordc[idxIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
								py =atof(recordc[idyIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
							}
						}
					}
				}
				roomData->excHandle(MAKEINT64(WCH_LockData, 0));
			}
		}
		if(type == FT_Fuben)
		{
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short fubenid = *(unsigned short *)param;
			if(fubenid > 0)
			{
				ref_ptr<crTableIO>fubenMarkTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenMarkTab);
				if (fubenMarkTab.valid())
				{
					crTableIO::StrVec recordf;
					int idxIndex = fubenMarkTab->getTitleIndex("x");
					int idyIndex = fubenMarkTab->getTitleIndex("y");
					if(fubenMarkTab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),recordf) >= 0)
					{
						px =atof(recordf[idxIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
						py =atof(recordf[idyIndex].c_str())*crGlobalHandle::gData()->gUnitScale();
					}
				}
			}
		}
		crVector3 m_targetPosition(px,py,0.0f);
		crMyPlayerData::getInstance()->lockMyRoleNpcMap();
		crRole *role;
		crMyPlayerData::MyRoleNpcMap &myRoles = crMyPlayerData::getInstance()->getMyRoleNpcMap();
		for( crMyPlayerData::MyRoleNpcMap::iterator itr = myRoles.begin();
			itr != myRoles.end();
			++itr )
		{
			role = itr->second.first.get();
			if (role && role->getDataClass())
			{
				unsigned short useResult = UR_None;
				crData *roleData = role->getDataClass();
				int roleid = role->getRoleID();
				roleData->excHandle(MAKEINT64(WCH_LockData, 1));
				roleData->getParam(WCHDATA_ItemState, param);
				unsigned char itemstate = *((unsigned char*)param);
				unsigned int guisestate = GS_Normal;
				role->doEvent(MAKEINT64(WCH_GetGuiseState,0),MAKEINT64(&guisestate,NULL));
				roleData->getParam(WCHDATA_RTHP,param);
				float rthp = *(float*)param;

				if( itemstate != IS_Dead && rthp>0.0f && 
					!(guisestate & GS_Silent) && !(guisestate & GS_Confusion) && 
					!(guisestate & GS_Sheep) && !(guisestate & GS_OnHorse) && 
					/*!(guisestate & GS_Disarm) &&*/ !(guisestate & GS_Scare) && 
					/*!(guisestate & GS_Nihility) &&*/ !(guisestate & GS_Swoon) &&
					!(guisestate & GS_Stagnate) && !(guisestate & GS_Taunt) && 
					!(guisestate & GS_ExtraShifting)/* && !(guisestate & GS_NoAttack)*/ )
				{
					int abstractID = 0;
					int aboutUseID = 0;
					for (FormationInfoVec::iterator itr = myteam->begin();
						itr != myteam->end();
						++itr)
					{
						if (roleid == (*itr)->getRoleID())
						{
							equips = (*itr)->getEquips();
							break;
						}
					}
					if (equips[0] > 0)
					{
						if (itemtab->queryOneRecord(0, crArgumentParser::appItoa(equips[0]), itemrecord) >= 0)
						{
							abstractID = atoi(itemrecord[itemtab->getTitleIndex("abstractid")].c_str());
						}
					}
					if (abstractID != 0)
					{
						roleData->getParam(WCHDATA_EquipOnMap, param);
						EquipOnMap *equipOnMap = (EquipOnMap *)param;
						crItemChild *itemChild = role->findChildItem(equipOnMap->find(abstractID)->second);
						if (itemChild && itemChild->isLoaded())
						{
							unsigned short range = 0;
							crInstanceItem *item = itemChild->getInstanceItem();
							crData *itemData = item->getDataClass();
							aboutUseID = item->getInstanceItemID();
							UseItemParam useItemParam;
							useItemParam.m_user = role;
							useItemParam.m_target = NULL;
							item->doEvent(WCH_UseItemCheck, MAKEINT64(&useItemParam, &useResult));
							if (useResult == UR_Succeed)
							{
								itemData->getParam(WCHDATA_ItemUseRange,param);
								if(param)
								{
									range = *(unsigned short *)param;
									if(range == 0)
									{
										//直接释放技能
										crVector3 pos;
										crMatrixTransform *bot;
										bot = dynamic_cast<crMatrixTransform *>(role->getRelNode());
										if(bot && bot->getVisiable())
										{
											pos = role->getPosition()+role->getDir() * 0.5f;
											unsigned char itemstate = IS_UseItem;
											roleData->inputParam(WCHDATA_ItemState,&itemstate);
											unsigned char targettype = Target_Coord;
											roleData->inputParam(WCHDATA_TargetType,&targettype);						
											roleData->inputParam(WCHDATA_TargetPos,&pos);	
											roleData->inputParam(WCHDATA_AboutToUseItemID,&aboutUseID);
										}
									}
									else
									{
										ref_ptr<crInstanceItem> targetItem;
										ref_ptr<crMatrixTransform> targetNode;
										role->clientGetTarget(targetItem,targetNode);
										if (targetItem.valid())
										{
											unsigned char targettype = targetItem->getItemtype()==crInstanceItem::Role?Target_Role:Target_Npc;
											roleData->getParam(WCHDATA_TargetID,param);
											int targetid = *(int *)param;
											if(targetid!=0)
											{
												roleData->getParam(WCHDATA_TargetRoleID,param);
												int targetroleid = *(int *)param;
												unsigned char targettype = targetroleid == 0?Target_Npc:Target_Role;
												roleData->inputParam(WCHDATA_TargetType,&targettype);
											}
											else
											{
												roleData->inputParam(WCHDATA_TargetType,&targettype);
												targetid = targetItem->getID();
												roleData->inputParam(WCHDATA_TargetID,&targetid);
											}
											roleData->inputParam(WCHDATA_TargetNode,targetItem->getRelNode());
											int targetroleid = targetItem->getRoleID();
											roleData->inputParam(WCHDATA_TargetRoleID,&targetroleid);
											crVector3 targetPos = targetItem->getPosition();
											roleData->inputParam(WCHDATA_TargetPos,&targetPos);
											crData *targetData = targetItem->getDataClass();
											if(targetData)
											{
												targetData->getParam(WCHDATA_ItemState,param);
												unsigned char targetItemState = *(unsigned char *)param;
												if(targetItemState == IS_Dead)
												{//目标死亡
													roleData->excHandle(MAKEINT64(WCH_LockData, 0));
													continue;
												}
											}
											unsigned char itemstate = IS_UseItem;
											roleData->inputParam(WCHDATA_ItemState,&itemstate);							
											roleData->inputParam(WCHDATA_AboutToUseItemID,&aboutUseID);
										}
										else 
										{//useResult 值为UR_Succeed ，但是没有施法目标，此时也应该前往政厅或BOSS处
											unsigned char itemstate = IS_AttackToPos;
											unsigned char targettype = Target_Coord;
											roleData->inputParam(WCHDATA_ItemState,&itemstate);
											roleData->inputParam(WCHDATA_TargetType,&targettype);
											roleData->inputParam(WCHDATA_TargetPos,&m_targetPosition);
											roleData->inputParam(WCHDATA_MoveToPos,&m_targetPosition);
											crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(role);
										}
									}
								}
							}
						}
					}
				}
				roleData->excHandle(MAKEINT64(WCH_LockData, 0));
				if (useResult != UR_Succeed)
				{//未施法状态	
					bool templateCancleMove = false; //true表示消灭当前敌对目标，临时取消前往政厅或BOSS处
					roleData->getParam(WCHDATA_TargetType,param);
					unsigned char newTargettype = *(unsigned char *)param;
					if (newTargettype & Target_EnemyAll)
					{//消灭当前敌对目标，临时取消前往政厅或BOSS处
						templateCancleMove = true;
					}
					if (!templateCancleMove)
					{//前往政厅或BOSS处
						unsigned char itemstate = IS_AttackToPos;
						unsigned char targettype = Target_Coord;
						roleData->inputParam(WCHDATA_ItemState,&itemstate);
						roleData->inputParam(WCHDATA_TargetType,&targettype);
						roleData->inputParam(WCHDATA_TargetPos,&m_targetPosition);
						roleData->inputParam(WCHDATA_MoveToPos,&m_targetPosition);
						crMyPlayerData::getInstance()->getScene()->getPathFindingManager()->addPathFindRequest(role);
					}
				}
			}
		}
		crMyPlayerData::getInstance()->unlockMyRoleNpcMap();
	}
}
void crJXJRobotMethod::operator()(crHandle &handle)
{
	time_t t1 = time(0);
	if(m_lastupdtime == 0)
	{
		m_lastupdtime = t1+1;
		return;
	}
	if(crDisplaySettings::instance()->getRunMode() >= crDisplaySettings::Robot &&
		m_robotTab.valid() && 
		t1 - m_lastupdtime>1)
	{
		crTableIO::StrVec record;
		bool done = true;
		if(m_robotTab->queryOneRecord(0,crArgumentParser::appItoa(m_currentState),1,crArgumentParser::appItoa(m_currentStep),record)>=0)
		{
			int type = atoi(record[2].c_str());
			//0:UI不可跳过 1:UI可跳过 2:领地GM指令 3:战场GM指令
			if(type<2)
			{
				bool notRequest = type==1;
				std::string& canvas = record[3];
				std::string& widget = record[4];
				ref_ptr<crCanvasNode> canvasNode = crFilterRenderManager::getInstance()->findCanvas(canvas);
				done = notRequest;
				if(canvasNode.valid() && canvasNode->getVisiable() && canvasNode->getEnable())
				{
					crWidgetNode *widgetNode = canvasNode->getWidget(widget);
					if(widgetNode && widgetNode->getEnable())
					{
						widgetNode->doEvent(MAKEINT64(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE),NULL));
						done = true;
					}
				}
			}
			else if(type==2 && !record[5].empty())
			{//领地GM指令
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(record[5].length()+4);
				stream->_writeString(record[5]);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGMOrder,stream.get());
				crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			else if(type==3 && !record[5].empty())
			{//战场GM指令
				if(record[5].compare("/AI")==0)
				{
					battleAI();
				}
				else
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(record[5].length()+5);
					stream->_writeChar(ChatInTeam);
					stream->_writeString(record[5]);
					crPlayerDataSceneEventPacket packet;
					crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvRoomChatMessage,stream.get());
					crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
			if(done)
			{
				m_currentStep++;
				m_lastupdtime = t1;
			}
			else if(t1 - m_lastupdtime>5)
			{
				int maxState = atoi(m_robotTab->getData(m_robotTab->getRowCount()-1,0).c_str());
				m_currentState = rangei(1,maxState+1).get_random();
				m_currentStep=1;
			}
		}
		else if(m_robotTab->getRowCount()>0)
		{
			int maxState = atoi(m_robotTab->getData(m_robotTab->getRowCount()-1,0).c_str());
			m_currentState = rangei(1,maxState+1).get_random();
			m_currentStep=1;
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoadingTipsMethod
//
/////////////////////////////////////////
crJXJLoadingTipsMethod::crJXJLoadingTipsMethod():
	m_updateInterval(2.0f),
	m_dt(0.0f),
	m_timer(0.0f),
	m_currentid(-1){}
crJXJLoadingTipsMethod::crJXJLoadingTipsMethod(const crJXJLoadingTipsMethod& handle):
	crMethod(handle),
	m_tipsTab(handle.m_tipsTab),
	m_updateInterval(handle.m_updateInterval),
	m_dt(0.0f),
	m_timer(0.0f),
	m_currentid(-1)
{
}
void crJXJLoadingTipsMethod::inputParam(int i, void *param)
{
	if(i==0)
		m_element = (CRGUI::crStaticTextBoxElement*)param;
	else if(i == -3)
	{
		m_dt = *(float *)param;
	}
}
void crJXJLoadingTipsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tipsTab = crTableIO::openFile(str);
		break;
	case 1:
		m_updateInterval = atof(str.c_str());
		break;
	}
}
void crJXJLoadingTipsMethod::operator()(crHandle &handle)
{
	if(m_element && m_tipsTab.valid())
	{
		if(m_currentid == -1)
		{
			int maxid = m_tipsTab->getRowCount();
			m_currentid = rangei(0,maxid).get_random();
			m_timer = m_updateInterval;
		}
		m_timer+=m_dt;
		if(m_timer>m_updateInterval)
		{
			m_element->setStringArrayByString(m_tipsTab->getData(m_currentid,1));
			m_timer = 0.0f;
			m_currentid++;
			if(m_currentid>=m_tipsTab->getRowCount())
				m_currentid = 0;
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoadingTips1Method
//
/////////////////////////////////////////
crJXJLoadingTips1Method::crJXJLoadingTips1Method():
	m_updateInterval(2.0f),
	m_dt(NULL),
	m_timer(0.0f){}
crJXJLoadingTips1Method::crJXJLoadingTips1Method(const crJXJLoadingTips1Method& handle):
	crMethod(handle),
	m_tipsWidget(handle.m_tipsWidget),
	m_tipsTab(handle.m_tipsTab),
	m_updateInterval(handle.m_updateInterval),
	m_dt(NULL),
	m_timer(0.0f)
{
}
void crJXJLoadingTips1Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float *)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}
void crJXJLoadingTips1Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tipsWidget = str;
		break;
	case 1:
		m_tipsTab = crTableIO::openFile(str);
		break;
	case 2:
		m_updateInterval = atof(str.c_str());
		break;
	}
}
void crJXJLoadingTips1Method::operator()(crHandle &handle)
{
	static int s_currentid = -1;
	crStaticTextWidgetNode *tips = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_tipsWidget)); 
	if(tips && m_tipsTab.valid())
	{
		if(s_currentid == -1)
		{
			int maxid = m_tipsTab->getRowCount();
			s_currentid = rangei(0,maxid).get_random();
			//m_timer = m_updateInterval;
		}
		m_timer-=*m_dt;
		if(m_timer<=0.0f)
		{
			tips->setString(m_tipsTab->getData(s_currentid,1));
			m_timer = m_updateInterval;
			s_currentid++;
			if(s_currentid>=m_tipsTab->getRowCount())
				s_currentid = 0;
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoginMethod
//
/////////////////////////////////////////
crJXJLoginMethod::crJXJLoginMethod(){}
crJXJLoginMethod::crJXJLoginMethod(const crJXJLoginMethod& handle):
	crMethod(handle),
	m_userNameWidget(handle.m_userNameWidget),
	m_userPasswordWidget(handle.m_userPasswordWidget)
{
}
void crJXJLoginMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJLoginMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_userNameWidget = str;
		break;
	case 1:
		m_userPasswordWidget = str;
		break;
	}
}
void crJXJLoginMethod::operator()(crHandle &handle)
{
	std::string userName;
	std::string userPassword;
	crCanvasNode *canvas = m_this->getParentCanvas();

	ref_ptr<crEditWidgetNode> nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userNameWidget));
	if(nameWidget.valid())
	{
		userName = crArgumentParser::trim(const_cast<char *>(nameWidget->getUTF8String().c_str()));
	}
	ref_ptr<crEditWidgetNode> passwordWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userPasswordWidget));
	if(passwordWidget.valid())
	{
		userPassword = crArgumentParser::trim(const_cast<char *>(passwordWidget->getUTF8String().c_str()));
		passwordWidget->clearString();
	}

	if(userName.empty()||userPassword.empty())
	{
		CRCore::notify(CRCore::FATAL)<<"Name或者Password不能为空"<<std::endl;
		return;
	}
	crJXJLoginPacket packet;
	crJXJLoginPacket::buildRequestPacket(packet,userName,userPassword);
	CRNet::crNetConductor* netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJLoginGameMethod
//
/////////////////////////////////////////
crJXJLoginGameMethod::crJXJLoginGameMethod(){}
crJXJLoginGameMethod::crJXJLoginGameMethod(const crJXJLoginGameMethod& handle):
	crMethod(handle),
	m_callback(handle.m_callback),
	m_servername(handle.m_servername),
	m_password(handle.m_password)
{
}
void crJXJLoginGameMethod::inputParam(int i, void *param)
{
}

void crJXJLoginGameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_callback = str;
		break;
	case 1:
		m_servername = str;
		break;
	case 2:
		m_password = str;
		break;
	}
}
void crJXJLoginGameMethod::operator()(crHandle &handle)
{
	bool sucess = false;
	crQueryConnectServerData *connectServerData = crMyPlayerData::getInstance()->getConnectServerData();
	if(connectServerData)
	{
		CRCore::ref_ptr<CRNet::crNetConductor> netConductor = new CRNet::crNetConductor;
		netConductor->init(connectServerData->getPort());
		netConductor->setNetType(CRNetApp::GameClient_Game);
		netConductor->setName("GameClient_Game");
		netConductor->setEnableCook(true);
		int playerid = crMyPlayerData::getInstance()->getPlayerID();
		CRCore::notify(CRCore::ALWAYS)<<"连接到游戏服务器:"<<connectServerData->getIP()<<":"<<connectServerData->getPort()<<std::endl;
		crBlockDetectThread::getInstance()->pause();
		int code = 0;
		if(crDisplaySettings::instance()->getRunMode()>=crDisplaySettings::Robot)
			code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0);
		else
			code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0,10);
		//int code = netConductor->getNetManager()->clientReconnectToServerCircle(connectServerData->getIP(),m_callback,playerid,m_servername,m_password,connectServerData->getPort(),0,5);
		crBlockDetectThread::getInstance()->resume();
		if(code<=0)
		{
			switch (code)
			{
			case 0:
				//无法创建客户端
				CRCore::notify(CRCore::FATAL)<<"无法连接到游戏服务器，请检查服务器IP地址，端口或者WaiterConnectServer是否启动"<<std::endl;
				break;
			case -1:
				//超出服务器连接人数限制
				CRCore::notify(CRCore::FATAL)<<"超出服务器连接人数限制"<<std::endl;
				break;
			case -2:
				//同名客户端已经存在
				CRCore::notify(CRCore::FATAL)<<"同名客户端已经存在"<<std::endl;
				break;
			case -3:
				//要求连接的服务端名字与本服务器名不同
				CRCore::notify(CRCore::FATAL)<<"要求连接的服务端名字与本服务器名不同"<<std::endl;
				break;
			case -4:
				//服务器密码不正确
				CRCore::notify(CRCore::FATAL)<<"服务器密码不正确"<<std::endl;
				break;
			default:
				CRCore::notify(CRCore::FATAL)<<"无法连接到游戏服务器"<<std::endl;
			}
		}
		else
		{
			CRNet::crNetContainer::getInstance()->pushDynamicNetConductor(netConductor.get());
			//CRCore::notify(CRCore::ALWAYS)<<"已经与游戏服务器建立连接"<<std::endl;
			if(crMyPlayerData::getInstance()->getSelectedGame())
			{
				crJXJLoginGamePacket packet;
				crJXJLoginGamePacket::buildRequestPacket(packet);
				netConductor->getNetManager()->sendPacket("all",packet);

				sucess = true;
			}
		}
	}
	handle.outputParam(0,&sucess);
}
/////////////////////////////////////////
//
//crJXJRegisterAccountMethod
//
/////////////////////////////////////////
crJXJRegisterAccountMethod::crJXJRegisterAccountMethod(){}
crJXJRegisterAccountMethod::crJXJRegisterAccountMethod(const crJXJRegisterAccountMethod& handle):
	crMethod(handle),
	m_userNameWidget(handle.m_userNameWidget),
	m_userPasswordWidget(handle.m_userPasswordWidget),
	m_password2Widget(handle.m_password2Widget),
	m_emailWidget(handle.m_emailWidget),
	m_cdkeyWidget(handle.m_cdkeyWidget)
{
}
void crJXJRegisterAccountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJRegisterAccountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_userNameWidget = str;
		break;
	case 1:
		m_userPasswordWidget = str;
		break;
	case 2:
		m_password2Widget = str;
		break;
	case 3:
		m_emailWidget = str;
		break;
	case 4:
		m_cdkeyWidget = str;
		break;
	}
}
void crJXJRegisterAccountMethod::operator()(crHandle &handle)
{		
	std::string userName;
	std::string userPassword;
	crCanvasNode *canvas = m_this->getParentCanvas();

	ref_ptr<crEditWidgetNode> nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userNameWidget));
	if(nameWidget.valid())
	{
		userName = nameWidget->getUTF8String();
	}
	ref_ptr<crEditWidgetNode> passwordWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_userPasswordWidget));
	if(passwordWidget.valid())
	{
		userPassword = passwordWidget->getUTF8String();
		passwordWidget->clearString();
	}
	//CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
	std::wstring notice;
	if(userName.empty()||userPassword.empty())
	{
		/*CRCore::notify(CRCore::FATAL)<<"Name或者Password不能为空"<<std::endl;
		if(noticeText)
		{
		notice = L"帐号或者密码不能为空";
		noticeText->setText(notice.c_str());
		noticeText->setVisiable(true);
		}*/
		crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(1,NULL));
		return;
	}
	ref_ptr<crEditWidgetNode> password2Widget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_password2Widget));
	if(password2Widget.valid())
	{
		std::string password2 = password2Widget->getUTF8String();
		password2Widget->clearString();
		if(password2.compare(userPassword) != 0)
		{
			/*if(noticeText)
			{
			notice = L"2次输入密码不一致";
			noticeText->setText(notice.c_str());
			noticeText->setVisiable(true);
			}*/
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(2,NULL));
			return;
		}
	}
	ref_ptr<crEditWidgetNode> emailWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_emailWidget));
	std::string email;
	if(emailWidget.valid())
	{
		email = emailWidget->getUTF8String();
		if(email.empty())
		{
			/*if(noticeText)
			{
			notice = L"Email不能为空";
			noticeText->setText(notice.c_str());
			noticeText->setVisiable(true);
			}*/
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(3,NULL));
			return;
		}
		else if(email.find('@')==std::string::npos)
		{
			//if(noticeText)
			//{
			//	notice = L"请输入正确的Email";
			//	noticeText->setText(notice.c_str());
			//	noticeText->setVisiable(true);
			//}
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(4,NULL));
			return;
		}
	}
	ref_ptr<crEditWidgetNode> codeWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_cdkeyWidget));
	std::string code;
	if(codeWidget.valid())
	{
		code = codeWidget->getUTF8String();
		if(code.empty())
		{
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(31,NULL));
			return;
		}
		else if(code.size()<10)
		{
			crGlobalHandle::getInstance()->doEvent(WCH_UINotify,MAKEINT64(32,NULL));
			return;
		}
	}
	std::string relname;
	crJXJRegisterAccountPacket packet;
	crJXJRegisterAccountPacket::buildRequestPacket(packet,userName,userPassword,email,userName,relname,0,code);
	CRNet::crNetConductor* netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Login);
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJDownloadFilesMethod
//
/////////////////////////////////////////
crJXJDownloadFilesMethod::crJXJDownloadFilesMethod(){}
crJXJDownloadFilesMethod::crJXJDownloadFilesMethod(const crJXJDownloadFilesMethod& handle):
crMethod(handle)
{
}
void crJXJDownloadFilesMethod::inputParam(int i, void *param)
{
}

void crJXJDownloadFilesMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgid = atoi(str.c_str());
		break;
	case 1:
		m_filename = str;
		break;
	}
}

void crJXJDownloadFilesMethod::operator()(crHandle &handle)
{
	crGameClientData *data = dynamic_cast<crGameClientData *>(crGlobalHandle::getInstance()->getDataClass());
	if(data)
	{
		data->insertDownloadFile(m_msgid,m_filename);
		data->startDownloadFile(m_msgid,GameClient_Game);
	}
}
/////////////////////////////////////////
//
//crJXJLoadUISceneMethod
//
/////////////////////////////////////////
crJXJLoadUISceneMethod::crJXJLoadUISceneMethod(){}
crJXJLoadUISceneMethod::crJXJLoadUISceneMethod(const crJXJLoadUISceneMethod& handle):
	crMethod(handle),
	m_filename(handle.m_filename)
{
}
void crJXJLoadUISceneMethod::inputParam(int i, void *param)
{
}

void crJXJLoadUISceneMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_filename = str;
		break;
	}
}

void crJXJLoadUISceneMethod::operator()(crHandle &handle)
{
	ref_ptr<crGroup> uiroot = dynamic_cast<crGroup *>(CRIOManager::readNodeFile(m_filename));
	if(uiroot.valid())
	{
		crLoadUISceneVisitor visitor;
		visitor.init(uiroot.get());
		uiroot->accept(visitor);
	}
}
///////////////////////////////////////////
////
////crJXJCheckAndDownFrontMethod
////
///////////////////////////////////////////
//crJXJCheckAndDownFrontMethod::crJXJCheckAndDownFrontMethod(){}
//crJXJCheckAndDownFrontMethod::crJXJCheckAndDownFrontMethod(const crJXJCheckAndDownFrontMethod& handle):
//	crMethod(handle),
//	m_frontname(handle.m_frontname)
//{
//}
//void crJXJCheckAndDownFrontMethod::inputParam(int i, void *param)
//{
//}
//
//void crJXJCheckAndDownFrontMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_frontname = str;
//		break;
//	}
//}
//
//void crJXJCheckAndDownFrontMethod::operator()(crHandle &handle)
//{
//	std::string foundFile = CRText::findFontFile(m_frontname);
//	if(foundFile.empty())
//	{
//		ref_ptr<crDownload> download = new crDownload("media/fonts/"+m_frontname);
//		crDownloadManager::getInstance()->addImmediatelyDownloadRequest(download.get());
//	}
//}
/////////////////////////////////////////
//
//crJXJQueryGmMethod
//
/////////////////////////////////////////
crJXJQueryGmMethod::crJXJQueryGmMethod():
	m_serverid(0)
{
}
crJXJQueryGmMethod::crJXJQueryGmMethod(const crJXJQueryGmMethod& handle):
	crMethod(handle),
	m_serverid(0)
{
}
void crJXJQueryGmMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			m_serverName = *(std::string*)lparam;
			m_serverid = HIINT64(param64);
		}
		break;
	}
}
void crJXJQueryGmMethod::addParam(int i, const std::string& str)
{
}
void crJXJQueryGmMethod::operator()(crHandle &handle)
{
	crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
	ref_ptr<crDataBase> globalSession = db->beginSession();
	//查询并返回GameList
	ref_ptr<crJXJGmQueryData> gmQueryQuery = new crJXJGmQueryData;
	gmQueryQuery->buildQuerySql(m_serverid);
	globalSession->executeQuery(gmQueryQuery.get());
	crDataBase::QueryResultVec gmQueryQueryResultVec = globalSession->getQueryResult();
	globalSession->releaseQuery();
	db->endSession(globalSession.get());

	crGlobalHandle::gData()->lockGMMap();
	GMMap &gmMap = crGlobalHandle::gData()->getGMMap();
	gmMap.clear();
	for( crDataBase::QueryResultVec::iterator itr = gmQueryQueryResultVec.begin();
		 itr != gmQueryQueryResultVec.end();
		 ++itr )
	{
		gmQueryQuery = dynamic_cast<crJXJGmQueryData *>(itr->get());
		gmMap[gmQueryQuery->getPlayerID()] = gmQueryQuery->getAuthorityid();
	}
	crGlobalHandle::gData()->unlockGMMap();
}
/////////////////////////////////////////
//
//crJXJQueryGmMapMethod
//
/////////////////////////////////////////
crJXJQueryGmMapMethod::crJXJQueryGmMapMethod()
{
}
crJXJQueryGmMapMethod::crJXJQueryGmMapMethod(const crJXJQueryGmMapMethod& handle):
	crMethod(handle)
{
}
void crJXJQueryGmMapMethod::inputParam(int i, void *param)
{
}
void crJXJQueryGmMapMethod::addParam(int i, const std::string& str)
{
}
void crJXJQueryGmMapMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
	crJXJQueryGmMapPacket packet;
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJQueryNoChatMethod
//
/////////////////////////////////////////
crJXJQueryNoChatMethod::crJXJQueryNoChatMethod():
	m_serverid(0)
{
}
crJXJQueryNoChatMethod::crJXJQueryNoChatMethod(const crJXJQueryNoChatMethod& handle):
	crMethod(handle),
	m_serverid(0)
{
}
void crJXJQueryNoChatMethod::inputParam(int i, void *param)
{
	switch(i)
	{
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_serverid = HIINT64(param64);
		}
		break;
	}
}
void crJXJQueryNoChatMethod::addParam(int i, const std::string& str)
{
}
void crJXJQueryNoChatMethod::operator()(crHandle &handle)
{
	crData *gameData = crServerBrainHandle::getInstance()->getDataClass();
	gameData->excHandle(MAKEINT64(WCH_LockData,1));

	crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
	ref_ptr<crDataBase> globalSession = db->beginSession();

	ref_ptr<crJXJNoChatQueryData> noChatQueryQuery = new crJXJNoChatQueryData;
	noChatQueryQuery->buildQuerySql(m_serverid);
	globalSession->executeQuery(noChatQueryQuery.get());
	crDataBase::QueryResultVec& noChatQueryQueryResultVec = globalSession->getQueryResult();

	void *param;
	gameData->getParam(WCHDATA_JXJNoChatSet,param);
	NoChatSet *noChatSet = (NoChatSet *)param;
	noChatSet->clear();
	for( crDataBase::QueryResultVec::iterator itr = noChatQueryQueryResultVec.begin();
		itr != noChatQueryQueryResultVec.end();
		++itr )
	{
		noChatQueryQuery = dynamic_cast<crJXJNoChatQueryData *>(itr->get());
		noChatSet->insert(noChatQueryQuery->getPlayerID());
	}

	globalSession->releaseQuery();
	db->endSession(globalSession.get());

	gameData->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJQueryNoChatSetMethod
//
/////////////////////////////////////////
crJXJQueryNoChatSetMethod::crJXJQueryNoChatSetMethod()
{
}
crJXJQueryNoChatSetMethod::crJXJQueryNoChatSetMethod(const crJXJQueryNoChatSetMethod& handle):
	crMethod(handle)
{
}
void crJXJQueryNoChatSetMethod::inputParam(int i, void *param)
{
}
void crJXJQueryNoChatSetMethod::addParam(int i, const std::string& str)
{
}
void crJXJQueryNoChatSetMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(SceneServerClient_Game);
	crJXJQueryNoChatSetPacket packet;
	netConductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJLoadingProgressMethod
//
/////////////////////////////////////////
crJXJLoadingProgressMethod::crJXJLoadingProgressMethod():
	m_speed(10.0f),
m_dt(NULL){}
crJXJLoadingProgressMethod::crJXJLoadingProgressMethod(const crJXJLoadingProgressMethod& handle):
	crMethod(handle),
	m_speed(handle.m_speed),
	m_dt(NULL),
	m_progressWidget(handle.m_progressWidget),
	m_donghua(handle.m_donghua)
{
}
void crJXJLoadingProgressMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_dt = (float *)(LOINT64(param64));
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJLoadingProgressMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_speed = atof(str.c_str());
		break;
	case 1:
		m_progressWidget = str;
		break;
	case 2:
		m_donghua = str;
		break;
	}
}

void crJXJLoadingProgressMethod::operator()(crHandle &handle)
{
	crProgressWidgetNode *progresswidget = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progressWidget));
	crMatrixSequence *seq = dynamic_cast<crMatrixSequence *>(m_this->getChildNode(m_donghua));
	float progress = crRunGameHandle::getInstance()->getLoadingProgress();
	float& curProgress = crRunGameHandle::getInstance()->curLoadingProgress();
	if(curProgress<progress)
	{
		curProgress += *m_dt * m_speed;
		if(curProgress>progress)
			curProgress = progress;
		if(progresswidget)
		{
			progresswidget->setProgress(curProgress);
			if(seq)
			{
				crVector2 barpos = progresswidget->getBarOffsetPosition();
				seq->setEffectPosition(crVector3(barpos[0],barpos[1],0.0f));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoadingProgressInitMethod
//
/////////////////////////////////////////
crJXJLoadingProgressInitMethod::crJXJLoadingProgressInitMethod(){}
crJXJLoadingProgressInitMethod::crJXJLoadingProgressInitMethod(const crJXJLoadingProgressInitMethod& handle):
	crMethod(handle),
	m_progressWidget(handle.m_progressWidget)
{
}
void crJXJLoadingProgressInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJLoadingProgressInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progressWidget = str;
		break;
	}
}

void crJXJLoadingProgressInitMethod::operator()(crHandle &handle)
{
	crProgressWidgetNode *progresswidget = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progressWidget));
	if(progresswidget)
		progresswidget->setProgress(0.0f);
}
/////////////////////////////////////////
//
//crJXJDisplayGameStartImgMethod
//
/////////////////////////////////////////
crJXJDisplayGameStartImgMethod::crJXJDisplayGameStartImgMethod(){}
crJXJDisplayGameStartImgMethod::crJXJDisplayGameStartImgMethod(const crJXJDisplayGameStartImgMethod& handle):
	crMethod(handle),
	m_gamestartImg(handle.m_gamestartImg)
{
}
void crJXJDisplayGameStartImgMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJDisplayGameStartImgMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_gamestartImg = str;
		break;
	}
}

void crJXJDisplayGameStartImgMethod::operator()(crHandle &handle)
{
	static int s_gamestart = 0;
	crNode *gamestartImg = m_this->getChildNode(m_gamestartImg);
	if(gamestartImg)
	{
		gamestartImg->setVisiable(s_gamestart==0);
		s_gamestart++;
	}
}
/////////////////////////////////////////
//
//crJXJPlayerDataMonitorMethod
//
/////////////////////////////////////////
crJXJPlayerDataMonitorMethod::crJXJPlayerDataMonitorMethod():
m_init(false){}
crJXJPlayerDataMonitorMethod::crJXJPlayerDataMonitorMethod(const crJXJPlayerDataMonitorMethod& handle):
	crMethod(handle),
	m_init(false)
{
}
void crJXJPlayerDataMonitorMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJPlayerDataMonitorMethod::addParam(int i, const std::string& str)
{
}
void crJXJPlayerDataMonitorMethod::operator()(crHandle &handle)
{
	crRole *mainRole = m_this->getMainRole();
	if(!mainRole || !mainRole->getDataClass())
		return;
	crData *data = m_this->getDataClass();
	void *param;
	data->getParam(WCHDATA_JXJPlayerDataMonitor,param);
	crJXJPlayerDataMonitor *monitor = (crJXJPlayerDataMonitor *)param;
	if(m_init)
	{
		std::string warnstr;
		int delta = 0;
		int i = 0;
		///元宝
		data->getParam(WCHDATA_JXJGoldingot,param);
		int goldingot = *(int *)param;
		int mgoldingot = monitor->getGoldingot();
		monitor->setGoldingot(goldingot);
		ref_ptr<crTableIO>monitorTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJDataMonitorTab);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(goldingot  - mgoldingot > delta)
		{//变化超出,警报
			warnstr+="元宝变化过大 ";
		}
		//礼金
		i++;
		data->getParam(WCHDATA_JXJGiftGold,param);
		int giftgold = *(int *)param;
		int mgiftgold = monitor->getGiftgold();
		monitor->setGiftgold(giftgold);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(giftgold - mgiftgold > delta)
		{//变化超出,警报
			warnstr+="礼金变化过大 ";
		}
		//vip经验
		i++;
		data->getParam(WCHDATA_JXJVipExp,param);
		int vipexp = *(int *)param;
		int mvipexp = monitor->getVipExp();
		monitor->setVipExp(vipexp);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(vipexp - mvipexp > delta)
		{//变化超出,警报
			warnstr+="VIP经验变化过大 ";
		}
		//铜钱
		i++;
		data->getParam(WCHDATA_JXJCoppercash,param);
		int coppercash = *(int *)param;
		int mcoppercash = monitor->getCoppercash();
		monitor->setCoppercash(coppercash);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(coppercash - mcoppercash > delta)
		{//变化超出,警报
			warnstr+="铜钱变化过大 ";
		}
		//粮食
		i++;
		data->getParam(WCHDATA_JXJFood,param);
		int food = *(int *)param;
		int mfood = monitor->getFood();
		monitor->setFood(food);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(food - mfood > delta)
		{//变化超出,警报
			warnstr+="粮食变化过大 ";
		}
		//木材
		i++;
		data->getParam(WCHDATA_JXJWood,param);
		int wood = *(int *)param;
		int mwood = monitor->getWood();
		monitor->setWood(wood);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(wood - mwood > delta)
		{//变化超出,警报
			warnstr+="木材变化过大 ";
		}
		//铁
		i++;
		data->getParam(WCHDATA_JXJIron,param);
		int iron = *(int *)param;
		int miron = monitor->getIron();
		monitor->setIron(iron);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(iron - miron > delta)
		{//变化超出,警报
			warnstr+="铁矿变化过大 ";
		}
		//马匹
		i++;
		data->getParam(WCHDATA_JXJHorse,param);
		int horse = *(int *)param;
		int mhorse = monitor->getHorse();
		monitor->setHorse(horse);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(horse - mhorse > delta)
		{//变化超出,警报
			warnstr+="马匹变化过大 ";
		}

		crData *roledata = mainRole->getDataClass();
		//等级
		i++;
		roledata->getParam(WCHDATA_Level,param);
		unsigned char level = *(unsigned char *)param;
		unsigned char mlevel = monitor->getLevel();
		monitor->setLevel(level);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(level - mlevel > delta)
		{//变化超出,警报
			warnstr+="等级变化过大 ";
		}
		//功勋
		i++;
		roledata->getParam(WCHDATA_JXJExploit,param);
		int exploit = *(int *)param;
		int mexploit = monitor->getExploit();
		monitor->setExploit(exploit);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(exploit - mexploit > delta)
		{//变化超出,警报
			warnstr+="功勋变化过大 ";
		}

		//总兵力
		i++;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troopsMap = (TroopsMap *)param;
		int troopsCount = 0;
		for( TroopsMap::iterator itr = troopsMap->begin();
			itr != troopsMap->end();
			++itr )
		{
			troopsCount += itr->second;
		}
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		for( FormationInfoVec::iterator itr = formationInfoVec->begin();
			itr != formationInfoVec->end();
			++itr )
		{
			troopsCount += (*itr)->getCount();
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		int mtroopsCount = monitor->getTroops();
		monitor->setTroops(troopsCount);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(troopsCount - mtroopsCount > delta)
		{//变化超出,警报
			warnstr+="总兵力变化过大 ";
		}
		//建筑总等级
		///统计领地总等级
		i++;
		unsigned short manorlv = 0;
		for (int i = WCHDATA_JXJFuyalv; i <= WCHDATA_JXJFukulv; i++)
		{
			data->getParam(i,param);
			manorlv += *(unsigned char *)param;
		}
		for (int i = WCHDATA_JXJMingjulv1; i <= WCHDATA_JXJKuangshanlv4; i++)
		{
			data->getParam(i,param);
			manorlv += *(unsigned char *)param;
		}
		int mmanorlv = monitor->getManorlv();
		monitor->setManorlv(mmanorlv);
		delta = atoi(monitorTab->getData(i,1).c_str());
		if(manorlv - mmanorlv > delta)
		{//变化超出,警报
			warnstr+="建筑总等级变化过大 ";
		}
		if(!warnstr.empty())
		{
			/////游戏日志
			//std::string logdata = warnstr;
			//GameLogData gamelog(Log_DataMonitor,logdata);
			//crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_this->getPlayerID(),&gamelog));
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
			int playerid = m_this->getPlayerID();
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
			ref_ptr<crInsertDatamonitor> insertsql = new crInsertDatamonitor;
			insertsql->buildUpdateSql(playerid,callback->getServerID(),warnstr);
			crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
			crDBSavePacket packet;
			crDBSavePacket::buildRequestPacket(packet,insertsql.get());
			dbConductor->getNetManager()->sendPacket("all",packet);
		}
	}
	else
	{
		///元宝
		data->getParam(WCHDATA_JXJGoldingot,param);
		int goldingot = *(int *)param;
		monitor->setGoldingot(goldingot);
		//礼金
		data->getParam(WCHDATA_JXJGiftGold,param);
		int giftgold = *(int *)param;
		monitor->setGiftgold(giftgold);
		//vip经验
		data->getParam(WCHDATA_JXJVipExp,param);
		int vipexp = *(int *)param;
		monitor->setVipExp(vipexp);
		//铜钱
		data->getParam(WCHDATA_JXJCoppercash,param);
		int coppercash = *(int *)param;
		monitor->setCoppercash(coppercash);
		//粮食
		data->getParam(WCHDATA_JXJFood,param);
		int food = *(int *)param;
		monitor->setFood(food);
		//木材
		data->getParam(WCHDATA_JXJWood,param);
		int wood = *(int *)param;
		monitor->setWood(wood);
		//铁
		data->getParam(WCHDATA_JXJIron,param);
		int iron = *(int *)param;
		monitor->setIron(iron);
		//马匹
		data->getParam(WCHDATA_JXJHorse,param);
		int horse = *(int *)param;
		monitor->setHorse(horse);
		
		crData *roledata = mainRole->getDataClass();
		//等级
		roledata->getParam(WCHDATA_Level,param);
		unsigned char level = *(unsigned char *)param;
		monitor->setLevel(level);
		//功勋
		roledata->getParam(WCHDATA_JXJExploit,param);
		int exploit = *(int *)param;
		monitor->setExploit(exploit);

		//总兵力
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJTroopsMap,param);
		TroopsMap *troopsMap = (TroopsMap *)param;
		int troopsCount = 0;
		for( TroopsMap::iterator itr = troopsMap->begin();
			itr != troopsMap->end();
			++itr )
		{
			troopsCount += itr->second;
		}
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		for( FormationInfoVec::iterator itr = formationInfoVec->begin();
			itr != formationInfoVec->end();
			++itr )
		{
			troopsCount += (*itr)->getCount();
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
		monitor->setTroops(troopsCount);
		//建筑总等级
		///统计领地总等级
		unsigned short manorlv = 0;
		for (int i = WCHDATA_JXJFuyalv; i <= WCHDATA_JXJFukulv; i++)
		{
			data->getParam(i,param);
			manorlv += *(unsigned char *)param;
		}
		for (int i = WCHDATA_JXJMingjulv1; i <= WCHDATA_JXJKuangshanlv4; i++)
		{
			data->getParam(i,param);
			manorlv += *(unsigned char *)param;
		}
		monitor->setManorlv(manorlv);
		m_init = true;
	}
}
/////////////////////////////////////////
//
//crJXJDataMonitorMethod
//
/////////////////////////////////////////
crJXJDataMonitorMethod::crJXJDataMonitorMethod(){}
crJXJDataMonitorMethod::crJXJDataMonitorMethod(const crJXJDataMonitorMethod& handle):
	crMethod(handle)
{
}
void crJXJDataMonitorMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJDataMonitorMethod::addParam(int i, const std::string& str)
{
}
void crJXJDataMonitorMethod::operator()(crHandle &handle)
{
	m_this->doEvent(WCH_JXJPlayerDataMonitor);
}
/////////////////////////////////////////
//
//crJXJPlayerShouchongMethod
//
/////////////////////////////////////////
crJXJPlayerShouchongMethod::crJXJPlayerShouchongMethod(){}
crJXJPlayerShouchongMethod::crJXJPlayerShouchongMethod(const crJXJPlayerShouchongMethod& handle) :
	crMethod(handle)
{
}
void crJXJPlayerShouchongMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if (param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}

void crJXJPlayerShouchongMethod::addParam(int i, const std::string& str)
{
}

void crJXJPlayerShouchongMethod::operator()(crHandle &handle)
{
	void * param;
	crData * playerData = m_this->getDataClass();
	int playerid = m_this->getPlayerID();
	if (playerData)
	{
		playerData->getParam(WCHDATA_JXJShouchong, param);
		unsigned char shoucong = *(unsigned char *)param;
		if(shoucong == 0)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
			int serverid = callback->getServerID();
			crDataBase *db = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
			ref_ptr<crDataBase> globalSession = db->beginSession();
			//检测是否首冲
			ref_ptr<crCheckPayMoneyCountData> checkpaymoneycount;
			checkpaymoneycount = new crCheckPayMoneyCountData;
			checkpaymoneycount->buildQuerySql(playerid,serverid);
			globalSession->executeQuery(checkpaymoneycount.get());
			crDataBase::QueryResultVec checkpaymoneycountResultVec = globalSession->getQueryResult();
			globalSession->releaseQuery();
			db->endSession(globalSession.get());
			if (!checkpaymoneycountResultVec.empty())
			{
				checkpaymoneycount = dynamic_cast<crCheckPayMoneyCountData *>(checkpaymoneycountResultVec[0].get());
				if(checkpaymoneycount->getCount()>0)
				{
					shoucong = 1;
					playerData->inputParam(WCHDATA_JXJShouchong, &shoucong);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetShouchongAwardMethod
//
/////////////////////////////////////////
crJXJGetShouchongAwardMethod::crJXJGetShouchongAwardMethod()
{
}

crJXJGetShouchongAwardMethod::crJXJGetShouchongAwardMethod( const crJXJGetShouchongAwardMethod & handle ):
	crMethod(handle)
{
}

void crJXJGetShouchongAwardMethod::inputParam( int i, void *param )
{
}

void crJXJGetShouchongAwardMethod::addParam( int i, const std::string& str )
{
}

void crJXJGetShouchongAwardMethod::operator()( crHandle &handle )
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if (netConductor)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvShouchongAward,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}

/////////////////////////////////////////
//
//crJXJGetShouchongAwardMethod
//
/////////////////////////////////////////
crJXJRecvShouchongAwardMethod::crJXJRecvShouchongAwardMethod():
	m_this(NULL),
	m_stream(NULL),
	m_netType(CRNetApp::Client)
{

}
crJXJRecvShouchongAwardMethod::crJXJRecvShouchongAwardMethod( const crJXJRecvShouchongAwardMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_stream(NULL),
	m_netType(CRNetApp::Client)
{
}
void crJXJRecvShouchongAwardMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_netType = Client;
			m_stream = NULL;
		}
		break;
	}

}

void crJXJRecvShouchongAwardMethod::addParam( int i, const std::string& str )
{
}

void crJXJRecvShouchongAwardMethod::operator()( crHandle &handle )
{
	if(m_netType == GameServer)
	{
		int playerid = m_this->getPlayerID();
		crData * data = m_this->getDataClass();
		void *param;
		unsigned char ret = 0;
		data->getParam(WCHDATA_JXJShouchong,param);
		unsigned char shouchong = *(unsigned char *)param;
		if(shouchong == 1)
		{
			std::string logdata = "领取首充：";
			ref_ptr<crTableIO> awardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShouchongAwardTab);
			if (awardTab.valid())
			{
				crVector3i vec3;
				RewardItemVec rewardItems;
				CRCore::ref_ptr<crBagItemData> itemdata;
				int count = awardTab->getRowCount();
				for(int i = 0; i<count; i++)
				{
					if(crArgumentParser::appAtoVec((*awardTab)(i,1),vec3))
					{
						logdata += (*awardTab)(i,1);
						itemdata = new crBagItemData;
						itemdata->setItemID(vec3[0]);
						itemdata->setEquipMagic(vec3[1]);
						itemdata->setItemCount(vec3[2]);
						rewardItems.push_back(itemdata);
					}
				}
				if(!rewardItems.empty())
				{
					data->excHandle(MAKEINT64(WCH_LockData,1));
					m_this->doEvent(WCH_JXJRecvRewardItems,MAKEINT64(&rewardItems,0));
					data->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
			ret = 1;
			shouchong = 2;
			data->inputParam(WCHDATA_JXJShouchong,&shouchong);
			GameLogData gamelog(Log_ShouchongAward,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
		}
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(2);
			stream->_writeUChar(ret);
			stream->_writeUChar(shouchong);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvShouchongAward,stream.get());
			gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
		}
	}
	else if (m_netType == GameClient_Game)
	{
		unsigned char ret = m_stream->_readUChar();
		unsigned char shouchong = m_stream->_readUChar();
		crData *data = m_this->getDataClass();
		data->inputParam(WCHDATA_JXJShouchong,&shouchong);
		if(ret==0)
		{
			int msgid = shouchong==0?1084:1085;
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			noticeHandle->inputParam(WCHDATA_NoticeTextID,&msgid);
			int mode = 1;
			noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
			crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
		}
	}
}
/////////////////////////////////////////
//
//crJXJGainCountryCandidateVecTMethod
//
/////////////////////////////////////////
crJXJGainCountryCandidateVecTMethod::crJXJGainCountryCandidateVecTMethod():
	m_this(NULL){}
crJXJGainCountryCandidateVecTMethod::crJXJGainCountryCandidateVecTMethod(const crJXJGainCountryCandidateVecTMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJGainCountryCandidateVecTMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJGainCountryCandidateVecTMethod::addParam(int i, const std::string& str)
{
}

void crJXJGainCountryCandidateVecTMethod::operator()(crHandle &handle)
{
	crData *gsBrainData = m_this->getDataClass();
	void *param;
	crJXJShili *shili;
	crData *shiliData;
	CandidateVec *candidateVecT;
	CandidateVec::iterator cvItr;
	PeopleMap *peopleMap = NULL;
	PeopleMap::iterator peoItr;
	int maxum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCountryVotePeopleMaxNum).c_str()));
	gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
	//gsBrainData->getParam(WCHDATA_JXJConsortiaLvRank,param);
	//ConsortialvRank *consortialvRank = (ConsortialvRank *)param;
	//gsBrainData->getParam(WCHDATA_JXJLevelRankingMap,param);
	//LevelRankingMap *levelRankingMap = (LevelRankingMap *)param;
	//gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
	//ConsortiaMap *consortiamap = (ConsortiaMap *)param;
	//int shiliid;
	//int rankVal;
	bool modify = true;
	gsBrainData->getParam(WCHDATA_JXJLevelRankingMap,param);
	LevelRankingMap * lvRankingmap = (LevelRankingMap *)param;
	gsBrainData->getParam(WCHDATA_JXJExpRankingMap,param);
	ExpRankingMap * expRankingmap = (ExpRankingMap *)param;
	gsBrainData->getParam(WCHDATA_JXJAccomplishRankingMap,param);
	AccomplishRankingMap * accomplishRankingmap = (AccomplishRankingMap *)param;
	for( int i = 0; i < 3; ++ i)
	{
		gsBrainData->getParam(WCHDATA_JXJShiliWei+i,param);
		shili = (crJXJShili *)param;
		if (shili && shili->getDataClass())
		{
			shiliData = shili->getDataClass();
			shiliData->excHandle(MAKEINT64(WCH_LockData,1));
			shiliData->getParam(WCHDATA_JXJCountryCandidateVecT,param);
			candidateVecT = (CandidateVec*)param;
			candidateVecT->clear();

			//ConsortialvRank::RankSet & rankSet = consortialvRank->getRankSet();
			//ConsortialvRank::RankSet::iterator rsItr = rankSet.begin();
			//ConsortiaMap::iterator cmItr;
			//for (; candidateVecT->size() < maxum && rsItr != rankSet.end(); ++ rsItr)
			//{
			//	if (rsItr->valid())
			//	{
			//		cmItr = consortiamap->find((*rsItr)->m_id);
			//		if (cmItr == consortiamap->end() || cmItr->second.valid() == false) continue;
			//		if (cmItr->second->getShiLi() != c_startShiliID+i) continue;

			shiliData->getParam(WCHDATA_JXJPeopleMap,param);
			peopleMap = (PeopleMap *)param;
			peoItr = peopleMap->begin();
			if (!(lvRankingmap->empty()))
			{
				LevelRankingMap::iterator pmItr_1 = lvRankingmap->begin();
				int count = 0;
				for (; pmItr_1 != lvRankingmap->end() && pmItr_1->second.valid() && count < 10; pmItr_1++)
				{
					if (candidateVecT->size() < maxum)
					{
						peoItr = peopleMap->find(pmItr_1->second->getPlayerID());
						if(peoItr != peopleMap->end() && peoItr->second.valid())
						{
							CRCore::ref_ptr<strToupiaoInfo> strinfo = new strToupiaoInfo;
							strinfo->nPlayerID = pmItr_1->second->getPlayerID();
							strinfo->playerName = pmItr_1->second->getName();
							strinfo->nJuntuanID = peoItr->second->getConsortiaId();
							strinfo->juntuanName = peoItr->second->getConsortiaName();
							strinfo->m_level = peoItr->second->getLv();
							candidateVecT->push_back(strinfo);
							count++;
						}
					}
					else
					{
						break;
					}
				}
			}

			if (!(expRankingmap->empty()) && candidateVecT->size() < maxum)
			{
				ExpRankingMap::iterator pmItr_2 = expRankingmap->begin();
				int count_2 = 0;
				bool exist = false;
				for (; pmItr_2 != expRankingmap->end() && pmItr_2->second.valid() && count_2 < 10; pmItr_2++)
				{
					for (cvItr = candidateVecT->begin(); cvItr != candidateVecT->end(); ++ cvItr)
					{
						if (cvItr->valid() && (*cvItr)->nPlayerID == pmItr_2->second->getPlayerID())
						{
							exist = true;
							break;
						}
					}
					if (exist)
					{//已存在count_2也要推进
						exist = false;
						count_2++;
						continue;
					}
					if (candidateVecT->size() < maxum)
					{
						peoItr = peopleMap->find(pmItr_2->second->getPlayerID());
						if(peoItr != peopleMap->end() && peoItr->second.valid())
						{
							CRCore::ref_ptr<strToupiaoInfo> strinfo = new strToupiaoInfo;
							strinfo->nPlayerID = pmItr_2->second->getPlayerID();
							strinfo->playerName = pmItr_2->second->getName();
							strinfo->nJuntuanID = peoItr->second->getConsortiaId();
							strinfo->juntuanName = peoItr->second->getConsortiaName();
							strinfo->m_level = peoItr->second->getLv();
							candidateVecT->push_back(strinfo);
							count_2++;
						}
					}
					else
					{
						break;
					}
				}
			}

			if (!(accomplishRankingmap->empty()) && candidateVecT->size() < maxum)
			{
				AccomplishRankingMap::iterator pmItr_3 = accomplishRankingmap->begin();
				int count_3 = 0;
				bool exist = false;
				for (; pmItr_3 != accomplishRankingmap->end() && pmItr_3->second.valid() && count_3 < 10; pmItr_3++)
				{
					for (cvItr = candidateVecT->begin(); cvItr != candidateVecT->end(); ++ cvItr)
					{
						if (cvItr->valid() && (*cvItr)->nPlayerID == pmItr_3->second->getPlayerID())
						{
							exist = true;
							break;
						}
					}
					if (exist)
					{//已存在count_3也要推进
						exist = false;
						count_3++;
						continue;
					}
					if (candidateVecT->size() < maxum)
					{
						peoItr = peopleMap->find(pmItr_3->second->getPlayerID());
						if(peoItr != peopleMap->end() && peoItr->second.valid())
						{
							CRCore::ref_ptr<strToupiaoInfo> strinfo = new strToupiaoInfo;
							strinfo->nPlayerID = pmItr_3->second->getPlayerID();
							strinfo->playerName = pmItr_3->second->getName();
							strinfo->nJuntuanID = peoItr->second->getConsortiaId();
							strinfo->juntuanName = peoItr->second->getConsortiaName();
							strinfo->m_level = peoItr->second->getLv();
							candidateVecT->push_back(strinfo);
							count_3++;
						}
					}
					else
					{
						break;
					}
				}
			}

			//	crData * groupData = cmItr->second->getDataClass();
			//	if (groupData)
			//	{
			//		groupData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
			//		ConsortiaMemberMap *consortiaMemberMap  = (ConsortiaMemberMap *)param;
			//		ConsortiaMemberMap::iterator cmmItr;
			//		groupData->getParam(WCHDATA_JXJConsortiaLeaderVec,param);
			//		GroupLeaderVec *groupLeaderVec = (GroupLeaderVec *)param;
			//		GroupLeaderVec::iterator glvItr = groupLeaderVec->begin();
			//		for (; candidateVecT->size() < maxum && glvItr != groupLeaderVec->end(); ++ glvItr)
			//		{
			//			cmmItr = consortiaMemberMap->find(*glvItr);
			//			if (cmmItr != consortiaMemberMap->end())
			//			{
			//				CRCore::ref_ptr<strToupiaoInfo> strinfo = new strToupiaoInfo;
			//				strinfo->nPlayerID = *glvItr;
			//				strinfo->playerName = cmmItr->second->getName();
			//				strinfo->nJuntuanID = cmItr->second->getID();
			//				cmItr->second->getName(strinfo->juntuanName);
			//				candidateVecT->push_back(strinfo);
			//			}
			//		}
			//	}
			//}
			//}
			//if(!candidateVecT->empty())
			//{							
			//	for( CandidateVec::iterator wbItr = candidateVecT->begin();
			//		wbItr != candidateVecT->end(); 
			//		++ wbItr )
			//	{
			//		rankVal = 0;
			//		for( LevelRankingMap::iterator lrmItr = levelRankingMap->begin();
			//			 lrmItr != levelRankingMap->end(); 
			//			 ++ rankVal,++ lrmItr)
			//		{
			//			if (lrmItr->second.valid())
			//			{
			//				if (lrmItr->second->getPlayerID() == (*wbItr)->nPlayerID)
			//				{
			//					break;
			//				}
			//			}
			//		}
			//		(*wbItr)->m_rankVal = rankVal + 1;
			//	}
			//	std::sort(candidateVecT->begin(),candidateVecT->end(),strToupiaoInfoCmp());
			//	bool modify = true;
			//	shiliData->inputParam(WCHDATA_JXJShiliModify,&modify);
			//}
			shiliData->inputParam(WCHDATA_JXJShiliModify,&modify);
			shiliData->excHandle(MAKEINT64(WCH_LockData,0));
		}
	}
	gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJCheckInManorMethod
//
/////////////////////////////////////////
crJXJCheckInManorMethod::crJXJCheckInManorMethod(){}
crJXJCheckInManorMethod::crJXJCheckInManorMethod(const crJXJCheckInManorMethod& handle):
	crMethod(handle)
{
}
void crJXJCheckInManorMethod::inputParam(int i, void *param)
{
}

void crJXJCheckInManorMethod::addParam(int i, const std::string& str)
{
}

void crJXJCheckInManorMethod::operator()(crHandle &handle)
{
	bool cancelTask = !crRunGameHandle::getInstance()->isInManor();
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJBattleRecruitCheckMethod
//
/////////////////////////////////////////
crJXJBattleRecruitCheckMethod::crJXJBattleRecruitCheckMethod():
	m_this(NULL),
	m_result(NULL)
{
}

crJXJBattleRecruitCheckMethod::crJXJBattleRecruitCheckMethod(const crJXJBattleRecruitCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_result(NULL)
{
}

void crJXJBattleRecruitCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_recruitTroopsMap = (TroopsMap*)(LOINT64(param64));
			m_result = (BattleRecruitCheckResult *)(HIINT64(param64));
		}
		else
		{
			m_recruitTroopsMap = NULL;
			m_result = NULL;
		}
		break;
	}
}

void crJXJBattleRecruitCheckMethod::addParam(int i, const std::string& str)
{
}

void crJXJBattleRecruitCheckMethod::operator()(crHandle &handle)
{
	if(m_result && m_recruitTroopsMap)
	{
		m_result->m_code = -1;//不能补兵
		void *param;
		crData *data = m_this->getDataClass();
		CRCore::ScopedLock<crData> lock(*data);
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char vipLevel = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFood,param);
		int myfood = *(int *)param;

		if(m_recruitTroopsMap->empty())
		{
			if(vipLevel == 0)
			{
				int addArmyNeedExtraFood = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleAddArmyExtraFoodNeed, vipLevel).c_str()));
				if(myfood>=addArmyNeedExtraFood)
				{
					m_result->m_code = 0;//兵源充足VIP0补兵需要额外粮草
					m_result->m_foodneed = addArmyNeedExtraFood;
					//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedFood,&addArmyNeedExtraFood);
				}
				else
					m_result->m_code = -2;//粮草不足
			}
			else
			{
				m_result->m_code = 1;//兵源充足
			}
		}
		else
		{
			data->getParam(WCHDATA_JXJCoppercash,param);
			int mycopper = *(int *)param;
			data->getParam(WCHDATA_JXJWood,param);
			int mywood = *(int *)param;
			data->getParam(WCHDATA_JXJIron,param);
			int myiron = *(int *)param;
			data->getParam(WCHDATA_JXJHorse,param);
			int myhorse = *(int *)param;
			data->getParam(WCHDATA_JXJGoldingot,param);
			int myGold = *(int *)param;
			data->getParam(WCHDATA_JXJGiftGold,param);
			myGold+=(*(int *)param);
			data->getParam(WCHDATA_JXJTroopsMap,param);
			TroopsMap *troops = (TroopsMap *)param;

			if(vipLevel > 1)
			{
				int copperneed=0,
					woodneed = 0,
					ironneed = 0,
					horseneed = 0,
					foodneed = 0,
					timeneed = 0;
				int	equipneed = 0,
					equipid = 0;
				int percopperneed = 0;
				int perwoodneed = 0;
				int perironneed = 0;
				int perhorseneed = 0;
				int perfoodneed = 0;
				int pertimeneed = 0;

				ref_ptr<crTableIO>troopTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
				ref_ptr<crTableIO>equipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
				short overTimes = (short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOverloadTime, vipLevel).c_str()));
				int credittime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRecruitCreditTime, vipLevel).c_str()));

				crTableIO::StrVec record,record2;
				TroopsMap::iterator itr = m_recruitTroopsMap->begin();
				int leaderneedindex = troopTab->getTitleIndex("领导力");

				int equipcopperindex = equipTab->getTitleIndex("铜钱");
				int equipfoodindex = equipTab->getTitleIndex("粮食");
				int equiphorseindex = equipTab->getTitleIndex("马匹");
				int equipironindex = equipTab->getTitleIndex("铁矿");
				int equipwoodindex = equipTab->getTitleIndex("木材");
				while (itr!=m_recruitTroopsMap->end())
				{
					RecruitCheckResult recruitCheck;
					m_this->doEvent(WCH_JXJRecruitCheck,MAKEINT64(itr->first,&recruitCheck));
					if(recruitCheck.m_code!=1)
					{
						m_result->m_code = -12;//不能招募
						break;
					}
					copperneed += ceil((float)(itr->second)*recruitCheck.m_needresourcevec[T_Copper - 1]);
					foodneed += ceil((float)(itr->second)*recruitCheck.m_needresourcevec[T_Food - 1]);
					woodneed += ceil((float)(itr->second)*recruitCheck.m_needresourcevec[T_Wood - 1]);
					ironneed += ceil((float)(itr->second)*recruitCheck.m_needresourcevec[T_Iron - 1]);
					horseneed += ceil((float)(itr->second)*recruitCheck.m_needresourcevec[T_Horse - 1]);
					timeneed += ceil((float)(itr->second)*recruitCheck.m_timeNeed);
					//timeneed += itr->second*pertimeneed;
					//totalLeaderCount += itr->second*perleaderneed;

					if(equipTab->queryOneRecord(0,crArgumentParser::appItoa(recruitCheck.m_equipid),record2)>=0)
					{
						if(equipcopperindex>0)
							percopperneed = atoi(record2[equipcopperindex].c_str());
						if(equipfoodindex>0)
							perfoodneed = atoi(record2[equipfoodindex].c_str());
						if(equiphorseindex>0)
							perhorseneed = atoi(record2[equiphorseindex].c_str());
						if(equipironindex>0)
							perironneed = atoi(record2[equipironindex].c_str());
						if(equipwoodindex)
							perwoodneed = atoi(record2[equipwoodindex].c_str());
					}
					copperneed += percopperneed * recruitCheck.m_equipCount *itr->second;
					woodneed += perwoodneed * recruitCheck.m_equipCount *itr->second;
					ironneed += perironneed * recruitCheck.m_equipCount * itr->second;
					horseneed += perhorseneed * recruitCheck.m_equipCount * itr->second;
					foodneed += perfoodneed * recruitCheck.m_equipCount *itr->second;

					itr++;
				}
				if(m_result->m_code!=-12)
				{//不能招募
					data->getParam(WCHDATA_JXJRecruitTimes,param);
					crVector4i recruitTimes = *(crVector4i *)param;

					int i = 0;
					int timeRemain = 0;
					for(; i<4; i++)
					{
						if(recruitTimes[i]>=0 && recruitTimes[i] < overTimes)
							timeRemain += overTimes - recruitTimes[i] + credittime;
					}
					if(copperneed > mycopper)
					{//铜钱不足
						m_result->m_code = -6;//铜钱不足
					}
					else if(woodneed > mywood || ironneed > myiron || horseneed > myhorse || foodneed > myfood || timeneed > timeRemain)
					{
						if(vipLevel>=3)
						{
							int goldneed = 0;
							//够买时间
							if(timeneed>timeRemain)
							{//
								ref_ptr<crTableIO>hintTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHintTab);
								crTableIO::StrVec record;
								hintTable->queryOneRecord(0,crArgumentParser::appItoa(WCHDATA_JXJRecruitCDHint),record);
								goldneed += ceil((float)(timeneed - timeRemain) * atof(record[2].c_str()));
							}
							//够买资源
							int needbuycount = woodneed > mywood?woodneed - mywood:0;
							needbuycount += ironneed > myiron?ironneed - myiron:0;
							needbuycount += horseneed > myhorse?horseneed - myhorse:0;
							needbuycount += foodneed > myfood?foodneed - myfood:0;
							if(needbuycount>0)
							{
								int limitbuy = 0;
								m_this->doEvent(WCH_JXJCheckMarketLimitBuy,MAKEINT64(&limitbuy,NULL));
								if(needbuycount>limitbuy)
								{
									m_result->m_code = -7;//今日可购资源量不足，不能购买！
								}
								else
								{//购买资源，需要做元宝修正
									do 
									{
										ref_ptr<crTableIO>goodsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGoodsTab);
										int goldid = goodsTab->getTitleIndex("系统售价");
										int iprice;
										float price;
										int buycount = foodneed - myfood;
										if(buycount>0)
										{
											crTableIO::StrVec record;
											if(goodsTab->queryOneRecord(1,crArgumentParser::appItoa(WCHDATA_JXJFood),record)>=0)
											{
												iprice = atoi(record[goldid].c_str());
												price = 1.0f/(float)iprice;
												goldneed += ceil(price * buycount);
											}
											else
											{
												m_result->m_code = -8;//资源够买失败！
												break;
											}
										}
										buycount = woodneed - mywood;
										if(buycount>0)
										{
											crTableIO::StrVec record;
											if(goodsTab->queryOneRecord(1,crArgumentParser::appItoa(WCHDATA_JXJWood),record)>=0)
											{
												iprice = atoi(record[goldid].c_str());
												price = 1.0f/(float)iprice;
												goldneed += ceil(price * buycount);
											}
											else
											{
												m_result->m_code = -8;//资源够买失败！
												break;
											}
										}
										buycount = ironneed - myiron;
										if(buycount>0)
										{
											crTableIO::StrVec record;
											if(goodsTab->queryOneRecord(1,crArgumentParser::appItoa(WCHDATA_JXJIron),record)>=0)
											{
												iprice = atoi(record[goldid].c_str());
												price = 1.0f/(float)iprice;
												goldneed += ceil(price * buycount);
											}
											else
											{
												m_result->m_code = -8;//资源够买失败！
												break;
											}
										}
										buycount = horseneed - myhorse;
										if(buycount>0)
										{
											crTableIO::StrVec record;
											if(goodsTab->queryOneRecord(1,crArgumentParser::appItoa(WCHDATA_JXJHorse),record)>=0)
											{
												iprice = atoi(record[goldid].c_str());
												price = 1.0f/(float)iprice;
												goldneed += ceil(price * buycount);
											}
											else
											{
												m_result->m_code = -8;//资源够买失败！
												break;
											}
										}
									} while (0);
									if(m_result->m_code!=-8)
									{
										if(goldneed<=myGold)
										{
											m_result->m_code = 3;//元宝补兵
											m_result->m_goldneed = goldneed;
											m_result->m_shijibuycount = needbuycount;
										
											m_result->m_copperneed = copperneed;
											m_result->m_foodneed = foodneed > myfood?myfood:foodneed;
											m_result->m_woodneed = woodneed > mywood?mywood:woodneed;
											m_result->m_ironneed = ironneed > myiron?myiron:ironneed;
											m_result->m_horseneed = horseneed > myhorse?myhorse:horseneed;
											m_result->m_timeneed = timeneed>timeRemain?timeRemain:timeneed;

											//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedGold,&goldneed);
										}
										else
											m_result->m_code = -3;//元宝不足
									}
								}
							}
						}
						else
							m_result->m_code = -4;//资源不足
					}
					else
					{
						m_result->m_code = 2;//兵力不足，资源充足，直接扣除资源补兵；
						m_result->m_copperneed = copperneed;
						m_result->m_foodneed = foodneed;
						m_result->m_woodneed = woodneed;
						m_result->m_ironneed = ironneed;
						m_result->m_horseneed = horseneed;
						//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedCopper,&copperneed);
						//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedFood,&foodneed);
						//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedWood,&woodneed);
						//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedIron,&ironneed);
						//canvasData->inputParam(WCHDATA_JXJBattleAddArmyNeedHorse,&horseneed);
					}
				}
			}
		}
	}
}
/************************************************************************/
/*    crJXJHuodongUpdateMethod                                                                  */
/************************************************************************/
crJXJHuodongUpdateMethod::crJXJHuodongUpdateMethod():
	m_dt(NULL)
{

}

crJXJHuodongUpdateMethod::crJXJHuodongUpdateMethod( const crJXJHuodongUpdateMethod & handle ):
	m_dt(NULL)
{

}


void crJXJHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i)
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			int lparam = LOINT64(param64);
			m_dt = (float*)lparam;
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJHuodongUpdateMethod::operator()( crHandle &handle )
{
	ref_ptr<crData> data = m_this->getDataClass();
	void *param;
	ref_ptr<crRole> mainrole = m_this->getMainRole();
	if(mainrole.valid() && mainrole->getDataClass())
	{
		crData *roleData = mainrole->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		roleData->excHandle(MAKEINT64(WCH_LockData,1));
		roleData->getParam(WCHDATA_JXJNewHuodongMap,param);
		NewHuodongMap *huodongMap = (NewHuodongMap *)param;

		for( NewHuodongMap::iterator hmItr = huodongMap->begin();
			 hmItr != huodongMap->end(); 
			 ++hmItr )
		{
			hmItr->second->activationCheck(m_this->getPlayerID());
			if(hmItr->second->getActivation()==1/* && !hmItr->second->isCanAdvance()*/)
			{
				hmItr->second->doEvent(WCH_UPDATE,MAKEINT64(m_this,NULL));
			}
		}
		roleData->excHandle(MAKEINT64(WCH_LockData,0));
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	data->getParam(WCHDATA_JXJLastZeroRefreshTime,param);
	_crInt64 LastZeroRefreshTime = *(_crInt64 *)param;
	crVector3i lasttm,curtm;
	char tmp[20];
	strftime( tmp, sizeof(tmp), "%Y|%m|%d\0", localtime(&LastZeroRefreshTime) );
	crArgumentParser::appTimetoVec(tmp,lasttm,'|');
	time_t t = time( 0 );
	strftime( tmp, sizeof(tmp), "%Y|%m|%d\0", localtime(&t) );
	crArgumentParser::appTimetoVec(tmp,curtm,'|');
	if (curtm > lasttm)
	{
		int count = 0;
		data->inputParam(WCHDATA_JXJChongZhiCountT,&count);
		data->inputParam(WCHDATA_JXJLastZeroRefreshTime,&t);
	}
}
/////////////////////////////////////////
//
//crJXJCheckPlayerGameNameMethod
//
/////////////////////////////////////////
crJXJCheckPlayerGameNameMethod::crJXJCheckPlayerGameNameMethod(){}
crJXJCheckPlayerGameNameMethod::crJXJCheckPlayerGameNameMethod(const crJXJCheckPlayerGameNameMethod& handle):
	crMethod(handle),
	m_nameWidget(handle.m_nameWidget)
{
}
void crJXJCheckPlayerGameNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJCheckPlayerGameNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameWidget = str;
		break;
	}
}

void crJXJCheckPlayerGameNameMethod::operator()(crHandle &handle)
{
	crCanvasNode *canvas = m_this->getParentCanvas();
	crEditWidgetNode *nameWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_nameWidget));
	if(nameWidget)
	{
		std::string name = crArgumentParser::trim(const_cast<char *>(nameWidget->getUTF8String().c_str()));
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(!name.empty() && netConductor)
		{
			crJXJCheckPlayerGameNamePacket packet;
			crJXJCheckPlayerGameNamePacket::buildRequestPacket(packet,name);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}

/////////////////////////////////////////
//
//crJXJRecvNewHuodongActiveMethod
//
/////////////////////////////////////////
crJXJRecvNewHuodongActiveMethod::crJXJRecvNewHuodongActiveMethod():
	m_this(NULL),
	m_stream(NULL),
	m_netType(CRNetApp::Client)
{

}
crJXJRecvNewHuodongActiveMethod::crJXJRecvNewHuodongActiveMethod( const crJXJRecvNewHuodongActiveMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_stream(NULL),
	m_netType(CRNetApp::Client)
{
}
void crJXJRecvNewHuodongActiveMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_netType = Client;
			m_stream = NULL;
		}
		break;
	}

}

void crJXJRecvNewHuodongActiveMethod::addParam( int i, const std::string& str )
{
}

void crJXJRecvNewHuodongActiveMethod::operator()( crHandle &handle )
{
	if (m_netType == GameClient_Game)
	{
		ref_ptr<crPlayerGameData> playerdata = crMyPlayerData::getInstance()->getPlayerGameData();
		if(playerdata.valid())
		{
			ref_ptr<crRole> mainrole = playerdata->getMainRole();
			if(mainrole.valid() && mainrole->getDataClass())
			{
				unsigned short id = m_stream->_readUShort();
				unsigned char activation = m_stream->_readUChar();
				unsigned char circles = m_stream->_readUChar();
				int step = m_stream->_readInt();
				void *param;
				crData *roledata = mainrole->getDataClass();
				roledata->excHandle(MAKEINT64(WCH_LockData,1));
				roledata->getParam(WCHDATA_JXJNewHuodongMap,param);
				NewHuodongMap *huodongmap = (NewHuodongMap *)param;
				NewHuodongMap::iterator itr = huodongmap->find(id);
				if(itr != huodongmap->end())
				{
					itr->second->setCircles(circles);
					itr->second->setActivation(activation,0);
					itr->second->setStep(step,0);
				}
				roledata->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvNewHuodongStepMethod
//
/////////////////////////////////////////
crJXJRecvNewHuodongStepMethod::crJXJRecvNewHuodongStepMethod():
	m_this(NULL),
	m_stream(NULL),
	m_netType(CRNetApp::Client)
{

}
crJXJRecvNewHuodongStepMethod::crJXJRecvNewHuodongStepMethod( const crJXJRecvNewHuodongStepMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_stream(NULL),
	m_netType(CRNetApp::Client)
{
}
void crJXJRecvNewHuodongStepMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_netType = Client;
			m_stream = NULL;
		}
		break;
	}

}

void crJXJRecvNewHuodongStepMethod::addParam( int i, const std::string& str )
{
}

void crJXJRecvNewHuodongStepMethod::operator()( crHandle &handle )
{
	if (m_netType == GameClient_Game)
	{
		ref_ptr<crPlayerGameData> playerdata = crMyPlayerData::getInstance()->getPlayerGameData();
		if(playerdata.valid())
		{
			ref_ptr<crRole> mainrole = playerdata->getMainRole();
			if(mainrole.valid() && mainrole->getDataClass())
			{
				unsigned short id = m_stream->_readUShort();
				int step = m_stream->_readInt();
				void *param;
				crData *roledata = mainrole->getDataClass();
				roledata->excHandle(MAKEINT64(WCH_LockData,1));
				roledata->getParam(WCHDATA_JXJNewHuodongMap,param);
				NewHuodongMap *huodongmap = (NewHuodongMap *)param;
				NewHuodongMap::iterator itr = huodongmap->find(id);
				if(itr != huodongmap->end())
				{
					itr->second->setStep(step,0);
				}
				roledata->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerFriendListInitMethod
//
/////////////////////////////////////////
crJXJPlayerFriendListInitMethod::crJXJPlayerFriendListInitMethod(){}
crJXJPlayerFriendListInitMethod::crJXJPlayerFriendListInitMethod(const crJXJPlayerFriendListInitMethod& handle) :
	crMethod(handle)
{
}
void crJXJPlayerFriendListInitMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if (param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}

void crJXJPlayerFriendListInitMethod::addParam(int i, const std::string& str)
{
}

void crJXJPlayerFriendListInitMethod::operator()(crHandle &handle)
{
	void * param;
	crData * playerData = m_this->getDataClass();
	int playerid = m_this->getPlayerID();
	if (playerData)
	{
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
		crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
		playerData->excHandle(MAKEINT64(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJFriendList, param);
		FriendVec *friendVec = (FriendVec *)param;
		if(!friendVec->empty())
		{
			playerData->getParam(WCHDATA_JXJShiliID, param);
			unsigned char shiliid = *(unsigned char *)param;
			gsBrainData->excHandle(MAKEINT64(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
			crJXJShili *shili = (crJXJShili *)param;
			if (shili && shili->getDataClass())
			{
				ref_ptr<crGameServerPlayerData> frienddata;
				crJXJShiliData * shiliData = dynamic_cast<crJXJShiliData * > (shili->getDataClass());
				CRCore::ScopedLock<crData> lock(*shiliData);
				shiliData->getParam(WCHDATA_JXJPeopleMap,param);
				PeopleMap *peopleMap = (PeopleMap *)param;
				PeopleMap::iterator pitr;
				for( FriendVec::iterator itr = friendVec->begin();
					 itr != friendVec->end();
					 )
				{
					if ((*itr)!=NULL)
					{
						pitr = peopleMap->find((*itr)->getPlayerID());
						if(pitr != peopleMap->end())
						{
							(*itr)->setName(pitr->second->getName());
							(*itr)->setLevel(pitr->second->getLv());
							frienddata = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
							if(frienddata.valid())
							{
								(*itr)->setOnline(true);
							}
							else
							{
								(*itr)->setOnline(false);
							}
						}
						else
						{
							itr = friendVec->erase(itr);
							continue;
						}
					}
					++itr;
				}
			}
			gsBrainData->excHandle(MAKEINT64(WCH_LockData,0));
		}
		playerData->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJTaskCheckFormationMethod
//
/////////////////////////////////////////
crJXJTaskCheckFormationMethod::crJXJTaskCheckFormationMethod()
{
}
crJXJTaskCheckFormationMethod::crJXJTaskCheckFormationMethod(const crJXJTaskCheckFormationMethod& handle):
	crMethod(handle)
{
	m_formation[0] = handle.m_formation[0];
	m_formation[1] = handle.m_formation[1];
	m_formation[2] = handle.m_formation[2];
}
void crJXJTaskCheckFormationMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crGameTask*)param;
		break;
	}
}
void crJXJTaskCheckFormationMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
	case 1:
	case 2:
		crArgumentParser::appAtoVec(str,m_formation[i]);
		break;
	}
}
void crJXJTaskCheckFormationMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		crData *data = playerData->getDataClass();
		if(!data)return;
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		int fsize = formationInfoVec->size();
		bool check = true;
		for( int i = 0; i<3; i++)
		{
			if(m_formation[i][0]!=0)
			{
				if(i>=fsize)
				{
					check = false;
					break;
				}
				else
				{
					if(m_formation[i][0]!=(*formationInfoVec)[i]->getAbstractID())
					{
						check = false;
						break;
					}
					if(m_formation[i][1]!=0 && (*formationInfoVec)[i]->getEquips()[0]<=0)
					{
						check = false;
						break;
					}
					if(m_formation[i][2]!=0 && (*formationInfoVec)[i]->getEquips()[1]<=0)
					{
						check = false;
						break;
					}
				}
			}
		}
		if(check)
		{
			playerData->doEvent(WCH_JXJAdvanceTask,MAKEINT64(m_this->getTaskID(),0));
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSetWindowsTitleMethod
//
/////////////////////////////////////////
crJXJSetWindowsTitleMethod::crJXJSetWindowsTitleMethod()
{
}
crJXJSetWindowsTitleMethod::crJXJSetWindowsTitleMethod(const crJXJSetWindowsTitleMethod& handle):
	crMethod(handle)
{
}
void crJXJSetWindowsTitleMethod::inputParam(int i, void *param)
{
}
void crJXJSetWindowsTitleMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetWindowsTitleMethod::operator()(crHandle &handle)
{
	HWND hWnd = crStartHandler::getInstance()->getWindowHandle();
	const std::string& gamename = crMyPlayerData::getInstance()->getSelectedGame()->getCName();
	const std::string& servername = crMyPlayerData::getInstance()->getServerName();
	//std::string title = gamename+"-"+servername+"("+crArgumentParser::appItoa(crMyPlayerData::getInstance()->getWebServerID())+"区) 老板键(Ctrl+~)";
	std::string title = gamename + "-" + servername;// +"(" + crArgumentParser::appItoa(crMyPlayerData::getInstance()->getWebServerID()) + "区)";
	std::wstring wtitle = CRIOManager::convertUTF8toUTF16(title);
	::SetWindowTextW(hWnd, wtitle.c_str());
}
/////////////////////////////////////////
//
//crJXJHuodongExtUpdateMethod
//
/////////////////////////////////////////
crJXJHuodongExtUpdateMethod::crJXJHuodongExtUpdateMethod():
	m_this(NULL),
	m_step(0)
{
}
crJXJHuodongExtUpdateMethod::crJXJHuodongExtUpdateMethod(const crJXJHuodongExtUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_step(0)
{
}
void crJXJHuodongExtUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crRole*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
		}
		break;
	}
}
void crJXJHuodongExtUpdateMethod::addParam(int i, const std::string& str)
{
}
void crJXJHuodongExtUpdateMethod::operator()(crHandle &handle)
{
	crData *maindata = m_this->getDataClass();
	void *param;
	maindata->excHandle(MAKEINT64(WCH_LockData,1));
	/////////////活动update
	maindata->getParam(WCHDATA_JXJNewHuodongMap,param);
	NewHuodongMap *huodongMap = (NewHuodongMap *)param;

	for( NewHuodongMap::iterator hmItr = huodongMap->begin();
		hmItr != huodongMap->end(); 
		++hmItr )
	{
		hmItr->second->activationCheck(m_this->getPlayerID());
		if(hmItr->second->getActivation()==1)
		{
			hmItr->second->doEvent(WCH_JXJHuodongExtUpdate,MAKEINT64(m_step,m_this->getPlayerID()));
		}
	}
	maindata->excHandle(MAKEINT64(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRechargeHuodongUpdateMethod
//
/////////////////////////////////////////
crJXJRechargeHuodongUpdateMethod::crJXJRechargeHuodongUpdateMethod():
	m_this(NULL),
	m_addstep(0),
	m_playerid(0)
{
}

crJXJRechargeHuodongUpdateMethod::crJXJRechargeHuodongUpdateMethod( const crJXJRechargeHuodongUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_addstep(0),
	m_playerid(0)
{

}

void crJXJRechargeHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_addstep = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJRechargeHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJRechargeHuodongUpdateMethod::operator()( crHandle &handle )
{
	if(m_addstep > 0)
	{
		m_this->setStep(m_addstep+m_this->getStep(),m_playerid);
		ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
		if (huodongTab.valid())
		{
			int _index = huodongTab->getTitleIndex("标题");
			crTableIO::StrVec huoRecord;
			std::string text("小周卡");
			if (_index > 0)
			{
				if (huodongTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getID()),huoRecord) >= 0)
				{
					if(huoRecord[_index] == text && m_this->isCanAdvance() && !m_this->getComplete())
					{
						crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 	
						crNetDataManager *netDataManager = gameServer->getNetDataManager();
						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(m_playerid));
						if (playerData.valid() && playerData->getPlayerGameData())
						{
							crPlayerGameData *myPlayer = playerData->getPlayerGameData();
							if (myPlayer && myPlayer->getDataClass())
							{

								ref_ptr<crData> data = myPlayer->getDataClass();
								unsigned char status = 0;
								int dayidx = 0;
								time_t nowtime = time(0);
								int curday = (int)((nowtime + 28800)/c_24hours);
								time_t zhoukaendtime = (curday + 7)*c_24hours - 28800;
								int zhoukaid = (int)(m_this->getID());
								data->excHandle(MAKEINT64(WCH_LockData,1));
								data->inputParam(WCHDATA_JXJZhouKaEndTime,&zhoukaendtime);
								data->inputParam(WCHDATA_JXJGainedZhouKaID,&zhoukaid);
								data->inputParam(WCHDATA_JXJZhouKaGetStatus,&status);
								data->inputParam(WCHDATA_JXJZhouKaGetDayIdx,&dayidx);
								data->excHandle(MAKEINT64(WCH_LockData,0));
								m_this->setActivation(2,m_playerid);
								myPlayer->doEvent(WCH_JXJRecvUpdateZhouKaStatus,MAKEINT64(NULL,GameServer));
							}
						}
					}
				}
			}
			///充值类活动立即存储
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
			if(playerData.valid())
			{
				crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
				callback->savePlayerData(playerData.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSingleRechargeHuodongUpdateMethod
//
/////////////////////////////////////////
crJXJSingleRechargeHuodongUpdateMethod::crJXJSingleRechargeHuodongUpdateMethod():
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{
}

crJXJSingleRechargeHuodongUpdateMethod::crJXJSingleRechargeHuodongUpdateMethod( const crJXJSingleRechargeHuodongUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{

}

void crJXJSingleRechargeHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJSingleRechargeHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJSingleRechargeHuodongUpdateMethod::operator()( crHandle &handle )
{
	if(m_step > 0 && m_step >= m_this->getStepCount())
	{
		m_this->setStep(m_this->getStepCount()+m_this->getStep(),m_playerid);

		///充值类活动立即存储
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
		if(playerData.valid())
		{
			crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
			callback->savePlayerData(playerData.get());
		}
	}
}
/////////////////////////////////////////
//
//crJXJSingleRechargeBetweenHuodongUpdateMethod
//
/////////////////////////////////////////
crJXJSingleRechargeBetweenHuodongUpdateMethod::crJXJSingleRechargeBetweenHuodongUpdateMethod():
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{
}

crJXJSingleRechargeBetweenHuodongUpdateMethod::crJXJSingleRechargeBetweenHuodongUpdateMethod( const crJXJSingleRechargeBetweenHuodongUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{

}

void crJXJSingleRechargeBetweenHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJSingleRechargeBetweenHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJSingleRechargeBetweenHuodongUpdateMethod::operator()( crHandle &handle )
{
	ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
	if (huodongTab.valid())
	{
		int index = huodongTab->getTitleIndex("条件2");
		crTableIO::StrVec huoRecord;
		std::vector <int> Vec;
		if (index > 0)
		{
			if (huodongTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getID()),huoRecord) >= 0)
			{
				crArgumentParser::appAtoVec(huoRecord[index],Vec);
				if (Vec.size() >=2)
				{
					if (m_step >= Vec[0] && m_step <= Vec[1])
					{
						m_this->setStep(m_this->getStep()+1,m_playerid);

						///充值类活动立即存储
						crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
						if(playerData.valid())
						{
							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
							callback->savePlayerData(playerData.get());
						}
					}
				}
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJConsumptionHuodongUpdateMethod
//
/////////////////////////////////////////
crJXJConsumptionHuodongUpdateMethod::crJXJConsumptionHuodongUpdateMethod():
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{
}

crJXJConsumptionHuodongUpdateMethod::crJXJConsumptionHuodongUpdateMethod( const crJXJConsumptionHuodongUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{

}

void crJXJConsumptionHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJConsumptionHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJConsumptionHuodongUpdateMethod::operator()( crHandle &handle )
{
	if(m_step < 0)
		m_this->setStep(m_this->getStep()-m_step,m_playerid);
}

/////////////////////////////////////////
//
//crJXJZhengZhanTianXiaHuodongUpdateMethod
//
/////////////////////////////////////////
crJXJZhengZhanTianXiaHuodongUpdateMethod::crJXJZhengZhanTianXiaHuodongUpdateMethod():
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{
}

crJXJZhengZhanTianXiaHuodongUpdateMethod::crJXJZhengZhanTianXiaHuodongUpdateMethod( const crJXJZhengZhanTianXiaHuodongUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{

}

void crJXJZhengZhanTianXiaHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJZhengZhanTianXiaHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJZhengZhanTianXiaHuodongUpdateMethod::operator()( crHandle &handle )
{
	ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(!fubentab.valid()) return;
	int chaptureIdx = fubentab->getTitleIndex("chapterid");
	int chapterid = 0;
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
	if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
	{
		crPlayerGameData *playerGameData = playerData->getPlayerGameData();
		crData *data = playerGameData->getDataClass();
		if (data)
		{
			crTableIO::StrVec record;
			void *param = NULL;
			data->excHandle(MAKEINT64(WCH_LockData,1));
			data->getParam(WCHDATA_JXJFubenProgressMap,param);
			FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
			FubenProgressMap::iterator itr_fuben = fubenProgress->begin();
			int count = 0;
			for (;itr_fuben != fubenProgress->end(); ++itr_fuben)
			{
				if (itr_fuben->second.valid())
				{
					if(itr_fuben->second->getStarCount() == 3)
					{
						if (fubentab->queryOneRecord(0,crArgumentParser::appItoa(itr_fuben->first),record)>=0)
						{
							chapterid = atoi(record[chaptureIdx].c_str());
							if (chapterid >= 1000 && chapterid < 2000)
							{
								++count;
							}
						}
					}
				}
			}
			m_this->setStep(count,m_playerid);
			data->excHandle(MAKEINT64(WCH_LockData,0));
			/////活动立即存储
			//crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
			//callback->savePlayerData(playerData.get());
		}
	}
}

/////////////////////////////////////////
//
//crJXJMingJiangZhiLuHuoDongMethod
//
/////////////////////////////////////////
crJXJMingJiangZhiLuHuoDongMethod::crJXJMingJiangZhiLuHuoDongMethod():
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{
}

crJXJMingJiangZhiLuHuoDongMethod::crJXJMingJiangZhiLuHuoDongMethod( const crJXJMingJiangZhiLuHuoDongMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{

}

void crJXJMingJiangZhiLuHuoDongMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJMingJiangZhiLuHuoDongMethod::addParam( int i, const std::string& str )
{
}

void crJXJMingJiangZhiLuHuoDongMethod::operator()( crHandle &handle )
{
	m_this->setStep(m_this->getStep()+1,m_playerid);
	/////活动立即存储
	//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	//ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
	//if(playerData.valid())
	//{
	//	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
	//	callback->savePlayerData(playerData.get());
	//}
}

/////////////////////////////////////////
//
//crJXJXueZhanShaChangUpdateMethod
//
/////////////////////////////////////////
crJXJXueZhanShaChangUpdateMethod::crJXJXueZhanShaChangUpdateMethod():
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{
}

crJXJXueZhanShaChangUpdateMethod::crJXJXueZhanShaChangUpdateMethod( const crJXJXueZhanShaChangUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_step(0),
	m_playerid(0)
{

}

void crJXJXueZhanShaChangUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_step = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJXueZhanShaChangUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJXueZhanShaChangUpdateMethod::operator()( crHandle &handle )
{
	if (m_step > 0)
	{
		m_this->setStep(m_step,m_playerid);
		/////活动立即存储
		//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		//ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
		//if(playerData.valid())
		//{
		//	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
		//	callback->savePlayerData(playerData.get());
		//}
	}
}

/////////////////////////////////////////
//
//crJXJLianXuChongZhiHuodongUpdateMethod
//
/////////////////////////////////////////
crJXJLianXuChongZhiHuodongUpdateMethod::crJXJLianXuChongZhiHuodongUpdateMethod():
	m_this(NULL),
	m_addstep(0),
	m_playerid(0)
{
}

crJXJLianXuChongZhiHuodongUpdateMethod::crJXJLianXuChongZhiHuodongUpdateMethod( const crJXJLianXuChongZhiHuodongUpdateMethod & handle ):
	crMethod(handle),
	m_this(NULL),
	m_addstep(0),
	m_playerid(0)
{

}

void crJXJLianXuChongZhiHuodongUpdateMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJNewHuodong *)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_addstep = LOINT64(param64);
			m_playerid = HIINT64(param64);
		}
		break;
	}
}

void crJXJLianXuChongZhiHuodongUpdateMethod::addParam( int i, const std::string& str )
{
}

void crJXJLianXuChongZhiHuodongUpdateMethod::operator()( crHandle &handle )
{
	do 
	{
		ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
		if (false == huodongTab.valid())
		{
			break;
		}
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_playerid));
		if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass())
		{
			crPlayerGameData *playerGameData = playerData->getPlayerGameData();
			crData *data = playerGameData->getDataClass();
			if (data)
			{
				void *param;
				data->getParam(WCHDATA_JXJChongZhiCountT,param);
				int count = *(int *)param;
				int condition2 = huodongTab->getTitleIndex("条件2");
				int idIdx = huodongTab->getTitleIndex("id");
				crTableIO::StrVec record;
				if (huodongTab->queryOneRecord(idIdx,crArgumentParser::appItoa(m_this->getID()),record) >= 0)
				{
					int threshold = atoi(record[condition2].c_str());
					if (count >= threshold)
					{
						data->getParam(WCHDATA_JXJLastChongZhiTime,param);
						time_t lasttime = *(_crInt64 *)param;
						time_t curtime = time(0);
						int lastday = (lasttime + 28800) / c_24hours;
						int curday = (curtime + 28800) / c_24hours;
						if (curday > lastday || abs(curtime - lasttime) <= 2)
						{
							m_this->setStep(m_this->getStep()+1,m_playerid);
							data->inputParam(WCHDATA_JXJLastChongZhiTime,&curtime);
							///充值类活动立即存储
							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
							callback->savePlayerData(playerData.get());
						}
					}
				}
			}
		}

	} while (0);
}
/////////////////////////////////////////
//
//crJXJCheckFormationMethod
//
/////////////////////////////////////////
crJXJCheckFormationMethod::crJXJCheckFormationMethod()
{
}
crJXJCheckFormationMethod::crJXJCheckFormationMethod(const crJXJCheckFormationMethod& handle):
	crMethod(handle)
{
}
void crJXJCheckFormationMethod::inputParam(int i, void *param)
{
}
void crJXJCheckFormationMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckFormationMethod::operator()(crHandle &handle)
{
	bool full = true;
	void *param;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if (playerData && playerData->getDataClass())
	{
		int totallead = 0;
		playerData->doEvent(WCH_JXJFormationGetLeaderPower,MAKEINT64(&totallead,NULL));
		crData *data = playerData->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		int formationCount = formationInfoVec->size();
		if(formationCount>0)
		{
			int perlead;
			int maxtroopsselect;
			ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			int powerid = troopsTab->getTitleIndex("领导力");
			crTableIO::StrVec record;
			for( FormationInfoVec::iterator itr = formationInfoVec->begin();
				itr != formationInfoVec->end();
				++itr )
			{
				if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getAbstractID()),record)>=0)
				{
					perlead = atoi(record[powerid].c_str());
					if (perlead <= 0)
					{
						perlead = 1;
					}
					maxtroopsselect = (totallead / 3) / perlead;
					if((*itr)->getCount()<maxtroopsselect)
					{
						full = false;
						break;
					}
				}
				else
				{
					full = false;
					break;
				}
			}
		}
		else
		{
			full = false;
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));
	}
	handle.outputParam(0,&full);
}
/////////////////////////////////////////
//
//crJXJCheckFormationBtnMethod
//
/////////////////////////////////////////
crJXJCheckFormationBtnMethod::crJXJCheckFormationBtnMethod():
	m_this(NULL)
{
}
crJXJCheckFormationBtnMethod::crJXJCheckFormationBtnMethod(const crJXJCheckFormationBtnMethod& handle):
	crMethod(handle),
	m_sw(handle.m_sw),
	m_sequence(handle.m_sequence)
{
}
void crJXJCheckFormationBtnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJCheckFormationBtnMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_sw = str;
		break;
	case 1:
		m_sequence = str;
		break;
	default:
		break;
	}
}
void crJXJCheckFormationBtnMethod::operator()(crHandle &handle)
{	
	void *param;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if (playerData && playerData->getDataClass())
	{
		ref_ptr<crMultiSwitch> formationsw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_sw));
		ref_ptr<crSequence> sequence = dynamic_cast<crSequence *>(m_this->getChildNode(m_sequence));

		bool full = true;
		int totallead = 0;
		playerData->doEvent(WCH_JXJFormationGetLeaderPower,MAKEINT64(&totallead,NULL));
		crData *data = playerData->getDataClass();
		data->excHandle(MAKEINT64(WCH_LockData,1));
		data->getParam(WCHDATA_JXJFormationInfoVec,param);
		FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
		int formationCount = formationInfoVec->size();
		if(formationCount>0)
		{
			int perlead;
			int maxtroopsselect;
			ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			int powerid = troopsTab->getTitleIndex("领导力");
			crTableIO::StrVec record;
			for( FormationInfoVec::iterator itr = formationInfoVec->begin();
				itr != formationInfoVec->end();
				++itr )
			{
				if(troopsTab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getAbstractID()),record)>=0)
				{
					perlead = atoi(record[powerid].c_str());
					if (perlead <= 0)
					{
						perlead = 1;
					}
					maxtroopsselect = (totallead / 3) / perlead;
					if((*itr)->getCount()<maxtroopsselect)
					{
						full = false;
						break;
					}
				}
				else
				{
					full = false;
					break;
				}
			}
		}
		else
		{
			full = false;
		}
		data->excHandle(MAKEINT64(WCH_LockData,0));

		if(full)
		{
			if (formationsw.valid())
				formationsw->setActiveSwitchSet(0);
		}
		else
		{
			if (formationsw.valid())
			{
				formationsw->setActiveSwitchSet(1);
			}
			if (sequence.valid())
			{
				//sequence->setVanishWhenStop(true);
				//sequence->setDuration(0.1,1);
				sequence->startEffect();
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlatformCheckMethod
//
/////////////////////////////////////////
crJXJPlatformCheckMethod::crJXJPlatformCheckMethod()
{

}

crJXJPlatformCheckMethod::crJXJPlatformCheckMethod(const crJXJPlatformCheckMethod& handle):
	m_platformstr(handle.m_platformstr)
{

}

void crJXJPlatformCheckMethod::inputParam(int i, void *param)
{
}

void crJXJPlatformCheckMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_platformstr = str;
		break;
	}
}

void crJXJPlatformCheckMethod::operator ()(crHandle &handle)
{
	bool bln = crMyPlayerData::getInstance()->getSelectedGame()->getPlatform().find(m_platformstr) != std::string::npos;
	handle.outputParam(0,&bln);
}
/////////////////////////////////////////
//
//crJXJOnlineStateMethod
//
/////////////////////////////////////////
crJXJOnlineStateMethod::crJXJOnlineStateMethod():
	m_online(true)
{
}
crJXJOnlineStateMethod::crJXJOnlineStateMethod(const crJXJOnlineStateMethod& handle):
	crMethod(handle),
	m_online(handle.m_online)
{
}
void crJXJOnlineStateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJOnlineStateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_online = (bool)(atoi(str.c_str()));
		break;
	}
}
void crJXJOnlineStateMethod::operator()(crHandle &handle)
{
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
	crNetDataManager *netDataManager = gameServer->getNetDataManager();
	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
	int serverid = callback->getServerID();

	crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
	ref_ptr<crDataBase> globalSession = db->beginSession();
	ref_ptr<crUpdateCharacterOnlineState> onlinestateupd = new crUpdateCharacterOnlineState;
	onlinestateupd->buildUpdateSql(m_this->getPlayerID(),serverid,m_this->getMainRoleID(),m_online);
	globalSession->executeUpdate(onlinestateupd.get());
	db->endSession(globalSession.get());

}

/////////////////////////////////////////
//
//crJXJClientChangeNameMethod
//
/////////////////////////////////////////
crJXJClientChangeNameMethod::crJXJClientChangeNameMethod():
	m_maxsize(12)
{
}
crJXJClientChangeNameMethod::crJXJClientChangeNameMethod( const crJXJClientChangeNameMethod& handle ):
	crMethod(handle),
	m_nameedit(handle.m_nameedit),
	m_maxsize(handle.m_maxsize)
{
}

void crJXJClientChangeNameMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}

}

void crJXJClientChangeNameMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_nameedit = str;
		break;
	case 1:
		m_maxsize = atoi(str.c_str());
		break;
	}
}

void crJXJClientChangeNameMethod::operator ()( crHandle & handle )
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && canvas.valid())
	{
		crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		ref_ptr<crEditWidgetNode> editwidget = dynamic_cast<crEditWidgetNode *>(canvas -> getWidget(m_nameedit));
		std::string newName = editwidget->getUTF8String();
		if(newName.empty())
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1099,NULL));//名字不能为空！
			return;
		}
		if(newName == crMyPlayerData::getInstance()->getCharacterName())
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1100,NULL));//同名
			return;
		}
		if (newName.length() > m_maxsize)
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1101,NULL));//名称过长
			return;
		}
		crData *data = playerGameData->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;

		_crInt64 t = time(0);
		crData *roledata = playerGameData->getMainRole()->getDataClass();
		roledata->getParam(WCHDATA_JXJChangeNameTime,param);
		_crInt64 lastt = *(_crInt64 *)param;
		int interval = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJChangeNameInterval,viplv).c_str())*86400;
		time_t dt = t - lastt;
		if(dt<interval)
		{
			dt = interval-dt;
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			int texid = 1104;
			noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
			int mode = 1;
			noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
			std::string param1;
			if(dt<86400)
			{
				char tmp[20];
				strftime( tmp, sizeof(tmp), "%H:%M:%S\0", localtime(&dt) );
				param1 = tmp;
			}
			else
			{
				param1 = crArgumentParser::appItoa((int)(dt/86400))+"天";
			}
			noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
			crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
			return;
		}

		int changeNameCost = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJChangeNameCost,viplv).c_str());
		data->getParam(WCHDATA_JXJGiftGold,param);
		int mygold = *(int *)param;
		data->getParam(WCHDATA_Money,param);
		mygold += *(int *)param;
		if(mygold<changeNameCost)
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
			return;
		}
		int success = 1;
		playerGameData->doEvent(WCH_JXJCheckInvalidWords,MAKEINT64(&success,&newName));
		if (success == 1)
		{
			playerGameData->doEvent(WCH_JXJCheckNameLimit,MAKEINT64(&success,&newName));
			if (success == 1)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(newName.length()+4);
				stream->_writeString(newName);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvChangeName,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				return;
			}
		}
		playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2021,NULL));//名称不能含有敏感词！
	}
}
/////////////////////////////////////////
//
//crJXJClientChangeNameMethod
//
/////////////////////////////////////////
crJXJRecvChangeNameMethod::crJXJRecvChangeNameMethod():
	m_this(NULL),
	m_stream(NULL),
	m_netType(GameClient_Game),
	m_maxsize(12)
{
}
crJXJRecvChangeNameMethod::crJXJRecvChangeNameMethod( const crJXJRecvChangeNameMethod& handle ):
	crMethod(handle),
	m_this(NULL),
	m_stream(NULL),
	m_netType(GameClient_Game),
	m_maxsize(handle.m_maxsize)
{
}
void crJXJRecvChangeNameMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_maxsize = atoi(str.c_str());
		break;
	}
}
void crJXJRecvChangeNameMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvChangeNameMethod::operator ()( crHandle &handle )
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			char code = -5;//名称包含敏感词
			std::string newName = m_stream->_readString();
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			ref_ptr<crRole> mainrole = m_this->getMainRole();
			if ( playerData.valid() && mainrole.valid() && mainrole->getDataClass() )
			{
				std::string oldname = m_this->getCharacterName();
				do 
				{
					if(newName.empty())
					{
						code = -6;//名字不能为空
						break;
					}
					if(newName == oldname)
					{
						code = -1;//同名
						break;
					}
					if (newName.length() > m_maxsize)
					{
						code = -2;//名称过长
						break;
					}
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					_crInt64 t = time(0);
					crData *roledata = mainrole->getDataClass();
					roledata->getParam(WCHDATA_JXJChangeNameTime,param);
					_crInt64 lastt = *(_crInt64 *)param;
					int interval = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJChangeNameInterval,viplv).c_str());
					if(t - lastt<interval*86400)
					{
						code = -7;//时间未到
						break;
					}
					int success = 1;
					m_this->doEvent(WCH_JXJCheckInvalidWords,MAKEINT64(&success,&newName));
					if (success == 1)
					{
						m_this->doEvent(WCH_JXJCheckNameLimit,MAKEINT64(&success,&newName));
						if (success == 1)
						{
							crNetDataManager *netDataManager = gameServer->getNetDataManager();
							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
							if(callback->insertCharacterName(playerid,newName))
							{
								int changeNameCost = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJChangeNameCost,viplv).c_str());

								bool needdeductgold = false;
								MoneyChangeData moneydata(changeNameCost,"改名");
								m_this->doEvent(WCH_JXJDeductLijinGold,MAKEINT64(&moneydata,&needdeductgold));
								if (-1 == moneydata.first)
								{
									code = -3;//元宝不足
									callback->removeCharacterName(playerid);
								}
								else if (0 == moneydata.first)
								{
									mainrole->setIName(newName);
									roledata->inputParam(WCHDATA_JXJChangeNameTime,&t);
									crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
									crDBSavePacket packet;
									ref_ptr<crUpdateCharacterName> updateCharacterName = new crUpdateCharacterName;//如果已经存在，改成UPD
									updateCharacterName->buildUpdateSql(playerid,callback->getServerID(),m_this->getMainRoleID(),newName);
									crDBSavePacket::buildRequestPacket(packet,updateCharacterName.get());
									dbConductor->getNetManager()->sendPacket("all",packet);
									
									ref_ptr<crUpdateInstanceItem> updateItem = new crUpdateInstanceItem;
									updateItem->buildUpdateSql(mainrole->getInstanceItemID(),newName);
									crDBSavePacket::buildRequestPacket(packet,GameDB,playerData->getGameDBID(),updateItem.get());
									dbConductor->getNetManager()->sendPacket("all",packet);

									code = 1;//改名成功
								}
							}
							else
							{
								code = -4;//该名字已经被使用
							}
						}
					}
				} while (0);

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeChar(code);
				if (code == 1)
				{
					stream->_writeString(newName);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvChangeName,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

				if (code == 1)
				{
					///游戏日志
					std::string logdata ="玩家："+oldname+"改名为："+newName;
					GameLogData gamelog(Log_ChangeName,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
				}
			}
		}
		else if (m_netType == GameClient_Game)
		{
			char code = m_stream->_readChar();
			switch (code)
			{
			case 1:
				{
					std::string newName = m_stream->_readString();
					m_this->getMainRole()->setIName(newName);
					crData *data = m_this->getMainRole()->getDataClass();
					_crInt64 t = time(0);
					data->inputParam(WCHDATA_JXJChangeNameTime,&t);
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1102,NULL));//修改成功
				}
				break;
			case -1:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1100,NULL));//同名
				break;
			case -2:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1101,NULL));//名称过长
				break;
			case -3:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2002,NULL));//元宝不足
				break;
			case -4:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1103,NULL));//该名字已经被使用
				break;
			case -5:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(2021,NULL));//名称不能含有敏感词！
				break;
			case -6:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1099,NULL));//名字不能为空！
				break;
			case -7:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1105,NULL));//名字不能为空！
				break;
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJUIJKSetShiliSWMethod
//
/////////////////////////////////////////
crJXJUIJKSetShiliSWMethod::crJXJUIJKSetShiliSWMethod()
{
}

crJXJUIJKSetShiliSWMethod::crJXJUIJKSetShiliSWMethod(const crJXJUIJKSetShiliSWMethod& handle):
	crMethod(handle),
	m_sw1(handle.m_sw1),
	m_sw2(handle.m_sw2)
{
}
void crJXJUIJKSetShiliSWMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIJKSetShiliSWMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_sw1 = str;
		break;
	case 1:
		m_sw2 = str;
		break;
	}
}

void crJXJUIJKSetShiliSWMethod::operator()(crHandle &handle)
{
	ref_ptr<crMultiSwitch> sw1 = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_sw1));
	ref_ptr<crMultiSwitch> sw2 = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_sw2));
	crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	void *param;
	int swvalue = 0;
	if(data)
	{
		data->getParam(WCHDATA_JXJShiliID,param);
		unsigned char shili = *(unsigned char *)param;
		swvalue = shili - c_startShiliID;
	}
	if (sw1.valid())
	{
		sw1->setActiveSwitchSet(swvalue);
	}
	if (sw2.valid())
	{
		sw2->setActiveSwitchSet(swvalue);
	}
}

/////////////////////////////////////////
//
//crJXJUIJKComposeUpdateMethod
//
/////////////////////////////////////////
crJXJUIJKComposeUpdateMethod::crJXJUIJKComposeUpdateMethod()
{
}

crJXJUIJKComposeUpdateMethod::crJXJUIJKComposeUpdateMethod(const crJXJUIJKComposeUpdateMethod& handle):
	crMethod(handle),
	m_jkGuojieRaido(handle.m_jkGuojieRaido),
	m_jtouxiangRaido(handle.m_jtouxiangRaido),
	m_jiangkaImage(handle.m_jiangkaImage),
	m_jiangkaInfo(handle.m_jiangkaInfo),
	m_jiangkaText(handle.m_jiangkaText),
	m_jk_DikaRaido(handle.m_jk_DikaRaido),
	m_jkTiankaPer(handle.m_jkTiankaPer),
	m_jkTiankaNext(handle.m_jkTiankaNext),
	m_jkDikaPer(handle.m_jkDikaPer),
	m_jkDikaNext(handle.m_jkDikaNext)
{
	for (int i=0; i<3; i++)
	{
		m_jkzu_Jineng[i] = handle.m_jkzu_Jineng[i];
		m_jkzh_Wenb[i] = handle.m_jkzh_Wenb[i];
		m_jkzh_Wenb_X[i] = handle.m_jkzh_Wenb_X[i];
		m_jkzh_Wenb_S[i] = handle.m_jkzh_Wenb_S[i];
		m_jk_Tianming[i] = handle.m_jk_Tianming[i];
		m_jkzh_JinDu3[i] = handle.m_jkzh_JinDu3[i];
		m_jihuosw[i] = handle.m_jihuosw[i];
		m_jihuobtn[i] = handle.m_jihuobtn[i];
		m_jihuoTiaojianSw[i] = handle.m_jihuoTiaojianSw[i];
		m_jihuoTiaojianText[i] = handle.m_jihuoTiaojianText[i];
		m_tiananniu[i] = handle.m_tiananniu[i];
	}
	for (int i=0; i<10; i++)
	{
		m_jiangkaName[i] = handle.m_jiangkaName[i];
	}
}
void crJXJUIJKComposeUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIJKComposeUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_jkGuojieRaido = str;
		break;
	case 1:
		m_jtouxiangRaido = str;
		break;
	case 2:
		m_jiangkaImage = str;
		break;
	case 3:
		m_jiangkaInfo = str;
		break;
	case 4:
		m_jiangkaText = str;
		break;
	case 5:
		m_jk_DikaRaido = str;
		break;
	case 6:
	case 7:
	case 8:
		m_jkzu_Jineng[i-6] = str;
		break;
	case 9:
	case 10:
	case 11:
		m_jkzh_Wenb[i-9] = str;
		break;
	case 12:
	case 13:
	case 14:
		m_jkzh_Wenb_X[i-12] = str;
		break;
	case 15:
	case 16:
	case 17:
		m_jkzh_Wenb_S[i-15] = str;
		break;
	case 18:
	case 19:
	case 20:
		m_jk_Tianming[i-18] = str;
		break;
	case 21:
	case 22:
	case 23:
		m_jkzh_JinDu3[i-21] = str;
		break;
	case 24:
		m_jkTiankaPer = str;
		break;
	case 25:
		m_jkTiankaNext = str;
		break;
	case 26:
		m_jkDikaPer = str;
		break;
	case 27:
		m_jkDikaNext = str;
		break;
	case 28:
	case 29:
	case 30:
	case 31:
	case 32:
	case 33:
	case 34:
	case 35:
	case 36:
	case 37:
		m_jiangkaName[i-28]=str;
		break;
	case 38:
	case 39:
	case 40:
		m_jihuosw[i-38] = str;
		break;
	case 41:
	case 42:
	case 43:
		m_jihuobtn[i-41] = str;
		break;
	case 44:
	case 45:
	case 46:
		m_jihuoTiaojianSw[i-44] = str;
		break;
	case 47:
	case 48:
	case 49:
		m_jihuoTiaojianText[i-47] = str;
		break;
	case 50:
	case 51:
	case 52:
		m_tiananniu[i-50] = str;
		break;
	}
}

void crJXJUIJKComposeUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = playerData->getDataClass();
	if(data)
	{
		crData *canvasData = m_this->getDataClass();
		ref_ptr<crRadioGroupWidgetNode> jkGuojieRaido = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_jkGuojieRaido));
		ref_ptr<crRadioGroupWidgetNode> jtouxiangRaido = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_jtouxiangRaido));
		ref_ptr<crImageBoxWidgetNode> jiangkaImage = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_jiangkaImage));
		ref_ptr<crImageBoxWidgetNode> jiangkaInfo = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_jiangkaInfo));
		ref_ptr<crHypertextWidgetNode> jiangkaText = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_jiangkaText));
		ref_ptr<crRadioGroupWidgetNode> jk_DikaRaido = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_jk_DikaRaido));
		ref_ptr<crStaticTextWidgetNode> jkzu_Jineng[3]; 
		ref_ptr<crMultiSwitch> jkzh_Wenb[3]; 
		ref_ptr<crStaticTextWidgetNode> jkzh_Wenb_X[3]; 
		ref_ptr<crStaticTextWidgetNode> jkzh_Wenb_S[3]; 
		ref_ptr<crStaticTextWidgetNode> jk_Tianming[3]; 
		ref_ptr<crProgressWidgetNode> jkzh_JinDu3[3]; 
		ref_ptr<crMultiSwitch> jihuosw[3]; 
		ref_ptr<crButtonWidgetNode> jihuobtn[3];
		ref_ptr<crButtonWidgetNode> tiananniu[3];
		ref_ptr<crMultiSwitch> jihuoTiaojianSw[3]; 
		ref_ptr<crStaticTextWidgetNode> jihuoTiaojianText[3]; 
		for (int i=0; i<3; i++)
		{
			jkzu_Jineng[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jkzu_Jineng[i]));
			jkzh_Wenb[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_jkzh_Wenb[i]));
			jkzh_Wenb_X[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jkzh_Wenb_X[i]));
			jkzh_Wenb_S[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jkzh_Wenb_S[i]));
			jk_Tianming[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jk_Tianming[i]));
			jkzh_JinDu3[i] = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_jkzh_JinDu3[i]));
			jihuosw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_jihuosw[i]));
			jihuobtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_jihuobtn[i]));
			tiananniu[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_tiananniu[i]));
			jihuoTiaojianSw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_jihuoTiaojianSw[i]));
			jihuoTiaojianText[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jihuoTiaojianText[i]));
		}
		
		ref_ptr<crButtonWidgetNode> jkTiankaPer = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_jkTiankaPer));
		ref_ptr<crButtonWidgetNode> jkTiankaNext = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_jkTiankaNext));
		ref_ptr<crButtonWidgetNode> jkDikaPer = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_jkDikaPer));
		ref_ptr<crButtonWidgetNode> jkDikaNext = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_jkDikaNext));
		ref_ptr<crStaticTextWidgetNode> jiangkaName[10]; 
		for (int i=0; i<10; i++)
		{
			jiangkaName[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jiangkaName[i]));
		}

		int jkshiliselect = jkGuojieRaido.valid()?jkGuojieRaido->getSelect():0;
		void *param;
		data->getParam(WCHDATA_JXJShiliID,param);
		unsigned char shili = *(unsigned char *)param;
		jkshiliselect = jkshiliselect==0?shili:2;
		
		ref_ptr<crTableIO> cardExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCardExtraTab);
		ref_ptr<crTableIO> itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		int qualityid = itemTab->getTitleIndex("品质");//0
		int jkshiliindex = itemTab->getTitleIndex("国家");//1
		int iconid = itemTab->getTitleIndex("icon");//2
		int composeid = cardExtraTab->getTitleIndex("组合ID");//3
		int activeid = cardExtraTab->getTitleIndex("激活lv");//4
		int nameid = cardExtraTab->getTitleIndex("组合名称");//5
		int desid = cardExtraTab->getTitleIndex("描述");//6
		int requireid = cardExtraTab->getTitleIndex("激活需求");//7
		int jknameid = itemTab->getTitleIndex("name");//8
		int jkiconid = itemTab->getTitleIndex("icon");//9
		int jkInfoid = itemTab->getTitleIndex("姓名");//10
		int jkImgid = itemTab->getTitleIndex("picture");//11
		crTableIO::StrVec record;
		crTableIO::StrVec tmprecord;//天卡ID 地卡 组合ID 激活lv	组合名称 描述 激活需求
		crTableIO::DataVec dataVec,dataVec2; 
		std::set<int> cardidSet;
		std::vector<int> cardidVec;
		int selitemid = 0;
		int itemid = 0;
		std::vector<int>idvectmp;
		if(jtouxiangRaido.valid())
		{
			crRadioGroupWidgetNode::RadioGroup &radioGroup = jtouxiangRaido->getRadioGroup();
			int nRowCount = cardExtraTab->getRowCount();
			for (int i=0; i<nRowCount; i++)
			{
				crArgumentParser::appAtoVec((*cardExtraTab)(i,0),idvectmp,'|');
				for(std::vector<int>::iterator itr = idvectmp.begin(); itr != idvectmp.end(); ++itr)
				{
					if((*itr)>0 && itemTab->queryOneRecord(0,crArgumentParser::appItoa(*itr),record)>=0)
					{
						if(jkshiliselect != atoi(record[jkshiliindex].c_str()))
							break;
						if(record[qualityid] == "4")
						{
							cardidSet.insert(*itr);
							tmprecord.resize(0);
							tmprecord.push_back(record[0]);
							tmprecord.push_back((*cardExtraTab)(i,1));
							tmprecord.push_back((*cardExtraTab)(i,composeid));
							//tmprecord.push_back((*cardExtraTab)(i,activeid));
							//tmprecord.push_back((*cardExtraTab)(i,nameid));
							//tmprecord.push_back((*cardExtraTab)(i,desid));
							//tmprecord.push_back((*cardExtraTab)(i,requireid));
							//tmprecord.push_back(record[jknameid]);
							//tmprecord.push_back(record[jkiconid]);
							//tmprecord.push_back(record[jkInfoid]);
							//tmprecord.push_back(record[jkImgid]);
							dataVec.push_back(tmprecord);
							break;
						}
					}
				}
			}
			for( std::set<int>::iterator itr = cardidSet.begin();
				 itr != cardidSet.end();
				 ++itr )
			{
				cardidVec.push_back(*itr);
			}
			canvasData->getParam(WCHDATA_JXJCurTiankaRow,param);
			int curTiankaRow = *(int *)param;
			int rowCount = cardidVec.size();
			canvasData->inputParam(WCHDATA_JXJTiankaCount,&rowCount);
			jkTiankaPer->setEnable(curTiankaRow > 0);
			int count = rowCount - radioGroup.size();
			jkTiankaNext->setEnable(curTiankaRow < count);
			std::string iconfile1;
			crMultiSwitch *radioButton;
			crStateSet *ss1;
			crTexture2D *tex2d;
			crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
			int cursel = jtouxiangRaido->getSelect();
			int i = 0;
			int row = curTiankaRow;
			for( ; row<rowCount && itr != radioGroup.end(); ++row)
			{
				itemid = cardidVec[row];
				if(cursel == i)
					selitemid = itemid;
				itemTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record);
				iconfile1 = record[iconid];
				if(jiangkaName[i].valid())
				{
					jiangkaName[i]->setVisiable(true);
					jiangkaName[i]->setString(record[jknameid]);
				}
				radioButton = itr->second->getButton();
				radioButton->setVisiable(true);
				ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

				tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
				if(tex2d)
				{
					if(tex2d->getImageNameID().compare(iconfile1)!=0)
						tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				}
				else
				{
					tex2d = new crTexture2D;
					tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
					tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
					tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
					ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				}
				++itr;
				++i;
			}
			if(i>0) i--;
			if(cursel>i)
			{
				cursel = i;
				jtouxiangRaido->select(i);
				selitemid = itemid;
			}
			for( ;
				itr != radioGroup.end();
				++itr )
			{
				++i;
				radioButton = itr->second->getButton();
				radioButton->setVisiable(false);
				if(jiangkaName[i].valid())
				{
					jiangkaName[i]->setVisiable(false);
				}
			}
		}
		if(selitemid>0 && itemTab->queryOneRecord(0,crArgumentParser::appItoa(selitemid),record)>=0)
		{//天卡信息显示
			if(jiangkaImage.valid())
				jiangkaImage->setImageName(record[jkImgid]);
			if(jiangkaInfo.valid())
				jiangkaInfo->setImageName(record[jkInfoid]);
			if(jiangkaText.valid())
			{
				ItemMap itemMap;
				rcfg::ConfigScript outscript(&itemMap);
				crVector2i item(selitemid,0);
				playerData->doEvent(WCH_JXJCreateItemTips,MAKEINT64(&item,&outscript));
				jiangkaText->setHypertext(outscript);
			}
		}
		if(jk_DikaRaido.valid() && selitemid>0)
		{
			cardidSet.clear();
			cardidVec.clear();
			crRadioGroupWidgetNode::RadioGroup &radioGroup = jk_DikaRaido->getRadioGroup();
			std::string strselitem = crArgumentParser::appItoa(selitemid);
			for( crTableIO::DataVec::iterator itr = dataVec.begin();
				 itr != dataVec.end();
				 ++itr )
			{
				if(strselitem == (*itr)[0])
				{
					crArgumentParser::appAtoVec((*itr)[1],idvectmp,'|');
					for(std::vector<int>::iterator iitr = idvectmp.begin(); iitr != idvectmp.end(); ++iitr)
					{
						if((*iitr)>0 && itemTab->queryOneRecord(0,crArgumentParser::appItoa(*iitr),record)>=0)
						{
							if(record[qualityid] == "4")
							{
								cardidSet.insert(*iitr);
								tmprecord.resize(0);
								tmprecord.push_back(strselitem);
								tmprecord.push_back(record[0]);
								tmprecord.push_back((*itr)[2]);
								//tmprecord.push_back((*cardExtraTab)(i,activeid));
								//tmprecord.push_back((*cardExtraTab)(i,nameid));
								//tmprecord.push_back((*cardExtraTab)(i,desid));
								//tmprecord.push_back((*cardExtraTab)(i,requireid));
								//tmprecord.push_back(record[jknameid]);
								//tmprecord.push_back(record[jkiconid]);
								//tmprecord.push_back(record[jkInfoid]);
								//tmprecord.push_back(record[jkImgid]);
								dataVec2.push_back(tmprecord);
								break;
							}
						}
					}
				}
			}

			for( std::set<int>::iterator itr = cardidSet.begin();
				itr != cardidSet.end();
				++itr )
			{
				cardidVec.push_back(*itr);
			}
			canvasData->getParam(WCHDATA_JXJCurDikaRow,param);
			int curDiankaRow = *(int *)param;
			int rowCount = cardidVec.size();
			canvasData->inputParam(WCHDATA_JXJDikaCount,&rowCount);
			jkDikaPer->setEnable(curDiankaRow > 0);
			int count = rowCount - radioGroup.size();
			jkDikaNext->setEnable(curDiankaRow < count);
			std::string iconfile1;
			crMultiSwitch *radioButton;
			crStateSet *ss1;
			crTexture2D *tex2d;
			crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
			int cursel = jk_DikaRaido->getSelect();
			int i = 0;
			int row = curDiankaRow;
			for( ; row<rowCount && itr != radioGroup.end(); ++row)
			{
				itemid = cardidVec[row];
				if(cursel == i)
					selitemid = itemid;
				itemTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record);
				iconfile1 = record[iconid];

				radioButton = itr->second->getButton();
				radioButton->setVisiable(true);
				ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

				tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
				if(tex2d)
				{
					if(tex2d->getImageNameID().compare(iconfile1)!=0)
						tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				}
				else
				{
					tex2d = new crTexture2D;
					tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
					tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
					tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
					tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
					tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
					ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				}
				++itr;
				++i;
			}
			for( ;
				itr != radioGroup.end();
				++itr )
			{
				radioButton = itr->second->getButton();
				radioButton->setVisiable(false);
			}
			if(i>0) i--;
			if(cursel>i)
			{
				cursel = i;
				jk_DikaRaido->select(i);
				selitemid = itemid;
			}
			strselitem = crArgumentParser::appItoa(selitemid);
			std::string strcomposeid;
			for( crTableIO::DataVec::iterator itr = dataVec2.begin();
				itr != dataVec2.end();
				++itr )
			{
				if(strselitem == (*itr)[1])
				{//地卡
					strcomposeid = (*itr)[2];
					break;
				}
			}
			if(!strcomposeid.empty())
			{
				crVector2i needitems;
				crVector3i activeParam;
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				data->getParam(WCHDATA_JXJCardExtraTechMap,param);
				CardExtraTechMap *cardExtraTechMap = (CardExtraTechMap *)param;
				int cardcomposeid = atoi(strcomposeid.c_str());
				CardExtraTechMap::iterator ceitr = cardExtraTechMap->find(cardcomposeid);
				unsigned char cardExtralv = ceitr == cardExtraTechMap->end()?0:ceitr->second;
				int hascount;
				std::string str;
				crTableIO::StrVec itemrecord;
				std::string pername;
				canvasData->excHandle(MAKEINT64(WCH_LockData,1));
				canvasData->getParam(WCHDATA_JXJGongFangMaterialVec,param);
				GongFangMaterialVec *materialVec = (GongFangMaterialVec*)param;
				ref_ptr<crBagItemData> bagItem;
				if(materialVec->empty())
				{
					bagItem = new crBagItemData;
					materialVec->push_back(bagItem);
				}
				else
				{
					bagItem = (*materialVec)[0];
				}
				bagItem->setItemDeductCount(0);
				for( int i = 0; i<3; i++ )
				{
					if(cardExtraTab->queryOneRecord(composeid,strcomposeid,activeid,crArgumentParser::appItoa(i+1),record)>=0)
					{
						jkzu_Jineng[i]->setVisiable(true);
						jkzu_Jineng[i]->setString(record[nameid]);
						if(record[desid].find("/n")==std::string::npos)
						{
							jkzh_Wenb[i]->setActiveSwitchSet(0);
							jkzh_Wenb_X[i]->setString(record[desid]);
						}
						else
						{
							jkzh_Wenb[i]->setActiveSwitchSet(1);
							jkzh_Wenb_S[i]->setString(record[desid]);
						}
						crArgumentParser::appAtoVec(record[requireid],needitems);
						jk_Tianming[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jk_Tianming[i]));
						jkzh_JinDu3[i] = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_jkzh_JinDu3[i]));
						
						if(needitems[1]>0&&needitems[0]>0&&itemTab->queryOneRecord(0,crArgumentParser::appItoa(needitems[0]),itemrecord)>=0)
						{
							hascount = 0;
							for (JXJItemBagVec::iterator itr = itembagvec->begin();
								itr!= itembagvec->end();
								++itr)
							{
								if((*itr)!=NULL)
								{
									if((*itr)->getItemID() == needitems[0])
									{
										hascount+=(*itr)->getItemCount();
									}
								}
							}
							str = itemrecord[jknameid]+":"+crArgumentParser::appItoa(hascount)+"/"+crArgumentParser::appItoa(needitems[1]);
							jk_Tianming[i]->setString(str);
							jkzh_JinDu3[i]->setProgress((float)hascount/(float)needitems[1]);

							jk_Tianming[i]->setVisiable(true);
							jkzh_JinDu3[i]->setVisiable(true);
						}
						else
						{
							jk_Tianming[i]->setVisiable(false);
							jkzh_JinDu3[i]->setVisiable(false);
						}

						if(cardExtralv==i)
						{//需要激活
							if(jihuoTiaojianSw[i].valid()) jihuoTiaojianSw[i]->setActiveSwitchSet(0);
							activeParam.set(cardcomposeid,needitems[0],needitems[1]);
							canvasData->inputParam(WCHDATA_JXJCardExtraActiveParam,&activeParam);
							jihuosw[i]->setActiveSwitchSet(0);
							if(hascount>=needitems[1])
							{
								jihuobtn[i]->setEnable(hascount>=needitems[1]);
								if(tiananniu[i].valid()) tiananniu[i]->setVisiable(false);
							}
							else
							{
								jihuobtn[i]->setEnable(false);
								bagItem->setItemID(needitems[0]);
								bagItem->setItemDeductCount(needitems[1] - hascount);
								if(tiananniu[i].valid()) tiananniu[i]->setVisiable(true);
							}
						}
						else if(cardExtralv>i)
						{//已经激活
							jihuosw[i]->setActiveSwitchSet(1);
							if(jihuoTiaojianSw[i].valid()) jihuoTiaojianSw[i]->setActiveSwitchSet(2);
						}
						else
						{//激活条件不满足
							if(jihuoTiaojianSw[i].valid()) jihuoTiaojianSw[i]->setActiveSwitchSet(1);
							if(jihuoTiaojianText[i].valid())
							{
								str = "需要激活组合效果："+pername;
								jihuoTiaojianText[i]->setString(str);
							}
							jihuosw[i]->setActiveSwitchSet(0);
							jihuobtn[i]->setEnable(false);
						}
						pername = record[nameid];
					}
					else
					{
						jkzu_Jineng[i]->setVisiable(false);
						jkzh_Wenb[i]->setActiveSwitchSet(2);
						jk_Tianming[i]->setVisiable(false);
						jkzh_JinDu3[i]->setVisiable(false);
					}
				}
				canvasData->excHandle(MAKEINT64(WCH_LockData,0));
				data->excHandle(MAKEINT64(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUITiankaWalkMethod
//
/////////////////////////////////////////
crJXJUITiankaWalkMethod::crJXJUITiankaWalkMethod():
	m_this(NULL),
	m_step(1)
{
}
crJXJUITiankaWalkMethod::crJXJUITiankaWalkMethod(const crJXJUITiankaWalkMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_step(handle.m_step)
{
}
void crJXJUITiankaWalkMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUITiankaWalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	}
}
void crJXJUITiankaWalkMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	if (canvas.get())
	{
		crData *canvasData = canvas->getDataClass();
		void *param;
		canvasData->getParam(WCHDATA_JXJTiankaCount,param);
		int rowcount = *(int *)param;
		canvasData->getParam(WCHDATA_JXJCurTiankaRow,param);
		int* curTiankaRow = (int *)param;
		int tryID = *curTiankaRow + m_step;
		if(tryID<0)
			*curTiankaRow = 0;
		else if(tryID < rowcount)
			*curTiankaRow = tryID;
	}
}
/////////////////////////////////////////
//
//crJXJUIDikaWalkMethod
//
/////////////////////////////////////////
crJXJUIDikaWalkMethod::crJXJUIDikaWalkMethod():
	m_this(NULL),
	m_step(1)
{
}
crJXJUIDikaWalkMethod::crJXJUIDikaWalkMethod(const crJXJUIDikaWalkMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_step(handle.m_step)
{
}
void crJXJUIDikaWalkMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIDikaWalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	}
}
void crJXJUIDikaWalkMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	if (canvas.get())
	{
		crData *canvasData = canvas->getDataClass();
		void *param;
		canvasData->getParam(WCHDATA_JXJDikaCount,param);
		int rowcount = *(int *)param;
		canvasData->getParam(WCHDATA_JXJCurDikaRow,param);
		int* curDikaRow = (int *)param;
		int tryID = *curDikaRow + m_step;
		if(tryID<0)
			*curDikaRow = 0;
		else if(tryID < rowcount)
			*curDikaRow = tryID;
	}
}
/////////////////////////////////////////
//
//crJXJUIActiveCardExtraMethod
//
/////////////////////////////////////////
crJXJUIActiveCardExtraMethod::crJXJUIActiveCardExtraMethod():
	m_this(NULL)
{
}
crJXJUIActiveCardExtraMethod::crJXJUIActiveCardExtraMethod(const crJXJUIActiveCardExtraMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_promptCanvas(handle.m_promptCanvas),
	m_information(handle.m_information),
	m_okbtn(handle.m_okbtn)
{
}
void crJXJUIActiveCardExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIActiveCardExtraMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_promptCanvas = str;
		break;
	case 1:
		m_information = str;
		break;
	case 2:
		m_okbtn = str;
		break;
	default:
		break;
	}
}
void crJXJUIActiveCardExtraMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (canvas.valid())
	{
		crData *canvasdata = canvas->getDataClass();
		if (canvasdata)
		{
			void *param;
			canvasdata->getParam(WCHDATA_JXJCardExtraActiveParam,param);
			crVector3i activeParam = *(crVector3i *)param;
			ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			crTableIO::StrVec record;
			int nameid = itemTab->getTitleIndex("name");//8
			if (activeParam!=crVector3i(0,0,0) && itemTab->queryOneRecord(0,crArgumentParser::appItoa(activeParam[1]),record)>=0)
			{
				//	data->getParam(WCHDATA_JXJGoldCostHintInt,param);
				//	unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_GongFangBuyMaterialHint;
				ref_ptr<crCanvasNode>tipscanvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
				if (tipscanvas.valid())
				{
					ref_ptr<crHypertextWidgetNode> information = dynamic_cast<crHypertextWidgetNode *>(tipscanvas->getWidget(m_information));
					ref_ptr<crButtonWidgetNode> okbtn = dynamic_cast<crButtonWidgetNode *>(tipscanvas->getWidget(m_okbtn));
					//		if (ifhint)
					{
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");

						cfg_script.Add("Content");
						cfg_script.Push("Content",1);
						v_i.clear();
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						cfg_script.Add("Text","你确认要消耗");
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content",2);
						v_i.clear();
						v_i.push_back(140.0f);
						v_i.push_back(40.0f);
						v_i.push_back(40.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						char tmpText[32];
						sprintf(tmpText,"%d%s\0",activeParam[2],record[nameid].c_str());
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content",3);
						v_i.clear();
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						cfg_script.Add("Text","来激活该将卡组合功能吗？");
						cfg_script.Pop();


						cfg_script.Pop();

						if(information.valid())information->setHypertext(cfg_script);
					}
					if(okbtn.valid())okbtn->setEnable(true);
					crData *dlgData = tipscanvas->getDataClass();
					int commandtype = CDP_Widget;
					dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
					dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
					//	if (ifhint)
					//	{
					crFilterRenderManager::getInstance()->doModal(tipscanvas.get());
					//	}
					//	else
					//	{
					//		if(okbtn)okbtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
					//	}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJActiveCardExtraMethod
//
/////////////////////////////////////////
crJXJActiveCardExtraMethod::crJXJActiveCardExtraMethod():
	m_this(NULL)
{
}
crJXJActiveCardExtraMethod::crJXJActiveCardExtraMethod(const crJXJActiveCardExtraMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJActiveCardExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJActiveCardExtraMethod::addParam(int i, const std::string& str)
{
}
void crJXJActiveCardExtraMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if (canvas.valid() && netConductor)
	{
		crData *canvasdata = canvas->getDataClass();
		if (canvasdata)
		{
			void *param;
			canvasdata->getParam(WCHDATA_JXJCardExtraActiveParam,param);
			crVector3i activeParam = *(crVector3i *)param;
			if(activeParam!=crVector3i(0,0,0))
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(2);
				stream->_writeUShort(activeParam[0]);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvActiveCardExtra,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvActiveCardExtraMethod
//
/////////////////////////////////////////
crJXJRecvActiveCardExtraMethod::crJXJRecvActiveCardExtraMethod():
	m_netType(GameClient_Game){}
crJXJRecvActiveCardExtraMethod::crJXJRecvActiveCardExtraMethod(const crJXJRecvActiveCardExtraMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvActiveCardExtraMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvActiveCardExtraMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvActiveCardExtraMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			char success = 0;
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				ref_ptr<crTableIO> cardExtraTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCardExtraTab);
				int composeid = cardExtraTab->getTitleIndex("组合ID");//3
				int activeid = cardExtraTab->getTitleIndex("激活lv");//4
				int requireid = cardExtraTab->getTitleIndex("激活需求");//7
				crTableIO::StrVec record;
				unsigned short cardcomposid = m_stream->_readUShort();
				crData *data = m_this->getDataClass();
				void *param;
				char success = 0;//0不可激活，-1道具不足，1成功
				data->excHandle(MAKEINT64(WCH_LockData,1));
				data->getParam(WCHDATA_JXJCardExtraTechMap,param);
				CardExtraTechMap *cardExtraTechMap = (CardExtraTechMap *)param;
				CardExtraTechMap::iterator ceitr = cardExtraTechMap->find(cardcomposid);
				unsigned char lv = ceitr != cardExtraTechMap->end()?ceitr->second:0;
				lv++;
				if(cardExtraTab->queryOneRecord(composeid,crArgumentParser::appItoa(cardcomposid),activeid,crArgumentParser::appItoa(lv),record)>=0)
				{
					crVector2i require;
					crArgumentParser::appAtoVec(record[requireid],require);
					int hascount = 0;
					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					for (JXJItemBagVec::iterator itr = itembagvec->begin();
						itr!= itembagvec->end();
						++itr)
					{
						if((*itr)!=NULL)
						{
							if((*itr)->getItemID() == require[0])
							{
								hascount+=(*itr)->getItemCount();
							}
						}
					}
					if(hascount>=require[1])
					{
						ref_ptr<crBagItemData> deductitem;
						deductitem = new crBagItemData;
						deductitem->setItemID(require[0]);
						deductitem->setItemDeductCount(require[1]);
						DeductItemMap deductitemmap;
						deductitemmap.insert(std::make_pair(require[0],deductitem));
						m_this->doEvent(WCH_JXJRecvDeductItems,MAKEINT64(&deductitemmap,0));

						(*cardExtraTechMap)[cardcomposid] = lv;
						success = 1;
					}
					else
					{//道具不足
						success = -1;
					}
				}
				data->excHandle(MAKEINT64(WCH_LockData,0));
				
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeChar(success);
				if(success == 1)
				{
					stream->_writeUShort(cardcomposid);
					stream->_writeUChar(lv);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvActiveCardExtra,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = crArgumentParser::appVectoa(crVector3i(success,cardcomposid,lv),'|');
				GameLogData gamelog(Log_ActiveCardExtra,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char success = m_stream->_readChar();
			switch(success)
			{
			case 0:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1107,NULL));//不能激活
				break;
			case -1:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1108,NULL));//道具不足
				break;
			case 1:
				{
					unsigned short cardcomposid = m_stream->_readUShort();
					unsigned char lv = m_stream->_readUChar();
					crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
					if(playerData && playerData->getDataClass())
					{
						crData *data = playerData->getDataClass();
						void *param;
						data->excHandle(MAKEINT64(WCH_LockData,1));
						data->getParam(WCHDATA_JXJCardExtraTechMap,param);
						CardExtraTechMap *cardExtraTechMap = (CardExtraTechMap *)param;
						(*cardExtraTechMap)[cardcomposid] = lv;
						data->excHandle(MAKEINT64(WCH_LockData,0));
					}
				}
				break;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICardShopOpenCheckMethod
//
/////////////////////////////////////////
crJXJUICardShopOpenCheckMethod::crJXJUICardShopOpenCheckMethod():
	m_this(NULL)
{
}
crJXJUICardShopOpenCheckMethod::crJXJUICardShopOpenCheckMethod(const crJXJUICardShopOpenCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_cardshop(handle.m_cardshop)
{
}
void crJXJUICardShopOpenCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUICardShopOpenCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cardshop = str;
		break;
	}
}
void crJXJUICardShopOpenCheckMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJCardShopOpenTechLv,param);
		unsigned char CardShopOpenTechLv = *(unsigned char *)param;

		ref_ptr<crRadioWidgetNode> cardshop = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_cardshop));
		if (cardshop.valid())
		{
			cardshop->setVisiable(CardShopOpenTechLv > 0);
		}
	}
}
////////////////////////////////
//
//crJXJGetMultiSwitchValueMethod
//
///////////////////////////////////
crJXJGetMultiSwitchValueMethod::crJXJGetMultiSwitchValueMethod():
	m_this(NULL)
{}

crJXJGetMultiSwitchValueMethod::crJXJGetMultiSwitchValueMethod(const crJXJGetMultiSwitchValueMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_sw(handle.m_sw)
{
}

void crJXJGetMultiSwitchValueMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJGetMultiSwitchValueMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sw = str;
		break;
	}
}

void crJXJGetMultiSwitchValueMethod::operator()(crHandle &handle)
{
	ref_ptr<crMultiSwitch> sw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_sw));
	int value = sw.valid()?sw->getActiveSwitchSet():0;
	handle.outputParam(0,&value);
}
////////////////////////////////
//
//crJXJSetCanvasPositionMethod
//
///////////////////////////////////
crJXJSetCanvasPositionMethod::crJXJSetCanvasPositionMethod()
{}

crJXJSetCanvasPositionMethod::crJXJSetCanvasPositionMethod(const crJXJSetCanvasPositionMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_pos(handle.m_pos)
{
}

void crJXJSetCanvasPositionMethod::inputParam(int i, void *param)
{
}

void crJXJSetCanvasPositionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_pos);
		break;
	}
}

void crJXJSetCanvasPositionMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvas.valid())
		canvas->setPosition(m_pos);
}
////////////////////////////////
//
//crJXJCreateCharacterTimerMethod
//
///////////////////////////////////
crJXJCreateCharacterTimerMethod::crJXJCreateCharacterTimerMethod():
	m_this(NULL),
	m_timer(0L)
{}

crJXJCreateCharacterTimerMethod::crJXJCreateCharacterTimerMethod(const crJXJCreateCharacterTimerMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_setupBtn(handle.m_setupBtn),
	m_timetext(handle.m_timetext),
	m_timer(0L)
{
}

void crJXJCreateCharacterTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJCreateCharacterTimerMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_setupBtn = str;
		break;
	case 1:
		m_timetext = str;
		break;
	}
}

void crJXJCreateCharacterTimerMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->excHandle(MAKEINT64(WCH_LockData,1));
	data->getParam(WCHDATA_JXJCreateTimer,param);
	float *timer = (float *)param;
	if(*timer>0.0f)
	{//-1表示倒计时取消
		CRCore::Timer_t t1 = CRCore::Timer::instance()->tick();
		if(m_timer != 0L)
		{
			float dt = CRCore::Timer::instance()->delta_s(m_timer,t1);
			*timer -= dt;
			if(*timer<0.0f)
			{
				*timer = 0.0f;
				ref_ptr<crWidgetNode> setupBtn = m_this->getWidget(m_setupBtn);
				if(setupBtn.valid())
				{
					setupBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
				}
			}
		}
		m_timer = t1;
		ref_ptr<crStaticTextWidgetNode> timetext = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timetext));
		if(timetext.valid())
		{
			int t = *timer;
			timetext->setString(crArgumentParser::appItoa(t));
		}
	}
	data->excHandle(MAKEINT64(WCH_LockData,0));
}
////////////////////////////////
//
//crJXJCreateCharacterTimerCancelMethod
//
///////////////////////////////////
crJXJCreateCharacterTimerCancelMethod::crJXJCreateCharacterTimerCancelMethod():
	m_this(NULL)
{}

crJXJCreateCharacterTimerCancelMethod::crJXJCreateCharacterTimerCancelMethod(const crJXJCreateCharacterTimerCancelMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}

void crJXJCreateCharacterTimerCancelMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJCreateCharacterTimerCancelMethod::addParam(int i, const std::string& str)
{
}

void crJXJCreateCharacterTimerCancelMethod::operator()(crHandle &handle)
{
	crCanvasNode *canvas = m_this->getParentCanvas();
	if(canvas && canvas->getDataClass())
	{
		crData *data = canvas->getDataClass();
		float timer = -1.0f;
		data->inputParam(WCHDATA_JXJCreateTimer,&timer);
	}
}
////////////////////////////////
//
//crJXJUIPlayFxMethod
//
///////////////////////////////////
crJXJUIPlayFxMethod::crJXJUIPlayFxMethod():
	m_this(NULL),
	m_interval(1.0f)
{}

crJXJUIPlayFxMethod::crJXJUIPlayFxMethod(const crJXJUIPlayFxMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_interval(handle.m_interval),
	m_donghua(handle.m_donghua)
{
}

void crJXJUIPlayFxMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIPlayFxMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atof(str.c_str());
		break;
	case 1:
		m_donghua = str;
		break;
	}
}

void crJXJUIPlayFxMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_JXJVisiableTime,&m_interval);
	ref_ptr<crSequence> seq = dynamic_cast<crSequence *>(m_this->getChildNode(m_donghua));
	if(seq.valid())
	{
		seq->startEffect();
	}
}
/////////////////////////////////////////
//
//crJXJOpinionMethod
//
/////////////////////////////////////////
crJXJOpinionMethod::crJXJOpinionMethod()
{
}
crJXJOpinionMethod::crJXJOpinionMethod( const crJXJOpinionMethod& handle ):
	crMethod(handle),
	m_edit(handle.m_edit),
	m_sizeRange(handle.m_sizeRange)
{
}

void crJXJOpinionMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}

}

void crJXJOpinionMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		m_edit = str;
		break;
	case 1:
		crArgumentParser::appAtoVec(str,m_sizeRange);
		break;
	}
}

void crJXJOpinionMethod::operator ()( crHandle & handle )
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor && canvas.valid())
	{
		crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		ref_ptr<crEditWidgetNode> editwidget = dynamic_cast<crEditWidgetNode *>(canvas -> getWidget(m_edit));
		std::string str = editwidget->getUTF8String();
		int strsize = str.size();
		if(strsize == 0 || strsize<m_sizeRange[0] || strsize>m_sizeRange[1])
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1109,NULL));//请输入10~200个字！
			return;
		}
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(str.length()+4);
		stream->_writeString(str);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOpinion,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvOpinionMethod
//
/////////////////////////////////////////
crJXJRecvOpinionMethod::crJXJRecvOpinionMethod():
	m_this(NULL),
	m_stream(NULL),
	m_netType(GameClient_Game)
{
}
crJXJRecvOpinionMethod::crJXJRecvOpinionMethod( const crJXJRecvOpinionMethod& handle ):
	crMethod(handle),
	m_this(NULL),
	m_stream(NULL),
	m_netType(GameClient_Game),
	m_sizeRange(handle.m_sizeRange),
	m_canvas(handle.m_canvas),
	m_edit(handle.m_edit),
	m_color(handle.m_color)
{
}
void crJXJRecvOpinionMethod::addParam( int i, const std::string& str )
{
	switch (i)
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_sizeRange);
		break;
	case 1:
		m_canvas = str;
		break;
	case 2:
		m_edit = str;
		break;
	case 3:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	}
}
void crJXJRecvOpinionMethod::inputParam( int i, void *param )
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvOpinionMethod::operator ()( crHandle &handle )
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
			if ( playerData.valid() && dbConductor)
			{
				char code = 1;//名称包含敏感词
				std::string opin = m_stream->_readString();
				int strsize = opin.size();
				if(strsize == 0 || strsize<m_sizeRange[0] || strsize>m_sizeRange[1])
				{
					code = -1;
				}
				else
				{
					crNetDataManager *netDataManager = gameServer->getNetDataManager();
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
					int serverid = callback->getServerID();
					crDBSavePacket dbpacket;
					ref_ptr<crJXJInsertOpinions> insertOpinions = new crJXJInsertOpinions;
					insertOpinions->buildUpdateSql(playerid,serverid,m_this->getCharacterName(),opin);
					crDBSavePacket::buildRequestPacket(dbpacket,insertOpinions.get());
					dbConductor->getNetManager()->sendPacket("all",dbpacket);
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeChar(code);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvOpinion,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		else if (m_netType == GameClient_Game)
		{
			char code = m_stream->_readChar();
			switch (code)
			{
			case 1:
				{
					ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
					if(canvas.valid())
					{
						ref_ptr<crEditWidgetNode> opin = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_edit));
						if(opin.valid())
						{
							ref_ptr<crTableIO>textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
							crTableIO::StrVec record;
							std::string tipstr;
							if(textTab->queryOneRecord(0,crArgumentParser::appItoa(1111),record) >= 0 )
							{
								tipstr = record[1];		
							}
							opin->setString(tipstr);
							opin->setColor(m_color);
						}
					}
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1110,NULL));//提交成功！
				}
				break;
			case -1:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKEINT64(1109,NULL));//请输入10~200个字！
				break;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJTextColorEqualMethod
//
/////////////////////////////////////////
crJXJTextColorEqualMethod::crJXJTextColorEqualMethod(){}
crJXJTextColorEqualMethod::crJXJTextColorEqualMethod(const crJXJTextColorEqualMethod& handle):
	crMethod(handle),
	m_color(handle.m_color)
{
}
void crJXJTextColorEqualMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crTextAttrWidgetNode*)param;
		break;
	}
}

void crJXJTextColorEqualMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	}
}

void crJXJTextColorEqualMethod::operator()(crHandle &handle)
{
	bool equal = m_this->getColor()==m_color;
	handle.outputParam(0,&equal);
}
/////////////////////////////////////////
//
//crJXJClearTextMethod
//
/////////////////////////////////////////
crJXJClearTextMethod::crJXJClearTextMethod(){}
crJXJClearTextMethod::crJXJClearTextMethod(const crJXJClearTextMethod& handle):
	crMethod(handle)
{
}
void crJXJClearTextMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crStaticTextWidgetNode*)param;
		break;
	}
}

void crJXJClearTextMethod::addParam(int i, const std::string& str)
{
}

void crJXJClearTextMethod::operator()(crHandle &handle)
{
	m_this->clearString();
}
/////////////////////////////////////////
//
//crJXJTextEmptyMethod
//
/////////////////////////////////////////
crJXJTextEmptyMethod::crJXJTextEmptyMethod(){}
crJXJTextEmptyMethod::crJXJTextEmptyMethod(const crJXJTextEmptyMethod& handle):
	crMethod(handle),
	m_textNode(handle.m_textNode)
{
}
void crJXJTextEmptyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJTextEmptyMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textNode = str;
		break;
	}
}

void crJXJTextEmptyMethod::operator()(crHandle &handle)
{
	ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_textNode));
	bool isempty = true;
	if(text.valid())
		isempty = text->getString().empty();
	handle.outputParam(0,&isempty);
}
/////////////////////////////////////////
//
//crJXJSetCodeTextMethod
//
/////////////////////////////////////////
crJXJSetCodeTextMethod::crJXJSetCodeTextMethod(){}
crJXJSetCodeTextMethod::crJXJSetCodeTextMethod(const crJXJSetCodeTextMethod& handle):
	crMethod(handle),
	m_textNode(handle.m_textNode),
	m_textid(handle.m_textid),
	m_color(handle.m_color)
{
}
void crJXJSetCodeTextMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJSetCodeTextMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textNode = str;
		break;
	case 1:
		m_textid = str;
		break;
	case 2:
		crArgumentParser::appAtoVec(str,m_color);
		m_color /= 255.0f;
		break;
	}
}

void crJXJSetCodeTextMethod::operator()(crHandle &handle)
{
	ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_textNode));
	if(text.valid())
	{
		ref_ptr<crTableIO>textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		std::string tipstr;
		if(textTab->queryOneRecord(0,m_textid,record) >= 0 )
		{
			tipstr = record[1];		
		}
		text->setString(tipstr);
		text->setColor(m_color);
	}
}
/////////////////////////////////////////
//
//crJXJSetHypertextMethod
//
/////////////////////////////////////////
crJXJSetHypertextMethod::crJXJSetHypertextMethod(){}
crJXJSetHypertextMethod::crJXJSetHypertextMethod(const crJXJSetHypertextMethod& handle):
	crMethod(handle),
	m_textFile(handle.m_textFile)
{
}
void crJXJSetHypertextMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crHypertextWidgetNode*)param;
		break;
	}
}

void crJXJSetHypertextMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textFile = str;
		break;
	}
}

void crJXJSetHypertextMethod::operator()(crHandle &handle)
{
	m_this->setHypertext(crGlobalHandle::getInstance()->getTextDir()+m_textFile);
}
/////////////////////////////////////////
//
//crJXJRadioWidgetInitSelectMethod
//
/////////////////////////////////////////
crJXJRadioWidgetInitSelectMethod::crJXJRadioWidgetInitSelectMethod():
m_selectid(0){}
crJXJRadioWidgetInitSelectMethod::crJXJRadioWidgetInitSelectMethod(const crJXJRadioWidgetInitSelectMethod& handle):
	crMethod(handle),
	m_radioGroup(handle.m_radioGroup),
	m_selectid(handle.m_selectid)
{
}
void crJXJRadioWidgetInitSelectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJRadioWidgetInitSelectMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_radioGroup = str;
		break;
	case 1:
		m_selectid = atoi(str.c_str());
		break;
	}
}

void crJXJRadioWidgetInitSelectMethod::operator()(crHandle &handle)
{
	ref_ptr<crRadioGroupWidgetNode> radioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radioGroup));
	if(radioGroup.valid())
	{
		if(m_selectid<0)
		{
			radioGroup->getCurrentSelectedRadio()->select(false);
		}
		else
		{
			radioGroup->select(m_selectid);
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlatformCaseMethod
//
/////////////////////////////////////////
crJXJPlatformCaseMethod::crJXJPlatformCaseMethod(){}
crJXJPlatformCaseMethod::crJXJPlatformCaseMethod(const crJXJPlatformCaseMethod& handle):
	crMethod(handle)
{
}
void crJXJPlatformCaseMethod::inputParam(int i, void *param)
{
}
void crJXJPlatformCaseMethod::addParam(int i, const std::string& str)
{
	m_platformmap[str] = i+1;
}
void crJXJPlatformCaseMethod::operator()(crHandle &handle)
{
	int _case = 0;
	std::string platform = crMyPlayerData::getInstance()->getSelectedGame()->getPlatform();
	if(platform.empty())
	{
		std::string username = crMyPlayerData::getInstance()->getUserName();
		std::string::size_type comma = username.find_first_of('.');
		if(comma != std::string::npos)
			platform = std::string(username.begin(),username.begin()+comma);
	}
	if(!platform.empty())
	{
		std::map<std::string,int>::iterator itr = m_platformmap.find(platform);
		if(itr != m_platformmap.end())
		{
			_case = itr->second;
		}
	}
	handle.outputParam(0,&_case);
}
/////////////////////////////////////////
//
//crJXJBuyGoldURLMethod
//
/////////////////////////////////////////
crJXJBuyGoldURLMethod::crJXJBuyGoldURLMethod()
{
}
crJXJBuyGoldURLMethod::crJXJBuyGoldURLMethod(const crJXJBuyGoldURLMethod& handle):
	crMethod(handle),
	m_recharge(handle.m_recharge)
{
}
void crJXJBuyGoldURLMethod::inputParam(int i, void *param)
{
}
void crJXJBuyGoldURLMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_recharge = str;
		break;
	}
}
void crJXJBuyGoldURLMethod::operator()(crHandle &handle)
{
	std::string platform = crMyPlayerData::getInstance()->getSelectedGame()->getPlatform();
	std::string relname;
	if(platform.empty())
	{
		std::string username = crMyPlayerData::getInstance()->getUserName();
		std::string::size_type comma = username.find_first_of('.');
		if(comma != std::string::npos)
		{
			platform = std::string(username.begin(),username.begin()+comma);
			relname = std::string(username.begin()+comma + 1,username.end());
		}
		else
		{
			relname = username;
		}
	}
	ref_ptr<crTableIO> sitetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSiteTab);
	crTableIO::StrVec record;
	if(sitetab->queryOneRecord(0,platform,record)>=0)
	{
		int rechargeid = sitetab->getTitleIndex("Recharge");
		std::string url = record[rechargeid];
		if(platform.empty())
		{//自运营官网
			int playerid = crMyPlayerData::getInstance()->getPlayerID();
			int serverid = crMyPlayerData::getInstance()->getLastServerID();
			//http://www.quegame.com/index.php?
			std::string relurl = url+"player_id="+crArgumentParser::appItoa(playerid)+"&server_id=" + crArgumentParser::appItoa(serverid);
			ShellExecute(NULL,"open",relurl.c_str(),NULL,NULL,SW_SHOW);
		}
		else if(platform.compare("QQ")==0)
		{
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_recharge);
			if (canvas.valid())
			{
				crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
			}
		}
		else if(!url.empty())
		{//联运平台充值
			int serverid = crMyPlayerData::getInstance()->getWebServerID();
			//http://www.quegame.com/index.php?
			std::string relurl;
			//if(*(url.rbegin())=='?')
			//	relurl = url+"user="+relname+"&server=" + crArgumentParser::appItoa(serverid);
			//else
			//	relurl = url+"&user="+relname+"&server=" + crArgumentParser::appItoa(serverid);
			getDesstring(url,crArgumentParser::appItoa(serverid),relname,relurl);
			//MessageBox(NULL,relurl.c_str(),"",MB_OK);
			ShellExecute(NULL,"open",relurl.c_str(),NULL,NULL,SW_SHOW);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGoToSiteURLMethod
//
/////////////////////////////////////////
crJXJUIGoToSiteURLMethod::crJXJUIGoToSiteURLMethod()
{
}
crJXJUIGoToSiteURLMethod::crJXJUIGoToSiteURLMethod(const crJXJUIGoToSiteURLMethod& handle):
	crMethod(handle),
	m_title(handle.m_title)
{
}
void crJXJUIGoToSiteURLMethod::inputParam(int i, void *param)
{
}
void crJXJUIGoToSiteURLMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_title = str;
		break;
	}
}
void crJXJUIGoToSiteURLMethod::operator()(crHandle &handle)
{
	std::string platform = crMyPlayerData::getInstance()->getSelectedGame()->getPlatform();
	std::string relname;
	if(platform.empty())
	{
		std::string username = crMyPlayerData::getInstance()->getUserName();
		std::string::size_type comma = username.find_first_of('.');
		if(comma != std::string::npos)
		{
			platform = std::string(username.begin(),username.begin()+comma);
			relname = std::string(username.begin()+comma + 1,username.end());
		}
		else
		{
			relname = username;
		}
	}
	ref_ptr<crTableIO> sitetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSiteTab);
	crTableIO::StrVec record;
	if(sitetab->queryOneRecord(0,platform,record)>=0)
	{
		int index = sitetab->getTitleIndex(m_title);
		std::string url = record[index];
		//if (CRIOManager::fileExists("web.ini"))
		if(platform.compare("QQ")==0)
		{//tx
			if(CRCore::crDisplaySettings::instance()->getRunMode()==3)
			{
				TCHAR* str = new TCHAR[256] ;
				wsprintf(str,(LPCTSTR)url.c_str());

				HWND  hwnd = CRNetApp::crRunGameHandle::getInstance()->getParentWnd();
				COPYDATASTRUCT data;
				data.cbData = _msize(str);
				data.lpData = str;
				if (hwnd > 0 )
				{
					::SendMessage(hwnd,WM_USER+603,NULL,(LPARAM)&data);
				}
				delete [] str;
			}
			else
			{
				ShellExecute(NULL,"open",url.c_str(),NULL,NULL,SW_SHOW);
			}
		}
		else
		{
			ShellExecute(NULL,"open",url.c_str(),NULL,NULL,SW_SHOW);
		}
	}
}
///////////////////////////////////////////
////
////crJXJBuyGoldURLQQMethod
////
///////////////////////////////////////////
//crJXJBuyGoldURLQQMethod::crJXJBuyGoldURLQQMethod()
//{
//}
//crJXJBuyGoldURLQQMethod::crJXJBuyGoldURLQQMethod(const crJXJBuyGoldURLQQMethod& handle):
//	crMethod(handle),
//	m_recharge(handle.m_recharge)
//{
//}
//void crJXJBuyGoldURLQQMethod::inputParam(int i, void *param)
//{
//}
//void crJXJBuyGoldURLQQMethod::addParam(int i, const std::string& str)
//{
//	switch(i)
//	{
//	case 0:
//		m_recharge = str;
//		break;
//	}
//}
//void crJXJBuyGoldURLQQMethod::operator()(crHandle &handle)
//{
//	ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_recharge);
//	if (canvas.valid())
//	{
//		crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
//	}
//}
///////////////////////////////////////////
////
////crJXJBuyGoldURLSiteMethod
////
///////////////////////////////////////////
//crJXJBuyGoldURLSiteMethod::crJXJBuyGoldURLSiteMethod()
//{
//}
//crJXJBuyGoldURLSiteMethod::crJXJBuyGoldURLSiteMethod(const crJXJBuyGoldURLSiteMethod& handle):
//	crMethod(handle),
//	m_url(handle.m_url)
//{
//}
//void crJXJBuyGoldURLSiteMethod::inputParam(int i, void *param)
//{
//}
//void crJXJBuyGoldURLSiteMethod::addParam(int i, const std::string& str)
//{
//	switch(i)
//	{
//	case 0:
//		m_url = str;
//		break;
//	}
//}
//void crJXJBuyGoldURLSiteMethod::operator()(crHandle &handle)
//{
//	std::string username = crMyPlayerData::getInstance()->getUserName();
//	int serverid = crMyPlayerData::getInstance()->getLastServerID();
//	std::string type,relStr;
//	std::string::size_type comma = username.find_first_of('.');
//	type = std::string(username.begin(),username.begin()+comma);
//	relStr = std::string(username.begin()+comma + 1,username.end());
//
//	//http://www.quegame.com/index.php?
//	std::string url = m_url+"user="+relStr+"&server=" + crArgumentParser::appItoa(serverid);
//	ShellExecute(NULL,"open",url.c_str(),NULL,NULL,SW_SHOW);
//}
/////////////////////////////////////////
//
//crJXJSetUIScaleFactorTextMethod
//
/////////////////////////////////////////
crJXJSetUIScaleFactorTextMethod::crJXJSetUIScaleFactorTextMethod(){}
crJXJSetUIScaleFactorTextMethod::crJXJSetUIScaleFactorTextMethod(const crJXJSetUIScaleFactorTextMethod& handle):
	crMethod(handle),
	m_text(handle.m_text)
{
}
void crJXJSetUIScaleFactorTextMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crSliderWidgetNode*)param;
		break;
	}
}

void crJXJSetUIScaleFactorTextMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_text = str;
		break;
	}
}

void crJXJSetUIScaleFactorTextMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	if(canvas.valid())
	{
		ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_text));
		if(text.valid())
		{
			float v = m_this->getValue();
			float uiscalefactor = v*(1.2f-0.8f)+0.8f;
			char buf[16];
			memset(buf,0,16);
			sprintf(buf,"%.1f\0",uiscalefactor);
			text->setString(std::string(buf));
		}
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJTimerCanvasInitMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJTimerCanvasInitMethod::crJXJTimerCanvasInitMethod():
	m_this(NULL),
	m_interval(10),
	m_texid(0)
{

}
crJXJTimerCanvasInitMethod::crJXJTimerCanvasInitMethod(const crJXJTimerCanvasInitMethod &handle):
	crMethod(handle),
	m_this(NULL),
	m_interval(handle.m_interval),
	m_text(handle.m_text),
	m_texid(handle.m_texid)
{
}
void crJXJTimerCanvasInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJTimerCanvasInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_interval = atoi(str.c_str());
		break;
	case 1:
		m_text = str;
		break;
	case 2:
		m_texid = atoi(str.c_str());
		break;
	}
}
void crJXJTimerCanvasInitMethod::operator ()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->inputParam(WCHDATA_JXJCanvasTimer,&m_interval);
	ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_text));
	if(text.valid())
	{
		std::string output;
		if(m_texid>0)
		{
			std::string str = crArgumentParser::appItoa(m_interval);
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			noticeHandle->inputParam(WCHDATA_NoticeTextID,&m_texid);
			int mode = 2;
			noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
			noticeHandle->inputParam(WCHDATA_NoticeParam1,&str);
			noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
			crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
		}
		else
		{
			output = crArgumentParser::appItoa(m_interval);
		}
		text->setString(output);
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJTimerCanvasUpdateMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJTimerCanvasUpdateMethod::crJXJTimerCanvasUpdateMethod():
	m_this(NULL),
	m_texid(0)
{
}
crJXJTimerCanvasUpdateMethod::crJXJTimerCanvasUpdateMethod(const crJXJTimerCanvasUpdateMethod &handle):
	crMethod(handle),
	m_this(NULL),
	m_text(handle.m_text),
	m_button(handle.m_button),
	m_texid(handle.m_texid)
{
}
void crJXJTimerCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJTimerCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_text = str;
		break;
	case 1:
		m_button = str;
		break;
	case 2:
		m_texid = atoi(str.c_str());
		break;
	}
}
void crJXJTimerCanvasUpdateMethod::operator ()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJCanvasTimer,param);
	short timer = *(short*)param;
	if(timer>0)
	{
		timer--;
		if(timer<=0)
		{
			timer=0;
			ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_button));
			if(btn.valid())
			{
				btn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
			}
		}
		ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_text));
		if(text.valid())
		{
			std::string output;
			if(m_texid>0)
			{
				std::string str = crArgumentParser::appItoa(timer);
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&m_texid);
				int mode = 2;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				noticeHandle->inputParam(WCHDATA_NoticeParam1,&str);
				noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
			}
			else
			{
				output = crArgumentParser::appItoa(timer);
			}
			text->setString(output);
		}
		data->inputParam(WCHDATA_JXJCanvasTimer,&timer);
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJTelhuodongMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJTelhuodongMethod::crJXJTelhuodongMethod():
	m_this(NULL)
{
}
crJXJTelhuodongMethod::crJXJTelhuodongMethod(const crJXJTelhuodongMethod &handle):
	crMethod(handle),
	m_this(NULL),
	m_text(handle.m_text)
{
}
void crJXJTelhuodongMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJTelhuodongMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_text = str;
		break;
	}
}
void crJXJTelhuodongMethod::operator ()(crHandle &handle)
{
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_text));
	if(input.valid())
	{
		std::string tel = input->getUTF8String();
		if(tel.size() == 11)
		{
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(16);
				stream->_writeString(tel);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvTelhuodong,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvTelhuodongMethod
//
/////////////////////////////////////////
crJXJRecvTelhuodongMethod::crJXJRecvTelhuodongMethod():
	m_netType(GameClient_Game){}
crJXJRecvTelhuodongMethod::crJXJRecvTelhuodongMethod(const crJXJRecvTelhuodongMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvTelhuodongMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTelhuodongMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvTelhuodongMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			std::string tel = m_stream->_readString();
			if(tel.size()==11)
			{
				crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
				if (m_this->getMainRole() && m_this->getMainRole()->getDataClass() && dbConductor)
				{
					void *param;
					crData *mainroledata = m_this->getMainRole()->getDataClass();
					mainroledata->excHandle(MAKEINT64(WCH_LockData,1));
					mainroledata->getParam(WCHDATA_JXJNewHuodongMap, param);
					NewHuodongMap *huodongMap= (NewHuodongMap *)param;
					NewHuodongMap ::iterator hitr = huodongMap->find(Activation_Telephone);
					if(hitr != huodongMap->end() && hitr->second->isActivation())
					{
						hitr->second->setStep(1,m_this->getPlayerID());

						ref_ptr<crJXJUpdateTel> updatetel = new crJXJUpdateTel;
						updatetel->buildUpdateSql(m_this->getPlayerID(),tel);
						crDBSavePacket dbpacket;
						crDBSavePacket::buildRequestPacket(dbpacket,updatetel.get(),-1);
						dbConductor->getNetManager()->sendPacket("all",dbpacket);
					}
					mainroledata->excHandle(MAKEINT64(WCH_LockData,0));
				}
			}
		}
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJQiyuCanvasInitMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJQiyuCanvasInitMethod::crJXJQiyuCanvasInitMethod():
	m_this(NULL)
{
}
crJXJQiyuCanvasInitMethod::crJXJQiyuCanvasInitMethod(const crJXJQiyuCanvasInitMethod &handle):
	crMethod(handle),
	m_this(NULL),
	m_taskname(handle.m_taskname),
	m_taskdes(handle.m_taskdes),
	m_taskaward(handle.m_taskaward)
{
}
void crJXJQiyuCanvasInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJQiyuCanvasInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskname = str;
		break;
	case 1:
		m_taskdes = str;
		break;
	case 2:
		m_taskaward = str;
		break;
	}
}

void crJXJQiyuCanvasInitMethod::operator ()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *roledata = myPlayer->getMainRole()->getDataClass();
	void *param;
	roledata->getParam(WCHDATA_JXJQiyuTaskID,param);
	int qiyutaskid = *(int *)param;
	if(qiyutaskid>0)
	{
		ref_ptr<crTableIO> taskTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTab);
		int nameindex = taskTab->getTitleIndex("Name");
		int desindex = taskTab->getTitleIndex("任务描述");
		int awardindex = taskTab->getTitleIndex("奖励描述");
		int param1index = taskTab->getTitleIndex("参数1");
		crTableIO::StrVec record;
		if(taskTab->queryOneRecord(0,crArgumentParser::appItoa(qiyutaskid),record)>=0)
		{
			std::vector<float>v_i;										
			v_i.push_back(255.0f);									
			v_i.push_back(222.0f);									
			v_i.push_back(0.0f);									
			v_i.push_back(255.0f);
			ref_ptr<crHypertextWidgetNode> taskname = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_taskname));
			if(taskname.valid())
			{
				int n = 1;
				std::string str = "激活奇遇任务“";
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");

				cfg_script.Add("Content");
				cfg_script.Push("Content",n++);
				cfg_script.Add("Text",str);
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",n++);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text",record[nameindex]);
				cfg_script.Pop();

				str = "”";
				cfg_script.Add("Content");
				cfg_script.Push("Content",n++);
				cfg_script.Add("Text",str);
				cfg_script.Pop();

				cfg_script.Pop();
				taskname->setHypertext(cfg_script);
			}
			ref_ptr<crStaticTextWidgetNode> taskdes = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_taskdes));
			if(taskdes.valid())
			{
				std::string desstr = record[desindex];
				std::string output;
				int count = 0;
				crData *data = myPlayer->getDataClass();
				switch (qiyutaskid)
				{
				case 23000:
					data->getParam(WCHDATA_JXJDayKillPlayerCount,param);
					count = *(int*)param;
					break;
				case 23001:
					data->getParam(WCHDATA_JXJDayKillNPCCount,param);
					count = *(int*)param;
					break;
				case 23002:
					{
						data->getParam(WCHDATA_JXJDayKillEachTroops,param);
						crVector4i counts = *(crVector4i*)param;
						count = counts[0];
					}
					break;
				case 23003:
					{
						data->getParam(WCHDATA_JXJDayKillEachTroops,param);
						crVector4i counts = *(crVector4i*)param;
						count = counts[1];
					}
					break;
				case 23004:
					{
						data->getParam(WCHDATA_JXJDayKillEachTroops,param);
						crVector4i counts = *(crVector4i*)param;
						count = counts[2];
					}
					break;
				}
				getDesstring(desstr,crArgumentParser::appItoa(count),record[param1index],output);

				taskdes->setString(output);
			}
			ref_ptr<crStaticTextWidgetNode> taskaward = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_taskaward));
			if(taskaward.valid())
			{
				taskaward->setString(record[awardindex]);
			}
		}
	}

}
/////////////////////////////////////////
//
//crJXJCheckQiyuTaskMethod
//
/////////////////////////////////////////
crJXJCheckQiyuTaskMethod::crJXJCheckQiyuTaskMethod():
	m_trueExecCount(1)
{
}
crJXJCheckQiyuTaskMethod::crJXJCheckQiyuTaskMethod(const crJXJCheckQiyuTaskMethod& handle):
	crMethod(handle),
	m_trueExecCount(handle.m_trueExecCount)
{
}
void crJXJCheckQiyuTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crGameTask*)param;
		break;
	}
}
void crJXJCheckQiyuTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_trueExecCount = (char)(atoi(str.c_str()));
		break;
	}
}
void crJXJCheckQiyuTaskMethod::operator()(crHandle &handle)
{
	bool check = false;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData && playerData->getDataClass())
	{
		void *param;
		if (m_trueExecCount != 0)
		{
			crData *data = playerData->getDataClass();
			if (data)
			{
				std::vector<std::string> record;
				ref_ptr<crTableIO> taskTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTab);
				int paramid = taskTab->getTitleIndex("参数1");
				if(taskTab->queryOneRecord(0,crArgumentParser::appItoa(m_this->getTaskID()),record)>=0)
				{
					int p = atoi(record[paramid].c_str());
					switch (m_this->getTaskID())
					{
					case 23000:
						{
							data->getParam(WCHDATA_JXJDayKillPlayerCount,param);
							int count = *(int*)param;
							if (count >= p)
							{
								check = true;
							}
						}
						break;
					case 23001:
						{
							data->getParam(WCHDATA_JXJDayKillNPCCount,param);
							int count = *(int*)param;
							if (count >= p)
							{
								check = true;
							}
						}
						break;
					case 23002:
						{//弓
							data->getParam(WCHDATA_JXJDayKillEachTroops,param);
							crVector4i counts = *(crVector4i*)param;
							if (counts[0] >= p)
							{
								check = true;
							}
						}
						break;
					case 23003:
						{//步兵
							data->getParam(WCHDATA_JXJDayKillEachTroops,param);
							crVector4i counts = *(crVector4i*)param;
							if (counts[1] >= p)
							{
								check = true;
							}
						}
						break;
					case 23004:
						{//骑兵
							data->getParam(WCHDATA_JXJDayKillEachTroops,param);
							crVector4i counts = *(crVector4i*)param;
							if (counts[2] >= p)
							{
								check = true;
							}
						}
						break;
					}
					if(check && m_trueExecCount>0)
						m_trueExecCount--;
				}
			}
		}
	}
	handle.outputParam(0,&check);
}
/////////////////////////////////////////
//
//crJXJAddExtraProduceMethod
//
/////////////////////////////////////////
crJXJAddExtraProduceMethod::crJXJAddExtraProduceMethod(){}
crJXJAddExtraProduceMethod::crJXJAddExtraProduceMethod(const crJXJAddExtraProduceMethod& handle):
	crMethod(handle)
{
}
void crJXJAddExtraProduceMethod::inputParam(int i, void *param)
{

	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_award = *(crVector3i*)(LOINT64(param64));
		}
		break;
	}
}

void crJXJAddExtraProduceMethod::addParam(int i, const std::string& str)
{
}

void crJXJAddExtraProduceMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	ref_ptr<crExtraProduce> extraProduce = new crExtraProduce;
	extraProduce->timer() = m_award[1];
	extraProduce->setPercent(m_award[2]);
	data->excHandle(MAKEINT16(WCH_LockData,1));
	data->getParam(WCHDATA_JXJExtraProduceMap,param);
	ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
	(*extraProduceMap)[m_award[0]] = extraProduce;
	data->excHandle(MAKEINT16(WCH_LockData,0));

	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
	if(playerData.valid())
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(12);
		stream->_writeVec3i(m_award);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvAddExtraProduce,stream.get());
		gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvAddExtraProduceMethod
//
/////////////////////////////////////////
crJXJRecvAddExtraProduceMethod::crJXJRecvAddExtraProduceMethod(){}
crJXJRecvAddExtraProduceMethod::crJXJRecvAddExtraProduceMethod(const crJXJRecvAddExtraProduceMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvAddExtraProduceMethod::inputParam(int i, void *param)
{

	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvAddExtraProduceMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvAddExtraProduceMethod::operator()(crHandle &handle)
{
	if( m_stream.valid())
	{
		if(m_netType = GameClient_Game)
		{
			crVector3i award = m_stream->_readVec3i();
			crData *data = m_this->getDataClass();
			void *param;
			ref_ptr<crExtraProduce> extraProduce = new crExtraProduce;
			extraProduce->timer() = award[1];
			extraProduce->setPercent(award[2]);
			data->excHandle(MAKEINT16(WCH_LockData,1));
			data->getParam(WCHDATA_JXJExtraProduceMap,param);
			ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
			(*extraProduceMap)[award[0]] = extraProduce;
			data->excHandle(MAKEINT16(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJQiyuTipsMethod
//
/////////////////////////////////////////
crJXJQiyuTipsMethod::crJXJQiyuTipsMethod():
	m_this(NULL)
{
}

crJXJQiyuTipsMethod::crJXJQiyuTipsMethod(const crJXJQiyuTipsMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_tiptext(handle.m_tiptext),
	m_this(NULL),
	m_taskname(handle.m_taskname)
{
}
void crJXJQiyuTipsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJQiyuTipsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_taskname = str;
		break;
	case 2:
		m_tiptext = str;
		break;
	}
}

void crJXJQiyuTipsMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode> tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	if(!tips.valid())
		return;
	ref_ptr<crStaticTextWidgetNode>  taskname = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_taskname));
	ref_ptr<crStaticTextWidgetNode>  tiptext = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_tiptext));

	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *roledata = myPlayer->getMainRole()->getDataClass();
	void *param;
	roledata->getParam(WCHDATA_JXJQiyuTaskID,param);
	int qiyutaskid = *(int *)param;
	if(qiyutaskid>0)
	{
		ref_ptr<crTableIO> taskTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTab);
		int nameindex = taskTab->getTitleIndex("Name");
		int desindex = taskTab->getTitleIndex("任务描述");
		int awardindex = taskTab->getTitleIndex("奖励描述");
		int param1index = taskTab->getTitleIndex("参数1");
		crTableIO::StrVec record;
		if(taskTab->queryOneRecord(0,crArgumentParser::appItoa(qiyutaskid),record)>=0)
		{
			if(taskname.valid())
			{
				taskname->setString(record[nameindex]);
			}
			if(tiptext.valid())
			{
				std::string desstr = record[desindex];
				std::string output;
				int count = 0;
				crData *data = myPlayer->getDataClass();
				switch (qiyutaskid)
				{
				case 23000:
					data->getParam(WCHDATA_JXJDayKillPlayerCount,param);
					count = *(int*)param;
					break;
				case 23001:
					data->getParam(WCHDATA_JXJDayKillNPCCount,param);
					count = *(int*)param;
					break;
				case 23002:
					{
						data->getParam(WCHDATA_JXJDayKillEachTroops,param);
						crVector4i counts = *(crVector4i*)param;
						count = counts[0];
					}
					break;
				case 23003:
					{
						data->getParam(WCHDATA_JXJDayKillEachTroops,param);
						crVector4i counts = *(crVector4i*)param;
						count = counts[1];
					}
					break;
				case 23004:
					{
						data->getParam(WCHDATA_JXJDayKillEachTroops,param);
						crVector4i counts = *(crVector4i*)param;
						count = counts[2];
					}
					break;
				}
				getDesstring(desstr,crArgumentParser::appItoa(count),record[param1index],output);

				output +="\n" + record[awardindex];

				int timer = 0;
				std::string endtime = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQiYuEndTime,0);
				time_t curt = time(0);
				char tmp[20];
				strftime( tmp, sizeof(tmp), "%H:%M:%S\0", localtime(&curt) );
				crVector3i endtm,curtm,intm;
				crArgumentParser::appTimetoVec(endtime,endtm);
				crArgumentParser::appTimetoVec(tmp,curtm);
				if(curtm<endtm)
				{
					intm = endtm - curtm;
					timer = intm[0] * 3600 + intm[1] * 60 + intm[2];
				}
				int hour = timer/3600;
				int t = timer%3600;
				int minute = t/60;
				int s = t%60;
				if(hour>0)
				{
					output += "\n剩余时间:"+crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s);
				}
				else if(minute>0)
				{
					output += "\n剩余时间:0:"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s);
				}
				else if(s>0)
				{
					output += "\n剩余时间:0:0："+crArgumentParser::appItoa(s);
				}
				tiptext->setString(output);
			}
		}
	}

	const crBoundingBox &btnbox = m_this->getBoundBox();
	const crBoundingBox &tipsbox = tips->getBoundBox();
	const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
	float posx = btnbox.m_min[0];
	float posy = btnbox.m_min[1];
	////////////
	crVector2 mouse(crVector2(posx,posy));
	tips->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
	tips->setCanFocus(false);
	crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
}
/////////////////////////////////////////
//
//crJXJSearchRoleDataParamMethod
//
/////////////////////////////////////////
crJXJSearchRoleDataParamMethod::crJXJSearchRoleDataParamMethod():
	m_this(NULL),
	m_paramid(0),
	m_datatype(0)
{
}
crJXJSearchRoleDataParamMethod::crJXJSearchRoleDataParamMethod(const crJXJSearchRoleDataParamMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_paramid(handle.m_paramid),
	m_datatype(handle.m_datatype)
{
}
void crJXJSearchRoleDataParamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crJXJAccomplish*)param;
		break;
	}
}
void crJXJSearchRoleDataParamMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_paramid = atoi(str.c_str());
		break;
	case 1:
		m_datatype = (unsigned char)(atoi(str.c_str()));
		break;
	}
}
void crJXJSearchRoleDataParamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		crRole *mainRole = playerGameData->getMainRole();
		crData *mainRoleData = mainRole->getDataClass();
		mainRoleData->getParam(m_paramid,param);
		unsigned char step = 0;
		switch (m_datatype)
		{
		case JXJDataType_Char:
			{
				step = *(char *)param;
			}
			break;
		case JXJDataType_UChar:
			{
				step = *(unsigned char *)param;
			}
			break;
		case JXJDataType_Short:
			{
				step = *(short *)param;
			}
			break;
		case JXJDataType_UShort:
			{
				step = *(unsigned short *)param;
			}
			break;
		case JXJDataType_Int:
			{
				step = *(int *)param;
			}
			break;
		case JXJDataType_UInt:
			{
				step = *(unsigned int *)param;
			}
			break;
		case JXJDataType_Int64:
			{
				step = *(_crInt64 *)param;
			}
			break;
		}
		m_this->setStep(step);
	}
}

/////////////////////////////////////////
//
//crJXJSearchRoleDataParamCheckMethod
//
/////////////////////////////////////////
crJXJSearchRoleDataParamCheckMethod::crJXJSearchRoleDataParamCheckMethod():
	m_this(NULL),
	m_player(NULL)
{
}
crJXJSearchRoleDataParamCheckMethod::crJXJSearchRoleDataParamCheckMethod(const crJXJSearchRoleDataParamCheckMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_player(NULL)
{
}
void crJXJSearchRoleDataParamCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_player = NULL;
		}
		break;
	case 1:
		m_this = (crJXJAccomplish*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_player = (crPlayerGameData *)(LOINT64(param64));
		}
		else
		{
			m_player = NULL;
		}
		break;
	}
}
void crJXJSearchRoleDataParamCheckMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_paramid = atoi(str.c_str());
		break;
	case 1:
		m_datatype = (unsigned char)(atoi(str.c_str()));
		break;
	}
}
void crJXJSearchRoleDataParamCheckMethod::operator()(crHandle &handle)
{
	if(m_player)
	{
		void *param;
		crRole *mainRole = m_player->getMainRole();
		crData *mainRoleData = mainRole->getDataClass();
		mainRoleData->getParam(m_paramid,param);
		unsigned char step = 0;
		switch (m_datatype)
		{
		case JXJDataType_Char:
			{
				step = *(char *)param;
			}
			break;
		case JXJDataType_UChar:
			{
				step = *(unsigned char *)param;
			}
			break;
		case JXJDataType_Short:
			{
				step = *(short *)param;
			}
			break;
		case JXJDataType_UShort:
			{
				step = *(unsigned short *)param;
			}
			break;
		case JXJDataType_Int:
			{
				step = *(int *)param;
			}
			break;
		case JXJDataType_UInt:
			{
				step = *(unsigned int *)param;
			}
			break;
		case JXJDataType_Int64:
			{
				step = *(_crInt64 *)param;
			}
			break;
		}
		m_this->setStep(step);
	}
}
/////////////////////////////////////////
//
//crJXJMyCounrtyShopCanvasUpdateNewMethod
//
/////////////////////////////////////////
crJXJMyCounrtyShopCanvasUpdateNewMethod::crJXJMyCounrtyShopCanvasUpdateNewMethod():
	m_this(NULL)
{
}

crJXJMyCounrtyShopCanvasUpdateNewMethod::crJXJMyCounrtyShopCanvasUpdateNewMethod(const crJXJMyCounrtyShopCanvasUpdateNewMethod& handle):
	crMethod(handle),
	m_scroll (handle.m_scroll),
	m_typeRadio(handle.m_typeRadio),
	m_contribute(handle.m_contribute),
	m_govpostcheck(handle.m_govpostcheck)
{
	for (int i = 0; i < 12; ++ i)
	{
		m_icon[i] = handle.m_icon[i];
		m_num[i] = handle.m_num[i];
		m_price[i] = handle.m_price[i];
		m_buybtn[i] = handle.m_buybtn[i];
	}
}

void crJXJMyCounrtyShopCanvasUpdateNewMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJMyCounrtyShopCanvasUpdateNewMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
	case 11:
		m_icon[i] = str;
		break;
	case 12:
	case 13:
	case 14:
	case 15:
	case 16:
	case 17:
	case 18:
	case 19:
	case 20:
	case 21:
	case 22:
	case 23:
		m_num[i-12] = str;
		break;
	case 24:
	case 25:
	case 26:
	case 27:
	case 28:
	case 29:
	case 30:
	case 31:
	case 32:
	case 33:
	case 34:
	case 35:
		m_price[i-24] = str;
		break;
	case 36:
	case 37:
	case 38:
	case 39:
	case 40:
	case 41:
	case 42:
	case 43:
	case 44:
	case 45:
	case 46:
	case 47:
		m_buybtn[i-36] = str;
		break;
	case 48:
		m_scroll = str;
		break;
	case 49:
		m_typeRadio = str;
		break;
	case 50:
		m_contribute = str;
		break;
	case 51:
		m_govpostcheck = str;
		break;
	}
}

void crJXJMyCounrtyShopCanvasUpdateNewMethod::operator()(crHandle &handle)
{
	//成就商店
	void *param;
	crData *mainRoleData = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole()->getDataClass();
	mainRoleData->getParam(WCHDATA_JXJGovPost, param);
	unsigned char mypost = *(unsigned char *)param;
	crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	data->getParam(WCHDATA_JXJCountryContribute,param);
	int contribute = *(int *)param;
	data->getParam(WCHDATA_JXJGovShopMap,param);
	GovShopMap *govShopMap = (GovShopMap *)param;
	std::string commodityc;
	std::string strImageName;
	crTableIO::StrVec itemrecord;
	ref_ptr<crImageBoxWidgetNode > imageBox[12] = {NULL};
	ref_ptr<crStaticTextWidgetNode > priceInput[12] = {NULL};
	ref_ptr<crStaticTextWidgetNode > countInput[12] = {NULL};
	ref_ptr<crButtonWidgetNode> buyBtn[12] = {NULL};
	ref_ptr<crScrollBarWidgetNode>  shopscroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scroll));
	ref_ptr<crRadioGroupWidgetNode> typeRaido = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_typeRadio));
	ref_ptr<crCheckBoxWidgetNode> govpostcheck = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_govpostcheck));
	ref_ptr<crStaticTextWidgetNode> contributeText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_contribute));
	contributeText->setString(crArgumentParser::appItoa(contribute));
	int typeselect = typeRaido->getSelect();
	bool govpostselect = govpostcheck->getSelect();
	//ref_ptr<crTableIO> equipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
	//int eIconIndex = equipTab->getTitleIndex("icon");
	ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
	int iconIdx = itemtab->getTitleIndex("icon"); 
	ref_ptr<crTableIO> shoptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostShopTab);
	int priceindex = shoptab->getTitleIndex("消耗贡献");
	int govpostindex = shoptab->getTitleIndex("官职需求");
	int typeindex = shoptab->getTitleIndex("类型");
	int buycountindex = shoptab->getTitleIndex("购买次数");
	crTableIO::DataVec datavec;
	shoptab->queryRecords(typeindex,crArgumentParser::appItoa(typeselect),datavec);
	crTableIO::StrVec record;
	int buycount = 0;
	for( crTableIO::DataVec::iterator itr = datavec.begin();
		itr != datavec.end(); )
	{
		record = *itr;
		if(govpostselect)
		{//只显示官职可以购买
			if(mypost<atoi(record[govpostindex].c_str()))
			{
				itr = datavec.erase(itr);
				continue;
			}
		}
		buycount = atoi(record[buycountindex].c_str());
		if(buycount>0)
		{//购买次数上限
			CRCore::ScopedLock<crData> lock(*data);
			GovShopMap::iterator gitr = govShopMap->find(atoi(record[0].c_str()));
			if(gitr != govShopMap->end())
			{
				if(buycount<=gitr->second)
				{
					itr = datavec.erase(itr);
					continue;
				}
			}
		}
		++itr;
	}
	int cRow = datavec.size();
	int val = 0;
	if(shopscroll.valid())
	{
		if (cRow < 12)
		{
			shopscroll->setEnable(false);
		}
		else
		{
			shopscroll->setEnable(true);
			int crows = cRow%6==0? cRow/6 : cRow/6+1;
			shopscroll->setRange(0, crows-2);
			shopscroll->setLineValue(1.0f);
			shopscroll->setPageValue(1.0f);
			val = shopscroll->getValue();
		}
	}
	int id = 0;
	unsigned char shopid = 0;
	int itemid = 0;
	int itemcount = 1;
	int price;
	unsigned char needpost;
	bool canbuy = true;
	int count;
	crData *canvasData = m_this->getDataClass();
	CRCore::ScopedLock<crData> lock(*canvasData);
	canvasData->getParam(WCHDATA_JXJGovShopIDVec,param);
	GovShopIDVec *govShopIDVec = (GovShopIDVec *)param;
	govShopIDVec->resize(12,-1);
	for (int i = 0; i < 12; i++)
	{
		imageBox[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon[i]));
		buyBtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_buybtn[i]));
		priceInput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_price[i]));
		countInput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_num[i]));
		if (buyBtn[i].valid())
			buyBtn[i]->setEnable(false);
		if (imageBox[i].valid())
			imageBox[i]->setVisiable(false);
		if (priceInput[i].valid())
			priceInput[i]->clearString();
		if (countInput[i].valid())
			countInput[i]->clearString();
		countInput[i]->setVisiable(false);
		id = i+6*val;
		if(id < cRow) 
		{
			record = datavec[id];
			shopid = atoi(record[0].c_str());
			itemid = atoi(record[1].c_str());
			if(itemtab->queryOneRecord(0,record[1],itemrecord)>=0)
			{
				strImageName = itemrecord[iconIdx];
			}
			canbuy = true;
			count = 0;
			do 
			{
				buycount = atoi(record[buycountindex].c_str());
				count = buycount;
				if(buycount>0)
				{
					CRCore::ScopedLock<crData> lock(*data);
					GovShopMap::iterator itr = govShopMap->find(shopid);
					if(itr != govShopMap->end())
					{
						if(buycount>itr->second)
						{
							count = buycount - itr->second;
							break;
						}
					}
				}
				price = atoi(record[priceindex].c_str());
				if(contribute < price)
				{
					canbuy = false;
					break;
				}
				needpost = atoi(record[govpostindex].c_str());
				if(mypost < needpost)
				{
					canbuy = false;
					break;
				}
			} while (0);

			if (priceInput[i].valid())	
				priceInput[i]->setString(record[priceindex]);
			if (countInput[i].valid())
			{
				if(count > 0)
				{
					countInput[i]->setString(crArgumentParser::appItoa(count));
					countInput[i]->setVisiable(true);
				}
			}
			if (imageBox[i].valid())
			{
				imageBox[i]->setVisiable(true);
				imageBox[i]->setImageName(strImageName);
				crData* uiData = imageBox[i]->getDataClass();
				if (uiData)
				{
					uiData->inputParam(0,&itemid);
					uiData->inputParam(1,&itemcount);
				}
			}
			if (buyBtn[i].valid())
			{
				buyBtn[i]->setVisiable(true);
				buyBtn[i]->setEnable(canbuy);
			}
		}
		else
		{
			shopid = -1;
		}
		(*govShopIDVec)[i] = shopid;
	}
}
/////////////////////////////////////////
//
//crJXJScrollMethod
//
/////////////////////////////////////////
crJXJScrollMethod::crJXJScrollMethod()
{
}

crJXJScrollMethod::crJXJScrollMethod(const crJXJScrollMethod& handle):
	crMethod(handle),
	m_type(handle.m_type)
{
}

void crJXJScrollMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crScrollBarWidgetNode*)param;
		break;
	}
}

void crJXJScrollMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_type = atoi(str.c_str());
		break;
	}
}

void crJXJScrollMethod::operator()(crHandle &handle)
{
	if (!m_type)
	{
		m_this->setValue(m_this->getValue() - m_this->getLineValue());
	}
	else
	{
		m_this->setValue(m_this->getValue() + m_this->getLineValue());
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJCountryShopTipsMethod
//
//////////////////////////////////////////////////////////////////////////
crJXJCountryShopTipsMethod::crJXJCountryShopTipsMethod()
{}
crJXJCountryShopTipsMethod::crJXJCountryShopTipsMethod(const crJXJCountryShopTipsMethod& handle)
{

}
void crJXJCountryShopTipsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode *)param;
		break;
	}
}
void crJXJCountryShopTipsMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tiptext = str;
		break;
	case 2:
		m_index = atoi(str.c_str());
		break;
	}
}

void crJXJCountryShopTipsMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
		if (canvas.valid())
		{
			std::string buildingname;
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			ref_ptr<crTableIO>govpostshoptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostShopTab);
			crData *data = playerGameData->getDataClass();
			crData *mainroledata = playerGameData->getMainRole()->getDataClass();
			int nameindex = itemtab->getTitleIndex("name");
			int priceindex = govpostshoptab->getTitleIndex("消耗贡献");
			int govpostindex = govpostshoptab->getTitleIndex("官职需求");
			int buycountindex = govpostshoptab->getTitleIndex("购买次数");
			unsigned char shopid = 0;
			int itemid = 0;
			int price = 0;
			int needgovpost = 0;
			int remaincount = 0;
			int mode = 2;
			std::string tiptext;
			std::string output;
			crTableIO::StrVec recordg;
			crData *canvasdata = m_this->getParentCanvas()->getDataClass();
			if (canvasdata)
			{
				canvasdata->excHandle(MAKEINT64(WCH_LockData,1));
				canvasdata->getParam(WCHDATA_JXJGovShopIDVec,param);
				GovShopIDVec *itemiddeq = (GovShopIDVec *)param;
				if (m_index < itemiddeq->size())
				{
					shopid = (*itemiddeq)[m_index];
					if(govpostshoptab->queryOneRecord(0,crArgumentParser::appItoa(shopid),recordg) >= 0)
					{
						itemid = atoi(recordg[1].c_str());
					}
				}
				canvasdata->excHandle(MAKEINT64(WCH_LockData,0));
			}
			int texid;
			crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
			mainroledata -> getParam(WCHDATA_JXJGovPost,param);
			unsigned char govPost = *(unsigned char *)param;
			data -> getParam(WCHDATA_JXJCountryContribute,param);
			int mycountrycontribute = *(int *)param;
			if (itemid > 0)
			{
				crTableIO::StrVec record;
				if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0)
				{
					if (nameindex > 0 && priceindex > 0 && govpostindex > 0)
					{
						price = atoi(recordg[priceindex].c_str());
						needgovpost = atoi(recordg[govpostindex].c_str());
						int canbuycount = atoi(recordg[buycountindex].c_str());
						if(canbuycount>0)
						{
							data->excHandle(MAKEINT64(WCH_LockData,1));
							data->getParam(WCHDATA_JXJGovShopMap,param);
							GovShopMap *govShopMap = (GovShopMap *)param;
							GovShopMap::iterator itr = govShopMap->find(shopid);
							if(itr != govShopMap->end())
							{
								remaincount = canbuycount - itr->second;
							}
							else
							{
								remaincount = canbuycount;
							}
							data->excHandle(MAKEINT64(WCH_LockData,0));
							texid = 2117;
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							std::string param1 = crArgumentParser::appItoa(remaincount);
							noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
							tiptext = output;
						}
						if(mycountrycontribute < price)
						{
							texid = 2048;
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
							int mode = 2;
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
							if(tiptext.empty())
								tiptext = output;
							else
							{
								tiptext += "\n"+output;
							}
						}
						if(govPost<needgovpost)
						{
							texid = 2116;
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
							int mode = 2;
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
							if(tiptext.empty())
								tiptext = output;
							else
							{
								tiptext += "\n"+output;
							}
						}
					}
				}
				int needbagcount = 1;
				playerGameData->doEvent(WCH_JXJCheckBagEmptyBag,MAKEINT64(&needbagcount,NULL));
				if (needbagcount != 0)
				{//背包不足
					texid = 2008;
					noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
					int mode = 2;
					noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
					noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
					crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
					if(tiptext.empty())
						tiptext = output;
					else
					{
						tiptext += "\n"+output;
					}
				}
				if (!tiptext.empty())
				{
					ref_ptr<crStaticTextWidgetNode>  tipsText = dynamic_cast< crStaticTextWidgetNode  *>(canvas->getWidget(m_tiptext));
					tipsText->setString(tiptext);

					const crBoundingBox &btnbox = m_this->getBoundBox();
					const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
					float posx = btnbox.center()[0];
					float posy = btnbox.center()[1];
					////////////
					crVector2 mouse(crVector2(posx,posy));
					canvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
			}
		}
	}
}
//////////////////////////////////////////////////////////////////////////
//
//crJXJReloadVersionTabMethod
//
//
//////////////////////////////////////////////////////////////////////////
crJXJReloadVersionTabMethod::crJXJReloadVersionTabMethod():
	m_id(0)
{}
crJXJReloadVersionTabMethod::crJXJReloadVersionTabMethod(const crJXJReloadVersionTabMethod& handle):
	m_id(handle.m_id)
{
}
void crJXJReloadVersionTabMethod::inputParam(int i, void *param)
{
}
void crJXJReloadVersionTabMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_id = atoi(str.c_str());
		break;
	}
}

void crJXJReloadVersionTabMethod::operator()(crHandle &handle)
{
	crGlobalHandle::gData()->reloadGlobalTable(m_id);
}
/////////////////////////////////////////
//
//crJXJAddTroopsMethod
//
/////////////////////////////////////////
crJXJAddTroopsMethod::crJXJAddTroopsMethod(){}
crJXJAddTroopsMethod::crJXJAddTroopsMethod(const crJXJAddTroopsMethod& handle):
	crMethod(handle)
{
}
void crJXJAddTroopsMethod::inputParam(int i, void *param)
{

	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_award = *(crVector2i*)(LOINT64(param64));
		}
		break;
	}
}

void crJXJAddTroopsMethod::addParam(int i, const std::string& str)
{
}

void crJXJAddTroopsMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	int count = 0;
	data->excHandle(MAKEINT16(WCH_LockData,1));
	data->getParam(WCHDATA_JXJTroopsMap,param);
	TroopsMap *troopsMap = (TroopsMap *)param;
	TroopsMap::iterator titr = troopsMap->find(m_award[0]);
	if (titr != troopsMap->end())
	{
		titr->second += m_award[1];
		if (titr->second < 0)
		{
			titr->second = 0;
		}
		count = titr->second;
	}
	else if (m_award[1] > 0)
	{
		troopsMap->insert(std::make_pair(m_award[0],m_award[1]));
		count = m_award[1];
	}
	data->excHandle(MAKEINT16(WCH_LockData,0));

	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
	if(playerData.valid())
	{
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(8);
		stream->_writeInt(m_award[0]);
		stream->_writeInt(count);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvTroops,stream.get());
		gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvTroopsMethod
//
/////////////////////////////////////////
crJXJRecvTroopsMethod::crJXJRecvTroopsMethod(){}
crJXJRecvTroopsMethod::crJXJRecvTroopsMethod(const crJXJRecvTroopsMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvTroopsMethod::inputParam(int i, void *param)
{

	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTroopsMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvTroopsMethod::operator()(crHandle &handle)
{
	if( m_stream.valid())
	{
		if(m_netType = GameClient_Game)
		{
			int id,count,extra;
			id = m_stream->_readInt();
			count = m_stream->_readInt();
			void *param;
			crData *userData = m_this->getDataClass();
			userData->excHandle(MAKEINT64(WCH_LockData,1));
			userData->getParam(WCHDATA_JXJTroopsMap,param);
			TroopsMap *troopsMap = (TroopsMap *)param;
			if(troopsMap->find(id)!=troopsMap->end())
			{
				extra = count-(*troopsMap)[id];
			}
			else
				extra = count;

			(*troopsMap)[id] = count;
			userData->excHandle(MAKEINT64(WCH_LockData,0));
			if(extra!=0)
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(id,extra));
		}
	}
}
/////////////////////////////////////////
//
//crJXJIsNewGuideTaskMethod
//
/////////////////////////////////////////
crJXJIsNewGuideTaskMethod::crJXJIsNewGuideTaskMethod()
{
}
crJXJIsNewGuideTaskMethod::crJXJIsNewGuideTaskMethod(const crJXJIsNewGuideTaskMethod& handle):
	crMethod(handle)
{
}
void crJXJIsNewGuideTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJIsNewGuideTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJIsNewGuideTaskMethod::operator()(crHandle &handle)
{
	bool condition = false;
	crData *data = m_this->getDataClass();
	void *param;
	data->getParam(WCHDATA_JXJGetRenWuRewardID,param);
	int taskid = *(int *)param;
	ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
	int taskidindex = tasktitletab->getTitleIndex("taskid");
	crTableIO::StrVec record;
	int renwutype = 0;
	if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),record) >= 0)
	{
		renwutype = atoi(record[0].c_str());
		if(renwutype == 1)
		{
			condition = true;
		}
	}
	handle.outputParam(0,&condition);
}
/////////////////////////////////////////
//
//crJXJSetAutoBuildingMethod
//
/////////////////////////////////////////
crJXJSetAutoBuildingMethod::crJXJSetAutoBuildingMethod()
{
}
crJXJSetAutoBuildingMethod::crJXJSetAutoBuildingMethod(const crJXJSetAutoBuildingMethod& handle):
	crMethod(handle)
{
}
void crJXJSetAutoBuildingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCheckBoxWidgetNode*)param;
		break;
	}
}
void crJXJSetAutoBuildingMethod::addParam(int i, const std::string& str)
{
}
void crJXJSetAutoBuildingMethod::operator()(crHandle &handle)
{
	bool select = m_this->getSelect();
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *playerData = myPlayer->getDataClass();
	playerData->getParam(WCHDATA_JXJAutoBuilding,param);
	bool autobuilding = *(bool *)param;
	if(autobuilding != select)
	{
		playerData->inputParam(WCHDATA_JXJAutoBuilding,&select);
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(1);
			stream->_writeBool(select);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvSetAutoBuilding,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSetAutoBuildingMethod
//
/////////////////////////////////////////
crJXJRecvSetAutoBuildingMethod::crJXJRecvSetAutoBuildingMethod():
	m_netType(GameClient_Game){}
crJXJRecvSetAutoBuildingMethod::crJXJRecvSetAutoBuildingMethod(const crJXJRecvSetAutoBuildingMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSetAutoBuildingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSetAutoBuildingMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSetAutoBuildingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			bool autobuilding = m_stream->_readBool();
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_JXJAutoBuilding,&autobuilding);
		}
	}
}
/////////////////////////////////////////
//
//crJXJAutoBuildingMethod
//
/////////////////////////////////////////
crJXJAutoBuildingMethod::crJXJAutoBuildingMethod()
{
}
crJXJAutoBuildingMethod::crJXJAutoBuildingMethod(const crJXJAutoBuildingMethod& handle):
	crMethod(handle)
{
}
void crJXJAutoBuildingMethod::inputParam(int i, void *param)
{
}
void crJXJAutoBuildingMethod::addParam(int i, const std::string& str)
{
}
void crJXJAutoBuildingMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *playerData = myPlayer->getDataClass();
	playerData->getParam(WCHDATA_JXJAutoBuilding,param);
	bool autobuilding = *(bool *)param;
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(autobuilding && netConductor)
	{
		std::vector<int> buildingidArray;
		if(m_buildingids.empty())
		{
			m_buildingids.push_back(WCHDATA_JXJFuyalv);
			m_buildingids.push_back(WCHDATA_JXJFukulv);
			for (int i = 0; i<8; i++)
			{
				m_buildingids.push_back(WCHDATA_JXJMingjulv1+i);
			}
			for (int i = 0; i<8; i++)
			{
				m_buildingids.push_back(WCHDATA_JXJNongtianlv1+i);
			}
			for (int i = 0; i<4; i++)
			{
				m_buildingids.push_back(WCHDATA_JXJLingdilv1+i);
			}
			for (int i = 0; i<4; i++)
			{
				m_buildingids.push_back(WCHDATA_JXJKuangshanlv1+i);
			}
			for (int i = 0; i<4; i++)
			{
				m_buildingids.push_back(WCHDATA_JXJMuchanglv1+i);
			}
		}
		//
		int buildingid;
		BuildingLevelUpCheckResult result;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		unsigned char buildinglv;
		crPlayerDataEventPacket packet;
		CRNetApp::crScene *scene = crMyPlayerData::getInstance()->getScene();
		crData *itemdata;
		void *param;
		crInstanceItem *item;
		int itembuildingid;
		CRNetApp::crScene::SceneItemMap &sceneItemMap = scene->getSceneItemMap();
		for( BuildingIDArray::iterator itr = m_buildingids.begin();
			 itr != m_buildingids.end();
			 ++itr )
		{
			buildingid = *itr;
			playerData->getParam(buildingid,param);
			buildinglv = *(unsigned char *)(param);
			if(buildinglv == 0)
				continue;
			result.m_code = 0;
			myPlayer->doEvent(WCH_JXJBuildingLevelUpCheck,MAKEINT64(buildingid,&result));
			if(result.m_code > 0)
			{
				stream->createBuf(4);
				stream->_writeInt(buildingid);		
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuildingLevelUp,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);

				//播放特效
				if(scene && buildingid>0)
				{
					for( CRNetApp::crScene::SceneItemMap::iterator itr = sceneItemMap.begin();
						itr != sceneItemMap.end();
						++itr )
					{
						item = itr->second.get();
						itemdata = item->getDataClass();
						itemdata->getParam(WCHDATA_JXJBuildingID,param);
						if(param)
						{
							itembuildingid = *(int *)param;
							if(itembuildingid == buildingid)
							{
								item->doEvent(WCH_JXJBuildingLevelChange);
								break;
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAutoBuildingInitMethod
//
/////////////////////////////////////////
crJXJAutoBuildingInitMethod::crJXJAutoBuildingInitMethod()
{
}
crJXJAutoBuildingInitMethod::crJXJAutoBuildingInitMethod(const crJXJAutoBuildingInitMethod& handle):
	crMethod(handle),
	m_autoBuildWidget(handle.m_autoBuildWidget)
{
}
void crJXJAutoBuildingInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJAutoBuildingInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_autoBuildWidget = str;
		break;
	}
}
void crJXJAutoBuildingInitMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *playerData = myPlayer->getDataClass();
	playerData->getParam(WCHDATA_JXJAutoBuilding,param);
	bool autobuilding = *(bool *)param;
	ref_ptr<crCheckBoxWidgetNode> widget = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_autoBuildWidget));
	if(widget.valid())
		widget->select(autobuilding);
}
/////////////////////////////////////////
//
//crJXJQueryBattleRankingMapMethod
//
/////////////////////////////////////////
crJXJQueryBattleRankingMapMethod::crJXJQueryBattleRankingMapMethod()
{
}

crJXJQueryBattleRankingMapMethod::crJXJQueryBattleRankingMapMethod(const crJXJQueryBattleRankingMapMethod& handle):
	crMethod(handle)
{
}

void crJXJQueryBattleRankingMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJQueryBattleRankingMapMethod::addParam(int i, const std::string& str)
{
}

void crJXJQueryBattleRankingMapMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		crData *data = m_this->getDataClass();
		void *param;
		data->getParam(WCHDATA_JXJUIBattleRankingVer,param);
		char ver = *(char *)param;
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(1);
		stream->_writeUChar(ver);
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryBattleRankingMap, stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryBattleRankingMapMethod
//
/////////////////////////////////////////
crJXJRecvQueryBattleRankingMapMethod::crJXJRecvQueryBattleRankingMapMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryBattleRankingMapMethod::crJXJRecvQueryBattleRankingMapMethod(const crJXJRecvQueryBattleRankingMapMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvQueryBattleRankingMapMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryBattleRankingMapMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_table = str;
		break;
	}
}

void crJXJRecvQueryBattleRankingMapMethod::operator()(crHandle &handle)
{
	if(m_netType == GameServer)
	{
		void *param;
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if (playerData.valid())
		{
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *(unsigned char *)param;
			char clientver = m_stream->_readUChar();
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			if (gsBrainData)
			{
				int maxcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleRankingCount).c_str());
				short mypos = -1;
				ref_ptr<crBattleRanking> myRanking;
				gsBrainData->getParam(WCHDATA_JXJBattleRankingVerWei+shiliid-c_startShiliID,param);
				char ver = *(char *)param;
				if(clientver != ver)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1024);
					stream->_writeUChar(0);
					int i = 0;
					int writecount = 0;
					int killtotal = 0;
					int deadtotal = 0;
					CRNetApp::crDataLock scopedLock(gsBrainData);
					gsBrainData->getParam(WCHDATA_JXJBattleRankingMapWei+shiliid-c_startShiliID,param);
					BattleRankingMap *battleRankingMap = (BattleRankingMap *)param;
					for( BattleRankingMap::iterator itr = battleRankingMap->begin();
						itr != battleRankingMap->end();
						++itr )
					{
						if(itr->second->getPlayerID() == playerid)
						{
							myRanking = itr->second;
							mypos = i;
						}
						killtotal += itr->second->getKillCount();
						deadtotal += itr->second->getDeadCount();
						if(i<maxcount)
						{
							stream->_writeInt(itr->second->getPlayerID());
							stream->_writeString(itr->second->getName());
							stream->_writeInt(itr->second->getJifeng());
							stream->_writeInt(itr->second->getKillCount());
							stream->_writeInt(itr->second->getDeadCount());
							stream->_writeInt(itr->second->getExploit());
							writecount++;
						}
						i++;
					}
					scopedLock.unlock();

					stream->_writeInt(killtotal);
					stream->_writeInt(deadtotal);

					stream->_writeShort(mypos);
					if(myRanking.valid())
					{
						stream->_writeInt(myRanking->getJifeng());
						stream->_writeInt(myRanking->getKillCount());
						stream->_writeInt(myRanking->getDeadCount());
						stream->_writeInt(myRanking->getExploit());
						stream->_writeBool(myRanking->getLingqu());
					}
					stream->_writeChar(ver);
					int bufsize = stream->getBufSize();
					stream->seekBegin();
					stream->_writeUChar(writecount);
					stream->setBufSize(bufsize);
					stream->seekBegin();
					creCompress(stream);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryBattleRankingMap,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
	}
	else if (m_netType == GameClient_Game)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
		if(canvas.valid())
		{
			creUnCompress(m_stream);
			void *param;
			crData *canvasdata = canvas->getDataClass();
			CRNetApp::crDataLock scopedLock(canvasdata);
			canvasdata->getParam(WCHDATA_JXJUIBattleRankingMap,param);
			BattleRankingMap *battleRankingMap = (BattleRankingMap *)param;
			battleRankingMap->clear();
			unsigned char size = m_stream->_readUChar();
			ref_ptr<crBattleRanking> ranking;
			for( int i = 0; i<size; i++ )
			{
				ranking = new crBattleRanking;
				ranking->setPlayerID(m_stream->_readInt());
				ranking->setName(m_stream->_readString());
				ranking->addJifeng(m_stream->_readInt());
				ranking->addKillCount(m_stream->_readInt());
				ranking->addDeadCount(m_stream->_readInt());
				ranking->addExploit(m_stream->_readInt());
				battleRankingMap->insert(std::make_pair(ranking->getJifeng(),ranking));
			}
			//////test
			//for( int i = 0; i<50; i++ )
			//{
			//	ranking = new crBattleRanking;
			//	ranking->setPlayerID(i);
			//	ranking->setName(crArgumentParser::appItoa(i));
			//	ranking->addJifeng(1000-i);
			//	ranking->addKillCount(i);
			//	ranking->addDeadCount(i);
			//	ranking->addExploit(i);
			//	battleRankingMap->insert(std::make_pair(ranking->getJifeng(),ranking));
			//}

			ref_ptr<crTableWidgetNode> rankingTab = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_table));
			if(rankingTab.valid())
			{
				rankingTab->clearData();
				int row = 0;
				for( BattleRankingMap::iterator itr = battleRankingMap->begin();
					itr != battleRankingMap->end();
					++itr)
				{
					rankingTab->addData(0,row,itr->second->getName());
					rankingTab->addData(1,row,crArgumentParser::appItoa(itr->second->getJifeng()));
					rankingTab->addData(2,row,crArgumentParser::appItoa(itr->second->getKillCount()));
					rankingTab->addData(3,row,crArgumentParser::appItoa(itr->second->getDeadCount()));
					rankingTab->addData(4,row,crArgumentParser::appItoa(itr->second->getExploit()));
					row++;
				}
			}

			scopedLock.unlock();
			int killcount = m_stream->_readInt();
			int deadcount = m_stream->_readInt();
			short mypos = m_stream->_readShort();
			int myjifeng = 0;
			int myKillCount = 0;
			int myDeadCount = 0;
			int myExploit = 0;
			bool lingqu = false;
			if(mypos>=0)
			{
				myjifeng = m_stream->_readInt();
				myKillCount = m_stream->_readInt();
				myDeadCount = m_stream->_readInt();
				myExploit = m_stream->_readInt();
				lingqu = m_stream->_readBool();
			}
			char ver = m_stream->_readChar();
			canvasdata->inputParam(WCHDATA_JXJUIBattleRankingMyPos,&mypos);
			canvasdata->inputParam(WCHDATA_JXJUIBattleRankingKill,&killcount);
			canvasdata->inputParam(WCHDATA_JXJUIBattleRankingDead,&deadcount);
			canvasdata->inputParam(WCHDATA_JXJBattleRankingMyJifen,&myjifeng);
			canvasdata->inputParam(WCHDATA_JXJBattleRankingMyKill,&myKillCount);
			canvasdata->inputParam(WCHDATA_JXJBattleRankingMyDead,&myDeadCount);
			canvasdata->inputParam(WCHDATA_JXJBattleRankingMyExploit,&myExploit);
			canvasdata->inputParam(WCHDATA_JXJBattleRankingMyLingqu,&lingqu);
			canvasdata->inputParam(WCHDATA_JXJUIBattleRankingVer,&ver);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJBattleRankingCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJBattleRankingCanvasUpdateMethod::crJXJBattleRankingCanvasUpdateMethod()
{
}
crJXJBattleRankingCanvasUpdateMethod::crJXJBattleRankingCanvasUpdateMethod(const crJXJBattleRankingCanvasUpdateMethod& handle):
	crMethod(handle)
{
}
void crJXJBattleRankingCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJBattleRankingCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_table = str;
		break;
	case 1:
		m_scroll = str;
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
		m_paimingimg[i-2] = str;
		break;
	case 7:
	case 8:
	case 9:
		m_iconimg[0][i-7] = str;
		break;
	case 10:
	case 11:
	case 12:
		m_iconimg[1][i-10] = str;
		break;
	case 13:
	case 14:
	case 15:
		m_iconimg[2][i-13] = str;
		break;
	case 16:
	case 17:
	case 18:
		m_iconimg[3][i-16] = str;
		break;
	case 19:
	case 20:
	case 21:
		m_iconimg[4][i-19] = str;
		break;
	case 22:
	case 23:
	case 24:
		m_myicon[i-22] = str;
		break;
	case 25:
	case 26:
	case 27:
		m_num[0][i-25] = str;
		break;
	case 28:
	case 29:
	case 30:
		m_num[1][i-28] = str;
		break;
	case 31:
	case 32:
	case 33:
		m_num[2][i-31] = str;
		break;
	case 34:
	case 35:
	case 36:
		m_num[3][i-34] = str;
		break;
	case 37:
	case 38:
	case 39:
		m_num[4][i-37] = str;
		break;
	case 40:
	case 41:
	case 42:
		m_mynum[i-40] = str;
		break;
	case 43:
		m_killcount = str;
		break;
	case 44:
		m_deadcount = str;
		break;
	case 45:
		m_mypos = str;
		break;
	case 46:
		m_myname = str;
		break;
	case 47:
		m_myjifen = str;
		break;
	case 48:
		m_mykill = str;
		break;
	case 49:
		m_mydead = str;
		break;
	case 50:
		m_myexploit = str;
		break;
	case 51:
		m_lingqu = str;
		break;
	}
}
void crJXJBattleRankingCanvasUpdateMethod::operator()(crHandle &handle)
{
	crData *canvasdata = m_this->getDataClass();
	void *param;
	CRNetApp::crDataLock scopedLock(canvasdata);
	canvasdata->getParam(WCHDATA_JXJUIBattleRankingMap,param);
	BattleRankingMap *battleRankingMap = (BattleRankingMap *)param;
	ref_ptr<crScrollBarWidgetNode> rankingScroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scroll));
	ref_ptr<crTableIO> battleRankingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBattleRankingTab);
	crVector4i award1,award2,award3;
	int iconindex = battleRankingTab->getTitleIndex("icon");
	int awardindex = battleRankingTab->getTitleIndex("奖励1");
	ref_ptr<crImageBoxWidgetNode> paimingImg[5];
	ref_ptr<crImageBoxWidgetNode> iconImg[5][3];
	ref_ptr<crStaticTextWidgetNode> num[5][3];
	ref_ptr<crImageBoxWidgetNode> myicon[3];
	ref_ptr<crStaticTextWidgetNode> mynum[3];
	int scrollvalue = rankingScroll.valid()?(int)(rankingScroll->getValue() / rankingScroll->getLineValue() + 0.5f):0;
	int i = 0;
	int j = 0;
	for( ;i<5;i++)
	{
		paimingImg[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_paimingimg[i]));
		if(paimingImg[i].valid()) paimingImg[i]->clearImage();
		for(j=0;j<3;j++)
		{
			iconImg[i][j] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_iconimg[i][j]));
			if(iconImg[i][j].valid()) iconImg[i][j]->clearImage();
			num[i][j] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_num[i][j]));
			if(num[i][j].valid()) num[i][j]->clearString();
		}
	}
	for(j=0;j<3;j++)
	{
		myicon[j] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_myicon[j]));
		if(myicon[j].valid()) myicon[j]->clearImage();
		mynum[j] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_mynum[j]));
		if(mynum[j].valid()) mynum[j]->clearString();
	}
	i = scrollvalue;
	j = 0;
	int row = battleRankingMap->size();
	for( ; i<row && j<5; i++,j++)
	{
		if(paimingImg[j].valid()) paimingImg[j]->setImageName((*battleRankingTab)(i,iconindex));
		crArgumentParser::appAtoVec((*battleRankingTab)(i,awardindex),award1);
		crArgumentParser::appAtoVec((*battleRankingTab)(i,awardindex+1),award2);
		crArgumentParser::appAtoVec((*battleRankingTab)(i,awardindex+2),award3);
		setRewardInfo(award1,iconImg[j][0].get(),num[j][0].get());
		setRewardInfo(award2,iconImg[j][1].get(),num[j][1].get());
		setRewardInfo(award3,iconImg[j][2].get(),num[j][2].get());
	}

	canvasdata->getParam(WCHDATA_JXJUIBattleRankingKill,param);
	int killcount = *(int *)param;
	canvasdata->getParam(WCHDATA_JXJUIBattleRankingDead,param);
	int deadcount = *(int *)param;
	ref_ptr<crStaticTextWidgetNode> killcountText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_killcount));
	ref_ptr<crStaticTextWidgetNode> deadcountText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_deadcount));
	if (killcountText.valid())
	{
		if (killcount >= 100000)
			killcountText->setString(crArgumentParser::appItoa(killcount / 10000) + "万");
		else
			killcountText->setString(crArgumentParser::appItoa(killcount));
	}
	if (deadcountText.valid())
	{
		if (deadcount >= 100000)
			deadcountText->setString(crArgumentParser::appItoa(deadcount / 10000) + "万");
		else
			deadcountText->setString(crArgumentParser::appItoa(deadcount));
	}
	//if(killcountText.valid())
	//	killcountText->setString(crArgumentParser::appItoa(killcount));
	//if(deadcountText.valid())
	//	deadcountText->setString(crArgumentParser::appItoa(deadcount));

	ref_ptr<crStaticTextWidgetNode> myposText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_mypos));
	ref_ptr<crStaticTextWidgetNode> mynameText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_myname));
	ref_ptr<crStaticTextWidgetNode> myjifenText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_myjifen));
	ref_ptr<crStaticTextWidgetNode> mykillText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_mykill));
	ref_ptr<crStaticTextWidgetNode> mydeadText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_mydead));
	ref_ptr<crStaticTextWidgetNode> myexploitText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_myexploit));
	ref_ptr<crButtonWidgetNode> lingqu = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_lingqu));
	canvasdata->getParam(WCHDATA_JXJUIBattleRankingMyPos,param);
	short mypos = *(short *)param;
	canvasdata->getParam(WCHDATA_JXJBattleRankingMyJifen,param);
	int myjifen = *(int *)param;
	canvasdata->getParam(WCHDATA_JXJBattleRankingMyKill,param);
	int mykill = *(int *)param;
	canvasdata->getParam(WCHDATA_JXJBattleRankingMyDead,param);
	int mydead = *(int *)param;
	canvasdata->getParam(WCHDATA_JXJBattleRankingMyExploit,param);
	int myexploit = *(int *)param;
	canvasdata->getParam(WCHDATA_JXJBattleRankingMyLingqu,param);
	bool mylingqu = *(bool *)param;
	if(myposText.valid())
		myposText->setString(mypos>=0?crArgumentParser::appItoa(mypos+1):"无");
	if(myjifenText.valid())
		myjifenText->setString(crArgumentParser::appItoa(myjifen));
	if(mykillText.valid())
		mykillText->setString(crArgumentParser::appItoa(mykill));
	if(mydeadText.valid())
		mydeadText->setString(crArgumentParser::appItoa(mydead));
	if(myexploitText.valid())
		myexploitText->setString(crArgumentParser::appItoa(myexploit));
	if(mynameText.valid())
		mynameText->setString(crMyPlayerData::getInstance()->getCharacterName());
	if(lingqu.valid())
	{
		if(mylingqu)
		{
			lingqu->setVisiable(false);
		}
		else
		{
			lingqu->setVisiable(true);
			bool openbattle = false;
			crPlayerGameData *myData = crMyPlayerData::getInstance()->getPlayerGameData();
			if(myData)
			{
				crData *data = myData->getDataClass();
				data->getParam(WCHDATA_JXJOpenBattle,param);
				openbattle = *(bool *)param;
			}
			if(mypos>=0 && !openbattle)
			{
				lingqu->setEnable(true);
			}
			else
			{
				lingqu->setEnable(false);
			}
		}
	}
	if(mypos>=0)
	{
		int rowcount = battleRankingTab->getRowCount();
		if(mypos>=rowcount)
		{
			mypos = rowcount-1;
		}
		crArgumentParser::appAtoVec((*battleRankingTab)(mypos,awardindex),award1);
		crArgumentParser::appAtoVec((*battleRankingTab)(mypos,awardindex+1),award2);
		crArgumentParser::appAtoVec((*battleRankingTab)(mypos,awardindex+2),award3);
		setRewardInfo(award1,myicon[0].get(),mynum[0].get());
		setRewardInfo(award2,myicon[1].get(),mynum[1].get());
		setRewardInfo(award3,myicon[2].get(),mynum[2].get());
	}
}
/////////////////////////////////////////
//
//crJXJGetBattleRankingRewardMethod
//
/////////////////////////////////////////
crJXJGetBattleRankingRewardMethod::crJXJGetBattleRankingRewardMethod()
{
}
crJXJGetBattleRankingRewardMethod::crJXJGetBattleRankingRewardMethod(const crJXJGetBattleRankingRewardMethod& handle):
	crMethod(handle)
{
}
void crJXJGetBattleRankingRewardMethod::inputParam(int i, void *param)
{
}
void crJXJGetBattleRankingRewardMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetBattleRankingRewardMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGetBattleRankingReward,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvGetBattleRankingRewardMethod
//
/////////////////////////////////////////
crJXJRecvGetBattleRankingRewardMethod::crJXJRecvGetBattleRankingRewardMethod():
	m_netType(GameClient_Game){}
crJXJRecvGetBattleRankingRewardMethod::crJXJRecvGetBattleRankingRewardMethod(const crJXJRecvGetBattleRankingRewardMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_lingqubtn(handle.m_lingqubtn)
{
}
void crJXJRecvGetBattleRankingRewardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvGetBattleRankingRewardMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_lingqubtn = str;
		break;
	}
}

void crJXJRecvGetBattleRankingRewardMethod::operator()(crHandle &handle)
{
	if(m_netType == GameServer)
	{
		ref_ptr<crTableIO> battleRankingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBattleRankingTab);
		crTableIO::StrVec record;
		int rowcount = battleRankingTab->getRowCount();
		if(rowcount == 0)
			return;

		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if (playerData.valid())
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *(unsigned char *)param;
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			if (gsBrainData)
			{
				short mypos = -1;
				{
					CRNetApp::crDataLock scopedLock(gsBrainData);
					gsBrainData->getParam(WCHDATA_JXJBattleRankingMapWei+shiliid-c_startShiliID,param);
					BattleRankingMap *battleRankingMap = (BattleRankingMap *)param;
					int i = 0;
					for( BattleRankingMap::iterator itr = battleRankingMap->begin();
						itr != battleRankingMap->end();
						++itr )
					{
						if(itr->second->getPlayerID() == playerid && !itr->second->getLingqu())
						{
							mypos = i;
							itr->second->setLingqu(true);
						}
						i++;
					}
				}
				if(mypos>=0)
				{
					int rowcount = battleRankingTab->getRowCount();
					if(mypos>=rowcount)
					{
						mypos = rowcount-1;
					}
					int awardindex = battleRankingTab->getTitleIndex("奖励1");
					crVector4i award1,award2,award3;
					std::vector<CRCore::crVector4i> awardVec;
					crArgumentParser::appAtoVec((*battleRankingTab)(mypos,awardindex),award1);
					crArgumentParser::appAtoVec((*battleRankingTab)(mypos,awardindex+1),award2);
					crArgumentParser::appAtoVec((*battleRankingTab)(mypos,awardindex+2),award3);
					awardVec.push_back(award1);
					awardVec.push_back(award2);
					awardVec.push_back(award3);
					CRNetApp::crDataLock scopedLock(data);
					sendReward(awardVec,m_this,"国战排行榜奖励");

					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvGetBattleRankingReward,NULL);
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

					GameLogData gamelog(Log_GetBattleRankingReward,"领取国战排行榜奖励");
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKEINT64(m_this->getPlayerID(),&gamelog));
				}
			}
		}
	}
	else if (m_netType == GameClient_Game)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if(canvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			bool lingqu = true;
			canvasdata->inputParam(WCHDATA_JXJBattleRankingMyLingqu,&lingqu);
			ref_ptr<crButtonWidgetNode> lingquBtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_lingqubtn));
			if(lingquBtn.valid())
				lingquBtn->setVisiable(false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJScrollValueInitMethod
//
/////////////////////////////////////////
crJXJScrollValueInitMethod::crJXJScrollValueInitMethod()
{
}
crJXJScrollValueInitMethod::crJXJScrollValueInitMethod(const crJXJScrollValueInitMethod& handle):
	crMethod(handle)
{
}
void crJXJScrollValueInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJScrollValueInitMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_scroll = str;
		break;
	}
}
void crJXJScrollValueInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crScrollBarWidgetNode> rankingScroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scroll));
	if(rankingScroll.valid()) rankingScroll->setValue(0);
}
/////////////////////////////////////////
//
//crJXJSaveBattleRankingMethod
//
/////////////////////////////////////////
crJXJSaveBattleRankingMethod::crJXJSaveBattleRankingMethod() :
	m_this(NULL)
{
}

crJXJSaveBattleRankingMethod::crJXJSaveBattleRankingMethod(const crJXJSaveBattleRankingMethod & handle) :
	crMethod(handle),
	m_file(handle.m_file)
{
}

void crJXJSaveBattleRankingMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 0:
		if (param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJSaveBattleRankingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_file = str;
		break;
	}
}

void crJXJSaveBattleRankingMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJOpenBattle,param);
	bool openbattle = *(bool *)param;
	if(openbattle)
	{
		CRNet::crNetConductor * gameServerConductor = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		CRNet::crNetDataManager *netDataManager = gameServerConductor->getNetDataManager();
		CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
		std::string filepath = crArgumentParser::getFilePath(m_file);
		std::string filename = crArgumentParser::getSimpleFileName(m_file);
		std::string relFileName = filepath + "/" + netCallback->getServerName() + "/" + filename;
		if (!relFileName.empty())
		{
			time_t t = time(0);
			ref_ptr<CRCore::crStreamBuf> streamBuf = new crStreamBuf;
			streamBuf->createBuf(1024);
			streamBuf->_writeInt64(t);
			data->lock();
			for(int i = 0; i<3; i++)
			{
				data->getParam(WCHDATA_JXJBattleRankingVerWei+i,param);
				char ver = *(char *)param;
				streamBuf->_writeChar(ver);
				data->getParam(WCHDATA_JXJBattleRankingMapWei+i,param);
				BattleRankingMap *battlerankingmap= (BattleRankingMap *)param;
				streamBuf->_writeUShort(battlerankingmap->size());
				for( BattleRankingMap::iterator itr = battlerankingmap->begin();
					itr != battlerankingmap->end();
					++itr )
				{
					streamBuf->_writeInt(itr->second->getPlayerID());
					streamBuf->_writeString(itr->second->getName());
					streamBuf->_writeInt(itr->second->getJifeng());
					streamBuf->_writeInt(itr->second->getKillCount());
					streamBuf->_writeInt(itr->second->getDeadCount());
					streamBuf->_writeInt(itr->second->getExploit());
				}
			}
			data->unlock();
			streamBuf->seekBegin();

			streamBuf->saveToFile2(relFileName);
		}
	}
}
/////////////////////////////////////////
//
//crJXJLoadBattleRankingMethod
//
/////////////////////////////////////////
crJXJLoadBattleRankingMethod::crJXJLoadBattleRankingMethod() :
	m_this(NULL)
{
}

crJXJLoadBattleRankingMethod::crJXJLoadBattleRankingMethod(const crJXJLoadBattleRankingMethod & handle) :
	crMethod(handle),
	m_file(handle.m_file)
{
}

void crJXJLoadBattleRankingMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_serverName = *((std::string *)(LOINT64(param64)));
		}
		else
		{
			m_serverName.clear();
		}
		break;
	}
}

void crJXJLoadBattleRankingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_file = str;
		break;
	}
}

void crJXJLoadBattleRankingMethod::operator()(crHandle &handle)
{
	std::string filepath = crArgumentParser::getFilePath(m_file);
	std::string filename = crArgumentParser::getSimpleFileName(m_file);
	std::string relFileName = filepath + "/" + m_serverName + "/" + filename;
	CRCore::ref_ptr<CRCore::crStreamBuf> streamBuf = new crStreamBuf;
	if(streamBuf->loadFromFile2(relFileName))
	{
		crData *data = m_this->getDataClass();
		time_t t = streamBuf->_readInt64();
		time_t now = time(0);
		if(now - t < 86400)
		{
			data->lock();
			data->inputParam(WCHDATA_JXJBattleRankingSaveTime,&t);
			char ver;
			BattleRankingMap *battlerankingmap;
			void *param;
			unsigned short count;
			ref_ptr<crBattleRanking> battleRanking;
			for (int i=0; i<3; i++)
			{
				ver = streamBuf->_readChar();
				data->inputParam(WCHDATA_JXJBattleRankingVerWei+i,&ver);
				data->getParam(WCHDATA_JXJBattleRankingMapWei+i,param);
				battlerankingmap= (BattleRankingMap *)param;
				count = streamBuf->_readUShort();
				for( int j = 0; j<count; j++ )
				{
					battleRanking = new crBattleRanking;
					battleRanking->setPlayerID(streamBuf->_readInt());
					battleRanking->setName(streamBuf->_readString());
					battleRanking->addJifeng(streamBuf->_readInt());
					battleRanking->addKillCount(streamBuf->_readInt());
					battleRanking->addDeadCount(streamBuf->_readInt());
					battleRanking->addExploit(streamBuf->_readInt());
					battlerankingmap->insert(std::make_pair(battleRanking->getJifeng(),battleRanking));
				}
			}
			data->unlock();
		}
	}
}
/////////////////////////////////////////
//
//crJXJRefreshForeignCardMsgBoxMethod
//
/////////////////////////////////////////
crJXJRefreshForeignCardMsgBoxMethod::crJXJRefreshForeignCardMsgBoxMethod()
{
}
crJXJRefreshForeignCardMsgBoxMethod::crJXJRefreshForeignCardMsgBoxMethod(const crJXJRefreshForeignCardMsgBoxMethod& handle) :
crMethod(handle),
m_msgbox(handle.m_msgbox),
m_msgtext(handle.m_msgtext)
{
}
void crJXJRefreshForeignCardMsgBoxMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJRefreshForeignCardMsgBoxMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_msgtext = str;
		break;
	}
}
void crJXJRefreshForeignCardMsgBoxMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
	if (msgCanvas.valid() && myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_VipLv, param);
		unsigned char viplv = *(unsigned char *)param;
		int cost = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRefreshForeignCardCost, viplv).c_str());
		crData *roledata = myPlayer->getMainRole()->getDataClass();
		int openlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJForeignCardOpenLevel, 0).c_str());
		roledata->getParam(WCHDATA_Level, param);
		unsigned char lv = *(unsigned char *)param;
		if (lv >= openlv)
		{
			data->getParam(WCHDATA_JXJCoppercash, param);
			int coppercash = *(int *)param;
			if (coppercash >= cost)
			{
				crHypertextWidgetNode *msgtext = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msgtext));
				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				//cfg_script.Add("Font",m_font);
				//cfg_script.Add("CharacterSize",m_characterSize);

				cfg_script.Add("Content");
				cfg_script.Push("Content", 1);
				v_i.clear();
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color", v_i);
				cfg_script.Add("Text", "您确认要花费");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content", 2);
				v_i.clear();
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(0.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color", v_i);
				char tmpText[32];
				sprintf(tmpText, "%d铜钱\0", cost);
				cfg_script.Add("Text", tmpText);
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content", 3);
				v_i.clear();
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color", v_i);
				cfg_script.Add("Text", "刷新将卡吗？");
				cfg_script.Pop();

				cfg_script.Pop();

				if (msgtext)msgtext->setHypertext(cfg_script);
				crData *dlgData = msgCanvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType, &commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent, m_this);
				crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
			}
			else
			{
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2001, NULL));
			}
		}
		else
		{//等级不足！
			myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2003, NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRefreshForeignCardMethod
//
/////////////////////////////////////////
crJXJRefreshForeignCardMethod::crJXJRefreshForeignCardMethod()
{
}
crJXJRefreshForeignCardMethod::crJXJRefreshForeignCardMethod(const crJXJRefreshForeignCardMethod& handle) :
crMethod(handle)
{
}
void crJXJRefreshForeignCardMethod::inputParam(int i, void *param)
{
}
void crJXJRefreshForeignCardMethod::addParam(int i, const std::string& str)
{
}
void crJXJRefreshForeignCardMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	crPlayerDataEventPacket packet;
	crPlayerDataEventPacket::buildRequestPacket(packet, WCH_JXJRecvRefreshForeignCard, NULL);
	netConductor->getNetManager()->sendPacket("all", packet);
}
/////////////////////////////////////////
//
//crJXJRecvRefreshForeignCardMethod
//
/////////////////////////////////////////
crJXJRecvRefreshForeignCardMethod::crJXJRecvRefreshForeignCardMethod() :
m_netType(GameClient_Game){}
crJXJRecvRefreshForeignCardMethod::crJXJRecvRefreshForeignCardMethod(const crJXJRecvRefreshForeignCardMethod& handle) :
crMethod(handle),
m_netType(handle.m_netType)
{
}
void crJXJRecvRefreshForeignCardMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if (param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRefreshForeignCardMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvRefreshForeignCardMethod::operator()(crHandle &handle)
{
	//////////////////////////////////
	//返回
	//0：失败
	//1：成功
	//2: 铜钱不足
	//3: 等级不足
	//////////////////////////////////
	if (m_netType == GameServer)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if (playerData.valid())
		{
			char success = 0;
			void *param;
			crData *data = m_this->getDataClass();
			crData *roledata = m_this->getMainRole()->getDataClass();
			int openlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJForeignCardOpenLevel, 0).c_str());
			roledata->getParam(WCHDATA_Level, param);
			unsigned char lv = *(unsigned char *)param;
			data->lock();
			data->getParam(WCHDATA_JXJForeignCard, param);
			crVector3i* foreignCard = (crVector3i *)param;
			data->getParam(WCHDATA_JXJCoppercash, param);
			int *coppercash = (int *)param;
			int cost = 0;
			if (lv >= openlv)
			{
				data->getParam(WCHDATA_VipLv, param);
				unsigned char viplv = *(unsigned char *)param;
				cost = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRefreshForeignCardCost, viplv).c_str());
				if (*coppercash >= cost)
				{
					*coppercash -= cost;
					///异国将卡商店刷新
					ref_ptr<crTableIO>foreignCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJForeignCardTab);
					data->getParam(WCHDATA_JXJShiliID, param);
					unsigned char shiliid = *(unsigned char *)param;

					int rowcount = foreignCardTab->getRowCount();
					std::vector<int>CardVec;
					int cardid;
					crVector2i saleShili;
					for (int i = 0; i < rowcount; ++i)
					{
						crArgumentParser::appAtoVec((*foreignCardTab)(i, 1), saleShili, '|');
						if (saleShili[0] == shiliid || saleShili[1] == shiliid)
						{
							cardid = atoi((*foreignCardTab)(i, 0).c_str());
							if (cardid != (*foreignCard)[0] && cardid != (*foreignCard)[1] && cardid != (*foreignCard)[2])
							{
								CardVec.push_back(cardid);
							}
						}
					}
					if (!CardVec.empty())
					{
						rangei cardrange(0, CardVec.size());
						int cardrnd[2];
						int cardrndtmp = cardrange.get_random();
						(*foreignCard)[0] = CardVec[cardrndtmp];
						cardrnd[0] = cardrndtmp;
						do
						{
							cardrndtmp = cardrange.get_random();
						} while (cardrndtmp == cardrnd[0]);
						(*foreignCard)[1] = CardVec[cardrndtmp];
						cardrnd[1] = cardrndtmp;
						do
						{
							cardrndtmp = cardrange.get_random();
						} while (cardrndtmp == cardrnd[0] || cardrndtmp == cardrnd[1]);
						(*foreignCard)[2] = CardVec[cardrndtmp];

						success = 1;
					}
				}
				else
				{
					success = 2;
				}
			}
			else
			{
				success = 3;
			}
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(17);
			stream->_writeChar(success);
			if (success == 1)
			{
				stream->_writeInt(*coppercash);
				stream->_writeVec3i(*foreignCard);
				std::string str = "刷新异国将卡商店,花费铜钱";
				str += crArgumentParser::appItoa(cost);
				str += "刷出将卡";
				str += crArgumentParser::appVectoa(*foreignCard);
				GameLogData gamelog(Log_RefreshForeignCard, str);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog, MAKEINT64(playerid, &gamelog));
			}
			data->unlock();

			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet, playerid, WCH_JXJRecvRefreshForeignCard, stream.get());
			gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet);
		}
	}
	else if (m_netType == GameClient_Game)
	{
		char success = m_stream->_readChar();
		if (success==1)
		{
			void *param;
			int coppercash = m_stream->_readInt();
			crVector3i foreignCard = m_stream->_readVec3i();
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_JXJForeignCard, &foreignCard);
			data->getParam(WCHDATA_JXJCoppercash,param);
			int totalpieces = *(int *)param;
			int extra = coppercash - totalpieces;
			data->inputParam(WCHDATA_JXJCoppercash, &coppercash);
			if(extra!=0)
			{
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKEINT64(T_Copper,extra));
			}
		}
		else if (success == 2)
		{
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2001, NULL));
		}
		else
		{
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2003, NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExchangeForeignCardMsgBoxMethod
//
/////////////////////////////////////////
crJXJExchangeForeignCardMsgBoxMethod::crJXJExchangeForeignCardMsgBoxMethod():
m_index(0)
{
}
crJXJExchangeForeignCardMsgBoxMethod::crJXJExchangeForeignCardMsgBoxMethod(const crJXJExchangeForeignCardMsgBoxMethod& handle) :
crMethod(handle),
m_index(handle.m_index),
m_msgbox(handle.m_msgbox),
m_msgtext(handle.m_msgtext)
{
}
void crJXJExchangeForeignCardMsgBoxMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJExchangeForeignCardMsgBoxMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_msgbox = str;
		break;
	case 2:
		m_msgtext = str;
		break;
	}
}
void crJXJExchangeForeignCardMsgBoxMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
	if (msgCanvas.valid() && myPlayer && netConductor)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		crData *roledata = myPlayer->getMainRole()->getDataClass();
		int openlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJForeignCardOpenLevel, 0).c_str());
		roledata->getParam(WCHDATA_Level, param);
		unsigned char lv = *(unsigned char *)param;
		if (lv >= openlv)
		{
			data->getParam(WCHDATA_JXJForeignCard, param);
			crVector3i foreignCard = *(crVector3i *)param;
			int itemid = foreignCard[m_index];
			ref_ptr<crTableIO>foreignCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJForeignCardTab);
			crTableIO::StrVec record;
			int cost = 0;
			if (foreignCardTab->queryOneRecord(0, crArgumentParser::appItoa(itemid), record) >= 0)
			{
				cost = atoi(record[2].c_str());
				data->getParam(WCHDATA_JXJCardPieces, param);
				int cardpieces = *(int *)param;
				if (cardpieces >= cost)
				{
					int needbagcount = 1;
					myPlayer->doEvent(WCH_JXJCheckJiangkaBagEmpty, MAKEINT64(&needbagcount, NULL));
					if (needbagcount == 0)
					{
						crHypertextWidgetNode *msgtext = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msgtext));
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						//cfg_script.Add("Font",m_font);
						//cfg_script.Add("CharacterSize",m_characterSize);

						cfg_script.Add("Content");
						cfg_script.Push("Content", 1);
						v_i.clear();
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color", v_i);
						cfg_script.Add("Text", "您确认要花费");
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content", 2);
						v_i.clear();
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color", v_i);
						char tmpText[32];
						sprintf(tmpText, "%d将魂\0", cost);
						cfg_script.Add("Text", tmpText);
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content", 3);
						v_i.clear();
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color", v_i);
						cfg_script.Add("Text", "兑换该将卡吗？");
						cfg_script.Pop();

						cfg_script.Pop();

						if (msgtext)msgtext->setHypertext(cfg_script);
						crData *dlgData = msgCanvas->getDataClass();
						int commandtype = CDP_Widget;
						dlgData->inputParam(WCHDATA_CommandDlgParentType, &commandtype);
						dlgData->inputParam(WCHDATA_CommandDlgParent, m_this);
						crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
					}
					else
					{
						myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(1032, NULL));
					}
				}
				else
				{
					myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2039, NULL));
				}
			}
			else
			{
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(1128, NULL));
			}
		}
		else
		{//等级不足！
			myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2003, NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJExchangeForeignCardMethod
//
/////////////////////////////////////////
crJXJExchangeForeignCardMethod::crJXJExchangeForeignCardMethod():
m_index(0)
{
}
crJXJExchangeForeignCardMethod::crJXJExchangeForeignCardMethod(const crJXJExchangeForeignCardMethod& handle) :
crMethod(handle),
m_index(handle.m_index)
{
}
void crJXJExchangeForeignCardMethod::inputParam(int i, void *param)
{
}
void crJXJExchangeForeignCardMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJExchangeForeignCardMethod::operator()(crHandle &handle)
{
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(1);
	stream->_writeUChar(m_index);
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	crPlayerDataEventPacket packet;
	crPlayerDataEventPacket::buildRequestPacket(packet, WCH_JXJRecvExchangeForeignCard, stream.get());
	netConductor->getNetManager()->sendPacket("all", packet);
}
/////////////////////////////////////////
//
//crJXJRecvExchangeForeignCardMethod
//
/////////////////////////////////////////
crJXJRecvExchangeForeignCardMethod::crJXJRecvExchangeForeignCardMethod() :
m_netType(GameClient_Game){}
crJXJRecvExchangeForeignCardMethod::crJXJRecvExchangeForeignCardMethod(const crJXJRecvExchangeForeignCardMethod& handle) :
crMethod(handle),
m_netType(handle.m_netType)
{
}
void crJXJRecvExchangeForeignCardMethod::inputParam(int i, void *param)
{
	switch (i)
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if (param)
		{
			_crInt64 param64 = *(_crInt64*)param;
			m_stream = (crStreamBuf *)(LOINT64(param64));
			m_netType = HIINT64(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvExchangeForeignCardMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvExchangeForeignCardMethod::operator()(crHandle &handle)
{
	//////////////////////////////////
	//返回
	//0：失败
	//1：成功
	//2：将魂不足
	//3：背包已满
	//4：该将卡已经下架
	//5: 等级不足
	//////////////////////////////////
	if (m_netType == GameServer)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer);
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if (playerData.valid())
		{
			char code = 0;
			void *param;
			crData *data = m_this->getDataClass();
			unsigned char index = m_stream->_readUChar();
			if (index < 3)
			{
				crData *roledata = m_this->getMainRole()->getDataClass();
				int openlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJForeignCardOpenLevel, 0).c_str());
				roledata->getParam(WCHDATA_Level, param);
				unsigned char lv = *(unsigned char *)param;
				data->lock();
				data->getParam(WCHDATA_JXJCardPieces, param);
				int *cardpieces = (int *)param;
				int cost = 0;
				int itemid = 0;
				if (lv >= openlv)
				{
					data->getParam(WCHDATA_JXJForeignCard, param);
					crVector3i foreignCard = *(crVector3i *)param;
					itemid = foreignCard[index];
					ref_ptr<crTableIO>foreignCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJForeignCardTab);
					crTableIO::StrVec record;
					if (foreignCardTab->queryOneRecord(0, crArgumentParser::appItoa(itemid), record) >= 0)
					{
						cost = atoi(record[2].c_str());
						if (*cardpieces >= cost)
						{
							int needbagcount = 1;
							m_this->doEvent(WCH_JXJCheckJiangkaBagEmpty, MAKEINT64(&needbagcount, NULL));
							if (needbagcount == 0)
							{
								*cardpieces -= cost;
								ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
								bagitemdata->setItemID(itemid);
								bagitemdata->setItemCount(1);
								RewardItemVec rewardItems;
								rewardItems.push_back(bagitemdata);
								m_this->doEvent(WCH_JXJRecvRewardItems, MAKEINT64(&rewardItems, 0));
								code = 1;
							}
							else
							{
								code = 3;
							}
						}
						else
						{
							code = 2;
						}
					}
					else
					{
						code = 4;
					}
				}
				else
				{
					code = 5;
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(17);
				stream->_writeChar(code);
				if (code == 1)
				{
					stream->_writeInt(*cardpieces);
					std::string str = "兑换异国将卡,花费将魂";
					str += crArgumentParser::appItoa(cost);
					str += "获得将卡";
					str += crArgumentParser::appItoa(itemid);
					GameLogData gamelog(Log_ExchangeForeignCard, str);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog, MAKEINT64(playerid, &gamelog));
				}
				data->unlock();

				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet, playerid, WCH_JXJRecvExchangeForeignCard, stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet);
			}
		}
	}
	else if (m_netType == GameClient_Game)
	{
		char code = m_stream->_readChar();
		switch (code)
		{
		case 1:
			{
				void *param;
				int cardpieces = m_stream->_readInt();
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJCardPieces, param);
				int oldvalue = *(int *)param;
				int extra = cardpieces - oldvalue;
				data->inputParam(WCHDATA_JXJCardPieces, &cardpieces);
				if (extra != 0)
				{
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue, MAKEINT64(T_JiangHun, extra));
				}
			}
			break;
		case 2:
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2039, NULL));
			break;
		case 3:
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(1032, NULL));
			break;
		case 4:
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(1128, NULL));
			break;
		case 5:
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(2003, NULL));
			break;
		case 0:
			m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKEINT64(1086, NULL));
			break;
		}
	}
}